{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateDependenciesVersionsAsync = validateDependenciesVersionsAsync;\nexports.logIncorrectDependencies = logIncorrectDependencies;\nexports.getVersionedDependenciesAsync = getVersionedDependenciesAsync;\nvar _jsonFile = _interopRequireDefault(require(\"@expo/json-file\"));\nvar _assert = _interopRequireDefault(require(\"assert\"));\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\nvar _resolveFrom = _interopRequireDefault(require(\"resolve-from\"));\nvar _semver = _interopRequireDefault(require(\"semver\"));\nvar Log = _interopRequireWildcard(require(\"../../../log\"));\nvar _env = require(\"../../../utils/env\");\nvar _errors = require(\"../../../utils/errors\");\nvar _getVersionedPackages = require(\"./getVersionedPackages\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nvar debug = require(\"debug\")(\"expo:doctor:dependencies:validate\");\nfunction validateDependenciesVersionsAsync(_x, _x2, _x3, _x4) {\n  return _validateDependenciesVersionsAsync.apply(this, arguments);\n}\nfunction _validateDependenciesVersionsAsync() {\n  _validateDependenciesVersionsAsync = _asyncToGenerator(function* (projectRoot, exp, pkg, packagesToCheck) {\n    if (_env.env.EXPO_OFFLINE) {\n      Log.warn(\"Skipping dependency validation in offline mode\");\n      return null;\n    }\n    var incorrectDeps = yield getVersionedDependenciesAsync(projectRoot, exp, pkg, packagesToCheck);\n    return logIncorrectDependencies(incorrectDeps);\n  });\n  return _validateDependenciesVersionsAsync.apply(this, arguments);\n}\nfunction logInvalidDependency(_ref) {\n  var packageName = _ref.packageName,\n    expectedVersionOrRange = _ref.expectedVersionOrRange,\n    actualVersion = _ref.actualVersion;\n  Log.warn(_chalk.default`  {bold ${packageName}}{cyan @}{red ${actualVersion}} - expected version: {green ${expectedVersionOrRange}}`);\n}\nfunction logIncorrectDependencies(incorrectDeps) {\n  if (!incorrectDeps.length) {\n    return true;\n  }\n  Log.warn(_chalk.default`Some dependencies are incompatible with the installed {bold expo} version:`);\n  incorrectDeps.forEach(function (dep) {\n    return logInvalidDependency(dep);\n  });\n  Log.warn(\"Your project may not work correctly until you install the correct versions of the packages.\\n\" + _chalk.default`Fix with: {bold npx expo install --fix}`);\n  return false;\n}\nfunction getVersionedDependenciesAsync(_x5, _x6, _x7, _x8) {\n  return _getVersionedDependenciesAsync.apply(this, arguments);\n}\nfunction _getVersionedDependenciesAsync() {\n  _getVersionedDependenciesAsync = _asyncToGenerator(function* (projectRoot, exp, pkg, packagesToCheck) {\n    var ref, ref1;\n    (0, _assert).default(exp.sdkVersion, \"SDK Version is missing\");\n    var combinedKnownPackages = yield (0, _getVersionedPackages).getCombinedKnownVersionsAsync({\n      projectRoot: projectRoot,\n      sdkVersion: exp.sdkVersion\n    });\n    var resolvedDependencies = (packagesToCheck == null ? void 0 : packagesToCheck.length) ? getFilteredObject(packagesToCheck, _objectSpread(_objectSpread({}, pkg.dependencies), pkg.devDependencies)) : _objectSpread(_objectSpread({}, pkg.dependencies), pkg.devDependencies);\n    debug(`Checking dependencies for ${exp.sdkVersion}: %O`, resolvedDependencies);\n    var _getPackagesToCheck = getPackagesToCheck(resolvedDependencies, combinedKnownPackages),\n      resolvedPackagesToCheck = _getPackagesToCheck.known,\n      unknown = _getPackagesToCheck.unknown;\n    debug(`Comparing known versions: %O`, resolvedPackagesToCheck);\n    debug(`Skipping packages that cannot be versioned automatically: %O`, unknown);\n    var packageVersions = yield resolvePackageVersionsAsync(projectRoot, resolvedPackagesToCheck);\n    debug(`Package versions: %O`, packageVersions);\n    var incorrectDeps = findIncorrectDependencies(pkg, packageVersions, combinedKnownPackages);\n    debug(`Incorrect dependencies: %O`, incorrectDeps);\n    if (pkg == null ? void 0 : (ref = pkg.expo) == null ? void 0 : (ref1 = ref.install) == null ? void 0 : ref1.exclude) {\n      var packagesToExclude = pkg.expo.install.exclude;\n      var incorrectAndExcludedDeps = incorrectDeps.filter(function (dep) {\n        return packagesToExclude.includes(dep.packageName);\n      });\n      debug(`Incorrect dependency warnings filtered out by expo.install.exclude: %O`, incorrectAndExcludedDeps.map(function (dep) {\n        return dep.packageName;\n      }));\n      incorrectDeps = incorrectDeps.filter(function (dep) {\n        return !packagesToExclude.includes(dep.packageName);\n      });\n    }\n    return incorrectDeps;\n  });\n  return _getVersionedDependenciesAsync.apply(this, arguments);\n}\nfunction getFilteredObject(keys, object) {\n  return keys.reduce(function (acc, key) {\n    acc[key] = object[key];\n    return acc;\n  }, {});\n}\nfunction getPackagesToCheck(dependencies, bundledNativeModules) {\n  var dependencyNames = Object.keys(dependencies != null ? dependencies : {});\n  var known = [];\n  var unknown = [];\n  for (var dependencyName of dependencyNames) {\n    if (dependencyName in bundledNativeModules) {\n      known.push(dependencyName);\n    } else {\n      unknown.push(dependencyName);\n    }\n  }\n  return {\n    known: known,\n    unknown: unknown\n  };\n}\nfunction resolvePackageVersionsAsync(_x9, _x10) {\n  return _resolvePackageVersionsAsync.apply(this, arguments);\n}\nfunction _resolvePackageVersionsAsync() {\n  _resolvePackageVersionsAsync = _asyncToGenerator(function* (projectRoot, packages) {\n    var packageVersionsFromPackageJSON = yield Promise.all(packages.map(function (packageName) {\n      return getPackageVersionAsync(projectRoot, packageName);\n    }));\n    return packages.reduce(function (acc, packageName, idx) {\n      acc[packageName] = packageVersionsFromPackageJSON[idx];\n      return acc;\n    }, {});\n  });\n  return _resolvePackageVersionsAsync.apply(this, arguments);\n}\nfunction getPackageVersionAsync(_x11, _x12) {\n  return _getPackageVersionAsync.apply(this, arguments);\n}\nfunction _getPackageVersionAsync() {\n  _getPackageVersionAsync = _asyncToGenerator(function* (projectRoot, packageName) {\n    var packageJsonPath;\n    try {\n      packageJsonPath = (0, _resolveFrom).default(projectRoot, `${packageName}/package.json`);\n    } catch (error) {\n      if (error.code === \"ERR_PACKAGE_PATH_NOT_EXPORTED\") {\n        var ref;\n        packageJsonPath = (ref = error.message.match(/(\"exports\"|defined) in (.*)$/i)) == null ? void 0 : ref[2];\n      }\n    }\n    if (!packageJsonPath) {\n      throw new _errors.CommandError(`\"${packageName}\" is added as a dependency in your project's package.json but it doesn't seem to be installed. Please run \"yarn\" or \"npm install\" to fix this issue.`);\n    }\n    var packageJson = yield _jsonFile.default.readAsync(packageJsonPath);\n    return packageJson.version;\n  });\n  return _getPackageVersionAsync.apply(this, arguments);\n}\nfunction findIncorrectDependencies(pkg, packageVersions, bundledNativeModules) {\n  var packages = Object.keys(packageVersions);\n  var incorrectDeps = [];\n  for (var packageName of packages) {\n    var expectedVersionOrRange = bundledNativeModules[packageName];\n    var actualVersion = packageVersions[packageName];\n    if (typeof expectedVersionOrRange === \"string\" && !_semver.default.intersects(expectedVersionOrRange, actualVersion)) {\n      incorrectDeps.push({\n        packageName: packageName,\n        packageType: findDependencyType(pkg, packageName),\n        expectedVersionOrRange: expectedVersionOrRange,\n        actualVersion: actualVersion\n      });\n    }\n  }\n  return incorrectDeps;\n}\nfunction findDependencyType(pkg, packageName) {\n  if (pkg.devDependencies && packageName in pkg.devDependencies) {\n    return \"devDependencies\";\n  }\n  return \"dependencies\";\n}","map":{"version":3,"names":["_defineProperty","require","_asyncToGenerator","ownKeys","e","r","t","Object","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","length","forEach","getOwnPropertyDescriptors","defineProperties","defineProperty","validateDependenciesVersionsAsync","logIncorrectDependencies","getVersionedDependenciesAsync","_jsonFile","_interopRequireDefault","_assert","_chalk","_resolveFrom","_semver","Log","_interopRequireWildcard","_env","_errors","_getVersionedPackages","debug","_x","_x2","_x3","_x4","_validateDependenciesVersionsAsync","projectRoot","exp","pkg","packagesToCheck","env","EXPO_OFFLINE","warn","incorrectDeps","logInvalidDependency","_ref","packageName","expectedVersionOrRange","actualVersion","default","dep","_x5","_x6","_x7","_x8","_getVersionedDependenciesAsync","ref","ref1","sdkVersion","combinedKnownPackages","getCombinedKnownVersionsAsync","resolvedDependencies","getFilteredObject","dependencies","devDependencies","_getPackagesToCheck","getPackagesToCheck","resolvedPackagesToCheck","known","unknown","packageVersions","resolvePackageVersionsAsync","findIncorrectDependencies","expo","install","exclude","packagesToExclude","incorrectAndExcludedDeps","includes","map","object","reduce","acc","key","bundledNativeModules","dependencyNames","dependencyName","_x9","_x10","_resolvePackageVersionsAsync","packages","packageVersionsFromPackageJSON","Promise","all","getPackageVersionAsync","idx","_x11","_x12","_getPackageVersionAsync","packageJsonPath","error","code","message","match","CommandError","packageJson","readAsync","version","intersects","packageType","findDependencyType"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\cli\\src\\start\\doctor\\dependencies\\validateDependenciesVersions.ts"],"sourcesContent":["import { ExpoConfig, PackageJSONConfig } from '@expo/config';\nimport JsonFile from '@expo/json-file';\nimport assert from 'assert';\nimport chalk from 'chalk';\nimport resolveFrom from 'resolve-from';\nimport semver from 'semver';\n\nimport * as Log from '../../../log';\nimport { env } from '../../../utils/env';\nimport { CommandError } from '../../../utils/errors';\nimport { BundledNativeModules } from './bundledNativeModules';\nimport { getCombinedKnownVersionsAsync } from './getVersionedPackages';\n\nconst debug = require('debug')('expo:doctor:dependencies:validate') as typeof console.log;\n\ninterface IncorrectDependency {\n  packageName: string;\n  packageType: 'dependencies' | 'devDependencies';\n  expectedVersionOrRange: string;\n  actualVersion: string;\n}\n\n/**\n * Print a list of incorrect dependency versions.\n * This only checks dependencies when not running in offline mode.\n *\n * @param projectRoot Expo project root.\n * @param exp Expo project config.\n * @param pkg Project's `package.json`.\n * @param packagesToCheck A list of packages to check, if undefined or empty, all will be checked.\n * @returns `true` if there are no incorrect dependencies.\n */\nexport async function validateDependenciesVersionsAsync(\n  projectRoot: string,\n  exp: Pick<ExpoConfig, 'sdkVersion'>,\n  pkg: PackageJSONConfig,\n  packagesToCheck?: string[]\n): Promise<boolean | null> {\n  if (env.EXPO_OFFLINE) {\n    Log.warn('Skipping dependency validation in offline mode');\n    return null;\n  }\n\n  const incorrectDeps = await getVersionedDependenciesAsync(projectRoot, exp, pkg, packagesToCheck);\n  return logIncorrectDependencies(incorrectDeps);\n}\n\nfunction logInvalidDependency({\n  packageName,\n  expectedVersionOrRange,\n  actualVersion,\n}: IncorrectDependency) {\n  Log.warn(\n    // chalk` - {underline ${packageName}} - expected version: {underline ${expectedVersionOrRange}} - actual version installed: {underline ${actualVersion}}`\n    chalk`  {bold ${packageName}}{cyan @}{red ${actualVersion}} - expected version: {green ${expectedVersionOrRange}}`\n  );\n}\n\nexport function logIncorrectDependencies(incorrectDeps: IncorrectDependency[]) {\n  if (!incorrectDeps.length) {\n    return true;\n  }\n\n  Log.warn(chalk`Some dependencies are incompatible with the installed {bold expo} version:`);\n  incorrectDeps.forEach((dep) => logInvalidDependency(dep));\n\n  Log.warn(\n    'Your project may not work correctly until you install the correct versions of the packages.\\n' +\n      chalk`Fix with: {bold npx expo install --fix}`\n  );\n  return false;\n}\n\n/**\n * Return a list of versioned dependencies for the project SDK version.\n *\n * @param projectRoot Expo project root.\n * @param exp Expo project config.\n * @param pkg Project's `package.json`.\n * @param packagesToCheck A list of packages to check, if undefined or empty, all will be checked.\n * @returns A list of incorrect dependencies.\n */\nexport async function getVersionedDependenciesAsync(\n  projectRoot: string,\n  exp: Pick<ExpoConfig, 'sdkVersion'>,\n  pkg: PackageJSONConfig,\n  packagesToCheck?: string[]\n): Promise<IncorrectDependency[]> {\n  // This should never happen under normal circumstances since\n  // the CLI is versioned in the `expo` package.\n  assert(exp.sdkVersion, 'SDK Version is missing');\n\n  // Get from both endpoints and combine the known package versions.\n  const combinedKnownPackages = await getCombinedKnownVersionsAsync({\n    projectRoot,\n    sdkVersion: exp.sdkVersion,\n  });\n  // debug(`Known dependencies: %O`, combinedKnownPackages);\n\n  const resolvedDependencies = packagesToCheck?.length\n    ? // Diff the provided packages to ensure we only check against installed packages.\n      getFilteredObject(packagesToCheck, { ...pkg.dependencies, ...pkg.devDependencies })\n    : // If no packages are provided, check against the `package.json` `dependencies` + `devDependencies` object.\n      { ...pkg.dependencies, ...pkg.devDependencies };\n  debug(`Checking dependencies for ${exp.sdkVersion}: %O`, resolvedDependencies);\n\n  // intersection of packages from package.json and bundled native modules\n  const { known: resolvedPackagesToCheck, unknown } = getPackagesToCheck(\n    resolvedDependencies,\n    combinedKnownPackages\n  );\n  debug(`Comparing known versions: %O`, resolvedPackagesToCheck);\n  debug(`Skipping packages that cannot be versioned automatically: %O`, unknown);\n  // read package versions from the file system (node_modules)\n  const packageVersions = await resolvePackageVersionsAsync(projectRoot, resolvedPackagesToCheck);\n  debug(`Package versions: %O`, packageVersions);\n  // find incorrect dependencies by comparing the actual package versions with the bundled native module version ranges\n  let incorrectDeps = findIncorrectDependencies(pkg, packageVersions, combinedKnownPackages);\n  debug(`Incorrect dependencies: %O`, incorrectDeps);\n\n  if (pkg?.expo?.install?.exclude) {\n    const packagesToExclude = pkg.expo.install.exclude;\n    const incorrectAndExcludedDeps = incorrectDeps.filter((dep) =>\n      packagesToExclude.includes(dep.packageName)\n    );\n    debug(\n      `Incorrect dependency warnings filtered out by expo.install.exclude: %O`,\n      incorrectAndExcludedDeps.map((dep) => dep.packageName)\n    );\n    incorrectDeps = incorrectDeps.filter((dep) => !packagesToExclude.includes(dep.packageName));\n  }\n\n  return incorrectDeps;\n}\n\nfunction getFilteredObject(keys: string[], object: Record<string, string>) {\n  return keys.reduce<Record<string, string>>((acc, key) => {\n    acc[key] = object[key];\n    return acc;\n  }, {});\n}\n\nfunction getPackagesToCheck(\n  dependencies: Record<string, string> | null | undefined,\n  bundledNativeModules: BundledNativeModules\n): { known: string[]; unknown: string[] } {\n  const dependencyNames = Object.keys(dependencies ?? {});\n  const known: string[] = [];\n  const unknown: string[] = [];\n  for (const dependencyName of dependencyNames) {\n    if (dependencyName in bundledNativeModules) {\n      known.push(dependencyName);\n    } else {\n      unknown.push(dependencyName);\n    }\n  }\n  return { known, unknown };\n}\n\nasync function resolvePackageVersionsAsync(\n  projectRoot: string,\n  packages: string[]\n): Promise<Record<string, string>> {\n  const packageVersionsFromPackageJSON = await Promise.all(\n    packages.map((packageName) => getPackageVersionAsync(projectRoot, packageName))\n  );\n  return packages.reduce((acc, packageName, idx) => {\n    acc[packageName] = packageVersionsFromPackageJSON[idx];\n    return acc;\n  }, {} as Record<string, string>);\n}\n\nasync function getPackageVersionAsync(projectRoot: string, packageName: string): Promise<string> {\n  let packageJsonPath: string | undefined;\n  try {\n    packageJsonPath = resolveFrom(projectRoot, `${packageName}/package.json`);\n  } catch (error: any) {\n    // This is a workaround for packages using `exports`. If this doesn't\n    // include `package.json`, we have to use the error message to get the location.\n    if (error.code === 'ERR_PACKAGE_PATH_NOT_EXPORTED') {\n      packageJsonPath = error.message.match(/(\"exports\"|defined) in (.*)$/i)?.[2];\n    }\n  }\n  if (!packageJsonPath) {\n    throw new CommandError(\n      `\"${packageName}\" is added as a dependency in your project's package.json but it doesn't seem to be installed. Please run \"yarn\" or \"npm install\" to fix this issue.`\n    );\n  }\n  const packageJson = await JsonFile.readAsync<BundledNativeModules>(packageJsonPath);\n  return packageJson.version;\n}\n\nfunction findIncorrectDependencies(\n  pkg: PackageJSONConfig,\n  packageVersions: Record<string, string>,\n  bundledNativeModules: BundledNativeModules\n): IncorrectDependency[] {\n  const packages = Object.keys(packageVersions);\n  const incorrectDeps: IncorrectDependency[] = [];\n  for (const packageName of packages) {\n    const expectedVersionOrRange = bundledNativeModules[packageName];\n    const actualVersion = packageVersions[packageName];\n    if (\n      typeof expectedVersionOrRange === 'string' &&\n      !semver.intersects(expectedVersionOrRange, actualVersion)\n    ) {\n      incorrectDeps.push({\n        packageName,\n        packageType: findDependencyType(pkg, packageName),\n        expectedVersionOrRange,\n        actualVersion,\n      });\n    }\n  }\n  return incorrectDeps;\n}\n\nfunction findDependencyType(\n  pkg: PackageJSONConfig,\n  packageName: string\n): IncorrectDependency['packageType'] {\n  if (pkg.devDependencies && packageName in pkg.devDependencies) {\n    return 'devDependencies';\n  }\n\n  return 'dependencies';\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}