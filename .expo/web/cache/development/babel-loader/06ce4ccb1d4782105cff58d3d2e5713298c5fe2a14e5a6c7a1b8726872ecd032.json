{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport { anchorIsValid } from \"../doc/anchors.js\";\nimport { visit } from \"../visit.js\";\nimport { ALIAS, isAlias, isCollection, isPair } from \"./identity.js\";\nimport { NodeBase } from \"./Node.js\";\nimport { toJS } from \"./toJS.js\";\nvar Alias = function (_NodeBase) {\n  _inherits(Alias, _NodeBase);\n  var _super = _createSuper(Alias);\n  function Alias(source) {\n    var _this;\n    _classCallCheck(this, Alias);\n    _this = _super.call(this, ALIAS);\n    _this.source = source;\n    Object.defineProperty(_assertThisInitialized(_this), 'tag', {\n      set: function set() {\n        throw new Error('Alias nodes cannot have tags');\n      }\n    });\n    return _this;\n  }\n  _createClass(Alias, [{\n    key: \"resolve\",\n    value: function resolve(doc) {\n      var _this2 = this;\n      var found = undefined;\n      visit(doc, {\n        Node: function Node(_key, node) {\n          if (node === _this2) return visit.BREAK;\n          if (node.anchor === _this2.source) found = node;\n        }\n      });\n      return found;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(_arg, ctx) {\n      if (!ctx) return {\n        source: this.source\n      };\n      var anchors = ctx.anchors,\n        doc = ctx.doc,\n        maxAliasCount = ctx.maxAliasCount;\n      var source = this.resolve(doc);\n      if (!source) {\n        var msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n        throw new ReferenceError(msg);\n      }\n      var data = anchors.get(source);\n      if (!data) {\n        toJS(source, null, ctx);\n        data = anchors.get(source);\n      }\n      if (!data || data.res === undefined) {\n        var _msg = 'This should not happen: Alias anchor was not resolved?';\n        throw new ReferenceError(_msg);\n      }\n      if (maxAliasCount >= 0) {\n        data.count += 1;\n        if (data.aliasCount === 0) data.aliasCount = getAliasCount(doc, source, anchors);\n        if (data.count * data.aliasCount > maxAliasCount) {\n          var _msg2 = 'Excessive alias count indicates a resource exhaustion attack';\n          throw new ReferenceError(_msg2);\n        }\n      }\n      return data.res;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(ctx, _onComment, _onChompKeep) {\n      var src = `*${this.source}`;\n      if (ctx) {\n        anchorIsValid(this.source);\n        if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {\n          var msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n          throw new Error(msg);\n        }\n        if (ctx.implicitKey) return `${src} `;\n      }\n      return src;\n    }\n  }]);\n  return Alias;\n}(NodeBase);\nfunction getAliasCount(doc, node, anchors) {\n  if (isAlias(node)) {\n    var source = node.resolve(doc);\n    var anchor = anchors && source && anchors.get(source);\n    return anchor ? anchor.count * anchor.aliasCount : 0;\n  } else if (isCollection(node)) {\n    var count = 0;\n    for (var item of node.items) {\n      var c = getAliasCount(doc, item, anchors);\n      if (c > count) count = c;\n    }\n    return count;\n  } else if (isPair(node)) {\n    var kc = getAliasCount(doc, node.key, anchors);\n    var vc = getAliasCount(doc, node.value, anchors);\n    return Math.max(kc, vc);\n  }\n  return 1;\n}\nexport { Alias };","map":{"version":3,"names":["anchorIsValid","visit","ALIAS","isAlias","isCollection","isPair","NodeBase","toJS","Alias","_NodeBase","_inherits","_super","_createSuper","source","_this","_classCallCheck","call","Object","defineProperty","_assertThisInitialized","set","Error","_createClass","key","value","resolve","doc","_this2","found","undefined","Node","_key","node","BREAK","anchor","toJSON","_arg","ctx","anchors","maxAliasCount","msg","ReferenceError","data","get","res","count","aliasCount","getAliasCount","toString","_onComment","_onChompKeep","src","options","verifyAliasOrder","has","implicitKey","item","items","c","kc","vc","Math","max"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native-community/cli-doctor/node_modules/yaml/browser/dist/nodes/Alias.js"],"sourcesContent":["import { anchorIsValid } from '../doc/anchors.js';\nimport { visit } from '../visit.js';\nimport { ALIAS, isAlias, isCollection, isPair } from './identity.js';\nimport { NodeBase } from './Node.js';\nimport { toJS } from './toJS.js';\n\nclass Alias extends NodeBase {\n    constructor(source) {\n        super(ALIAS);\n        this.source = source;\n        Object.defineProperty(this, 'tag', {\n            set() {\n                throw new Error('Alias nodes cannot have tags');\n            }\n        });\n    }\n    /**\n     * Resolve the value of this alias within `doc`, finding the last\n     * instance of the `source` anchor before this node.\n     */\n    resolve(doc) {\n        let found = undefined;\n        visit(doc, {\n            Node: (_key, node) => {\n                if (node === this)\n                    return visit.BREAK;\n                if (node.anchor === this.source)\n                    found = node;\n            }\n        });\n        return found;\n    }\n    toJSON(_arg, ctx) {\n        if (!ctx)\n            return { source: this.source };\n        const { anchors, doc, maxAliasCount } = ctx;\n        const source = this.resolve(doc);\n        if (!source) {\n            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n            throw new ReferenceError(msg);\n        }\n        let data = anchors.get(source);\n        if (!data) {\n            // Resolve anchors for Node.prototype.toJS()\n            toJS(source, null, ctx);\n            data = anchors.get(source);\n        }\n        /* istanbul ignore if */\n        if (!data || data.res === undefined) {\n            const msg = 'This should not happen: Alias anchor was not resolved?';\n            throw new ReferenceError(msg);\n        }\n        if (maxAliasCount >= 0) {\n            data.count += 1;\n            if (data.aliasCount === 0)\n                data.aliasCount = getAliasCount(doc, source, anchors);\n            if (data.count * data.aliasCount > maxAliasCount) {\n                const msg = 'Excessive alias count indicates a resource exhaustion attack';\n                throw new ReferenceError(msg);\n            }\n        }\n        return data.res;\n    }\n    toString(ctx, _onComment, _onChompKeep) {\n        const src = `*${this.source}`;\n        if (ctx) {\n            anchorIsValid(this.source);\n            if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {\n                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n                throw new Error(msg);\n            }\n            if (ctx.implicitKey)\n                return `${src} `;\n        }\n        return src;\n    }\n}\nfunction getAliasCount(doc, node, anchors) {\n    if (isAlias(node)) {\n        const source = node.resolve(doc);\n        const anchor = anchors && source && anchors.get(source);\n        return anchor ? anchor.count * anchor.aliasCount : 0;\n    }\n    else if (isCollection(node)) {\n        let count = 0;\n        for (const item of node.items) {\n            const c = getAliasCount(doc, item, anchors);\n            if (c > count)\n                count = c;\n        }\n        return count;\n    }\n    else if (isPair(node)) {\n        const kc = getAliasCount(doc, node.key, anchors);\n        const vc = getAliasCount(doc, node.value, anchors);\n        return Math.max(kc, vc);\n    }\n    return 1;\n}\n\nexport { Alias };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}