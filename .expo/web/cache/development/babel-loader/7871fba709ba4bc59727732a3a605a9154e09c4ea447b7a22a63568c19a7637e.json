{"ast":null,"code":"'use strict';\n\nvar _require = require(\"../parseTopLevelType\"),\n  flattenIntersectionType = _require.flattenIntersectionType;\nvar _require2 = require(\"../components/componentsUtils\"),\n  flattenProperties = _require2.flattenProperties;\nvar _require3 = require(\"../utils\"),\n  resolveTypeAnnotation = _require3.resolveTypeAnnotation;\nvar _require4 = require(\"../../parsers-commons\"),\n  parseObjectProperty = _require4.parseObjectProperty;\nvar _require5 = require(\"../../parsers-primitives\"),\n  emitArrayType = _require5.emitArrayType,\n  emitBoolean = _require5.emitBoolean,\n  emitFunction = _require5.emitFunction,\n  emitNumber = _require5.emitNumber,\n  emitGenericObject = _require5.emitGenericObject,\n  emitPromise = _require5.emitPromise,\n  emitRootTag = _require5.emitRootTag,\n  emitVoid = _require5.emitVoid,\n  emitString = _require5.emitString,\n  emitMixed = _require5.emitMixed,\n  emitUnion = _require5.emitUnion,\n  emitCommonTypes = _require5.emitCommonTypes,\n  typeAliasResolution = _require5.typeAliasResolution,\n  typeEnumResolution = _require5.typeEnumResolution,\n  translateArrayTypeAnnotation = _require5.translateArrayTypeAnnotation;\nvar _require6 = require(\"../../errors\"),\n  UnsupportedGenericParserError = _require6.UnsupportedGenericParserError,\n  UnsupportedTypeAnnotationParserError = _require6.UnsupportedTypeAnnotationParserError;\nfunction translateObjectTypeAnnotation(hasteModuleName, nullable, objectMembers, typeResolutionStatus, baseTypes, types, aliasMap, enumMap, tryParse, cxxOnly, parser) {\n  var properties = objectMembers.map(function (property) {\n    return tryParse(function () {\n      return parseObjectProperty(property, hasteModuleName, types, aliasMap, enumMap, tryParse, cxxOnly, nullable, translateTypeAnnotation, parser);\n    });\n  }).filter(Boolean);\n  var objectTypeAnnotation;\n  if (baseTypes.length === 0) {\n    objectTypeAnnotation = {\n      type: 'ObjectTypeAnnotation',\n      properties: properties\n    };\n  } else {\n    objectTypeAnnotation = {\n      type: 'ObjectTypeAnnotation',\n      properties: properties,\n      baseTypes: baseTypes\n    };\n  }\n  return typeAliasResolution(typeResolutionStatus, objectTypeAnnotation, aliasMap, nullable);\n}\nfunction translateTypeReferenceAnnotation(typeName, nullable, typeAnnotation, hasteModuleName, types, aliasMap, enumMap, tryParse, cxxOnly, parser) {\n  switch (typeName) {\n    case 'RootTag':\n      {\n        return emitRootTag(nullable);\n      }\n    case 'Promise':\n      {\n        return emitPromise(hasteModuleName, typeAnnotation, parser, nullable, types, aliasMap, enumMap, tryParse, cxxOnly, translateTypeAnnotation);\n      }\n    case 'Array':\n    case 'ReadonlyArray':\n      {\n        return emitArrayType(hasteModuleName, typeAnnotation, parser, types, aliasMap, enumMap, cxxOnly, nullable, translateTypeAnnotation);\n      }\n    default:\n      {\n        var commonType = emitCommonTypes(hasteModuleName, types, typeAnnotation, aliasMap, enumMap, tryParse, cxxOnly, nullable, parser);\n        if (!commonType) {\n          throw new UnsupportedGenericParserError(hasteModuleName, typeAnnotation, parser);\n        }\n        return commonType;\n      }\n  }\n}\nfunction translateTypeAnnotation(hasteModuleName, typeScriptTypeAnnotation, types, aliasMap, enumMap, tryParse, cxxOnly, parser) {\n  var _resolveTypeAnnotatio = resolveTypeAnnotation(typeScriptTypeAnnotation, types),\n    nullable = _resolveTypeAnnotatio.nullable,\n    typeAnnotation = _resolveTypeAnnotatio.typeAnnotation,\n    typeResolutionStatus = _resolveTypeAnnotatio.typeResolutionStatus;\n  switch (typeAnnotation.type) {\n    case 'TSArrayType':\n      {\n        return translateArrayTypeAnnotation(hasteModuleName, types, aliasMap, enumMap, cxxOnly, 'Array', typeAnnotation.elementType, nullable, translateTypeAnnotation, parser);\n      }\n    case 'TSTypeOperator':\n      {\n        if (typeAnnotation.operator === 'readonly' && typeAnnotation.typeAnnotation.type === 'TSArrayType') {\n          return translateArrayTypeAnnotation(hasteModuleName, types, aliasMap, enumMap, cxxOnly, 'ReadonlyArray', typeAnnotation.typeAnnotation.elementType, nullable, translateTypeAnnotation, parser);\n        } else {\n          throw new UnsupportedGenericParserError(hasteModuleName, typeAnnotation, parser);\n        }\n      }\n    case 'TSTypeReference':\n      {\n        return translateTypeReferenceAnnotation(typeAnnotation.typeName.name, nullable, typeAnnotation, hasteModuleName, types, aliasMap, enumMap, tryParse, cxxOnly, parser);\n      }\n    case 'TSInterfaceDeclaration':\n      {\n        var _typeAnnotation$exten;\n        var baseTypes = ((_typeAnnotation$exten = typeAnnotation.extends) !== null && _typeAnnotation$exten !== void 0 ? _typeAnnotation$exten : []).map(function (extend) {\n          return extend.expression.name;\n        });\n        for (var baseType of baseTypes) {\n          translateTypeAnnotation(hasteModuleName, {\n            type: 'TSTypeReference',\n            typeName: {\n              type: 'Identifier',\n              name: baseType\n            }\n          }, types, aliasMap, enumMap, tryParse, cxxOnly, parser);\n        }\n        return translateObjectTypeAnnotation(hasteModuleName, nullable, flattenProperties([typeAnnotation], types), typeResolutionStatus, baseTypes, types, aliasMap, enumMap, tryParse, cxxOnly, parser);\n      }\n    case 'TSIntersectionType':\n      {\n        return translateObjectTypeAnnotation(hasteModuleName, nullable, flattenProperties(flattenIntersectionType(typeAnnotation, types), types), typeResolutionStatus, [], types, aliasMap, enumMap, tryParse, cxxOnly, parser);\n      }\n    case 'TSTypeLiteral':\n      {\n        if (typeAnnotation.members) {\n          var indexSignatures = typeAnnotation.members.filter(function (member) {\n            return member.type === 'TSIndexSignature';\n          });\n          if (indexSignatures.length > 0) {\n            var propertyType = indexSignatures[0].typeAnnotation;\n            translateTypeAnnotation(hasteModuleName, propertyType, types, aliasMap, enumMap, tryParse, cxxOnly, parser);\n            return emitGenericObject(nullable);\n          }\n        }\n        return translateObjectTypeAnnotation(hasteModuleName, nullable, typeAnnotation.members, typeResolutionStatus, [], types, aliasMap, enumMap, tryParse, cxxOnly, parser);\n      }\n    case 'TSEnumDeclaration':\n      {\n        return typeEnumResolution(typeAnnotation, typeResolutionStatus, nullable, hasteModuleName, enumMap, parser);\n      }\n    case 'TSBooleanKeyword':\n      {\n        return emitBoolean(nullable);\n      }\n    case 'TSNumberKeyword':\n      {\n        return emitNumber(nullable);\n      }\n    case 'TSVoidKeyword':\n      {\n        return emitVoid(nullable);\n      }\n    case 'TSStringKeyword':\n      {\n        return emitString(nullable);\n      }\n    case 'TSFunctionType':\n      {\n        return emitFunction(nullable, hasteModuleName, typeAnnotation, types, aliasMap, enumMap, tryParse, cxxOnly, translateTypeAnnotation, parser);\n      }\n    case 'TSUnionType':\n      {\n        return emitUnion(nullable, hasteModuleName, typeAnnotation, parser);\n      }\n    case 'TSUnknownKeyword':\n      {\n        if (cxxOnly) {\n          return emitMixed(nullable);\n        }\n      }\n    default:\n      {\n        throw new UnsupportedTypeAnnotationParserError(hasteModuleName, typeAnnotation, parser.language());\n      }\n  }\n}\nmodule.exports = {\n  typeScriptTranslateTypeAnnotation: translateTypeAnnotation\n};","map":{"version":3,"names":["_require","require","flattenIntersectionType","_require2","flattenProperties","_require3","resolveTypeAnnotation","_require4","parseObjectProperty","_require5","emitArrayType","emitBoolean","emitFunction","emitNumber","emitGenericObject","emitPromise","emitRootTag","emitVoid","emitString","emitMixed","emitUnion","emitCommonTypes","typeAliasResolution","typeEnumResolution","translateArrayTypeAnnotation","_require6","UnsupportedGenericParserError","UnsupportedTypeAnnotationParserError","translateObjectTypeAnnotation","hasteModuleName","nullable","objectMembers","typeResolutionStatus","baseTypes","types","aliasMap","enumMap","tryParse","cxxOnly","parser","properties","map","property","translateTypeAnnotation","filter","Boolean","objectTypeAnnotation","length","type","translateTypeReferenceAnnotation","typeName","typeAnnotation","commonType","typeScriptTypeAnnotation","_resolveTypeAnnotatio","elementType","operator","name","_typeAnnotation$exten","extends","extend","expression","baseType","members","indexSignatures","member","propertyType","language","module","exports","typeScriptTranslateTypeAnnotation"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native/codegen/lib/parsers/typescript/modules/index.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\n'use strict';\n\nconst _require = require('../parseTopLevelType'),\n  flattenIntersectionType = _require.flattenIntersectionType;\nconst _require2 = require('../components/componentsUtils'),\n  flattenProperties = _require2.flattenProperties;\nconst _require3 = require('../utils'),\n  resolveTypeAnnotation = _require3.resolveTypeAnnotation;\nconst _require4 = require('../../parsers-commons'),\n  parseObjectProperty = _require4.parseObjectProperty;\nconst _require5 = require('../../parsers-primitives'),\n  emitArrayType = _require5.emitArrayType,\n  emitBoolean = _require5.emitBoolean,\n  emitFunction = _require5.emitFunction,\n  emitNumber = _require5.emitNumber,\n  emitGenericObject = _require5.emitGenericObject,\n  emitPromise = _require5.emitPromise,\n  emitRootTag = _require5.emitRootTag,\n  emitVoid = _require5.emitVoid,\n  emitString = _require5.emitString,\n  emitMixed = _require5.emitMixed,\n  emitUnion = _require5.emitUnion,\n  emitCommonTypes = _require5.emitCommonTypes,\n  typeAliasResolution = _require5.typeAliasResolution,\n  typeEnumResolution = _require5.typeEnumResolution,\n  translateArrayTypeAnnotation = _require5.translateArrayTypeAnnotation;\nconst _require6 = require('../../errors'),\n  UnsupportedGenericParserError = _require6.UnsupportedGenericParserError,\n  UnsupportedTypeAnnotationParserError =\n    _require6.UnsupportedTypeAnnotationParserError;\nfunction translateObjectTypeAnnotation(\n  hasteModuleName,\n  /**\n   * TODO(T108222691): Use flow-types for @babel/parser\n   */\n  nullable,\n  objectMembers,\n  typeResolutionStatus,\n  baseTypes,\n  types,\n  aliasMap,\n  enumMap,\n  tryParse,\n  cxxOnly,\n  parser,\n) {\n  // $FlowFixMe[missing-type-arg]\n  const properties = objectMembers\n    .map(property => {\n      return tryParse(() => {\n        return parseObjectProperty(\n          property,\n          hasteModuleName,\n          types,\n          aliasMap,\n          enumMap,\n          tryParse,\n          cxxOnly,\n          nullable,\n          translateTypeAnnotation,\n          parser,\n        );\n      });\n    })\n    .filter(Boolean);\n  let objectTypeAnnotation;\n  if (baseTypes.length === 0) {\n    objectTypeAnnotation = {\n      type: 'ObjectTypeAnnotation',\n      properties,\n    };\n  } else {\n    objectTypeAnnotation = {\n      type: 'ObjectTypeAnnotation',\n      properties,\n      baseTypes,\n    };\n  }\n  return typeAliasResolution(\n    typeResolutionStatus,\n    objectTypeAnnotation,\n    aliasMap,\n    nullable,\n  );\n}\nfunction translateTypeReferenceAnnotation(\n  typeName,\n  nullable,\n  typeAnnotation,\n  hasteModuleName,\n  types,\n  aliasMap,\n  enumMap,\n  tryParse,\n  cxxOnly,\n  parser,\n) {\n  switch (typeName) {\n    case 'RootTag': {\n      return emitRootTag(nullable);\n    }\n    case 'Promise': {\n      return emitPromise(\n        hasteModuleName,\n        typeAnnotation,\n        parser,\n        nullable,\n        types,\n        aliasMap,\n        enumMap,\n        tryParse,\n        cxxOnly,\n        translateTypeAnnotation,\n      );\n    }\n    case 'Array':\n    case 'ReadonlyArray': {\n      return emitArrayType(\n        hasteModuleName,\n        typeAnnotation,\n        parser,\n        types,\n        aliasMap,\n        enumMap,\n        cxxOnly,\n        nullable,\n        translateTypeAnnotation,\n      );\n    }\n    default: {\n      const commonType = emitCommonTypes(\n        hasteModuleName,\n        types,\n        typeAnnotation,\n        aliasMap,\n        enumMap,\n        tryParse,\n        cxxOnly,\n        nullable,\n        parser,\n      );\n      if (!commonType) {\n        throw new UnsupportedGenericParserError(\n          hasteModuleName,\n          typeAnnotation,\n          parser,\n        );\n      }\n      return commonType;\n    }\n  }\n}\nfunction translateTypeAnnotation(\n  hasteModuleName,\n  /**\n   * TODO(T108222691): Use flow-types for @babel/parser\n   */\n  typeScriptTypeAnnotation,\n  types,\n  aliasMap,\n  enumMap,\n  tryParse,\n  cxxOnly,\n  parser,\n) {\n  const _resolveTypeAnnotatio = resolveTypeAnnotation(\n      typeScriptTypeAnnotation,\n      types,\n    ),\n    nullable = _resolveTypeAnnotatio.nullable,\n    typeAnnotation = _resolveTypeAnnotatio.typeAnnotation,\n    typeResolutionStatus = _resolveTypeAnnotatio.typeResolutionStatus;\n  switch (typeAnnotation.type) {\n    case 'TSArrayType': {\n      return translateArrayTypeAnnotation(\n        hasteModuleName,\n        types,\n        aliasMap,\n        enumMap,\n        cxxOnly,\n        'Array',\n        typeAnnotation.elementType,\n        nullable,\n        translateTypeAnnotation,\n        parser,\n      );\n    }\n    case 'TSTypeOperator': {\n      if (\n        typeAnnotation.operator === 'readonly' &&\n        typeAnnotation.typeAnnotation.type === 'TSArrayType'\n      ) {\n        return translateArrayTypeAnnotation(\n          hasteModuleName,\n          types,\n          aliasMap,\n          enumMap,\n          cxxOnly,\n          'ReadonlyArray',\n          typeAnnotation.typeAnnotation.elementType,\n          nullable,\n          translateTypeAnnotation,\n          parser,\n        );\n      } else {\n        throw new UnsupportedGenericParserError(\n          hasteModuleName,\n          typeAnnotation,\n          parser,\n        );\n      }\n    }\n    case 'TSTypeReference': {\n      return translateTypeReferenceAnnotation(\n        typeAnnotation.typeName.name,\n        nullable,\n        typeAnnotation,\n        hasteModuleName,\n        types,\n        aliasMap,\n        enumMap,\n        tryParse,\n        cxxOnly,\n        parser,\n      );\n    }\n    case 'TSInterfaceDeclaration': {\n      var _typeAnnotation$exten;\n      const baseTypes = (\n        (_typeAnnotation$exten = typeAnnotation.extends) !== null &&\n        _typeAnnotation$exten !== void 0\n          ? _typeAnnotation$exten\n          : []\n      ).map(extend => extend.expression.name);\n      for (const baseType of baseTypes) {\n        // ensure base types exist and appear in aliasMap\n        translateTypeAnnotation(\n          hasteModuleName,\n          {\n            type: 'TSTypeReference',\n            typeName: {\n              type: 'Identifier',\n              name: baseType,\n            },\n          },\n          types,\n          aliasMap,\n          enumMap,\n          tryParse,\n          cxxOnly,\n          parser,\n        );\n      }\n      return translateObjectTypeAnnotation(\n        hasteModuleName,\n        nullable,\n        flattenProperties([typeAnnotation], types),\n        typeResolutionStatus,\n        baseTypes,\n        types,\n        aliasMap,\n        enumMap,\n        tryParse,\n        cxxOnly,\n        parser,\n      );\n    }\n    case 'TSIntersectionType': {\n      return translateObjectTypeAnnotation(\n        hasteModuleName,\n        nullable,\n        flattenProperties(\n          flattenIntersectionType(typeAnnotation, types),\n          types,\n        ),\n        typeResolutionStatus,\n        [],\n        types,\n        aliasMap,\n        enumMap,\n        tryParse,\n        cxxOnly,\n        parser,\n      );\n    }\n    case 'TSTypeLiteral': {\n      // if there is TSIndexSignature, then it is a dictionary\n      if (typeAnnotation.members) {\n        const indexSignatures = typeAnnotation.members.filter(\n          member => member.type === 'TSIndexSignature',\n        );\n        if (indexSignatures.length > 0) {\n          // check the property type to prevent developers from using unsupported types\n          // the return value from `translateTypeAnnotation` is unused\n          const propertyType = indexSignatures[0].typeAnnotation;\n          translateTypeAnnotation(\n            hasteModuleName,\n            propertyType,\n            types,\n            aliasMap,\n            enumMap,\n            tryParse,\n            cxxOnly,\n            parser,\n          );\n          // no need to do further checking\n          return emitGenericObject(nullable);\n        }\n      }\n      return translateObjectTypeAnnotation(\n        hasteModuleName,\n        nullable,\n        typeAnnotation.members,\n        typeResolutionStatus,\n        [],\n        types,\n        aliasMap,\n        enumMap,\n        tryParse,\n        cxxOnly,\n        parser,\n      );\n    }\n    case 'TSEnumDeclaration': {\n      return typeEnumResolution(\n        typeAnnotation,\n        typeResolutionStatus,\n        nullable,\n        hasteModuleName,\n        enumMap,\n        parser,\n      );\n    }\n    case 'TSBooleanKeyword': {\n      return emitBoolean(nullable);\n    }\n    case 'TSNumberKeyword': {\n      return emitNumber(nullable);\n    }\n    case 'TSVoidKeyword': {\n      return emitVoid(nullable);\n    }\n    case 'TSStringKeyword': {\n      return emitString(nullable);\n    }\n    case 'TSFunctionType': {\n      return emitFunction(\n        nullable,\n        hasteModuleName,\n        typeAnnotation,\n        types,\n        aliasMap,\n        enumMap,\n        tryParse,\n        cxxOnly,\n        translateTypeAnnotation,\n        parser,\n      );\n    }\n    case 'TSUnionType': {\n      return emitUnion(nullable, hasteModuleName, typeAnnotation, parser);\n    }\n    case 'TSUnknownKeyword': {\n      if (cxxOnly) {\n        return emitMixed(nullable);\n      }\n      // Fallthrough\n    }\n\n    default: {\n      throw new UnsupportedTypeAnnotationParserError(\n        hasteModuleName,\n        typeAnnotation,\n        parser.language(),\n      );\n    }\n  }\n}\nmodule.exports = {\n  typeScriptTranslateTypeAnnotation: translateTypeAnnotation,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}