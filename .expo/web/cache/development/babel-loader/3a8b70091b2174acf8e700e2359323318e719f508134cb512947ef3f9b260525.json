{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findLastIndex = findLastIndex;\nexports.intersecting = intersecting;\nexports.replaceValue = replaceValue;\nexports.uniqBy = uniqBy;\nexports.chunk = chunk;\nexports.groupBy = groupBy;\nfunction findLastIndex(array, predicate) {\n  for (var i = array.length - 1; i >= 0; i--) {\n    if (predicate(array[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction intersecting(a, b) {\n  var _ref = a.length > b.length ? [a, b] : [b, a],\n    _ref2 = _slicedToArray(_ref, 2),\n    c = _ref2[0],\n    d = _ref2[1];\n  return c.filter(function (value) {\n    return d.includes(value);\n  });\n}\nfunction replaceValue(values, original, replacement) {\n  var index = values.indexOf(original);\n  if (index > -1) {\n    values[index] = replacement;\n  }\n  return values;\n}\nfunction uniqBy(array, key) {\n  var seen = {};\n  return array.filter(function (item) {\n    var k = key(item);\n    if (seen[k]) {\n      return false;\n    }\n    seen[k] = true;\n    return true;\n  });\n}\nfunction chunk(array, size) {\n  var chunked = [];\n  var index = 0;\n  while (index < array.length) {\n    chunked.push(array.slice(index, index += size));\n  }\n  return chunked;\n}\nfunction groupBy(list, getKey) {\n  return list.reduce(function (previous, currentItem) {\n    var group = getKey(currentItem);\n    if (!previous[group]) {\n      previous[group] = [];\n    }\n    previous[group].push(currentItem);\n    return previous;\n  }, {});\n}","map":{"version":3,"names":["_slicedToArray","require","findLastIndex","intersecting","replaceValue","uniqBy","chunk","groupBy","array","predicate","i","length","a","b","_ref","_ref2","c","d","filter","value","includes","values","original","replacement","index","indexOf","key","seen","item","k","size","chunked","push","slice","list","getKey","reduce","previous","currentItem","group"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\cli\\src\\utils\\array.ts"],"sourcesContent":["/** Returns the last index of an item based on a given criteria. */\nexport function findLastIndex<T>(array: T[], predicate: (item: T) => boolean) {\n  for (let i = array.length - 1; i >= 0; i--) {\n    if (predicate(array[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/** Returns a list of items that intersect between two given arrays. */\nexport function intersecting<T>(a: T[], b: T[]): T[] {\n  const [c, d] = a.length > b.length ? [a, b] : [b, a];\n  return c.filter((value) => d.includes(value));\n}\n\nexport function replaceValue<T>(values: T[], original: T, replacement: T): T[] {\n  const index = values.indexOf(original);\n  if (index > -1) {\n    values[index] = replacement;\n  }\n  return values;\n}\n\n/** lodash.uniqBy */\nexport function uniqBy<T>(array: T[], key: (item: T) => string): T[] {\n  const seen: { [key: string]: boolean } = {};\n  return array.filter((item) => {\n    const k = key(item);\n    if (seen[k]) {\n      return false;\n    }\n    seen[k] = true;\n    return true;\n  });\n}\n\n/** `lodash.chunk` */\nexport function chunk<T>(array: T[], size: number): T[][] {\n  const chunked = [];\n  let index = 0;\n  while (index < array.length) {\n    chunked.push(array.slice(index, (index += size)));\n  }\n  return chunked;\n}\n\n/** `lodash.groupBy` */\nexport function groupBy<T, K extends keyof any>(list: T[], getKey: (item: T) => K): Record<K, T[]> {\n  return list.reduce((previous, currentItem) => {\n    const group = getKey(currentItem);\n    if (!previous[group]) {\n      previous[group] = [];\n    }\n    previous[group].push(currentItem);\n    return previous;\n  }, {} as Record<K, T[]>);\n}\n"],"mappings":"AACA;;AAAA,IAAAA,cAAA,GAAAC,OAAA;;;;QAAgBC,aAAa,GAAbA,aAAa;QAUbC,YAAY,GAAZA,YAAY;QAKZC,YAAY,GAAZA,YAAY;QASZC,MAAM,GAANA,MAAM;QAaNC,KAAK,GAALA,KAAK;QAULC,OAAO,GAAPA,OAAO;AA/ChB,SAASL,aAAaA,CAAIM,KAAU,EAAEC,SAA+B,EAAE;EAC5E,KAAK,IAAIC,CAAC,GAAGF,KAAK,CAACG,MAAM,GAAG,CAAC,EAAED,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC1C,IAAID,SAAS,CAACD,KAAK,CAACE,CAAC,CAAC,CAAC,EAAE;MACvB,OAAOA,CAAC;;;EAGZ,OAAO,CAAC,CAAC;;AAIJ,SAASP,YAAYA,CAAIS,CAAM,EAAEC,CAAM,EAAO;EACnD,IAAAC,IAAA,GAAeF,CAAC,CAACD,MAAM,GAAGE,CAAC,CAACF,MAAM,GAAG,CAACC,CAAC,EAAEC,CAAC,CAAC,GAAG,CAACA,CAAC,EAAED,CAAC,CAAC;IAAAG,KAAA,GAAAf,cAAA,CAAAc,IAAA;IAA7CE,CAAC,GAAAD,KAAA;IAAEE,CAAC,GAAAF,KAAA;EACX,OAAOC,CAAC,CAACE,MAAM,CAAC,UAACC,KAAK;IAAA,OAAKF,CAAC,CAACG,QAAQ,CAACD,KAAK,CAAC;EAAA,EAAC;;AAGxC,SAASf,YAAYA,CAAIiB,MAAW,EAAEC,QAAW,EAAEC,WAAc,EAAO;EAC7E,IAAMC,KAAK,GAAGH,MAAM,CAACI,OAAO,CAACH,QAAQ,CAAC;EACtC,IAAIE,KAAK,GAAG,CAAC,CAAC,EAAE;IACdH,MAAM,CAACG,KAAK,CAAC,GAAGD,WAAW;;EAE7B,OAAOF,MAAM;;AAIR,SAAShB,MAAMA,CAAIG,KAAU,EAAEkB,GAAwB,EAAO;EACnE,IAAMC,IAAI,GAA+B,EAAE;EAC3C,OAAOnB,KAAK,CAACU,MAAM,CAAC,UAACU,IAAI,EAAK;IAC5B,IAAMC,CAAC,GAAGH,GAAG,CAACE,IAAI,CAAC;IACnB,IAAID,IAAI,CAACE,CAAC,CAAC,EAAE;MACX,OAAO,KAAK;;IAEdF,IAAI,CAACE,CAAC,CAAC,GAAG,IAAI;IACd,OAAO,IAAI;GACZ,CAAC;;AAIG,SAASvB,KAAKA,CAAIE,KAAU,EAAEsB,IAAY,EAAS;EACxD,IAAMC,OAAO,GAAG,EAAE;EAClB,IAAIP,KAAK,GAAG,CAAC;EACb,OAAOA,KAAK,GAAGhB,KAAK,CAACG,MAAM,EAAE;IAC3BoB,OAAO,CAACC,IAAI,CAACxB,KAAK,CAACyB,KAAK,CAACT,KAAK,EAAGA,KAAK,IAAIM,IAAI,CAAE,CAAC;;EAEnD,OAAOC,OAAO;;AAIT,SAASxB,OAAOA,CAAyB2B,IAAS,EAAEC,MAAsB,EAAkB;EACjG,OAAOD,IAAI,CAACE,MAAM,CAAC,UAACC,QAAQ,EAAEC,WAAW,EAAK;IAC5C,IAAMC,KAAK,GAAGJ,MAAM,CAACG,WAAW,CAAC;IACjC,IAAI,CAACD,QAAQ,CAACE,KAAK,CAAC,EAAE;MACpBF,QAAQ,CAACE,KAAK,CAAC,GAAG,EAAE;;IAEtBF,QAAQ,CAACE,KAAK,CAAC,CAACP,IAAI,CAACM,WAAW,CAAC;IACjC,OAAOD,QAAQ;GAChB,EAAE,EAAE,CAAmB"},"metadata":{},"sourceType":"script","externalDependencies":[]}