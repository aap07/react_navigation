{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { BOM, DOCUMENT, FLOW_END, SCALAR } from \"./cst.js\";\nfunction isEmpty(ch) {\n  switch (ch) {\n    case undefined:\n    case ' ':\n    case '\\n':\n    case '\\r':\n    case '\\t':\n      return true;\n    default:\n      return false;\n  }\n}\nvar hexDigits = '0123456789ABCDEFabcdef'.split('');\nvar tagChars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()\".split('');\nvar invalidFlowScalarChars = ',[]{}'.split('');\nvar invalidAnchorChars = ' ,[]{}\\n\\r\\t'.split('');\nvar isNotAnchorChar = function isNotAnchorChar(ch) {\n  return !ch || invalidAnchorChars.includes(ch);\n};\nvar Lexer = function () {\n  function Lexer() {\n    _classCallCheck(this, Lexer);\n    this.atEnd = false;\n    this.blockScalarIndent = -1;\n    this.blockScalarKeep = false;\n    this.buffer = '';\n    this.flowKey = false;\n    this.flowLevel = 0;\n    this.indentNext = 0;\n    this.indentValue = 0;\n    this.lineEndPos = null;\n    this.next = null;\n    this.pos = 0;\n  }\n  _createClass(Lexer, [{\n    key: \"lex\",\n    value: function lex(source) {\n      var _this = this;\n      var incomplete = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return function* (_this$next) {\n        if (source) {\n          _this.buffer = _this.buffer ? _this.buffer + source : source;\n          _this.lineEndPos = null;\n        }\n        _this.atEnd = !incomplete;\n        var next = (_this$next = _this.next) != null ? _this$next : 'stream';\n        while (next && (incomplete || _this.hasChars(1))) next = yield* _this.parseNext(next);\n      }();\n    }\n  }, {\n    key: \"atLineEnd\",\n    value: function atLineEnd() {\n      var i = this.pos;\n      var ch = this.buffer[i];\n      while (ch === ' ' || ch === '\\t') ch = this.buffer[++i];\n      if (!ch || ch === '#' || ch === '\\n') return true;\n      if (ch === '\\r') return this.buffer[i + 1] === '\\n';\n      return false;\n    }\n  }, {\n    key: \"charAt\",\n    value: function charAt(n) {\n      return this.buffer[this.pos + n];\n    }\n  }, {\n    key: \"continueScalar\",\n    value: function continueScalar(offset) {\n      var ch = this.buffer[offset];\n      if (this.indentNext > 0) {\n        var indent = 0;\n        while (ch === ' ') ch = this.buffer[++indent + offset];\n        if (ch === '\\r') {\n          var next = this.buffer[indent + offset + 1];\n          if (next === '\\n' || !next && !this.atEnd) return offset + indent + 1;\n        }\n        return ch === '\\n' || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;\n      }\n      if (ch === '-' || ch === '.') {\n        var dt = this.buffer.substr(offset, 3);\n        if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3])) return -1;\n      }\n      return offset;\n    }\n  }, {\n    key: \"getLine\",\n    value: function getLine() {\n      var end = this.lineEndPos;\n      if (typeof end !== 'number' || end !== -1 && end < this.pos) {\n        end = this.buffer.indexOf('\\n', this.pos);\n        this.lineEndPos = end;\n      }\n      if (end === -1) return this.atEnd ? this.buffer.substring(this.pos) : null;\n      if (this.buffer[end - 1] === '\\r') end -= 1;\n      return this.buffer.substring(this.pos, end);\n    }\n  }, {\n    key: \"hasChars\",\n    value: function hasChars(n) {\n      return this.pos + n <= this.buffer.length;\n    }\n  }, {\n    key: \"setNext\",\n    value: function setNext(state) {\n      this.buffer = this.buffer.substring(this.pos);\n      this.pos = 0;\n      this.lineEndPos = null;\n      this.next = state;\n      return null;\n    }\n  }, {\n    key: \"peek\",\n    value: function peek(n) {\n      return this.buffer.substr(this.pos, n);\n    }\n  }, {\n    key: \"parseNext\",\n    value: function* parseNext(next) {\n      switch (next) {\n        case 'stream':\n          return yield* this.parseStream();\n        case 'line-start':\n          return yield* this.parseLineStart();\n        case 'block-start':\n          return yield* this.parseBlockStart();\n        case 'doc':\n          return yield* this.parseDocument();\n        case 'flow':\n          return yield* this.parseFlowCollection();\n        case 'quoted-scalar':\n          return yield* this.parseQuotedScalar();\n        case 'block-scalar':\n          return yield* this.parseBlockScalar();\n        case 'plain-scalar':\n          return yield* this.parsePlainScalar();\n      }\n    }\n  }, {\n    key: \"parseStream\",\n    value: function* parseStream() {\n      var line = this.getLine();\n      if (line === null) return this.setNext('stream');\n      if (line[0] === BOM) {\n        yield* this.pushCount(1);\n        line = line.substring(1);\n      }\n      if (line[0] === '%') {\n        var dirEnd = line.length;\n        var cs = line.indexOf('#');\n        if (cs !== -1) {\n          var ch = line[cs - 1];\n          if (ch === ' ' || ch === '\\t') dirEnd = cs - 1;\n        }\n        while (true) {\n          var _ch = line[dirEnd - 1];\n          if (_ch === ' ' || _ch === '\\t') dirEnd -= 1;else break;\n        }\n        var n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));\n        yield* this.pushCount(line.length - n);\n        this.pushNewline();\n        return 'stream';\n      }\n      if (this.atLineEnd()) {\n        var sp = yield* this.pushSpaces(true);\n        yield* this.pushCount(line.length - sp);\n        yield* this.pushNewline();\n        return 'stream';\n      }\n      yield DOCUMENT;\n      return yield* this.parseLineStart();\n    }\n  }, {\n    key: \"parseLineStart\",\n    value: function* parseLineStart() {\n      var ch = this.charAt(0);\n      if (!ch && !this.atEnd) return this.setNext('line-start');\n      if (ch === '-' || ch === '.') {\n        if (!this.atEnd && !this.hasChars(4)) return this.setNext('line-start');\n        var s = this.peek(3);\n        if (s === '---' && isEmpty(this.charAt(3))) {\n          yield* this.pushCount(3);\n          this.indentValue = 0;\n          this.indentNext = 0;\n          return 'doc';\n        } else if (s === '...' && isEmpty(this.charAt(3))) {\n          yield* this.pushCount(3);\n          return 'stream';\n        }\n      }\n      this.indentValue = yield* this.pushSpaces(false);\n      if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1))) this.indentNext = this.indentValue;\n      return yield* this.parseBlockStart();\n    }\n  }, {\n    key: \"parseBlockStart\",\n    value: function* parseBlockStart() {\n      var _this$peek = this.peek(2),\n        _this$peek2 = _slicedToArray(_this$peek, 2),\n        ch0 = _this$peek2[0],\n        ch1 = _this$peek2[1];\n      if (!ch1 && !this.atEnd) return this.setNext('block-start');\n      if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {\n        var n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));\n        this.indentNext = this.indentValue + 1;\n        this.indentValue += n;\n        return yield* this.parseBlockStart();\n      }\n      return 'doc';\n    }\n  }, {\n    key: \"parseDocument\",\n    value: function* parseDocument() {\n      yield* this.pushSpaces(true);\n      var line = this.getLine();\n      if (line === null) return this.setNext('doc');\n      var n = yield* this.pushIndicators();\n      switch (line[n]) {\n        case '#':\n          yield* this.pushCount(line.length - n);\n        case undefined:\n          yield* this.pushNewline();\n          return yield* this.parseLineStart();\n        case '{':\n        case '[':\n          yield* this.pushCount(1);\n          this.flowKey = false;\n          this.flowLevel = 1;\n          return 'flow';\n        case '}':\n        case ']':\n          yield* this.pushCount(1);\n          return 'doc';\n        case '*':\n          yield* this.pushUntil(isNotAnchorChar);\n          return 'doc';\n        case '\"':\n        case \"'\":\n          return yield* this.parseQuotedScalar();\n        case '|':\n        case '>':\n          n += yield* this.parseBlockScalarHeader();\n          n += yield* this.pushSpaces(true);\n          yield* this.pushCount(line.length - n);\n          yield* this.pushNewline();\n          return yield* this.parseBlockScalar();\n        default:\n          return yield* this.parsePlainScalar();\n      }\n    }\n  }, {\n    key: \"parseFlowCollection\",\n    value: function* parseFlowCollection() {\n      var nl, sp;\n      var indent = -1;\n      do {\n        nl = yield* this.pushNewline();\n        if (nl > 0) {\n          sp = yield* this.pushSpaces(false);\n          this.indentValue = indent = sp;\n        } else {\n          sp = 0;\n        }\n        sp += yield* this.pushSpaces(true);\n      } while (nl + sp > 0);\n      var line = this.getLine();\n      if (line === null) return this.setNext('flow');\n      if (indent !== -1 && indent < this.indentNext && line[0] !== '#' || indent === 0 && (line.startsWith('---') || line.startsWith('...')) && isEmpty(line[3])) {\n        var atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === ']' || line[0] === '}');\n        if (!atFlowEndMarker) {\n          this.flowLevel = 0;\n          yield FLOW_END;\n          return yield* this.parseLineStart();\n        }\n      }\n      var n = 0;\n      while (line[n] === ',') {\n        n += yield* this.pushCount(1);\n        n += yield* this.pushSpaces(true);\n        this.flowKey = false;\n      }\n      n += yield* this.pushIndicators();\n      switch (line[n]) {\n        case undefined:\n          return 'flow';\n        case '#':\n          yield* this.pushCount(line.length - n);\n          return 'flow';\n        case '{':\n        case '[':\n          yield* this.pushCount(1);\n          this.flowKey = false;\n          this.flowLevel += 1;\n          return 'flow';\n        case '}':\n        case ']':\n          yield* this.pushCount(1);\n          this.flowKey = true;\n          this.flowLevel -= 1;\n          return this.flowLevel ? 'flow' : 'doc';\n        case '*':\n          yield* this.pushUntil(isNotAnchorChar);\n          return 'flow';\n        case '\"':\n        case \"'\":\n          this.flowKey = true;\n          return yield* this.parseQuotedScalar();\n        case ':':\n          {\n            var next = this.charAt(1);\n            if (this.flowKey || isEmpty(next) || next === ',') {\n              this.flowKey = false;\n              yield* this.pushCount(1);\n              yield* this.pushSpaces(true);\n              return 'flow';\n            }\n          }\n        default:\n          this.flowKey = false;\n          return yield* this.parsePlainScalar();\n      }\n    }\n  }, {\n    key: \"parseQuotedScalar\",\n    value: function* parseQuotedScalar() {\n      var quote = this.charAt(0);\n      var end = this.buffer.indexOf(quote, this.pos + 1);\n      if (quote === \"'\") {\n        while (end !== -1 && this.buffer[end + 1] === \"'\") end = this.buffer.indexOf(\"'\", end + 2);\n      } else {\n        while (end !== -1) {\n          var n = 0;\n          while (this.buffer[end - 1 - n] === '\\\\') n += 1;\n          if (n % 2 === 0) break;\n          end = this.buffer.indexOf('\"', end + 1);\n        }\n      }\n      var qb = this.buffer.substring(0, end);\n      var nl = qb.indexOf('\\n', this.pos);\n      if (nl !== -1) {\n        while (nl !== -1) {\n          var cs = this.continueScalar(nl + 1);\n          if (cs === -1) break;\n          nl = qb.indexOf('\\n', cs);\n        }\n        if (nl !== -1) {\n          end = nl - (qb[nl - 1] === '\\r' ? 2 : 1);\n        }\n      }\n      if (end === -1) {\n        if (!this.atEnd) return this.setNext('quoted-scalar');\n        end = this.buffer.length;\n      }\n      yield* this.pushToIndex(end + 1, false);\n      return this.flowLevel ? 'flow' : 'doc';\n    }\n  }, {\n    key: \"parseBlockScalarHeader\",\n    value: function* parseBlockScalarHeader() {\n      this.blockScalarIndent = -1;\n      this.blockScalarKeep = false;\n      var i = this.pos;\n      while (true) {\n        var ch = this.buffer[++i];\n        if (ch === '+') this.blockScalarKeep = true;else if (ch > '0' && ch <= '9') this.blockScalarIndent = Number(ch) - 1;else if (ch !== '-') break;\n      }\n      return yield* this.pushUntil(function (ch) {\n        return isEmpty(ch) || ch === '#';\n      });\n    }\n  }, {\n    key: \"parseBlockScalar\",\n    value: function* parseBlockScalar() {\n      var nl = this.pos - 1;\n      var indent = 0;\n      var ch;\n      loop: for (var i = this.pos; ch = this.buffer[i]; ++i) {\n        switch (ch) {\n          case ' ':\n            indent += 1;\n            break;\n          case '\\n':\n            nl = i;\n            indent = 0;\n            break;\n          case '\\r':\n            {\n              var next = this.buffer[i + 1];\n              if (!next && !this.atEnd) return this.setNext('block-scalar');\n              if (next === '\\n') break;\n            }\n          default:\n            break loop;\n        }\n      }\n      if (!ch && !this.atEnd) return this.setNext('block-scalar');\n      if (indent >= this.indentNext) {\n        if (this.blockScalarIndent === -1) this.indentNext = indent;else this.indentNext += this.blockScalarIndent;\n        do {\n          var cs = this.continueScalar(nl + 1);\n          if (cs === -1) break;\n          nl = this.buffer.indexOf('\\n', cs);\n        } while (nl !== -1);\n        if (nl === -1) {\n          if (!this.atEnd) return this.setNext('block-scalar');\n          nl = this.buffer.length;\n        }\n      }\n      if (!this.blockScalarKeep) {\n        do {\n          var _i = nl - 1;\n          var _ch2 = this.buffer[_i];\n          if (_ch2 === '\\r') _ch2 = this.buffer[--_i];\n          var lastChar = _i;\n          while (_ch2 === ' ' || _ch2 === '\\t') _ch2 = this.buffer[--_i];\n          if (_ch2 === '\\n' && _i >= this.pos && _i + 1 + indent > lastChar) nl = _i;else break;\n        } while (true);\n      }\n      yield SCALAR;\n      yield* this.pushToIndex(nl + 1, true);\n      return yield* this.parseLineStart();\n    }\n  }, {\n    key: \"parsePlainScalar\",\n    value: function* parsePlainScalar() {\n      var inFlow = this.flowLevel > 0;\n      var end = this.pos - 1;\n      var i = this.pos - 1;\n      var ch;\n      while (ch = this.buffer[++i]) {\n        if (ch === ':') {\n          var next = this.buffer[i + 1];\n          if (isEmpty(next) || inFlow && next === ',') break;\n          end = i;\n        } else if (isEmpty(ch)) {\n          var _next = this.buffer[i + 1];\n          if (ch === '\\r') {\n            if (_next === '\\n') {\n              i += 1;\n              ch = '\\n';\n              _next = this.buffer[i + 1];\n            } else end = i;\n          }\n          if (_next === '#' || inFlow && invalidFlowScalarChars.includes(_next)) break;\n          if (ch === '\\n') {\n            var cs = this.continueScalar(i + 1);\n            if (cs === -1) break;\n            i = Math.max(i, cs - 2);\n          }\n        } else {\n          if (inFlow && invalidFlowScalarChars.includes(ch)) break;\n          end = i;\n        }\n      }\n      if (!ch && !this.atEnd) return this.setNext('plain-scalar');\n      yield SCALAR;\n      yield* this.pushToIndex(end + 1, true);\n      return inFlow ? 'flow' : 'doc';\n    }\n  }, {\n    key: \"pushCount\",\n    value: function* pushCount(n) {\n      if (n > 0) {\n        yield this.buffer.substr(this.pos, n);\n        this.pos += n;\n        return n;\n      }\n      return 0;\n    }\n  }, {\n    key: \"pushToIndex\",\n    value: function* pushToIndex(i, allowEmpty) {\n      var s = this.buffer.slice(this.pos, i);\n      if (s) {\n        yield s;\n        this.pos += s.length;\n        return s.length;\n      } else if (allowEmpty) yield '';\n      return 0;\n    }\n  }, {\n    key: \"pushIndicators\",\n    value: function* pushIndicators() {\n      switch (this.charAt(0)) {\n        case '!':\n          return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());\n        case '&':\n          return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());\n        case '-':\n        case '?':\n        case ':':\n          {\n            var inFlow = this.flowLevel > 0;\n            var ch1 = this.charAt(1);\n            if (isEmpty(ch1) || inFlow && invalidFlowScalarChars.includes(ch1)) {\n              if (!inFlow) this.indentNext = this.indentValue + 1;else if (this.flowKey) this.flowKey = false;\n              return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());\n            }\n          }\n      }\n      return 0;\n    }\n  }, {\n    key: \"pushTag\",\n    value: function* pushTag() {\n      if (this.charAt(1) === '<') {\n        var i = this.pos + 2;\n        var ch = this.buffer[i];\n        while (!isEmpty(ch) && ch !== '>') ch = this.buffer[++i];\n        return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);\n      } else {\n        var _i2 = this.pos + 1;\n        var _ch3 = this.buffer[_i2];\n        while (_ch3) {\n          if (tagChars.includes(_ch3)) _ch3 = this.buffer[++_i2];else if (_ch3 === '%' && hexDigits.includes(this.buffer[_i2 + 1]) && hexDigits.includes(this.buffer[_i2 + 2])) {\n            _ch3 = this.buffer[_i2 += 3];\n          } else break;\n        }\n        return yield* this.pushToIndex(_i2, false);\n      }\n    }\n  }, {\n    key: \"pushNewline\",\n    value: function* pushNewline() {\n      var ch = this.buffer[this.pos];\n      if (ch === '\\n') return yield* this.pushCount(1);else if (ch === '\\r' && this.charAt(1) === '\\n') return yield* this.pushCount(2);else return 0;\n    }\n  }, {\n    key: \"pushSpaces\",\n    value: function* pushSpaces(allowTabs) {\n      var i = this.pos - 1;\n      var ch;\n      do {\n        ch = this.buffer[++i];\n      } while (ch === ' ' || allowTabs && ch === '\\t');\n      var n = i - this.pos;\n      if (n > 0) {\n        yield this.buffer.substr(this.pos, n);\n        this.pos = i;\n      }\n      return n;\n    }\n  }, {\n    key: \"pushUntil\",\n    value: function* pushUntil(test) {\n      var i = this.pos;\n      var ch = this.buffer[i];\n      while (!test(ch)) ch = this.buffer[++i];\n      return yield* this.pushToIndex(i, false);\n    }\n  }]);\n  return Lexer;\n}();\nexport { Lexer };","map":{"version":3,"names":["BOM","DOCUMENT","FLOW_END","SCALAR","isEmpty","ch","undefined","hexDigits","split","tagChars","invalidFlowScalarChars","invalidAnchorChars","isNotAnchorChar","includes","Lexer","_classCallCheck","atEnd","blockScalarIndent","blockScalarKeep","buffer","flowKey","flowLevel","indentNext","indentValue","lineEndPos","next","pos","_createClass","key","value","lex","source","_this","incomplete","arguments","length","_this$next","hasChars","parseNext","atLineEnd","i","charAt","n","continueScalar","offset","indent","dt","substr","getLine","end","indexOf","substring","setNext","state","peek","parseStream","parseLineStart","parseBlockStart","parseDocument","parseFlowCollection","parseQuotedScalar","parseBlockScalar","parsePlainScalar","line","pushCount","dirEnd","cs","pushSpaces","pushNewline","sp","s","_this$peek","_this$peek2","_slicedToArray","ch0","ch1","pushIndicators","pushUntil","parseBlockScalarHeader","nl","startsWith","atFlowEndMarker","quote","qb","pushToIndex","Number","loop","lastChar","inFlow","Math","max","allowEmpty","slice","pushTag","allowTabs","test"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native-community/cli-doctor/node_modules/yaml/browser/dist/parse/lexer.js"],"sourcesContent":["import { BOM, DOCUMENT, FLOW_END, SCALAR } from './cst.js';\n\n/*\nSTART -> stream\n\nstream\n  directive -> line-end -> stream\n  indent + line-end -> stream\n  [else] -> line-start\n\nline-end\n  comment -> line-end\n  newline -> .\n  input-end -> END\n\nline-start\n  doc-start -> doc\n  doc-end -> stream\n  [else] -> indent -> block-start\n\nblock-start\n  seq-item-start -> block-start\n  explicit-key-start -> block-start\n  map-value-start -> block-start\n  [else] -> doc\n\ndoc\n  line-end -> line-start\n  spaces -> doc\n  anchor -> doc\n  tag -> doc\n  flow-start -> flow -> doc\n  flow-end -> error -> doc\n  seq-item-start -> error -> doc\n  explicit-key-start -> error -> doc\n  map-value-start -> doc\n  alias -> doc\n  quote-start -> quoted-scalar -> doc\n  block-scalar-header -> line-end -> block-scalar(min) -> line-start\n  [else] -> plain-scalar(false, min) -> doc\n\nflow\n  line-end -> flow\n  spaces -> flow\n  anchor -> flow\n  tag -> flow\n  flow-start -> flow -> flow\n  flow-end -> .\n  seq-item-start -> error -> flow\n  explicit-key-start -> flow\n  map-value-start -> flow\n  alias -> flow\n  quote-start -> quoted-scalar -> flow\n  comma -> flow\n  [else] -> plain-scalar(true, 0) -> flow\n\nquoted-scalar\n  quote-end -> .\n  [else] -> quoted-scalar\n\nblock-scalar(min)\n  newline + peek(indent < min) -> .\n  [else] -> block-scalar(min)\n\nplain-scalar(is-flow, min)\n  scalar-end(is-flow) -> .\n  peek(newline + (indent < min)) -> .\n  [else] -> plain-scalar(min)\n*/\nfunction isEmpty(ch) {\n    switch (ch) {\n        case undefined:\n        case ' ':\n        case '\\n':\n        case '\\r':\n        case '\\t':\n            return true;\n        default:\n            return false;\n    }\n}\nconst hexDigits = '0123456789ABCDEFabcdef'.split('');\nconst tagChars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()\".split('');\nconst invalidFlowScalarChars = ',[]{}'.split('');\nconst invalidAnchorChars = ' ,[]{}\\n\\r\\t'.split('');\nconst isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);\n/**\n * Splits an input string into lexical tokens, i.e. smaller strings that are\n * easily identifiable by `tokens.tokenType()`.\n *\n * Lexing starts always in a \"stream\" context. Incomplete input may be buffered\n * until a complete token can be emitted.\n *\n * In addition to slices of the original input, the following control characters\n * may also be emitted:\n *\n * - `\\x02` (Start of Text): A document starts with the next token\n * - `\\x18` (Cancel): Unexpected end of flow-mode (indicates an error)\n * - `\\x1f` (Unit Separator): Next token is a scalar value\n * - `\\u{FEFF}` (Byte order mark): Emitted separately outside documents\n */\nclass Lexer {\n    constructor() {\n        /**\n         * Flag indicating whether the end of the current buffer marks the end of\n         * all input\n         */\n        this.atEnd = false;\n        /**\n         * Explicit indent set in block scalar header, as an offset from the current\n         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not\n         * explicitly set.\n         */\n        this.blockScalarIndent = -1;\n        /**\n         * Block scalars that include a + (keep) chomping indicator in their header\n         * include trailing empty lines, which are otherwise excluded from the\n         * scalar's contents.\n         */\n        this.blockScalarKeep = false;\n        /** Current input */\n        this.buffer = '';\n        /**\n         * Flag noting whether the map value indicator : can immediately follow this\n         * node within a flow context.\n         */\n        this.flowKey = false;\n        /** Count of surrounding flow collection levels. */\n        this.flowLevel = 0;\n        /**\n         * Minimum level of indentation required for next lines to be parsed as a\n         * part of the current scalar value.\n         */\n        this.indentNext = 0;\n        /** Indentation level of the current line. */\n        this.indentValue = 0;\n        /** Position of the next \\n character. */\n        this.lineEndPos = null;\n        /** Stores the state of the lexer if reaching the end of incpomplete input */\n        this.next = null;\n        /** A pointer to `buffer`; the current position of the lexer. */\n        this.pos = 0;\n    }\n    /**\n     * Generate YAML tokens from the `source` string. If `incomplete`,\n     * a part of the last line may be left as a buffer for the next call.\n     *\n     * @returns A generator of lexical tokens\n     */\n    *lex(source, incomplete = false) {\n        if (source) {\n            this.buffer = this.buffer ? this.buffer + source : source;\n            this.lineEndPos = null;\n        }\n        this.atEnd = !incomplete;\n        let next = this.next ?? 'stream';\n        while (next && (incomplete || this.hasChars(1)))\n            next = yield* this.parseNext(next);\n    }\n    atLineEnd() {\n        let i = this.pos;\n        let ch = this.buffer[i];\n        while (ch === ' ' || ch === '\\t')\n            ch = this.buffer[++i];\n        if (!ch || ch === '#' || ch === '\\n')\n            return true;\n        if (ch === '\\r')\n            return this.buffer[i + 1] === '\\n';\n        return false;\n    }\n    charAt(n) {\n        return this.buffer[this.pos + n];\n    }\n    continueScalar(offset) {\n        let ch = this.buffer[offset];\n        if (this.indentNext > 0) {\n            let indent = 0;\n            while (ch === ' ')\n                ch = this.buffer[++indent + offset];\n            if (ch === '\\r') {\n                const next = this.buffer[indent + offset + 1];\n                if (next === '\\n' || (!next && !this.atEnd))\n                    return offset + indent + 1;\n            }\n            return ch === '\\n' || indent >= this.indentNext || (!ch && !this.atEnd)\n                ? offset + indent\n                : -1;\n        }\n        if (ch === '-' || ch === '.') {\n            const dt = this.buffer.substr(offset, 3);\n            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))\n                return -1;\n        }\n        return offset;\n    }\n    getLine() {\n        let end = this.lineEndPos;\n        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {\n            end = this.buffer.indexOf('\\n', this.pos);\n            this.lineEndPos = end;\n        }\n        if (end === -1)\n            return this.atEnd ? this.buffer.substring(this.pos) : null;\n        if (this.buffer[end - 1] === '\\r')\n            end -= 1;\n        return this.buffer.substring(this.pos, end);\n    }\n    hasChars(n) {\n        return this.pos + n <= this.buffer.length;\n    }\n    setNext(state) {\n        this.buffer = this.buffer.substring(this.pos);\n        this.pos = 0;\n        this.lineEndPos = null;\n        this.next = state;\n        return null;\n    }\n    peek(n) {\n        return this.buffer.substr(this.pos, n);\n    }\n    *parseNext(next) {\n        switch (next) {\n            case 'stream':\n                return yield* this.parseStream();\n            case 'line-start':\n                return yield* this.parseLineStart();\n            case 'block-start':\n                return yield* this.parseBlockStart();\n            case 'doc':\n                return yield* this.parseDocument();\n            case 'flow':\n                return yield* this.parseFlowCollection();\n            case 'quoted-scalar':\n                return yield* this.parseQuotedScalar();\n            case 'block-scalar':\n                return yield* this.parseBlockScalar();\n            case 'plain-scalar':\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseStream() {\n        let line = this.getLine();\n        if (line === null)\n            return this.setNext('stream');\n        if (line[0] === BOM) {\n            yield* this.pushCount(1);\n            line = line.substring(1);\n        }\n        if (line[0] === '%') {\n            let dirEnd = line.length;\n            const cs = line.indexOf('#');\n            if (cs !== -1) {\n                const ch = line[cs - 1];\n                if (ch === ' ' || ch === '\\t')\n                    dirEnd = cs - 1;\n            }\n            while (true) {\n                const ch = line[dirEnd - 1];\n                if (ch === ' ' || ch === '\\t')\n                    dirEnd -= 1;\n                else\n                    break;\n            }\n            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));\n            yield* this.pushCount(line.length - n); // possible comment\n            this.pushNewline();\n            return 'stream';\n        }\n        if (this.atLineEnd()) {\n            const sp = yield* this.pushSpaces(true);\n            yield* this.pushCount(line.length - sp);\n            yield* this.pushNewline();\n            return 'stream';\n        }\n        yield DOCUMENT;\n        return yield* this.parseLineStart();\n    }\n    *parseLineStart() {\n        const ch = this.charAt(0);\n        if (!ch && !this.atEnd)\n            return this.setNext('line-start');\n        if (ch === '-' || ch === '.') {\n            if (!this.atEnd && !this.hasChars(4))\n                return this.setNext('line-start');\n            const s = this.peek(3);\n            if (s === '---' && isEmpty(this.charAt(3))) {\n                yield* this.pushCount(3);\n                this.indentValue = 0;\n                this.indentNext = 0;\n                return 'doc';\n            }\n            else if (s === '...' && isEmpty(this.charAt(3))) {\n                yield* this.pushCount(3);\n                return 'stream';\n            }\n        }\n        this.indentValue = yield* this.pushSpaces(false);\n        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))\n            this.indentNext = this.indentValue;\n        return yield* this.parseBlockStart();\n    }\n    *parseBlockStart() {\n        const [ch0, ch1] = this.peek(2);\n        if (!ch1 && !this.atEnd)\n            return this.setNext('block-start');\n        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {\n            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));\n            this.indentNext = this.indentValue + 1;\n            this.indentValue += n;\n            return yield* this.parseBlockStart();\n        }\n        return 'doc';\n    }\n    *parseDocument() {\n        yield* this.pushSpaces(true);\n        const line = this.getLine();\n        if (line === null)\n            return this.setNext('doc');\n        let n = yield* this.pushIndicators();\n        switch (line[n]) {\n            case '#':\n                yield* this.pushCount(line.length - n);\n            // fallthrough\n            case undefined:\n                yield* this.pushNewline();\n                return yield* this.parseLineStart();\n            case '{':\n            case '[':\n                yield* this.pushCount(1);\n                this.flowKey = false;\n                this.flowLevel = 1;\n                return 'flow';\n            case '}':\n            case ']':\n                // this is an error\n                yield* this.pushCount(1);\n                return 'doc';\n            case '*':\n                yield* this.pushUntil(isNotAnchorChar);\n                return 'doc';\n            case '\"':\n            case \"'\":\n                return yield* this.parseQuotedScalar();\n            case '|':\n            case '>':\n                n += yield* this.parseBlockScalarHeader();\n                n += yield* this.pushSpaces(true);\n                yield* this.pushCount(line.length - n);\n                yield* this.pushNewline();\n                return yield* this.parseBlockScalar();\n            default:\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseFlowCollection() {\n        let nl, sp;\n        let indent = -1;\n        do {\n            nl = yield* this.pushNewline();\n            if (nl > 0) {\n                sp = yield* this.pushSpaces(false);\n                this.indentValue = indent = sp;\n            }\n            else {\n                sp = 0;\n            }\n            sp += yield* this.pushSpaces(true);\n        } while (nl + sp > 0);\n        const line = this.getLine();\n        if (line === null)\n            return this.setNext('flow');\n        if ((indent !== -1 && indent < this.indentNext && line[0] !== '#') ||\n            (indent === 0 &&\n                (line.startsWith('---') || line.startsWith('...')) &&\n                isEmpty(line[3]))) {\n            // Allowing for the terminal ] or } at the same (rather than greater)\n            // indent level as the initial [ or { is technically invalid, but\n            // failing here would be surprising to users.\n            const atFlowEndMarker = indent === this.indentNext - 1 &&\n                this.flowLevel === 1 &&\n                (line[0] === ']' || line[0] === '}');\n            if (!atFlowEndMarker) {\n                // this is an error\n                this.flowLevel = 0;\n                yield FLOW_END;\n                return yield* this.parseLineStart();\n            }\n        }\n        let n = 0;\n        while (line[n] === ',') {\n            n += yield* this.pushCount(1);\n            n += yield* this.pushSpaces(true);\n            this.flowKey = false;\n        }\n        n += yield* this.pushIndicators();\n        switch (line[n]) {\n            case undefined:\n                return 'flow';\n            case '#':\n                yield* this.pushCount(line.length - n);\n                return 'flow';\n            case '{':\n            case '[':\n                yield* this.pushCount(1);\n                this.flowKey = false;\n                this.flowLevel += 1;\n                return 'flow';\n            case '}':\n            case ']':\n                yield* this.pushCount(1);\n                this.flowKey = true;\n                this.flowLevel -= 1;\n                return this.flowLevel ? 'flow' : 'doc';\n            case '*':\n                yield* this.pushUntil(isNotAnchorChar);\n                return 'flow';\n            case '\"':\n            case \"'\":\n                this.flowKey = true;\n                return yield* this.parseQuotedScalar();\n            case ':': {\n                const next = this.charAt(1);\n                if (this.flowKey || isEmpty(next) || next === ',') {\n                    this.flowKey = false;\n                    yield* this.pushCount(1);\n                    yield* this.pushSpaces(true);\n                    return 'flow';\n                }\n            }\n            // fallthrough\n            default:\n                this.flowKey = false;\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseQuotedScalar() {\n        const quote = this.charAt(0);\n        let end = this.buffer.indexOf(quote, this.pos + 1);\n        if (quote === \"'\") {\n            while (end !== -1 && this.buffer[end + 1] === \"'\")\n                end = this.buffer.indexOf(\"'\", end + 2);\n        }\n        else {\n            // double-quote\n            while (end !== -1) {\n                let n = 0;\n                while (this.buffer[end - 1 - n] === '\\\\')\n                    n += 1;\n                if (n % 2 === 0)\n                    break;\n                end = this.buffer.indexOf('\"', end + 1);\n            }\n        }\n        // Only looking for newlines within the quotes\n        const qb = this.buffer.substring(0, end);\n        let nl = qb.indexOf('\\n', this.pos);\n        if (nl !== -1) {\n            while (nl !== -1) {\n                const cs = this.continueScalar(nl + 1);\n                if (cs === -1)\n                    break;\n                nl = qb.indexOf('\\n', cs);\n            }\n            if (nl !== -1) {\n                // this is an error caused by an unexpected unindent\n                end = nl - (qb[nl - 1] === '\\r' ? 2 : 1);\n            }\n        }\n        if (end === -1) {\n            if (!this.atEnd)\n                return this.setNext('quoted-scalar');\n            end = this.buffer.length;\n        }\n        yield* this.pushToIndex(end + 1, false);\n        return this.flowLevel ? 'flow' : 'doc';\n    }\n    *parseBlockScalarHeader() {\n        this.blockScalarIndent = -1;\n        this.blockScalarKeep = false;\n        let i = this.pos;\n        while (true) {\n            const ch = this.buffer[++i];\n            if (ch === '+')\n                this.blockScalarKeep = true;\n            else if (ch > '0' && ch <= '9')\n                this.blockScalarIndent = Number(ch) - 1;\n            else if (ch !== '-')\n                break;\n        }\n        return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');\n    }\n    *parseBlockScalar() {\n        let nl = this.pos - 1; // may be -1 if this.pos === 0\n        let indent = 0;\n        let ch;\n        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {\n            switch (ch) {\n                case ' ':\n                    indent += 1;\n                    break;\n                case '\\n':\n                    nl = i;\n                    indent = 0;\n                    break;\n                case '\\r': {\n                    const next = this.buffer[i + 1];\n                    if (!next && !this.atEnd)\n                        return this.setNext('block-scalar');\n                    if (next === '\\n')\n                        break;\n                } // fallthrough\n                default:\n                    break loop;\n            }\n        }\n        if (!ch && !this.atEnd)\n            return this.setNext('block-scalar');\n        if (indent >= this.indentNext) {\n            if (this.blockScalarIndent === -1)\n                this.indentNext = indent;\n            else\n                this.indentNext += this.blockScalarIndent;\n            do {\n                const cs = this.continueScalar(nl + 1);\n                if (cs === -1)\n                    break;\n                nl = this.buffer.indexOf('\\n', cs);\n            } while (nl !== -1);\n            if (nl === -1) {\n                if (!this.atEnd)\n                    return this.setNext('block-scalar');\n                nl = this.buffer.length;\n            }\n        }\n        if (!this.blockScalarKeep) {\n            do {\n                let i = nl - 1;\n                let ch = this.buffer[i];\n                if (ch === '\\r')\n                    ch = this.buffer[--i];\n                const lastChar = i; // Drop the line if last char not more indented\n                while (ch === ' ' || ch === '\\t')\n                    ch = this.buffer[--i];\n                if (ch === '\\n' && i >= this.pos && i + 1 + indent > lastChar)\n                    nl = i;\n                else\n                    break;\n            } while (true);\n        }\n        yield SCALAR;\n        yield* this.pushToIndex(nl + 1, true);\n        return yield* this.parseLineStart();\n    }\n    *parsePlainScalar() {\n        const inFlow = this.flowLevel > 0;\n        let end = this.pos - 1;\n        let i = this.pos - 1;\n        let ch;\n        while ((ch = this.buffer[++i])) {\n            if (ch === ':') {\n                const next = this.buffer[i + 1];\n                if (isEmpty(next) || (inFlow && next === ','))\n                    break;\n                end = i;\n            }\n            else if (isEmpty(ch)) {\n                let next = this.buffer[i + 1];\n                if (ch === '\\r') {\n                    if (next === '\\n') {\n                        i += 1;\n                        ch = '\\n';\n                        next = this.buffer[i + 1];\n                    }\n                    else\n                        end = i;\n                }\n                if (next === '#' || (inFlow && invalidFlowScalarChars.includes(next)))\n                    break;\n                if (ch === '\\n') {\n                    const cs = this.continueScalar(i + 1);\n                    if (cs === -1)\n                        break;\n                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'\n                }\n            }\n            else {\n                if (inFlow && invalidFlowScalarChars.includes(ch))\n                    break;\n                end = i;\n            }\n        }\n        if (!ch && !this.atEnd)\n            return this.setNext('plain-scalar');\n        yield SCALAR;\n        yield* this.pushToIndex(end + 1, true);\n        return inFlow ? 'flow' : 'doc';\n    }\n    *pushCount(n) {\n        if (n > 0) {\n            yield this.buffer.substr(this.pos, n);\n            this.pos += n;\n            return n;\n        }\n        return 0;\n    }\n    *pushToIndex(i, allowEmpty) {\n        const s = this.buffer.slice(this.pos, i);\n        if (s) {\n            yield s;\n            this.pos += s.length;\n            return s.length;\n        }\n        else if (allowEmpty)\n            yield '';\n        return 0;\n    }\n    *pushIndicators() {\n        switch (this.charAt(0)) {\n            case '!':\n                return ((yield* this.pushTag()) +\n                    (yield* this.pushSpaces(true)) +\n                    (yield* this.pushIndicators()));\n            case '&':\n                return ((yield* this.pushUntil(isNotAnchorChar)) +\n                    (yield* this.pushSpaces(true)) +\n                    (yield* this.pushIndicators()));\n            case '-': // this is an error\n            case '?': // this is an error outside flow collections\n            case ':': {\n                const inFlow = this.flowLevel > 0;\n                const ch1 = this.charAt(1);\n                if (isEmpty(ch1) || (inFlow && invalidFlowScalarChars.includes(ch1))) {\n                    if (!inFlow)\n                        this.indentNext = this.indentValue + 1;\n                    else if (this.flowKey)\n                        this.flowKey = false;\n                    return ((yield* this.pushCount(1)) +\n                        (yield* this.pushSpaces(true)) +\n                        (yield* this.pushIndicators()));\n                }\n            }\n        }\n        return 0;\n    }\n    *pushTag() {\n        if (this.charAt(1) === '<') {\n            let i = this.pos + 2;\n            let ch = this.buffer[i];\n            while (!isEmpty(ch) && ch !== '>')\n                ch = this.buffer[++i];\n            return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);\n        }\n        else {\n            let i = this.pos + 1;\n            let ch = this.buffer[i];\n            while (ch) {\n                if (tagChars.includes(ch))\n                    ch = this.buffer[++i];\n                else if (ch === '%' &&\n                    hexDigits.includes(this.buffer[i + 1]) &&\n                    hexDigits.includes(this.buffer[i + 2])) {\n                    ch = this.buffer[(i += 3)];\n                }\n                else\n                    break;\n            }\n            return yield* this.pushToIndex(i, false);\n        }\n    }\n    *pushNewline() {\n        const ch = this.buffer[this.pos];\n        if (ch === '\\n')\n            return yield* this.pushCount(1);\n        else if (ch === '\\r' && this.charAt(1) === '\\n')\n            return yield* this.pushCount(2);\n        else\n            return 0;\n    }\n    *pushSpaces(allowTabs) {\n        let i = this.pos - 1;\n        let ch;\n        do {\n            ch = this.buffer[++i];\n        } while (ch === ' ' || (allowTabs && ch === '\\t'));\n        const n = i - this.pos;\n        if (n > 0) {\n            yield this.buffer.substr(this.pos, n);\n            this.pos = i;\n        }\n        return n;\n    }\n    *pushUntil(test) {\n        let i = this.pos;\n        let ch = this.buffer[i];\n        while (!test(ch))\n            ch = this.buffer[++i];\n        return yield* this.pushToIndex(i, false);\n    }\n}\n\nexport { Lexer };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}