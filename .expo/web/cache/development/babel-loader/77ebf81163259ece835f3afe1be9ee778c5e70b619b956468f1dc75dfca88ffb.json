{"ast":null,"code":"import { NODE_TYPE } from \"../nodes/identity.js\";","map":{"version":3,"names":["NODE_TYPE"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native-community/cli-doctor/node_modules/yaml/dist/doc/Document.d.ts"],"sourcesContent":["import type { YAMLError, YAMLWarning } from '../errors.js';\nimport { Alias } from '../nodes/Alias.js';\nimport { NODE_TYPE } from '../nodes/identity.js';\nimport type { Node, NodeType, ParsedNode, Range } from '../nodes/Node.js';\nimport { Pair } from '../nodes/Pair.js';\nimport type { Scalar } from '../nodes/Scalar.js';\nimport type { YAMLMap } from '../nodes/YAMLMap.js';\nimport type { YAMLSeq } from '../nodes/YAMLSeq.js';\nimport type { CreateNodeOptions, DocumentOptions, ParseOptions, SchemaOptions, ToJSOptions, ToStringOptions } from '../options.js';\nimport { Schema } from '../schema/Schema.js';\nimport { Directives } from './directives.js';\nexport type Replacer = any[] | ((key: any, value: any) => unknown);\nexport declare namespace Document {\n    /** @ts-ignore The typing of directives fails in TS <= 4.2 */\n    interface Parsed<Contents extends ParsedNode = ParsedNode, Strict extends boolean = true> extends Document<Contents, Strict> {\n        directives: Directives;\n        range: Range;\n    }\n}\nexport declare class Document<Contents extends Node = Node, Strict extends boolean = true> {\n    readonly [NODE_TYPE]: symbol;\n    /** A comment before this Document */\n    commentBefore: string | null;\n    /** A comment immediately after this Document */\n    comment: string | null;\n    /** The document contents. */\n    contents: Strict extends true ? Contents | null : Contents;\n    directives: Strict extends true ? Directives | undefined : Directives;\n    /** Errors encountered during parsing. */\n    errors: YAMLError[];\n    options: Required<Omit<ParseOptions & DocumentOptions, '_directives' | 'lineCounter' | 'version'>>;\n    /**\n     * The `[start, value-end, node-end]` character offsets for the part of the\n     * source parsed into this document (undefined if not parsed). The `value-end`\n     * and `node-end` positions are themselves not included in their respective\n     * ranges.\n     */\n    range?: Range;\n    /** The schema used with the document. Use `setSchema()` to change. */\n    schema: Schema;\n    /** Warnings encountered during parsing. */\n    warnings: YAMLWarning[];\n    /**\n     * @param value - The initial value for the document, which will be wrapped\n     *   in a Node container.\n     */\n    constructor(value?: any, options?: DocumentOptions & SchemaOptions & ParseOptions & CreateNodeOptions);\n    constructor(value: any, replacer: null | Replacer, options?: DocumentOptions & SchemaOptions & ParseOptions & CreateNodeOptions);\n    /**\n     * Create a deep copy of this Document and its contents.\n     *\n     * Custom Node values that inherit from `Object` still refer to their original instances.\n     */\n    clone(): Document<Contents, Strict>;\n    /** Adds a value to the document. */\n    add(value: any): void;\n    /** Adds a value to the document. */\n    addIn(path: Iterable<unknown>, value: unknown): void;\n    /**\n     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.\n     *\n     * If `node` already has an anchor, `name` is ignored.\n     * Otherwise, the `node.anchor` value will be set to `name`,\n     * or if an anchor with that name is already present in the document,\n     * `name` will be used as a prefix for a new unique anchor.\n     * If `name` is undefined, the generated anchor will use 'a' as a prefix.\n     */\n    createAlias(node: Strict extends true ? Scalar | YAMLMap | YAMLSeq : Node, name?: string): Alias;\n    /**\n     * Convert any value into a `Node` using the current schema, recursively\n     * turning objects into collections.\n     */\n    createNode<T = unknown>(value: T, options?: CreateNodeOptions): NodeType<T>;\n    createNode<T = unknown>(value: T, replacer: Replacer | CreateNodeOptions | null, options?: CreateNodeOptions): NodeType<T>;\n    /**\n     * Convert a key and a value into a `Pair` using the current schema,\n     * recursively wrapping all values as `Scalar` or `Collection` nodes.\n     */\n    createPair<K extends Node = Node, V extends Node = Node>(key: unknown, value: unknown, options?: CreateNodeOptions): Pair<K, V>;\n    /**\n     * Removes a value from the document.\n     * @returns `true` if the item was found and removed.\n     */\n    delete(key: unknown): boolean;\n    /**\n     * Removes a value from the document.\n     * @returns `true` if the item was found and removed.\n     */\n    deleteIn(path: Iterable<unknown> | null): boolean;\n    /**\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    get(key: unknown, keepScalar?: boolean): Strict extends true ? unknown : any;\n    /**\n     * Returns item at `path`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    getIn(path: Iterable<unknown> | null, keepScalar?: boolean): Strict extends true ? unknown : any;\n    /**\n     * Checks if the document includes a value with the key `key`.\n     */\n    has(key: unknown): boolean;\n    /**\n     * Checks if the document includes a value at `path`.\n     */\n    hasIn(path: Iterable<unknown> | null): boolean;\n    /**\n     * Sets a value in this document. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    set(key: any, value: unknown): void;\n    /**\n     * Sets a value in this document. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    setIn(path: Iterable<unknown> | null, value: unknown): void;\n    /**\n     * Change the YAML version and schema used by the document.\n     * A `null` version disables support for directives, explicit tags, anchors, and aliases.\n     * It also requires the `schema` option to be given as a `Schema` instance value.\n     *\n     * Overrides all previously set schema options.\n     */\n    setSchema(version: '1.1' | '1.2' | 'next' | null, options?: SchemaOptions): void;\n    /** A plain JavaScript representation of the document `contents`. */\n    toJS(opt?: ToJSOptions & {\n        [ignored: string]: unknown;\n    }): any;\n    /**\n     * A JSON representation of the document `contents`.\n     *\n     * @param jsonArg Used by `JSON.stringify` to indicate the array index or\n     *   property name.\n     */\n    toJSON(jsonArg?: string | null, onAnchor?: ToJSOptions['onAnchor']): any;\n    /** A YAML representation of the document. */\n    toString(options?: ToStringOptions): string;\n}\n"],"mappings":"AAEA,SAASA,SAAS"},"metadata":{},"sourceType":"module","externalDependencies":[]}