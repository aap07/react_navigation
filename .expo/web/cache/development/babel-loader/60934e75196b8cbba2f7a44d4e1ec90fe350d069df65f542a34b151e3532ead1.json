{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nvar _require = require(\"../parseTopLevelType\"),\n  parseTopLevelType = _require.parseTopLevelType,\n  flattenIntersectionType = _require.flattenIntersectionType;\nfunction getProperties(typeName, types) {\n  var alias = types[typeName];\n  if (!alias) {\n    throw new Error(`Failed to find definition for \"${typeName}\", please check that you have a valid codegen typescript file`);\n  }\n  var aliasKind = alias.type === 'TSInterfaceDeclaration' ? 'interface' : 'type';\n  try {\n    if (aliasKind === 'interface') {\n      var _alias$extends;\n      return [].concat(_toConsumableArray((_alias$extends = alias.extends) !== null && _alias$extends !== void 0 ? _alias$extends : []), _toConsumableArray(alias.body.body));\n    }\n    return alias.typeAnnotation.members || alias.typeAnnotation.typeParameters.params[0].members || alias.typeAnnotation.typeParameters.params;\n  } catch (e) {\n    throw new Error(`Failed to find ${aliasKind} definition for \"${typeName}\", please check that you have a valid codegen typescript file`);\n  }\n}\nfunction getUnionOfLiterals(name, forArray, elementTypes, defaultValue, types) {\n  var _elementTypes$0$liter, _elementTypes$0$liter2;\n  elementTypes.reduce(function (lastType, currType) {\n    var lastFlattenedType = lastType && lastType.type === 'TSLiteralType' ? lastType.literal.type : lastType.type;\n    var currFlattenedType = currType.type === 'TSLiteralType' ? currType.literal.type : currType.type;\n    if (lastFlattenedType && currFlattenedType !== lastFlattenedType) {\n      throw new Error(`Mixed types are not supported (see \"${name}\")`);\n    }\n    return currType;\n  });\n  if (defaultValue === undefined) {\n    throw new Error(`A default enum value is required for \"${name}\"`);\n  }\n  var unionType = elementTypes[0].type;\n  if (unionType === 'TSLiteralType' && ((_elementTypes$0$liter = elementTypes[0].literal) === null || _elementTypes$0$liter === void 0 ? void 0 : _elementTypes$0$liter.type) === 'StringLiteral') {\n    return {\n      type: 'StringEnumTypeAnnotation',\n      default: defaultValue,\n      options: elementTypes.map(function (option) {\n        return option.literal.value;\n      })\n    };\n  } else if (unionType === 'TSLiteralType' && ((_elementTypes$0$liter2 = elementTypes[0].literal) === null || _elementTypes$0$liter2 === void 0 ? void 0 : _elementTypes$0$liter2.type) === 'NumericLiteral') {\n    if (forArray) {\n      throw new Error(`Arrays of int enums are not supported (see: \"${name}\")`);\n    } else {\n      return {\n        type: 'Int32EnumTypeAnnotation',\n        default: defaultValue,\n        options: elementTypes.map(function (option) {\n          return option.literal.value;\n        })\n      };\n    }\n  } else {\n    var _elementTypes$0$liter3;\n    throw new Error(`Unsupported union type for \"${name}\", received \"${unionType === 'TSLiteralType' ? (_elementTypes$0$liter3 = elementTypes[0].literal) === null || _elementTypes$0$liter3 === void 0 ? void 0 : _elementTypes$0$liter3.type : unionType}\"`);\n  }\n}\nfunction detectArrayType(name, typeAnnotation, defaultValue, types, buildSchema) {\n  if (typeAnnotation.type === 'TSTypeOperator' && typeAnnotation.operator === 'readonly' && typeAnnotation.typeAnnotation.type === 'TSArrayType') {\n    return {\n      type: 'ArrayTypeAnnotation',\n      elementType: getTypeAnnotationForArray(name, typeAnnotation.typeAnnotation.elementType, defaultValue, types, buildSchema)\n    };\n  }\n  if (typeAnnotation.type === 'TSArrayType') {\n    return {\n      type: 'ArrayTypeAnnotation',\n      elementType: getTypeAnnotationForArray(name, typeAnnotation.elementType, defaultValue, types, buildSchema)\n    };\n  }\n  if (typeAnnotation.type === 'TSTypeReference' && (typeAnnotation.typeName.name === 'ReadonlyArray' || typeAnnotation.typeName.name === 'Array')) {\n    return {\n      type: 'ArrayTypeAnnotation',\n      elementType: getTypeAnnotationForArray(name, typeAnnotation.typeParameters.params[0], defaultValue, types, buildSchema)\n    };\n  }\n  return null;\n}\nfunction buildObjectType(rawProperties, types, buildSchema) {\n  var flattenedProperties = flattenProperties(rawProperties, types);\n  var properties = flattenedProperties.map(function (prop) {\n    return buildSchema(prop, types);\n  }).filter(Boolean);\n  return {\n    type: 'ObjectTypeAnnotation',\n    properties: properties\n  };\n}\nfunction getCommonTypeAnnotation(name, forArray, type, typeAnnotation, defaultValue, types, buildSchema) {\n  switch (type) {\n    case 'TSTypeLiteral':\n      return buildObjectType(typeAnnotation.members, types, buildSchema);\n    case 'TSInterfaceDeclaration':\n      return buildObjectType([typeAnnotation], types, buildSchema);\n    case 'TSIntersectionType':\n      return buildObjectType(flattenIntersectionType(typeAnnotation, types), types, buildSchema);\n    case 'ImageSource':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'ImageSourcePrimitive'\n      };\n    case 'ImageRequest':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'ImageRequestPrimitive'\n      };\n    case 'ColorValue':\n    case 'ProcessedColorValue':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'ColorPrimitive'\n      };\n    case 'PointValue':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'PointPrimitive'\n      };\n    case 'EdgeInsetsValue':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'EdgeInsetsPrimitive'\n      };\n    case 'DimensionValue':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'DimensionPrimitive'\n      };\n    case 'TSUnionType':\n      return getUnionOfLiterals(name, forArray, typeAnnotation.types, defaultValue, types);\n    case 'Int32':\n      return {\n        type: 'Int32TypeAnnotation'\n      };\n    case 'Double':\n      return {\n        type: 'DoubleTypeAnnotation'\n      };\n    case 'Float':\n      return {\n        type: 'FloatTypeAnnotation'\n      };\n    case 'TSBooleanKeyword':\n      return {\n        type: 'BooleanTypeAnnotation'\n      };\n    case 'Stringish':\n    case 'TSStringKeyword':\n      return {\n        type: 'StringTypeAnnotation'\n      };\n    case 'UnsafeMixed':\n      return {\n        type: 'MixedTypeAnnotation'\n      };\n    default:\n      return undefined;\n  }\n}\nfunction getTypeAnnotationForArray(name, typeAnnotation, defaultValue, types, buildSchema) {\n  var _extractedTypeAnnotat, _extractedTypeAnnotat2;\n  var topLevelType = parseTopLevelType(typeAnnotation, types);\n  if (topLevelType.defaultValue !== undefined) {\n    throw new Error('Nested optionals such as \"ReadonlyArray<boolean | null | undefined>\" are not supported, please declare optionals at the top level of value definitions as in \"ReadonlyArray<boolean> | null | undefined\"');\n  }\n  if (topLevelType.optional) {\n    throw new Error('Nested optionals such as \"ReadonlyArray<boolean | null | undefined>\" are not supported, please declare optionals at the top level of value definitions as in \"ReadonlyArray<boolean> | null | undefined\"');\n  }\n  var extractedTypeAnnotation = topLevelType.type;\n  var arrayType = detectArrayType(name, extractedTypeAnnotation, defaultValue, types, buildSchema);\n  if (arrayType) {\n    if (arrayType.elementType.type !== 'ObjectTypeAnnotation') {\n      throw new Error(`Only array of array of object is supported for \"${name}\".`);\n    }\n    return arrayType;\n  }\n  var type = extractedTypeAnnotation.elementType === 'TSTypeReference' ? extractedTypeAnnotation.elementType.typeName.name : ((_extractedTypeAnnotat = extractedTypeAnnotation.elementType) === null || _extractedTypeAnnotat === void 0 ? void 0 : _extractedTypeAnnotat.type) || ((_extractedTypeAnnotat2 = extractedTypeAnnotation.typeName) === null || _extractedTypeAnnotat2 === void 0 ? void 0 : _extractedTypeAnnotat2.name) || extractedTypeAnnotation.type;\n  var common = getCommonTypeAnnotation(name, true, type, extractedTypeAnnotation, defaultValue, types, buildSchema);\n  if (common) {\n    return common;\n  }\n  switch (type) {\n    case 'TSNumberKeyword':\n      return {\n        type: 'FloatTypeAnnotation'\n      };\n    default:\n      type;\n      throw new Error(`Unknown prop type for \"${name}\": ${type}`);\n  }\n}\nfunction setDefaultValue(common, defaultValue) {\n  switch (common.type) {\n    case 'Int32TypeAnnotation':\n    case 'DoubleTypeAnnotation':\n      common.default = defaultValue ? defaultValue : 0;\n      break;\n    case 'FloatTypeAnnotation':\n      common.default = defaultValue === null ? null : defaultValue ? defaultValue : 0;\n      break;\n    case 'BooleanTypeAnnotation':\n      common.default = defaultValue === null ? null : !!defaultValue;\n      break;\n    case 'StringTypeAnnotation':\n      common.default = defaultValue === undefined ? null : defaultValue;\n      break;\n  }\n}\nfunction getTypeAnnotation(name, annotation, defaultValue, types, buildSchema) {\n  var topLevelType = parseTopLevelType(annotation, types);\n  var typeAnnotation = topLevelType.type;\n  var arrayType = detectArrayType(name, typeAnnotation, defaultValue, types, buildSchema);\n  if (arrayType) {\n    return arrayType;\n  }\n  var type = typeAnnotation.type === 'TSTypeReference' || typeAnnotation.type === 'TSTypeAliasDeclaration' ? typeAnnotation.typeName.name : typeAnnotation.type;\n  var common = getCommonTypeAnnotation(name, false, type, typeAnnotation, defaultValue, types, buildSchema);\n  if (common) {\n    setDefaultValue(common, defaultValue);\n    return common;\n  }\n  switch (type) {\n    case 'ColorArrayValue':\n      return {\n        type: 'ArrayTypeAnnotation',\n        elementType: {\n          type: 'ReservedPropTypeAnnotation',\n          name: 'ColorPrimitive'\n        }\n      };\n    case 'TSNumberKeyword':\n      throw new Error(`Cannot use \"${type}\" type annotation for \"${name}\": must use a specific numeric type like Int32, Double, or Float`);\n    case 'TSFunctionType':\n      throw new Error(`Cannot use \"${type}\" type annotation for \"${name}\": must use a specific function type like BubblingEventHandler, or DirectEventHandler`);\n    default:\n      type;\n      throw new Error(`Unknown prop type for \"${name}\": \"${type}\"`);\n  }\n}\nfunction getSchemaInfo(property, types) {\n  var topLevelType = parseTopLevelType(property.typeAnnotation.typeAnnotation, types);\n  var name = property.key.name;\n  if (!property.optional && topLevelType.defaultValue !== undefined) {\n    throw new Error(`key ${name} must be optional if used with WithDefault<> annotation`);\n  }\n  return {\n    name: name,\n    optional: property.optional || topLevelType.optional,\n    typeAnnotation: topLevelType.type,\n    defaultValue: topLevelType.defaultValue\n  };\n}\nfunction verifyPropNotAlreadyDefined(props, needleProp) {\n  var propName = needleProp.key.name;\n  var foundProp = props.some(function (prop) {\n    return prop.key.name === propName;\n  });\n  if (foundProp) {\n    throw new Error(`A prop was already defined with the name ${propName}`);\n  }\n}\nfunction flattenProperties(typeDefinition, types) {\n  return typeDefinition.map(function (property) {\n    if (property.type === 'TSPropertySignature') {\n      return property;\n    } else if (property.type === 'TSTypeReference') {\n      return flattenProperties(getProperties(property.typeName.name, types), types);\n    } else if (property.type === 'TSExpressionWithTypeArguments' || property.type === 'TSInterfaceHeritage') {\n      return flattenProperties(getProperties(property.expression.name, types), types);\n    } else if (property.type === 'TSTypeLiteral') {\n      return flattenProperties(property.members, types);\n    } else if (property.type === 'TSInterfaceDeclaration') {\n      return flattenProperties(getProperties(property.id.name, types), types);\n    } else if (property.type === 'TSIntersectionType') {\n      return flattenProperties(property.types, types);\n    } else {\n      throw new Error(`${property.type} is not a supported object literal type.`);\n    }\n  }).filter(Boolean).reduce(function (acc, item) {\n    if (Array.isArray(item)) {\n      item.forEach(function (prop) {\n        verifyPropNotAlreadyDefined(acc, prop);\n      });\n      return acc.concat(item);\n    } else {\n      verifyPropNotAlreadyDefined(acc, item);\n      acc.push(item);\n      return acc;\n    }\n  }, []).filter(Boolean);\n}\nmodule.exports = {\n  getProperties: getProperties,\n  getSchemaInfo: getSchemaInfo,\n  getTypeAnnotation: getTypeAnnotation,\n  flattenProperties: flattenProperties\n};","map":{"version":3,"names":["_toConsumableArray","require","_require","parseTopLevelType","flattenIntersectionType","getProperties","typeName","types","alias","Error","aliasKind","type","_alias$extends","concat","extends","body","typeAnnotation","members","typeParameters","params","e","getUnionOfLiterals","name","forArray","elementTypes","defaultValue","_elementTypes$0$liter","_elementTypes$0$liter2","reduce","lastType","currType","lastFlattenedType","literal","currFlattenedType","undefined","unionType","default","options","map","option","value","_elementTypes$0$liter3","detectArrayType","buildSchema","operator","elementType","getTypeAnnotationForArray","buildObjectType","rawProperties","flattenedProperties","flattenProperties","properties","prop","filter","Boolean","getCommonTypeAnnotation","_extractedTypeAnnotat","_extractedTypeAnnotat2","topLevelType","optional","extractedTypeAnnotation","arrayType","common","setDefaultValue","getTypeAnnotation","annotation","getSchemaInfo","property","key","verifyPropNotAlreadyDefined","props","needleProp","propName","foundProp","some","typeDefinition","expression","id","acc","item","Array","isArray","forEach","push","module","exports"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native/codegen/lib/parsers/typescript/components/componentsUtils.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\n'use strict';\n\nconst _require = require('../parseTopLevelType'),\n  parseTopLevelType = _require.parseTopLevelType,\n  flattenIntersectionType = _require.flattenIntersectionType;\nfunction getProperties(typeName, types) {\n  const alias = types[typeName];\n  if (!alias) {\n    throw new Error(\n      `Failed to find definition for \"${typeName}\", please check that you have a valid codegen typescript file`,\n    );\n  }\n  const aliasKind =\n    alias.type === 'TSInterfaceDeclaration' ? 'interface' : 'type';\n  try {\n    if (aliasKind === 'interface') {\n      var _alias$extends;\n      return [\n        ...((_alias$extends = alias.extends) !== null &&\n        _alias$extends !== void 0\n          ? _alias$extends\n          : []),\n        ...alias.body.body,\n      ];\n    }\n    return (\n      alias.typeAnnotation.members ||\n      alias.typeAnnotation.typeParameters.params[0].members ||\n      alias.typeAnnotation.typeParameters.params\n    );\n  } catch (e) {\n    throw new Error(\n      `Failed to find ${aliasKind} definition for \"${typeName}\", please check that you have a valid codegen typescript file`,\n    );\n  }\n}\nfunction getUnionOfLiterals(name, forArray, elementTypes, defaultValue, types) {\n  var _elementTypes$0$liter, _elementTypes$0$liter2;\n  elementTypes.reduce((lastType, currType) => {\n    const lastFlattenedType =\n      lastType && lastType.type === 'TSLiteralType'\n        ? lastType.literal.type\n        : lastType.type;\n    const currFlattenedType =\n      currType.type === 'TSLiteralType' ? currType.literal.type : currType.type;\n    if (lastFlattenedType && currFlattenedType !== lastFlattenedType) {\n      throw new Error(`Mixed types are not supported (see \"${name}\")`);\n    }\n    return currType;\n  });\n  if (defaultValue === undefined) {\n    throw new Error(`A default enum value is required for \"${name}\"`);\n  }\n  const unionType = elementTypes[0].type;\n  if (\n    unionType === 'TSLiteralType' &&\n    ((_elementTypes$0$liter = elementTypes[0].literal) === null ||\n    _elementTypes$0$liter === void 0\n      ? void 0\n      : _elementTypes$0$liter.type) === 'StringLiteral'\n  ) {\n    return {\n      type: 'StringEnumTypeAnnotation',\n      default: defaultValue,\n      options: elementTypes.map(option => option.literal.value),\n    };\n  } else if (\n    unionType === 'TSLiteralType' &&\n    ((_elementTypes$0$liter2 = elementTypes[0].literal) === null ||\n    _elementTypes$0$liter2 === void 0\n      ? void 0\n      : _elementTypes$0$liter2.type) === 'NumericLiteral'\n  ) {\n    if (forArray) {\n      throw new Error(`Arrays of int enums are not supported (see: \"${name}\")`);\n    } else {\n      return {\n        type: 'Int32EnumTypeAnnotation',\n        default: defaultValue,\n        options: elementTypes.map(option => option.literal.value),\n      };\n    }\n  } else {\n    var _elementTypes$0$liter3;\n    throw new Error(\n      `Unsupported union type for \"${name}\", received \"${\n        unionType === 'TSLiteralType'\n          ? (_elementTypes$0$liter3 = elementTypes[0].literal) === null ||\n            _elementTypes$0$liter3 === void 0\n            ? void 0\n            : _elementTypes$0$liter3.type\n          : unionType\n      }\"`,\n    );\n  }\n}\nfunction detectArrayType(\n  name,\n  typeAnnotation,\n  defaultValue,\n  types,\n  buildSchema,\n) {\n  // Covers: readonly T[]\n  if (\n    typeAnnotation.type === 'TSTypeOperator' &&\n    typeAnnotation.operator === 'readonly' &&\n    typeAnnotation.typeAnnotation.type === 'TSArrayType'\n  ) {\n    return {\n      type: 'ArrayTypeAnnotation',\n      elementType: getTypeAnnotationForArray(\n        name,\n        typeAnnotation.typeAnnotation.elementType,\n        defaultValue,\n        types,\n        buildSchema,\n      ),\n    };\n  }\n\n  // Covers: T[]\n  if (typeAnnotation.type === 'TSArrayType') {\n    return {\n      type: 'ArrayTypeAnnotation',\n      elementType: getTypeAnnotationForArray(\n        name,\n        typeAnnotation.elementType,\n        defaultValue,\n        types,\n        buildSchema,\n      ),\n    };\n  }\n\n  // Covers: Array<T> and ReadonlyArray<T>\n  if (\n    typeAnnotation.type === 'TSTypeReference' &&\n    (typeAnnotation.typeName.name === 'ReadonlyArray' ||\n      typeAnnotation.typeName.name === 'Array')\n  ) {\n    return {\n      type: 'ArrayTypeAnnotation',\n      elementType: getTypeAnnotationForArray(\n        name,\n        typeAnnotation.typeParameters.params[0],\n        defaultValue,\n        types,\n        buildSchema,\n      ),\n    };\n  }\n  return null;\n}\nfunction buildObjectType(rawProperties, types, buildSchema) {\n  const flattenedProperties = flattenProperties(rawProperties, types);\n  const properties = flattenedProperties\n    .map(prop => buildSchema(prop, types))\n    .filter(Boolean);\n  return {\n    type: 'ObjectTypeAnnotation',\n    properties,\n  };\n}\nfunction getCommonTypeAnnotation(\n  name,\n  forArray,\n  type,\n  typeAnnotation,\n  defaultValue,\n  types,\n  buildSchema,\n) {\n  switch (type) {\n    case 'TSTypeLiteral':\n      return buildObjectType(typeAnnotation.members, types, buildSchema);\n    case 'TSInterfaceDeclaration':\n      return buildObjectType([typeAnnotation], types, buildSchema);\n    case 'TSIntersectionType':\n      return buildObjectType(\n        flattenIntersectionType(typeAnnotation, types),\n        types,\n        buildSchema,\n      );\n    case 'ImageSource':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'ImageSourcePrimitive',\n      };\n    case 'ImageRequest':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'ImageRequestPrimitive',\n      };\n    case 'ColorValue':\n    case 'ProcessedColorValue':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'ColorPrimitive',\n      };\n    case 'PointValue':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'PointPrimitive',\n      };\n    case 'EdgeInsetsValue':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'EdgeInsetsPrimitive',\n      };\n    case 'DimensionValue':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'DimensionPrimitive',\n      };\n    case 'TSUnionType':\n      return getUnionOfLiterals(\n        name,\n        forArray,\n        typeAnnotation.types,\n        defaultValue,\n        types,\n      );\n    case 'Int32':\n      return {\n        type: 'Int32TypeAnnotation',\n      };\n    case 'Double':\n      return {\n        type: 'DoubleTypeAnnotation',\n      };\n    case 'Float':\n      return {\n        type: 'FloatTypeAnnotation',\n      };\n    case 'TSBooleanKeyword':\n      return {\n        type: 'BooleanTypeAnnotation',\n      };\n    case 'Stringish':\n    case 'TSStringKeyword':\n      return {\n        type: 'StringTypeAnnotation',\n      };\n    case 'UnsafeMixed':\n      return {\n        type: 'MixedTypeAnnotation',\n      };\n    default:\n      return undefined;\n  }\n}\nfunction getTypeAnnotationForArray(\n  name,\n  typeAnnotation,\n  defaultValue,\n  types,\n  buildSchema,\n) {\n  var _extractedTypeAnnotat, _extractedTypeAnnotat2;\n  // unpack WithDefault, (T) or T|U\n  const topLevelType = parseTopLevelType(typeAnnotation, types);\n  if (topLevelType.defaultValue !== undefined) {\n    throw new Error(\n      'Nested optionals such as \"ReadonlyArray<boolean | null | undefined>\" are not supported, please declare optionals at the top level of value definitions as in \"ReadonlyArray<boolean> | null | undefined\"',\n    );\n  }\n  if (topLevelType.optional) {\n    throw new Error(\n      'Nested optionals such as \"ReadonlyArray<boolean | null | undefined>\" are not supported, please declare optionals at the top level of value definitions as in \"ReadonlyArray<boolean> | null | undefined\"',\n    );\n  }\n  const extractedTypeAnnotation = topLevelType.type;\n  const arrayType = detectArrayType(\n    name,\n    extractedTypeAnnotation,\n    defaultValue,\n    types,\n    buildSchema,\n  );\n  if (arrayType) {\n    if (arrayType.elementType.type !== 'ObjectTypeAnnotation') {\n      throw new Error(\n        `Only array of array of object is supported for \"${name}\".`,\n      );\n    }\n    return arrayType;\n  }\n  const type =\n    extractedTypeAnnotation.elementType === 'TSTypeReference'\n      ? extractedTypeAnnotation.elementType.typeName.name\n      : ((_extractedTypeAnnotat = extractedTypeAnnotation.elementType) ===\n          null || _extractedTypeAnnotat === void 0\n          ? void 0\n          : _extractedTypeAnnotat.type) ||\n        ((_extractedTypeAnnotat2 = extractedTypeAnnotation.typeName) === null ||\n        _extractedTypeAnnotat2 === void 0\n          ? void 0\n          : _extractedTypeAnnotat2.name) ||\n        extractedTypeAnnotation.type;\n  const common = getCommonTypeAnnotation(\n    name,\n    true,\n    type,\n    extractedTypeAnnotation,\n    defaultValue,\n    types,\n    buildSchema,\n  );\n  if (common) {\n    return common;\n  }\n  switch (type) {\n    case 'TSNumberKeyword':\n      return {\n        type: 'FloatTypeAnnotation',\n      };\n    default:\n      type;\n      throw new Error(`Unknown prop type for \"${name}\": ${type}`);\n  }\n}\nfunction setDefaultValue(common, defaultValue) {\n  switch (common.type) {\n    case 'Int32TypeAnnotation':\n    case 'DoubleTypeAnnotation':\n      common.default = defaultValue ? defaultValue : 0;\n      break;\n    case 'FloatTypeAnnotation':\n      common.default =\n        defaultValue === null ? null : defaultValue ? defaultValue : 0;\n      break;\n    case 'BooleanTypeAnnotation':\n      common.default = defaultValue === null ? null : !!defaultValue;\n      break;\n    case 'StringTypeAnnotation':\n      common.default = defaultValue === undefined ? null : defaultValue;\n      break;\n  }\n}\nfunction getTypeAnnotation(name, annotation, defaultValue, types, buildSchema) {\n  // unpack WithDefault, (T) or T|U\n  const topLevelType = parseTopLevelType(annotation, types);\n  const typeAnnotation = topLevelType.type;\n  const arrayType = detectArrayType(\n    name,\n    typeAnnotation,\n    defaultValue,\n    types,\n    buildSchema,\n  );\n  if (arrayType) {\n    return arrayType;\n  }\n  const type =\n    typeAnnotation.type === 'TSTypeReference' ||\n    typeAnnotation.type === 'TSTypeAliasDeclaration'\n      ? typeAnnotation.typeName.name\n      : typeAnnotation.type;\n  const common = getCommonTypeAnnotation(\n    name,\n    false,\n    type,\n    typeAnnotation,\n    defaultValue,\n    types,\n    buildSchema,\n  );\n  if (common) {\n    setDefaultValue(common, defaultValue);\n    return common;\n  }\n  switch (type) {\n    case 'ColorArrayValue':\n      return {\n        type: 'ArrayTypeAnnotation',\n        elementType: {\n          type: 'ReservedPropTypeAnnotation',\n          name: 'ColorPrimitive',\n        },\n      };\n    case 'TSNumberKeyword':\n      throw new Error(\n        `Cannot use \"${type}\" type annotation for \"${name}\": must use a specific numeric type like Int32, Double, or Float`,\n      );\n    case 'TSFunctionType':\n      throw new Error(\n        `Cannot use \"${type}\" type annotation for \"${name}\": must use a specific function type like BubblingEventHandler, or DirectEventHandler`,\n      );\n    default:\n      type;\n      throw new Error(`Unknown prop type for \"${name}\": \"${type}\"`);\n  }\n}\nfunction getSchemaInfo(property, types) {\n  // unpack WithDefault, (T) or T|U\n  const topLevelType = parseTopLevelType(\n    property.typeAnnotation.typeAnnotation,\n    types,\n  );\n  const name = property.key.name;\n  if (!property.optional && topLevelType.defaultValue !== undefined) {\n    throw new Error(\n      `key ${name} must be optional if used with WithDefault<> annotation`,\n    );\n  }\n  return {\n    name,\n    optional: property.optional || topLevelType.optional,\n    typeAnnotation: topLevelType.type,\n    defaultValue: topLevelType.defaultValue,\n  };\n}\n\n// $FlowFixMe[unclear-type] TODO(T108222691): Use flow-types for @babel/parser\n\nfunction verifyPropNotAlreadyDefined(props, needleProp) {\n  const propName = needleProp.key.name;\n  const foundProp = props.some(prop => prop.key.name === propName);\n  if (foundProp) {\n    throw new Error(`A prop was already defined with the name ${propName}`);\n  }\n}\nfunction flattenProperties(typeDefinition, types) {\n  return typeDefinition\n    .map(property => {\n      if (property.type === 'TSPropertySignature') {\n        return property;\n      } else if (property.type === 'TSTypeReference') {\n        return flattenProperties(\n          getProperties(property.typeName.name, types),\n          types,\n        );\n      } else if (\n        property.type === 'TSExpressionWithTypeArguments' ||\n        property.type === 'TSInterfaceHeritage'\n      ) {\n        return flattenProperties(\n          getProperties(property.expression.name, types),\n          types,\n        );\n      } else if (property.type === 'TSTypeLiteral') {\n        return flattenProperties(property.members, types);\n      } else if (property.type === 'TSInterfaceDeclaration') {\n        return flattenProperties(getProperties(property.id.name, types), types);\n      } else if (property.type === 'TSIntersectionType') {\n        return flattenProperties(property.types, types);\n      } else {\n        throw new Error(\n          `${property.type} is not a supported object literal type.`,\n        );\n      }\n    })\n    .filter(Boolean)\n    .reduce((acc, item) => {\n      if (Array.isArray(item)) {\n        item.forEach(prop => {\n          verifyPropNotAlreadyDefined(acc, prop);\n        });\n        return acc.concat(item);\n      } else {\n        verifyPropNotAlreadyDefined(acc, item);\n        acc.push(item);\n        return acc;\n      }\n    }, [])\n    .filter(Boolean);\n}\nmodule.exports = {\n  getProperties,\n  getSchemaInfo,\n  getTypeAnnotation,\n  flattenProperties,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}