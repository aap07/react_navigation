{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, 'string');\n  return typeof key === 'symbol' ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== 'object' || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || 'default');\n    if (typeof res !== 'object') return res;\n    throw new TypeError('@@toPrimitive must return a primitive value.');\n  }\n  return (hint === 'string' ? String : Number)(input);\n}\nvar _require = require(\"./modules\"),\n  flowTranslateTypeAnnotation = _require.flowTranslateTypeAnnotation;\nvar flowParser = require('flow-parser');\nvar _require2 = require(\"../parsers-commons\"),\n  buildSchema = _require2.buildSchema;\nvar _require3 = require(\"../parsers-primitives\"),\n  Visitor = _require3.Visitor;\nvar _require4 = require(\"./components\"),\n  buildComponentSchema = _require4.buildComponentSchema;\nvar _require5 = require(\"../schema.js\"),\n  wrapComponentSchema = _require5.wrapComponentSchema;\nvar _require6 = require(\"../parsers-commons.js\"),\n  buildModuleSchema = _require6.buildModuleSchema;\nvar _require7 = require(\"./utils\"),\n  resolveTypeAnnotation = _require7.resolveTypeAnnotation;\nvar fs = require('fs');\nvar _require8 = require(\"../errors\"),\n  UnsupportedObjectPropertyTypeAnnotationParserError = _require8.UnsupportedObjectPropertyTypeAnnotationParserError;\nvar FlowParser = function () {\n  function FlowParser() {\n    _classCallCheck(this, FlowParser);\n    _defineProperty(this, 'typeParameterInstantiation', 'TypeParameterInstantiation');\n  }\n  _createClass(FlowParser, [{\n    key: \"isProperty\",\n    value: function isProperty(property) {\n      return property.type === 'ObjectTypeProperty';\n    }\n  }, {\n    key: \"getKeyName\",\n    value: function getKeyName(property, hasteModuleName) {\n      if (!this.isProperty(property)) {\n        throw new UnsupportedObjectPropertyTypeAnnotationParserError(hasteModuleName, property, property.type, this.language());\n      }\n      return property.key.name;\n    }\n  }, {\n    key: \"language\",\n    value: function language() {\n      return 'Flow';\n    }\n  }, {\n    key: \"nameForGenericTypeAnnotation\",\n    value: function nameForGenericTypeAnnotation(typeAnnotation) {\n      return typeAnnotation.id.name;\n    }\n  }, {\n    key: \"checkIfInvalidModule\",\n    value: function checkIfInvalidModule(typeArguments) {\n      return typeArguments.type !== 'TypeParameterInstantiation' || typeArguments.params.length !== 1 || typeArguments.params[0].type !== 'GenericTypeAnnotation' || typeArguments.params[0].id.name !== 'Spec';\n    }\n  }, {\n    key: \"remapUnionTypeAnnotationMemberNames\",\n    value: function remapUnionTypeAnnotationMemberNames(membersTypes) {\n      var remapLiteral = function remapLiteral(item) {\n        return item.type.replace('NumberLiteralTypeAnnotation', 'NumberTypeAnnotation').replace('StringLiteralTypeAnnotation', 'StringTypeAnnotation');\n      };\n      return _toConsumableArray(new Set(membersTypes.map(remapLiteral)));\n    }\n  }, {\n    key: \"parseFile\",\n    value: function parseFile(filename) {\n      var contents = fs.readFileSync(filename, 'utf8');\n      return this.parseString(contents, filename);\n    }\n  }, {\n    key: \"parseString\",\n    value: function parseString(contents, filename) {\n      return buildSchema(contents, filename, wrapComponentSchema, buildComponentSchema, buildModuleSchema, Visitor, this, resolveTypeAnnotation, flowTranslateTypeAnnotation);\n    }\n  }, {\n    key: \"parseModuleFixture\",\n    value: function parseModuleFixture(filename) {\n      var contents = fs.readFileSync(filename, 'utf8');\n      return this.parseString(contents, 'path/NativeSampleTurboModule.js');\n    }\n  }, {\n    key: \"getAst\",\n    value: function getAst(contents) {\n      return flowParser.parse(contents, {\n        enums: true\n      });\n    }\n  }, {\n    key: \"getFunctionTypeAnnotationParameters\",\n    value: function getFunctionTypeAnnotationParameters(functionTypeAnnotation) {\n      return functionTypeAnnotation.params;\n    }\n  }, {\n    key: \"getFunctionNameFromParameter\",\n    value: function getFunctionNameFromParameter(parameter) {\n      return parameter.name;\n    }\n  }, {\n    key: \"getParameterName\",\n    value: function getParameterName(parameter) {\n      return parameter.name.name;\n    }\n  }, {\n    key: \"getParameterTypeAnnotation\",\n    value: function getParameterTypeAnnotation(parameter) {\n      return parameter.typeAnnotation;\n    }\n  }, {\n    key: \"getFunctionTypeAnnotationReturnType\",\n    value: function getFunctionTypeAnnotationReturnType(functionTypeAnnotation) {\n      return functionTypeAnnotation.returnType;\n    }\n  }, {\n    key: \"parseEnumMembersType\",\n    value: function parseEnumMembersType(typeAnnotation) {\n      var enumMembersType = typeAnnotation.type === 'EnumStringBody' ? 'StringTypeAnnotation' : typeAnnotation.type === 'EnumNumberBody' ? 'NumberTypeAnnotation' : null;\n      if (!enumMembersType) {\n        throw new Error(`Unknown enum type annotation type. Got: ${typeAnnotation.type}. Expected: EnumStringBody or EnumNumberBody.`);\n      }\n      return enumMembersType;\n    }\n  }, {\n    key: \"validateEnumMembersSupported\",\n    value: function validateEnumMembersSupported(typeAnnotation, enumMembersType) {\n      if (!typeAnnotation.members || typeAnnotation.members.length === 0) {\n        throw new Error('Enums should have at least one member and member values can not be mixed- they all must be either blank, number, or string values.');\n      }\n      typeAnnotation.members.forEach(function (member) {\n        if (enumMembersType === 'StringTypeAnnotation' && (!member.init || typeof member.init.value === 'string')) {\n          return;\n        }\n        if (enumMembersType === 'NumberTypeAnnotation' && member.init && typeof member.init.value === 'number') {\n          return;\n        }\n        throw new Error('Enums can not be mixed- they all must be either blank, number, or string values.');\n      });\n    }\n  }, {\n    key: \"parseEnumMembers\",\n    value: function parseEnumMembers(typeAnnotation) {\n      return typeAnnotation.members.map(function (member) {\n        var _member$init$value, _member$init;\n        return {\n          name: member.id.name,\n          value: (_member$init$value = (_member$init = member.init) === null || _member$init === void 0 ? void 0 : _member$init.value) !== null && _member$init$value !== void 0 ? _member$init$value : member.id.name\n        };\n      });\n    }\n  }, {\n    key: \"isModuleInterface\",\n    value: function isModuleInterface(node) {\n      return node.type === 'InterfaceDeclaration' && node.extends.length === 1 && node.extends[0].type === 'InterfaceExtends' && node.extends[0].id.name === 'TurboModule';\n    }\n  }, {\n    key: \"extractAnnotatedElement\",\n    value: function extractAnnotatedElement(typeAnnotation, types) {\n      return types[typeAnnotation.typeParameters.params[0].id.name];\n    }\n  }, {\n    key: \"getTypes\",\n    value: function getTypes(ast) {\n      return ast.body.reduce(function (types, node) {\n        if (node.type === 'ExportNamedDeclaration' && node.exportKind === 'type') {\n          if (node.declaration != null && (node.declaration.type === 'TypeAlias' || node.declaration.type === 'InterfaceDeclaration')) {\n            types[node.declaration.id.name] = node.declaration;\n          }\n        } else if (node.type === 'ExportNamedDeclaration' && node.exportKind === 'value' && node.declaration && node.declaration.type === 'EnumDeclaration') {\n          types[node.declaration.id.name] = node.declaration;\n        } else if (node.type === 'TypeAlias' || node.type === 'InterfaceDeclaration' || node.type === 'EnumDeclaration') {\n          types[node.id.name] = node;\n        }\n        return types;\n      }, {});\n    }\n  }, {\n    key: \"callExpressionTypeParameters\",\n    value: function callExpressionTypeParameters(callExpression) {\n      return callExpression.typeArguments || null;\n    }\n  }, {\n    key: \"computePartialProperties\",\n    value: function computePartialProperties(properties, hasteModuleName, types, aliasMap, enumMap, tryParse, cxxOnly) {\n      var _this = this;\n      return properties.map(function (prop) {\n        return {\n          name: prop.key.name,\n          optional: true,\n          typeAnnotation: flowTranslateTypeAnnotation(hasteModuleName, prop.value, types, aliasMap, enumMap, tryParse, cxxOnly, _this)\n        };\n      });\n    }\n  }, {\n    key: \"functionTypeAnnotation\",\n    value: function functionTypeAnnotation(propertyValueType) {\n      return propertyValueType === 'FunctionTypeAnnotation';\n    }\n  }, {\n    key: \"getTypeArgumentParamsFromDeclaration\",\n    value: function getTypeArgumentParamsFromDeclaration(declaration) {\n      return declaration.typeArguments.params;\n    }\n  }, {\n    key: \"getNativeComponentType\",\n    value: function getNativeComponentType(typeArgumentParams, funcArgumentParams) {\n      return {\n        propsTypeName: typeArgumentParams[0].id.name,\n        componentName: funcArgumentParams[0].value\n      };\n    }\n  }, {\n    key: \"getAnnotatedElementProperties\",\n    value: function getAnnotatedElementProperties(annotatedElement) {\n      return annotatedElement.right.properties;\n    }\n  }]);\n  return FlowParser;\n}();\nmodule.exports = {\n  FlowParser: FlowParser\n};","map":{"version":3,"names":["_toConsumableArray","require","_classCallCheck","_createClass","_defineProperty","obj","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","arg","_toPrimitive","String","input","hint","prim","Symbol","toPrimitive","undefined","res","call","TypeError","Number","_require","flowTranslateTypeAnnotation","flowParser","_require2","buildSchema","_require3","Visitor","_require4","buildComponentSchema","_require5","wrapComponentSchema","_require6","buildModuleSchema","_require7","resolveTypeAnnotation","fs","_require8","UnsupportedObjectPropertyTypeAnnotationParserError","FlowParser","isProperty","property","type","getKeyName","hasteModuleName","language","name","nameForGenericTypeAnnotation","typeAnnotation","id","checkIfInvalidModule","typeArguments","params","length","remapUnionTypeAnnotationMemberNames","membersTypes","remapLiteral","item","replace","Set","map","parseFile","filename","contents","readFileSync","parseString","parseModuleFixture","getAst","parse","enums","getFunctionTypeAnnotationParameters","functionTypeAnnotation","getFunctionNameFromParameter","parameter","getParameterName","getParameterTypeAnnotation","getFunctionTypeAnnotationReturnType","returnType","parseEnumMembersType","enumMembersType","Error","validateEnumMembersSupported","members","forEach","member","init","parseEnumMembers","_member$init$value","_member$init","isModuleInterface","node","extends","extractAnnotatedElement","types","typeParameters","getTypes","ast","body","reduce","exportKind","declaration","callExpressionTypeParameters","callExpression","computePartialProperties","properties","aliasMap","enumMap","tryParse","cxxOnly","_this","prop","optional","propertyValueType","getTypeArgumentParamsFromDeclaration","getNativeComponentType","typeArgumentParams","funcArgumentParams","propsTypeName","componentName","getAnnotatedElementProperties","annotatedElement","right","module","exports"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native/codegen/lib/parsers/flow/parser.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\n'use strict';\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true,\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, 'string');\n  return typeof key === 'symbol' ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== 'object' || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || 'default');\n    if (typeof res !== 'object') return res;\n    throw new TypeError('@@toPrimitive must return a primitive value.');\n  }\n  return (hint === 'string' ? String : Number)(input);\n}\nconst _require = require('./modules'),\n  flowTranslateTypeAnnotation = _require.flowTranslateTypeAnnotation;\n\n// $FlowFixMe[untyped-import] there's no flowtype flow-parser\nconst flowParser = require('flow-parser');\nconst _require2 = require('../parsers-commons'),\n  buildSchema = _require2.buildSchema;\nconst _require3 = require('../parsers-primitives'),\n  Visitor = _require3.Visitor;\nconst _require4 = require('./components'),\n  buildComponentSchema = _require4.buildComponentSchema;\nconst _require5 = require('../schema.js'),\n  wrapComponentSchema = _require5.wrapComponentSchema;\nconst _require6 = require('../parsers-commons.js'),\n  buildModuleSchema = _require6.buildModuleSchema;\nconst _require7 = require('./utils'),\n  resolveTypeAnnotation = _require7.resolveTypeAnnotation;\nconst fs = require('fs');\nconst _require8 = require('../errors'),\n  UnsupportedObjectPropertyTypeAnnotationParserError =\n    _require8.UnsupportedObjectPropertyTypeAnnotationParserError;\nclass FlowParser {\n  constructor() {\n    _defineProperty(\n      this,\n      'typeParameterInstantiation',\n      'TypeParameterInstantiation',\n    );\n  }\n  isProperty(property) {\n    return property.type === 'ObjectTypeProperty';\n  }\n  getKeyName(property, hasteModuleName) {\n    if (!this.isProperty(property)) {\n      throw new UnsupportedObjectPropertyTypeAnnotationParserError(\n        hasteModuleName,\n        property,\n        property.type,\n        this.language(),\n      );\n    }\n    return property.key.name;\n  }\n  language() {\n    return 'Flow';\n  }\n  nameForGenericTypeAnnotation(typeAnnotation) {\n    return typeAnnotation.id.name;\n  }\n  checkIfInvalidModule(typeArguments) {\n    return (\n      typeArguments.type !== 'TypeParameterInstantiation' ||\n      typeArguments.params.length !== 1 ||\n      typeArguments.params[0].type !== 'GenericTypeAnnotation' ||\n      typeArguments.params[0].id.name !== 'Spec'\n    );\n  }\n  remapUnionTypeAnnotationMemberNames(membersTypes) {\n    const remapLiteral = item => {\n      return item.type\n        .replace('NumberLiteralTypeAnnotation', 'NumberTypeAnnotation')\n        .replace('StringLiteralTypeAnnotation', 'StringTypeAnnotation');\n    };\n    return [...new Set(membersTypes.map(remapLiteral))];\n  }\n  parseFile(filename) {\n    const contents = fs.readFileSync(filename, 'utf8');\n    return this.parseString(contents, filename);\n  }\n  parseString(contents, filename) {\n    return buildSchema(\n      contents,\n      filename,\n      wrapComponentSchema,\n      buildComponentSchema,\n      buildModuleSchema,\n      Visitor,\n      this,\n      resolveTypeAnnotation,\n      flowTranslateTypeAnnotation,\n    );\n  }\n  parseModuleFixture(filename) {\n    const contents = fs.readFileSync(filename, 'utf8');\n    return this.parseString(contents, 'path/NativeSampleTurboModule.js');\n  }\n  getAst(contents) {\n    return flowParser.parse(contents, {\n      enums: true,\n    });\n  }\n  getFunctionTypeAnnotationParameters(functionTypeAnnotation) {\n    return functionTypeAnnotation.params;\n  }\n  getFunctionNameFromParameter(parameter) {\n    return parameter.name;\n  }\n  getParameterName(parameter) {\n    return parameter.name.name;\n  }\n  getParameterTypeAnnotation(parameter) {\n    return parameter.typeAnnotation;\n  }\n  getFunctionTypeAnnotationReturnType(functionTypeAnnotation) {\n    return functionTypeAnnotation.returnType;\n  }\n  parseEnumMembersType(typeAnnotation) {\n    const enumMembersType =\n      typeAnnotation.type === 'EnumStringBody'\n        ? 'StringTypeAnnotation'\n        : typeAnnotation.type === 'EnumNumberBody'\n        ? 'NumberTypeAnnotation'\n        : null;\n    if (!enumMembersType) {\n      throw new Error(\n        `Unknown enum type annotation type. Got: ${typeAnnotation.type}. Expected: EnumStringBody or EnumNumberBody.`,\n      );\n    }\n    return enumMembersType;\n  }\n  validateEnumMembersSupported(typeAnnotation, enumMembersType) {\n    if (!typeAnnotation.members || typeAnnotation.members.length === 0) {\n      // passing mixed members to flow would result in a flow error\n      // if the tool is launched ignoring that error, the enum would appear like not having enums\n      throw new Error(\n        'Enums should have at least one member and member values can not be mixed- they all must be either blank, number, or string values.',\n      );\n    }\n    typeAnnotation.members.forEach(member => {\n      if (\n        enumMembersType === 'StringTypeAnnotation' &&\n        (!member.init || typeof member.init.value === 'string')\n      ) {\n        return;\n      }\n      if (\n        enumMembersType === 'NumberTypeAnnotation' &&\n        member.init &&\n        typeof member.init.value === 'number'\n      ) {\n        return;\n      }\n      throw new Error(\n        'Enums can not be mixed- they all must be either blank, number, or string values.',\n      );\n    });\n  }\n  parseEnumMembers(typeAnnotation) {\n    return typeAnnotation.members.map(member => {\n      var _member$init$value, _member$init;\n      return {\n        name: member.id.name,\n        value:\n          (_member$init$value =\n            (_member$init = member.init) === null || _member$init === void 0\n              ? void 0\n              : _member$init.value) !== null && _member$init$value !== void 0\n            ? _member$init$value\n            : member.id.name,\n      };\n    });\n  }\n  isModuleInterface(node) {\n    return (\n      node.type === 'InterfaceDeclaration' &&\n      node.extends.length === 1 &&\n      node.extends[0].type === 'InterfaceExtends' &&\n      node.extends[0].id.name === 'TurboModule'\n    );\n  }\n  extractAnnotatedElement(typeAnnotation, types) {\n    return types[typeAnnotation.typeParameters.params[0].id.name];\n  }\n\n  /**\n   * This FlowFixMe is supposed to refer to an InterfaceDeclaration or TypeAlias\n   * declaration type. Unfortunately, we don't have those types, because flow-parser\n   * generates them, and flow-parser is not type-safe. In the future, we should find\n   * a way to get these types from our flow parser library.\n   *\n   * TODO(T71778680): Flow type AST Nodes\n   */\n\n  getTypes(ast) {\n    return ast.body.reduce((types, node) => {\n      if (\n        node.type === 'ExportNamedDeclaration' &&\n        node.exportKind === 'type'\n      ) {\n        if (\n          node.declaration != null &&\n          (node.declaration.type === 'TypeAlias' ||\n            node.declaration.type === 'InterfaceDeclaration')\n        ) {\n          types[node.declaration.id.name] = node.declaration;\n        }\n      } else if (\n        node.type === 'ExportNamedDeclaration' &&\n        node.exportKind === 'value' &&\n        node.declaration &&\n        node.declaration.type === 'EnumDeclaration'\n      ) {\n        types[node.declaration.id.name] = node.declaration;\n      } else if (\n        node.type === 'TypeAlias' ||\n        node.type === 'InterfaceDeclaration' ||\n        node.type === 'EnumDeclaration'\n      ) {\n        types[node.id.name] = node;\n      }\n      return types;\n    }, {});\n  }\n  callExpressionTypeParameters(callExpression) {\n    return callExpression.typeArguments || null;\n  }\n  computePartialProperties(\n    properties,\n    hasteModuleName,\n    types,\n    aliasMap,\n    enumMap,\n    tryParse,\n    cxxOnly,\n  ) {\n    return properties.map(prop => {\n      return {\n        name: prop.key.name,\n        optional: true,\n        typeAnnotation: flowTranslateTypeAnnotation(\n          hasteModuleName,\n          prop.value,\n          types,\n          aliasMap,\n          enumMap,\n          tryParse,\n          cxxOnly,\n          this,\n        ),\n      };\n    });\n  }\n  functionTypeAnnotation(propertyValueType) {\n    return propertyValueType === 'FunctionTypeAnnotation';\n  }\n  getTypeArgumentParamsFromDeclaration(declaration) {\n    return declaration.typeArguments.params;\n  }\n\n  /**\n   * This FlowFixMe is supposed to refer to typeArgumentParams and\n   * funcArgumentParams of generated AST.\n   */\n  getNativeComponentType(typeArgumentParams, funcArgumentParams) {\n    return {\n      propsTypeName: typeArgumentParams[0].id.name,\n      componentName: funcArgumentParams[0].value,\n    };\n  }\n  getAnnotatedElementProperties(annotatedElement) {\n    return annotatedElement.right.properties;\n  }\n}\nmodule.exports = {\n  FlowParser,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}