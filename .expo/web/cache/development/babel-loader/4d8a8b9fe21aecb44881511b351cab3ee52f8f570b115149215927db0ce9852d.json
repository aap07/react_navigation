{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.collectMissingPackages = collectMissingPackages;\nexports.versionSatisfiesRequiredPackage = versionSatisfiesRequiredPackage;\nexports.getMissingPackagesAsync = getMissingPackagesAsync;\nexports.mutatePackagesWithKnownVersionsAsync = mutatePackagesWithKnownVersionsAsync;\nvar _jsonFile = _interopRequireDefault(require(\"@expo/json-file\"));\nvar _resolveFrom = _interopRequireDefault(require(\"resolve-from\"));\nvar _semver = _interopRequireDefault(require(\"semver\"));\nvar _getVersionedPackages = require(\"./getVersionedPackages\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar debug = require(\"debug\")(\"expo:doctor:dependencies:getMissingPackages\");\nfunction collectMissingPackages(projectRoot, requiredPackages) {\n  var resolutions = {};\n  var missingPackages = requiredPackages.filter(function (p) {\n    var resolved = _resolveFrom.default.silent(projectRoot, p.file);\n    if (!resolved || !versionSatisfiesRequiredPackage(resolved, p)) {\n      return true;\n    }\n    resolutions[p.pkg] = resolved;\n    return false;\n  });\n  return {\n    missing: missingPackages,\n    resolutions: resolutions\n  };\n}\nfunction versionSatisfiesRequiredPackage(packageJsonFilePath, resolvedPackage) {\n  if (!resolvedPackage.version) {\n    debug(`Required package \"${resolvedPackage.pkg}\" found (no version constraint specified).`);\n    return true;\n  }\n  var pkgJson = _jsonFile.default.read(packageJsonFilePath);\n  if (typeof pkgJson.version === \"string\" && _semver.default.satisfies(pkgJson.version, resolvedPackage.version)) {\n    return true;\n  }\n  debug(`Installed package \"${resolvedPackage.pkg}\" does not satisfy version constraint \"${resolvedPackage.version}\" (version: \"${pkgJson.version}\")`);\n  return false;\n}\nfunction getMissingPackagesAsync(_x, _x2) {\n  return _getMissingPackagesAsync.apply(this, arguments);\n}\nfunction _getMissingPackagesAsync() {\n  _getMissingPackagesAsync = _asyncToGenerator(function* (projectRoot, _ref) {\n    var sdkVersion = _ref.sdkVersion,\n      requiredPackages = _ref.requiredPackages;\n    var results = collectMissingPackages(projectRoot, requiredPackages);\n    if (!results.missing.length) {\n      return results;\n    }\n    yield mutatePackagesWithKnownVersionsAsync(projectRoot, sdkVersion, results.missing);\n    return results;\n  });\n  return _getMissingPackagesAsync.apply(this, arguments);\n}\nfunction mutatePackagesWithKnownVersionsAsync(_x3, _x4, _x5) {\n  return _mutatePackagesWithKnownVersionsAsync.apply(this, arguments);\n}\nfunction _mutatePackagesWithKnownVersionsAsync() {\n  _mutatePackagesWithKnownVersionsAsync = _asyncToGenerator(function* (projectRoot, sdkVersion, packages) {\n    var relatedPackages = yield (0, _getVersionedPackages).getCombinedKnownVersionsAsync({\n      projectRoot: projectRoot,\n      sdkVersion: sdkVersion\n    });\n    for (var pkg of packages) {\n      if (!pkg.version && pkg.pkg in relatedPackages) {\n        pkg.version = relatedPackages[pkg.pkg];\n      }\n    }\n    return packages;\n  });\n  return _mutatePackagesWithKnownVersionsAsync.apply(this, arguments);\n}","map":{"version":3,"names":["_asyncToGenerator","require","collectMissingPackages","versionSatisfiesRequiredPackage","getMissingPackagesAsync","mutatePackagesWithKnownVersionsAsync","_jsonFile","_interopRequireDefault","_resolveFrom","_semver","_getVersionedPackages","debug","projectRoot","requiredPackages","resolutions","missingPackages","filter","p","resolved","default","silent","file","pkg","missing","packageJsonFilePath","resolvedPackage","version","pkgJson","read","satisfies","_x","_x2","_getMissingPackagesAsync","apply","arguments","_ref","sdkVersion","results","length","_x3","_x4","_x5","_mutatePackagesWithKnownVersionsAsync","packages","relatedPackages","getCombinedKnownVersionsAsync"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\cli\\src\\start\\doctor\\dependencies\\getMissingPackages.ts"],"sourcesContent":["import JsonFile from '@expo/json-file';\nimport resolveFrom from 'resolve-from';\nimport semver from 'semver';\n\nimport { getCombinedKnownVersionsAsync } from './getVersionedPackages';\n\nconst debug = require('debug')('expo:doctor:dependencies:getMissingPackages') as typeof console.log;\n\nexport type ResolvedPackage = {\n  /** Module ID pointing to the library `package.json`. */\n  file: string;\n  /** NPM package name. */\n  pkg: string;\n  /** Required version range. */\n  version?: string;\n  /** If the dependency should be installed as a `devDependency` */\n  dev?: boolean;\n};\n\n/** Given a set of required packages, this method returns a list of missing packages. */\nexport function collectMissingPackages(\n  projectRoot: string,\n  requiredPackages: ResolvedPackage[]\n): {\n  missing: ResolvedPackage[];\n  resolutions: Record<string, string>;\n} {\n  const resolutions: Record<string, string> = {};\n\n  const missingPackages = requiredPackages.filter((p) => {\n    const resolved = resolveFrom.silent(projectRoot, p.file);\n    if (!resolved || !versionSatisfiesRequiredPackage(resolved, p)) {\n      return true;\n    }\n    resolutions[p.pkg] = resolved;\n    return false;\n  });\n\n  return { missing: missingPackages, resolutions };\n}\n\nexport function versionSatisfiesRequiredPackage(\n  packageJsonFilePath: string,\n  resolvedPackage: Pick<ResolvedPackage, 'version' | 'pkg'>\n): boolean {\n  // If the version is specified, check that it satisfies the installed version.\n  if (!resolvedPackage.version) {\n    debug(`Required package \"${resolvedPackage.pkg}\" found (no version constraint specified).`);\n    return true;\n  }\n\n  const pkgJson = JsonFile.read(packageJsonFilePath);\n  if (\n    // package.json has version.\n    typeof pkgJson.version === 'string' &&\n    // semver satisfaction.\n    semver.satisfies(pkgJson.version, resolvedPackage.version)\n  ) {\n    return true;\n  }\n  debug(\n    `Installed package \"${resolvedPackage.pkg}\" does not satisfy version constraint \"${resolvedPackage.version}\" (version: \"${pkgJson.version}\")`\n  );\n  return false;\n}\n\n/**\n * Collect missing packages given a list of required packages.\n * Any missing packages will be versioned to the known versions for the current SDK.\n *\n * @param projectRoot\n * @param props.requiredPackages list of required packages to check for\n * @returns list of missing packages and resolutions to existing packages.\n */\nexport async function getMissingPackagesAsync(\n  projectRoot: string,\n  {\n    sdkVersion,\n    requiredPackages,\n  }: {\n    sdkVersion?: string;\n    requiredPackages: ResolvedPackage[];\n  }\n): Promise<{\n  missing: ResolvedPackage[];\n  resolutions: Record<string, string>;\n}> {\n  const results = collectMissingPackages(projectRoot, requiredPackages);\n  if (!results.missing.length) {\n    return results;\n  }\n\n  // Ensure the versions are right for the SDK that the project is currently using.\n  await mutatePackagesWithKnownVersionsAsync(projectRoot, sdkVersion, results.missing);\n\n  return results;\n}\n\nexport async function mutatePackagesWithKnownVersionsAsync(\n  projectRoot: string,\n  sdkVersion: string | undefined,\n  packages: ResolvedPackage[]\n) {\n  // Ensure the versions are right for the SDK that the project is currently using.\n  const relatedPackages = await getCombinedKnownVersionsAsync({ projectRoot, sdkVersion });\n  for (const pkg of packages) {\n    if (\n      // Only use the SDK versions if the package does not already have a hardcoded version.\n      // We do this because some packages have API coded into the CLI which expects an exact version.\n      !pkg.version &&\n      pkg.pkg in relatedPackages\n    ) {\n      pkg.version = relatedPackages[pkg.pkg];\n    }\n  }\n  return packages;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}