{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError('Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.');\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === 'string') return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === 'Object' && o.constructor) n = o.constructor.name;\n  if (n === 'Map' || n === 'Set') return Array.from(o);\n  if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : 'undefined' != typeof Symbol && arr[Symbol.iterator] || arr['@@iterator'];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nvar _require = require(\"../utils\"),\n  resolveTypeAnnotation = _require.resolveTypeAnnotation;\nvar _require2 = require(\"../../parsers-commons\"),\n  unwrapNullable = _require2.unwrapNullable,\n  wrapNullable = _require2.wrapNullable,\n  assertGenericTypeAnnotationHasExactlyOneTypeParameter = _require2.assertGenericTypeAnnotationHasExactlyOneTypeParameter,\n  parseObjectProperty = _require2.parseObjectProperty;\nvar _require3 = require(\"../../parsers-primitives\"),\n  emitArrayType = _require3.emitArrayType,\n  emitBoolean = _require3.emitBoolean,\n  emitFunction = _require3.emitFunction,\n  emitNumber = _require3.emitNumber,\n  emitGenericObject = _require3.emitGenericObject,\n  emitPromise = _require3.emitPromise,\n  emitRootTag = _require3.emitRootTag,\n  emitVoid = _require3.emitVoid,\n  emitString = _require3.emitString,\n  emitMixed = _require3.emitMixed,\n  emitUnion = _require3.emitUnion,\n  emitCommonTypes = _require3.emitCommonTypes,\n  typeAliasResolution = _require3.typeAliasResolution,\n  typeEnumResolution = _require3.typeEnumResolution;\nvar _require4 = require(\"../../errors\"),\n  UnsupportedTypeAnnotationParserError = _require4.UnsupportedTypeAnnotationParserError,\n  UnsupportedGenericParserError = _require4.UnsupportedGenericParserError;\nfunction translateTypeAnnotation(hasteModuleName, flowTypeAnnotation, types, aliasMap, enumMap, tryParse, cxxOnly, parser) {\n  var _resolveTypeAnnotatio = resolveTypeAnnotation(flowTypeAnnotation, types),\n    nullable = _resolveTypeAnnotatio.nullable,\n    typeAnnotation = _resolveTypeAnnotatio.typeAnnotation,\n    typeResolutionStatus = _resolveTypeAnnotatio.typeResolutionStatus;\n  switch (typeAnnotation.type) {\n    case 'GenericTypeAnnotation':\n      {\n        switch (typeAnnotation.id.name) {\n          case 'RootTag':\n            {\n              return emitRootTag(nullable);\n            }\n          case 'Promise':\n            {\n              return emitPromise(hasteModuleName, typeAnnotation, parser, nullable, types, aliasMap, enumMap, tryParse, cxxOnly, translateTypeAnnotation);\n            }\n          case 'Array':\n          case '$ReadOnlyArray':\n            {\n              return emitArrayType(hasteModuleName, typeAnnotation, parser, types, aliasMap, enumMap, cxxOnly, nullable, translateTypeAnnotation);\n            }\n          case '$ReadOnly':\n            {\n              assertGenericTypeAnnotationHasExactlyOneTypeParameter(hasteModuleName, typeAnnotation, parser);\n              var _unwrapNullable = unwrapNullable(translateTypeAnnotation(hasteModuleName, typeAnnotation.typeParameters.params[0], types, aliasMap, enumMap, tryParse, cxxOnly, parser)),\n                _unwrapNullable2 = _slicedToArray(_unwrapNullable, 2),\n                paramType = _unwrapNullable2[0],\n                isParamNullable = _unwrapNullable2[1];\n              return wrapNullable(nullable || isParamNullable, paramType);\n            }\n          default:\n            {\n              var commonType = emitCommonTypes(hasteModuleName, types, typeAnnotation, aliasMap, enumMap, tryParse, cxxOnly, nullable, parser);\n              if (!commonType) {\n                throw new UnsupportedGenericParserError(hasteModuleName, typeAnnotation, parser);\n              }\n              return commonType;\n            }\n        }\n      }\n    case 'ObjectTypeAnnotation':\n      {\n        if (typeAnnotation.indexers) {\n          var indexers = typeAnnotation.indexers.filter(function (member) {\n            return member.type === 'ObjectTypeIndexer';\n          });\n          if (indexers.length > 0) {\n            var propertyType = indexers[0].value;\n            translateTypeAnnotation(hasteModuleName, propertyType, types, aliasMap, enumMap, tryParse, cxxOnly, parser);\n            return emitGenericObject(nullable);\n          }\n        }\n        var objectTypeAnnotation = {\n          type: 'ObjectTypeAnnotation',\n          properties: [].concat(_toConsumableArray(typeAnnotation.properties), _toConsumableArray(typeAnnotation.indexers)).map(function (property) {\n            return tryParse(function () {\n              return parseObjectProperty(property, hasteModuleName, types, aliasMap, enumMap, tryParse, cxxOnly, nullable, translateTypeAnnotation, parser);\n            });\n          }).filter(Boolean)\n        };\n        return typeAliasResolution(typeResolutionStatus, objectTypeAnnotation, aliasMap, nullable);\n      }\n    case 'BooleanTypeAnnotation':\n      {\n        return emitBoolean(nullable);\n      }\n    case 'NumberTypeAnnotation':\n      {\n        return emitNumber(nullable);\n      }\n    case 'VoidTypeAnnotation':\n      {\n        return emitVoid(nullable);\n      }\n    case 'StringTypeAnnotation':\n      {\n        return emitString(nullable);\n      }\n    case 'FunctionTypeAnnotation':\n      {\n        return emitFunction(nullable, hasteModuleName, typeAnnotation, types, aliasMap, enumMap, tryParse, cxxOnly, translateTypeAnnotation, parser);\n      }\n    case 'UnionTypeAnnotation':\n      {\n        return emitUnion(nullable, hasteModuleName, typeAnnotation, parser);\n      }\n    case 'StringLiteralTypeAnnotation':\n      {\n        return wrapNullable(nullable, {\n          type: 'UnionTypeAnnotation',\n          memberType: 'StringTypeAnnotation'\n        });\n      }\n    case 'MixedTypeAnnotation':\n      {\n        if (cxxOnly) {\n          return emitMixed(nullable);\n        } else {\n          return emitGenericObject(nullable);\n        }\n      }\n    case 'EnumStringBody':\n    case 'EnumNumberBody':\n      {\n        return typeEnumResolution(typeAnnotation, typeResolutionStatus, nullable, hasteModuleName, enumMap, parser);\n      }\n    default:\n      {\n        throw new UnsupportedTypeAnnotationParserError(hasteModuleName, typeAnnotation, parser.language());\n      }\n  }\n}\nmodule.exports = {\n  flowTranslateTypeAnnotation: translateTypeAnnotation\n};","map":{"version":3,"names":["_toConsumableArray","require","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","len","length","arr2","_i","Symbol","iterator","_s","_e","_x","_r","_arr","_n","_d","next","done","push","value","err","return","isArray","_require","resolveTypeAnnotation","_require2","unwrapNullable","wrapNullable","assertGenericTypeAnnotationHasExactlyOneTypeParameter","parseObjectProperty","_require3","emitArrayType","emitBoolean","emitFunction","emitNumber","emitGenericObject","emitPromise","emitRootTag","emitVoid","emitString","emitMixed","emitUnion","emitCommonTypes","typeAliasResolution","typeEnumResolution","_require4","UnsupportedTypeAnnotationParserError","UnsupportedGenericParserError","translateTypeAnnotation","hasteModuleName","flowTypeAnnotation","types","aliasMap","enumMap","tryParse","cxxOnly","parser","_resolveTypeAnnotatio","nullable","typeAnnotation","typeResolutionStatus","type","id","_unwrapNullable","typeParameters","params","_unwrapNullable2","paramType","isParamNullable","commonType","indexers","filter","member","propertyType","objectTypeAnnotation","properties","concat","map","property","Boolean","memberType","language","module","exports","flowTranslateTypeAnnotation"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native/codegen/lib/parsers/flow/modules/index.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\n'use strict';\n\nfunction _slicedToArray(arr, i) {\n  return (\n    _arrayWithHoles(arr) ||\n    _iterableToArrayLimit(arr, i) ||\n    _unsupportedIterableToArray(arr, i) ||\n    _nonIterableRest()\n  );\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\n    'Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',\n  );\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === 'string') return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === 'Object' && o.constructor) n = o.constructor.name;\n  if (n === 'Map' || n === 'Set') return Array.from(o);\n  if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n    return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i =\n    null == arr\n      ? null\n      : ('undefined' != typeof Symbol && arr[Symbol.iterator]) ||\n        arr['@@iterator'];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (((_x = (_i = _i.call(arr)).next), 0 === i)) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else\n        for (\n          ;\n          !(_n = (_s = _x.call(_i)).done) &&\n          (_arr.push(_s.value), _arr.length !== i);\n          _n = !0\n        );\n    } catch (err) {\n      (_d = !0), (_e = err);\n    } finally {\n      try {\n        if (!_n && null != _i.return && ((_r = _i.return()), Object(_r) !== _r))\n          return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nconst _require = require('../utils'),\n  resolveTypeAnnotation = _require.resolveTypeAnnotation;\nconst _require2 = require('../../parsers-commons'),\n  unwrapNullable = _require2.unwrapNullable,\n  wrapNullable = _require2.wrapNullable,\n  assertGenericTypeAnnotationHasExactlyOneTypeParameter =\n    _require2.assertGenericTypeAnnotationHasExactlyOneTypeParameter,\n  parseObjectProperty = _require2.parseObjectProperty;\nconst _require3 = require('../../parsers-primitives'),\n  emitArrayType = _require3.emitArrayType,\n  emitBoolean = _require3.emitBoolean,\n  emitFunction = _require3.emitFunction,\n  emitNumber = _require3.emitNumber,\n  emitGenericObject = _require3.emitGenericObject,\n  emitPromise = _require3.emitPromise,\n  emitRootTag = _require3.emitRootTag,\n  emitVoid = _require3.emitVoid,\n  emitString = _require3.emitString,\n  emitMixed = _require3.emitMixed,\n  emitUnion = _require3.emitUnion,\n  emitCommonTypes = _require3.emitCommonTypes,\n  typeAliasResolution = _require3.typeAliasResolution,\n  typeEnumResolution = _require3.typeEnumResolution;\nconst _require4 = require('../../errors'),\n  UnsupportedTypeAnnotationParserError =\n    _require4.UnsupportedTypeAnnotationParserError,\n  UnsupportedGenericParserError = _require4.UnsupportedGenericParserError;\nfunction translateTypeAnnotation(\n  hasteModuleName,\n  /**\n   * TODO(T71778680): Flow-type this node.\n   */\n  flowTypeAnnotation,\n  types,\n  aliasMap,\n  enumMap,\n  tryParse,\n  cxxOnly,\n  parser,\n) {\n  const _resolveTypeAnnotatio = resolveTypeAnnotation(\n      flowTypeAnnotation,\n      types,\n    ),\n    nullable = _resolveTypeAnnotatio.nullable,\n    typeAnnotation = _resolveTypeAnnotatio.typeAnnotation,\n    typeResolutionStatus = _resolveTypeAnnotatio.typeResolutionStatus;\n  switch (typeAnnotation.type) {\n    case 'GenericTypeAnnotation': {\n      switch (typeAnnotation.id.name) {\n        case 'RootTag': {\n          return emitRootTag(nullable);\n        }\n        case 'Promise': {\n          return emitPromise(\n            hasteModuleName,\n            typeAnnotation,\n            parser,\n            nullable,\n            types,\n            aliasMap,\n            enumMap,\n            tryParse,\n            cxxOnly,\n            translateTypeAnnotation,\n          );\n        }\n        case 'Array':\n        case '$ReadOnlyArray': {\n          return emitArrayType(\n            hasteModuleName,\n            typeAnnotation,\n            parser,\n            types,\n            aliasMap,\n            enumMap,\n            cxxOnly,\n            nullable,\n            translateTypeAnnotation,\n          );\n        }\n        case '$ReadOnly': {\n          assertGenericTypeAnnotationHasExactlyOneTypeParameter(\n            hasteModuleName,\n            typeAnnotation,\n            parser,\n          );\n          const _unwrapNullable = unwrapNullable(\n              translateTypeAnnotation(\n                hasteModuleName,\n                typeAnnotation.typeParameters.params[0],\n                types,\n                aliasMap,\n                enumMap,\n                tryParse,\n                cxxOnly,\n                parser,\n              ),\n            ),\n            _unwrapNullable2 = _slicedToArray(_unwrapNullable, 2),\n            paramType = _unwrapNullable2[0],\n            isParamNullable = _unwrapNullable2[1];\n          return wrapNullable(nullable || isParamNullable, paramType);\n        }\n        default: {\n          const commonType = emitCommonTypes(\n            hasteModuleName,\n            types,\n            typeAnnotation,\n            aliasMap,\n            enumMap,\n            tryParse,\n            cxxOnly,\n            nullable,\n            parser,\n          );\n          if (!commonType) {\n            throw new UnsupportedGenericParserError(\n              hasteModuleName,\n              typeAnnotation,\n              parser,\n            );\n          }\n          return commonType;\n        }\n      }\n    }\n    case 'ObjectTypeAnnotation': {\n      // if there is any indexer, then it is a dictionary\n      if (typeAnnotation.indexers) {\n        const indexers = typeAnnotation.indexers.filter(\n          member => member.type === 'ObjectTypeIndexer',\n        );\n        if (indexers.length > 0) {\n          // check the property type to prevent developers from using unsupported types\n          // the return value from `translateTypeAnnotation` is unused\n          const propertyType = indexers[0].value;\n          translateTypeAnnotation(\n            hasteModuleName,\n            propertyType,\n            types,\n            aliasMap,\n            enumMap,\n            tryParse,\n            cxxOnly,\n            parser,\n          );\n          // no need to do further checking\n          return emitGenericObject(nullable);\n        }\n      }\n      const objectTypeAnnotation = {\n        type: 'ObjectTypeAnnotation',\n        // $FlowFixMe[missing-type-arg]\n        properties: [...typeAnnotation.properties, ...typeAnnotation.indexers]\n          .map(property => {\n            return tryParse(() => {\n              return parseObjectProperty(\n                property,\n                hasteModuleName,\n                types,\n                aliasMap,\n                enumMap,\n                tryParse,\n                cxxOnly,\n                nullable,\n                translateTypeAnnotation,\n                parser,\n              );\n            });\n          })\n          .filter(Boolean),\n      };\n      return typeAliasResolution(\n        typeResolutionStatus,\n        objectTypeAnnotation,\n        aliasMap,\n        nullable,\n      );\n    }\n    case 'BooleanTypeAnnotation': {\n      return emitBoolean(nullable);\n    }\n    case 'NumberTypeAnnotation': {\n      return emitNumber(nullable);\n    }\n    case 'VoidTypeAnnotation': {\n      return emitVoid(nullable);\n    }\n    case 'StringTypeAnnotation': {\n      return emitString(nullable);\n    }\n    case 'FunctionTypeAnnotation': {\n      return emitFunction(\n        nullable,\n        hasteModuleName,\n        typeAnnotation,\n        types,\n        aliasMap,\n        enumMap,\n        tryParse,\n        cxxOnly,\n        translateTypeAnnotation,\n        parser,\n      );\n    }\n    case 'UnionTypeAnnotation': {\n      return emitUnion(nullable, hasteModuleName, typeAnnotation, parser);\n    }\n    case 'StringLiteralTypeAnnotation': {\n      // 'a' is a special case for 'a' | 'b' but the type name is different\n      return wrapNullable(nullable, {\n        type: 'UnionTypeAnnotation',\n        memberType: 'StringTypeAnnotation',\n      });\n    }\n    case 'MixedTypeAnnotation': {\n      if (cxxOnly) {\n        return emitMixed(nullable);\n      } else {\n        return emitGenericObject(nullable);\n      }\n    }\n    case 'EnumStringBody':\n    case 'EnumNumberBody': {\n      return typeEnumResolution(\n        typeAnnotation,\n        typeResolutionStatus,\n        nullable,\n        hasteModuleName,\n        enumMap,\n        parser,\n      );\n    }\n    default: {\n      throw new UnsupportedTypeAnnotationParserError(\n        hasteModuleName,\n        typeAnnotation,\n        parser.language(),\n      );\n    }\n  }\n}\nmodule.exports = {\n  flowTranslateTypeAnnotation: translateTypeAnnotation,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}