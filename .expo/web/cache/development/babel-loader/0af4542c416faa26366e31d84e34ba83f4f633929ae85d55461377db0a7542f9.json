{"ast":null,"code":"","map":{"version":3,"names":[],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native-community/cli-doctor/node_modules/yaml/dist/parse/lexer.d.ts"],"sourcesContent":["/**\n * Splits an input string into lexical tokens, i.e. smaller strings that are\n * easily identifiable by `tokens.tokenType()`.\n *\n * Lexing starts always in a \"stream\" context. Incomplete input may be buffered\n * until a complete token can be emitted.\n *\n * In addition to slices of the original input, the following control characters\n * may also be emitted:\n *\n * - `\\x02` (Start of Text): A document starts with the next token\n * - `\\x18` (Cancel): Unexpected end of flow-mode (indicates an error)\n * - `\\x1f` (Unit Separator): Next token is a scalar value\n * - `\\u{FEFF}` (Byte order mark): Emitted separately outside documents\n */\nexport declare class Lexer {\n    /**\n     * Flag indicating whether the end of the current buffer marks the end of\n     * all input\n     */\n    private atEnd;\n    /**\n     * Explicit indent set in block scalar header, as an offset from the current\n     * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not\n     * explicitly set.\n     */\n    private blockScalarIndent;\n    /**\n     * Block scalars that include a + (keep) chomping indicator in their header\n     * include trailing empty lines, which are otherwise excluded from the\n     * scalar's contents.\n     */\n    private blockScalarKeep;\n    /** Current input */\n    private buffer;\n    /**\n     * Flag noting whether the map value indicator : can immediately follow this\n     * node within a flow context.\n     */\n    private flowKey;\n    /** Count of surrounding flow collection levels. */\n    private flowLevel;\n    /**\n     * Minimum level of indentation required for next lines to be parsed as a\n     * part of the current scalar value.\n     */\n    private indentNext;\n    /** Indentation level of the current line. */\n    private indentValue;\n    /** Position of the next \\n character. */\n    private lineEndPos;\n    /** Stores the state of the lexer if reaching the end of incpomplete input */\n    private next;\n    /** A pointer to `buffer`; the current position of the lexer. */\n    private pos;\n    /**\n     * Generate YAML tokens from the `source` string. If `incomplete`,\n     * a part of the last line may be left as a buffer for the next call.\n     *\n     * @returns A generator of lexical tokens\n     */\n    lex(source: string, incomplete?: boolean): Generator<string, void, unknown>;\n    private atLineEnd;\n    private charAt;\n    private continueScalar;\n    private getLine;\n    private hasChars;\n    private setNext;\n    private peek;\n    private parseNext;\n    private parseStream;\n    private parseLineStart;\n    private parseBlockStart;\n    private parseDocument;\n    private parseFlowCollection;\n    private parseQuotedScalar;\n    private parseBlockScalarHeader;\n    private parseBlockScalar;\n    private parsePlainScalar;\n    private pushCount;\n    private pushToIndex;\n    private pushIndicators;\n    private pushTag;\n    private pushNewline;\n    private pushSpaces;\n    private pushUntil;\n}\n"],"mappings":""},"metadata":{},"sourceType":"script","externalDependencies":[]}