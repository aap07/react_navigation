{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { warn } from \"../log.js\";\nimport { createStringifyContext } from \"../stringify/stringify.js\";\nimport { isAlias, isSeq, isScalar, isMap, isNode } from \"./identity.js\";\nimport { Scalar } from \"./Scalar.js\";\nimport { toJS } from \"./toJS.js\";\nvar MERGE_KEY = '<<';\nfunction addPairToJSMap(ctx, map, _ref) {\n  var key = _ref.key,\n    value = _ref.value;\n  if (ctx != null && ctx.doc.schema.merge && isMergeKey(key)) {\n    value = isAlias(value) ? value.resolve(ctx.doc) : value;\n    if (isSeq(value)) for (var it of value.items) mergeToJSMap(ctx, map, it);else if (Array.isArray(value)) for (var _it of value) mergeToJSMap(ctx, map, _it);else mergeToJSMap(ctx, map, value);\n  } else {\n    var jsKey = toJS(key, '', ctx);\n    if (map instanceof Map) {\n      map.set(jsKey, toJS(value, jsKey, ctx));\n    } else if (map instanceof Set) {\n      map.add(jsKey);\n    } else {\n      var stringKey = stringifyKey(key, jsKey, ctx);\n      var jsValue = toJS(value, stringKey, ctx);\n      if (stringKey in map) Object.defineProperty(map, stringKey, {\n        value: jsValue,\n        writable: true,\n        enumerable: true,\n        configurable: true\n      });else map[stringKey] = jsValue;\n    }\n  }\n  return map;\n}\nvar isMergeKey = function isMergeKey(key) {\n  return key === MERGE_KEY || isScalar(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.PLAIN);\n};\nfunction mergeToJSMap(ctx, map, value) {\n  var source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;\n  if (!isMap(source)) throw new Error('Merge sources must be maps or map aliases');\n  var srcMap = source.toJSON(null, ctx, Map);\n  for (var _ref2 of srcMap) {\n    var _ref3 = _slicedToArray(_ref2, 2);\n    var key = _ref3[0];\n    var _value = _ref3[1];\n    if (map instanceof Map) {\n      if (!map.has(key)) map.set(key, _value);\n    } else if (map instanceof Set) {\n      map.add(key);\n    } else if (!Object.prototype.hasOwnProperty.call(map, key)) {\n      Object.defineProperty(map, key, {\n        value: _value,\n        writable: true,\n        enumerable: true,\n        configurable: true\n      });\n    }\n  }\n  return map;\n}\nfunction stringifyKey(key, jsKey, ctx) {\n  if (jsKey === null) return '';\n  if (typeof jsKey !== 'object') return String(jsKey);\n  if (isNode(key) && ctx != null && ctx.doc) {\n    var strCtx = createStringifyContext(ctx.doc, {});\n    strCtx.anchors = new Set();\n    for (var node of ctx.anchors.keys()) strCtx.anchors.add(node.anchor);\n    strCtx.inFlow = true;\n    strCtx.inStringifyKey = true;\n    var strKey = key.toString(strCtx);\n    if (!ctx.mapKeyWarned) {\n      var jsonStr = JSON.stringify(strKey);\n      if (jsonStr.length > 40) jsonStr = jsonStr.substring(0, 36) + '...\"';\n      warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);\n      ctx.mapKeyWarned = true;\n    }\n    return strKey;\n  }\n  return JSON.stringify(jsKey);\n}\nexport { addPairToJSMap };","map":{"version":3,"names":["warn","createStringifyContext","isAlias","isSeq","isScalar","isMap","isNode","Scalar","toJS","MERGE_KEY","addPairToJSMap","ctx","map","_ref","key","value","doc","schema","merge","isMergeKey","resolve","it","items","mergeToJSMap","Array","isArray","jsKey","Map","set","Set","add","stringKey","stringifyKey","jsValue","Object","defineProperty","writable","enumerable","configurable","type","PLAIN","source","Error","srcMap","toJSON","_ref2","_ref3","_slicedToArray","has","prototype","hasOwnProperty","call","String","strCtx","anchors","node","keys","anchor","inFlow","inStringifyKey","strKey","toString","mapKeyWarned","jsonStr","JSON","stringify","length","substring","options","logLevel"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native-community/cli-doctor/node_modules/yaml/browser/dist/nodes/addPairToJSMap.js"],"sourcesContent":["import { warn } from '../log.js';\nimport { createStringifyContext } from '../stringify/stringify.js';\nimport { isAlias, isSeq, isScalar, isMap, isNode } from './identity.js';\nimport { Scalar } from './Scalar.js';\nimport { toJS } from './toJS.js';\n\nconst MERGE_KEY = '<<';\nfunction addPairToJSMap(ctx, map, { key, value }) {\n    if (ctx?.doc.schema.merge && isMergeKey(key)) {\n        value = isAlias(value) ? value.resolve(ctx.doc) : value;\n        if (isSeq(value))\n            for (const it of value.items)\n                mergeToJSMap(ctx, map, it);\n        else if (Array.isArray(value))\n            for (const it of value)\n                mergeToJSMap(ctx, map, it);\n        else\n            mergeToJSMap(ctx, map, value);\n    }\n    else {\n        const jsKey = toJS(key, '', ctx);\n        if (map instanceof Map) {\n            map.set(jsKey, toJS(value, jsKey, ctx));\n        }\n        else if (map instanceof Set) {\n            map.add(jsKey);\n        }\n        else {\n            const stringKey = stringifyKey(key, jsKey, ctx);\n            const jsValue = toJS(value, stringKey, ctx);\n            if (stringKey in map)\n                Object.defineProperty(map, stringKey, {\n                    value: jsValue,\n                    writable: true,\n                    enumerable: true,\n                    configurable: true\n                });\n            else\n                map[stringKey] = jsValue;\n        }\n    }\n    return map;\n}\nconst isMergeKey = (key) => key === MERGE_KEY ||\n    (isScalar(key) &&\n        key.value === MERGE_KEY &&\n        (!key.type || key.type === Scalar.PLAIN));\n// If the value associated with a merge key is a single mapping node, each of\n// its key/value pairs is inserted into the current mapping, unless the key\n// already exists in it. If the value associated with the merge key is a\n// sequence, then this sequence is expected to contain mapping nodes and each\n// of these nodes is merged in turn according to its order in the sequence.\n// Keys in mapping nodes earlier in the sequence override keys specified in\n// later mapping nodes. -- http://yaml.org/type/merge.html\nfunction mergeToJSMap(ctx, map, value) {\n    const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;\n    if (!isMap(source))\n        throw new Error('Merge sources must be maps or map aliases');\n    const srcMap = source.toJSON(null, ctx, Map);\n    for (const [key, value] of srcMap) {\n        if (map instanceof Map) {\n            if (!map.has(key))\n                map.set(key, value);\n        }\n        else if (map instanceof Set) {\n            map.add(key);\n        }\n        else if (!Object.prototype.hasOwnProperty.call(map, key)) {\n            Object.defineProperty(map, key, {\n                value,\n                writable: true,\n                enumerable: true,\n                configurable: true\n            });\n        }\n    }\n    return map;\n}\nfunction stringifyKey(key, jsKey, ctx) {\n    if (jsKey === null)\n        return '';\n    if (typeof jsKey !== 'object')\n        return String(jsKey);\n    if (isNode(key) && ctx?.doc) {\n        const strCtx = createStringifyContext(ctx.doc, {});\n        strCtx.anchors = new Set();\n        for (const node of ctx.anchors.keys())\n            strCtx.anchors.add(node.anchor);\n        strCtx.inFlow = true;\n        strCtx.inStringifyKey = true;\n        const strKey = key.toString(strCtx);\n        if (!ctx.mapKeyWarned) {\n            let jsonStr = JSON.stringify(strKey);\n            if (jsonStr.length > 40)\n                jsonStr = jsonStr.substring(0, 36) + '...\"';\n            warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);\n            ctx.mapKeyWarned = true;\n        }\n        return strKey;\n    }\n    return JSON.stringify(jsKey);\n}\n\nexport { addPairToJSMap };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}