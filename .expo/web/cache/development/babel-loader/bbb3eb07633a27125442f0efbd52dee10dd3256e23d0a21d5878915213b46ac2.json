{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.copyFilePathToPathAsync = copyFilePathToPathAsync;\nexports.removeFile = removeFile;\nfunction _fs() {\n  var data = _interopRequireDefault(require(\"fs\"));\n  _fs = function _fs() {\n    return data;\n  };\n  return data;\n}\nfunction _path() {\n  var data = _interopRequireDefault(require(\"path\"));\n  _path = function _path() {\n    return data;\n  };\n  return data;\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction copyFilePathToPathAsync(_x, _x2) {\n  return _copyFilePathToPathAsync.apply(this, arguments);\n}\nfunction _copyFilePathToPathAsync() {\n  _copyFilePathToPathAsync = _asyncToGenerator(function* (src, dest) {\n    var srcFile = yield _fs().default.promises.readFile(src);\n    yield _fs().default.promises.mkdir(_path().default.dirname(dest), {\n      recursive: true\n    });\n    yield _fs().default.promises.writeFile(dest, srcFile);\n  });\n  return _copyFilePathToPathAsync.apply(this, arguments);\n}\nfunction removeFile(filePath) {\n  try {\n    _fs().default.unlinkSync(filePath);\n    return true;\n  } catch (error) {\n    if (error.code === 'ENOENT') {\n      return false;\n    }\n    throw error;\n  }\n}","map":{"version":3,"names":["_fs","data","_interopRequireDefault","require","_path","obj","__esModule","default","copyFilePathToPathAsync","_x","_x2","_copyFilePathToPathAsync","apply","arguments","_asyncToGenerator","src","dest","srcFile","promises","readFile","mkdir","dirname","recursive","writeFile","removeFile","filePath","unlinkSync","error","code"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\config-plugins\\src\\utils\\fs.ts"],"sourcesContent":["import fs from 'fs';\nimport path from 'path';\n\n/** A basic function that copies a single file to another file location. */\nexport async function copyFilePathToPathAsync(src: string, dest: string): Promise<void> {\n  const srcFile = await fs.promises.readFile(src);\n  await fs.promises.mkdir(path.dirname(dest), { recursive: true });\n  await fs.promises.writeFile(dest, srcFile);\n}\n\n/** Remove a single file (not directory). Returns `true` if a file was actually deleted. */\nexport function removeFile(filePath: string): boolean {\n  try {\n    fs.unlinkSync(filePath);\n    return true;\n  } catch (error: any) {\n    // Skip if the remove did nothing.\n    if (error.code === 'ENOENT') {\n      return false;\n    }\n    throw error;\n  }\n}\n"],"mappings":";;;;;;;;AAAA,SAAAA,IAAA;EAAA,IAAAC,IAAA,GAAAC,sBAAA,CAAAC,OAAA;EAAAH,GAAA,YAAAA,IAAA;IAAA,OAAAC,IAAA;EAAA;EAAA,OAAAA,IAAA;AAAA;AACA,SAAAG,MAAA;EAAA,IAAAH,IAAA,GAAAC,sBAAA,CAAAC,OAAA;EAAAC,KAAA,YAAAA,MAAA;IAAA,OAAAH,IAAA;EAAA;EAAA,OAAAA,IAAA;AAAA;AAAwB,SAAAC,uBAAAG,GAAA;EAAA,OAAAA,GAAA,IAAAA,GAAA,CAAAC,UAAA,GAAAD,GAAA;IAAAE,OAAA,EAAAF;EAAA;AAAA;AAAA,SAGFG,uBAAuBA,CAAAC,EAAA,EAAAC,GAAA;EAAA,OAAAC,wBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAF,yBAAA;EAAAA,wBAAA,GAAAG,iBAAA,CAAtC,WAAuCC,GAAW,EAAEC,IAAY,EAAiB;IACtF,IAAMC,OAAO,SAASjB,GAAA,GAAAO,OAAE,CAACW,QAAQ,CAACC,QAAQ,CAACJ,GAAG,CAAC;IAC/C,MAAMf,GAAA,GAAAO,OAAE,CAACW,QAAQ,CAACE,KAAK,CAAChB,KAAA,GAAAG,OAAI,CAACc,OAAO,CAACL,IAAI,CAAC,EAAE;MAAEM,SAAS,EAAE;IAAK,CAAC,CAAC;IAChE,MAAMtB,GAAA,GAAAO,OAAE,CAACW,QAAQ,CAACK,SAAS,CAACP,IAAI,EAAEC,OAAO,CAAC;EAC5C;EAAA,OAAAN,wBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAGO,SAASW,UAAUA,CAACC,QAAgB,EAAW;EACpD,IAAI;IACFzB,GAAA,GAAAO,OAAE,CAACmB,UAAU,CAACD,QAAQ,CAAC;IACvB,OAAO,IAAI;EACb,CAAC,CAAC,OAAOE,KAAU,EAAE;IAEnB,IAAIA,KAAK,CAACC,IAAI,KAAK,QAAQ,EAAE;MAC3B,OAAO,KAAK;IACd;IACA,MAAMD,KAAK;EACb;AACF"},"metadata":{},"sourceType":"script","externalDependencies":[]}