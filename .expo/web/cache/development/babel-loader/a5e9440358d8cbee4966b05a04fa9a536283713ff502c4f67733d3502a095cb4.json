{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.installExitHooks = installExitHooks;\nvar _fn = require(\"./fn\");\nvar debug = require(\"debug\")(\"expo:utils:exit\");\nvar PRE_EXIT_SIGNALS = [\"SIGHUP\", \"SIGINT\", \"SIGTERM\", \"SIGBREAK\"];\nvar queue = [];\nvar unsubscribe = null;\nfunction installExitHooks(asyncExitHook) {\n  if (!queue.length) {\n    unsubscribe = attachMasterListener();\n  }\n  queue.push(asyncExitHook);\n  return function () {\n    var index = queue.indexOf(asyncExitHook);\n    if (index >= 0) {\n      queue.splice(index, 1);\n    }\n    if (!queue.length) {\n      unsubscribe == null ? void 0 : unsubscribe();\n    }\n  };\n}\nfunction createExitHook(signal) {\n  return (0, _fn).guardAsync(_asyncToGenerator(function* () {\n    debug(`pre-exit (signal: ${signal}, queue length: ${queue.length})`);\n    for (var _ref2 of Object.entries(queue)) {\n      var _ref3 = _slicedToArray(_ref2, 2);\n      var index = _ref3[0];\n      var hookAsync = _ref3[1];\n      try {\n        yield hookAsync(signal);\n      } catch (error) {\n        debug(`Error in exit hook: %O (queue: ${index})`, error);\n      }\n    }\n    var _exitCode;\n    debug(`post-exit (code: ${(_exitCode = process.exitCode) != null ? _exitCode : 0})`);\n    process.exit();\n  }));\n}\nfunction attachMasterListener() {\n  var hooks = [];\n  for (var signal1 of PRE_EXIT_SIGNALS) {\n    var hook = createExitHook(signal1);\n    hooks.push([signal1, hook]);\n    process.on(signal1, hook);\n  }\n  return function () {\n    for (var _ref4 of hooks) {\n      var _ref5 = _slicedToArray(_ref4, 2);\n      var signal = _ref5[0];\n      var _hook = _ref5[1];\n      process.removeListener(signal, _hook);\n    }\n  };\n}","map":{"version":3,"names":["_slicedToArray","require","_asyncToGenerator","installExitHooks","_fn","debug","PRE_EXIT_SIGNALS","queue","unsubscribe","asyncExitHook","length","attachMasterListener","push","index","indexOf","splice","createExitHook","signal","guardAsync","_ref2","Object","entries","_ref3","hookAsync","error","_exitCode","process","exitCode","exit","hooks","signal1","hook","on","_ref4","_ref5","removeListener"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\cli\\src\\utils\\exit.ts"],"sourcesContent":["import { guardAsync } from './fn';\n\nconst debug = require('debug')('expo:utils:exit') as typeof console.log;\n\ntype AsyncExitHook = (signal: NodeJS.Signals) => void | Promise<void>;\n\nconst PRE_EXIT_SIGNALS: NodeJS.Signals[] = ['SIGHUP', 'SIGINT', 'SIGTERM', 'SIGBREAK'];\n\n// We create a queue since Node.js throws an error if we try to append too many listeners:\n// (node:4405) MaxListenersExceededWarning: Possible EventEmitter memory leak detected. 11 SIGINT listeners added to [process]. Use emitter.setMaxListeners() to increase limit\nconst queue: AsyncExitHook[] = [];\n\nlet unsubscribe: (() => void) | null = null;\n\n/** Add functions that run before the process exits. Returns a function for removing the listeners. */\nexport function installExitHooks(asyncExitHook: AsyncExitHook): () => void {\n  // We need to instantiate the master listener the first time the queue is used.\n  if (!queue.length) {\n    // Track the master listener so we can remove it later.\n    unsubscribe = attachMasterListener();\n  }\n\n  queue.push(asyncExitHook);\n\n  return () => {\n    const index = queue.indexOf(asyncExitHook);\n    if (index >= 0) {\n      queue.splice(index, 1);\n    }\n    // Clean up the master listener if we don't need it anymore.\n    if (!queue.length) {\n      unsubscribe?.();\n    }\n  };\n}\n\n// Create a function that runs before the process exits and guards against running multiple times.\nfunction createExitHook(signal: NodeJS.Signals) {\n  return guardAsync(async () => {\n    debug(`pre-exit (signal: ${signal}, queue length: ${queue.length})`);\n\n    for (const [index, hookAsync] of Object.entries(queue)) {\n      try {\n        await hookAsync(signal);\n      } catch (error: any) {\n        debug(`Error in exit hook: %O (queue: ${index})`, error);\n      }\n    }\n\n    debug(`post-exit (code: ${process.exitCode ?? 0})`);\n\n    process.exit();\n  });\n}\n\nfunction attachMasterListener() {\n  const hooks: [NodeJS.Signals, () => any][] = [];\n  for (const signal of PRE_EXIT_SIGNALS) {\n    const hook = createExitHook(signal);\n    hooks.push([signal, hook]);\n    process.on(signal, hook);\n  }\n  return () => {\n    for (const [signal, hook] of hooks) {\n      process.removeListener(signal, hook);\n    }\n  };\n}\n"],"mappings":"AAAA;;AAAA,IAAAA,cAAA,GAAAC,OAAA;AAAA,IAAAC,iBAAA,GAAAD,OAAA;;;;QAegBE,gBAAgB,GAAhBA,gBAAgB;AAfL,IAAAC,GAAM,GAAAH,OAAA;AAEjC,IAAMI,KAAK,GAAGJ,OAAO,CAAC,OAAO,CAAC,CAAC,iBAAiB,CAAC;AAIjD,IAAMK,gBAAgB,GAAqB,CAAC,QAAQ,EAAE,QAAQ,EAAE,SAAS,EAAE,UAAU,CAAC;AAItF,IAAMC,KAAK,GAAoB,EAAE;AAEjC,IAAIC,WAAW,GAAwB,IAAI;AAGpC,SAASL,gBAAgBA,CAACM,aAA4B,EAAc;EAEzE,IAAI,CAACF,KAAK,CAACG,MAAM,EAAE;IAEjBF,WAAW,GAAGG,oBAAoB,EAAE;;EAGtCJ,KAAK,CAACK,IAAI,CAACH,aAAa,CAAC;EAEzB,OAAO,YAAM;IACX,IAAMI,KAAK,GAAGN,KAAK,CAACO,OAAO,CAACL,aAAa,CAAC;IAC1C,IAAII,KAAK,IAAI,CAAC,EAAE;MACdN,KAAK,CAACQ,MAAM,CAACF,KAAK,EAAE,CAAC,CAAC;;IAGxB,IAAI,CAACN,KAAK,CAACG,MAAM,EAAE;MACjBF,WAAW,QAAI,GAAf,MAAe,GAAfA,WAAW,EAAI;;GAElB;;AAIH,SAASQ,cAAcA,CAACC,MAAsB,EAAE;EAC9C,OAAO,IAAAb,GAAU,EAcfc,UAde,CAAAhB,iBAAA,CAAC,aAAY;IAC5BG,KAAK,CAAE,qBAAoBY,MAAO,mBAAkBV,KAAK,CAACG,MAAO,GAAE,CAAC;IAEpE,SAAAS,KAAA,IAAiCC,MAAM,CAACC,OAAO,CAACd,KAAK,CAAC,EAAE;MAAA,IAAAe,KAAA,GAAAtB,cAAA,CAAAmB,KAAA;MAAA,IAA5CN,KAAK,GAAAS,KAAA;MAAA,IAAEC,SAAS,GAAAD,KAAA;MAC1B,IAAI;QACF,MAAMC,SAAS,CAACN,MAAM,CAAC;OACxB,CAAC,OAAOO,KAAK,EAAO;QACnBnB,KAAK,CAAE,kCAAiCQ,KAAM,GAAE,EAAEW,KAAK,CAAC;;;QAIlCC,SAAgB;IAA1CpB,KAAK,CAAE,oBAAmB,CAAAoB,SAAgB,GAAhBC,OAAO,CAACC,QAAQ,YAAhBF,SAAgB,GAAI,CAAE,GAAE,CAAC;IAEnDC,OAAO,CAACE,IAAI,EAAE;GACf,EAAC;;AAGJ,SAASjB,oBAAoBA,CAAA,EAAG;EAC9B,IAAMkB,KAAK,GAAkC,EAAE;EAC/C,KAAK,IAAMC,OAAM,IAAIxB,gBAAgB,EAAE;IACrC,IAAMyB,IAAI,GAAGf,cAAc,CAACc,OAAM,CAAC;IACnCD,KAAK,CAACjB,IAAI,CAAC,CAACkB,OAAM,EAAEC,IAAI,CAAC,CAAC;IAC1BL,OAAO,CAACM,EAAE,CAACF,OAAM,EAAEC,IAAI,CAAC;;EAE1B,OAAO,YAAM;IACX,SAAAE,KAAA,IAA6BJ,KAAK,EAAE;MAAA,IAAAK,KAAA,GAAAlC,cAAA,CAAAiC,KAAA;MAAA,IAAxBhB,MAAM,GAAAiB,KAAA;MAAA,IAAEH,KAAI,GAAAG,KAAA;MACtBR,OAAO,CAACS,cAAc,CAAClB,MAAM,EAAEc,KAAI,CAAC;;GAEvC"},"metadata":{},"sourceType":"script","externalDependencies":[]}