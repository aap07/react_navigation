{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchTsConfigPathAlias = matchTsConfigPathAlias;\nvar asterisk = 42;\nfunction hasZeroOrOneAsteriskCharacter(str) {\n  var seenAsterisk = false;\n  for (var i = 0; i < str.length; i++) {\n    if (str.charCodeAt(i) === asterisk) {\n      if (!seenAsterisk) {\n        seenAsterisk = true;\n      } else {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nfunction tryParsePattern(pattern) {\n  var indexOfStar = pattern.indexOf(\"*\");\n  return indexOfStar === -1 ? undefined : {\n    prefix: pattern.slice(0, indexOfStar),\n    suffix: pattern.slice(indexOfStar + 1)\n  };\n}\nfunction isPatternMatch(_ref, candidate) {\n  var prefix = _ref.prefix,\n    suffix = _ref.suffix;\n  return candidate.length >= prefix.length + suffix.length && candidate.startsWith(prefix) && candidate.endsWith(suffix);\n}\nfunction findBestPatternMatch(values, getPattern, candidate) {\n  var matchedValue;\n  var longestMatchPrefixLength = -1;\n  for (var v of values) {\n    var pattern = getPattern(v);\n    if (isPatternMatch(pattern, candidate) && pattern.prefix.length > longestMatchPrefixLength) {\n      longestMatchPrefixLength = pattern.prefix.length;\n      matchedValue = v;\n    }\n  }\n  return matchedValue;\n}\nfunction matchPatternOrExact(patternStrings, candidate) {\n  var patterns = [];\n  for (var patternString of patternStrings) {\n    if (!hasZeroOrOneAsteriskCharacter(patternString)) continue;\n    var pattern = tryParsePattern(patternString);\n    if (pattern) {\n      patterns.push(pattern);\n    } else if (patternString === candidate) {\n      return patternString;\n    }\n  }\n  return findBestPatternMatch(patterns, function (_) {\n    return _;\n  }, candidate);\n}\nfunction matchedText(pattern, candidate) {\n  return candidate.substring(pattern.prefix.length, candidate.length - pattern.suffix.length);\n}\nfunction getStar(matchedPattern, moduleName) {\n  return typeof matchedPattern === \"string\" ? undefined : matchedText(matchedPattern, moduleName);\n}\nfunction matchTsConfigPathAlias(pathsKeys, moduleName) {\n  var matchedPattern = matchPatternOrExact(pathsKeys, moduleName);\n  if (!matchedPattern) {\n    return null;\n  }\n  return {\n    star: getStar(matchedPattern, moduleName),\n    text: typeof matchedPattern === \"string\" ? matchedPattern : `${matchedPattern.prefix}*${matchedPattern.suffix}`\n  };\n}","map":{"version":3,"names":["matchTsConfigPathAlias","asterisk","hasZeroOrOneAsteriskCharacter","str","seenAsterisk","i","length","charCodeAt","tryParsePattern","pattern","indexOfStar","indexOf","undefined","prefix","slice","suffix","isPatternMatch","_ref","candidate","startsWith","endsWith","findBestPatternMatch","values","getPattern","matchedValue","longestMatchPrefixLength","v","matchPatternOrExact","patternStrings","patterns","patternString","push","_","matchedText","substring","getStar","matchedPattern","moduleName","pathsKeys","star","text"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\cli\\src\\utils\\tsconfig\\matchTsConfigPathAlias.ts"],"sourcesContent":["// From TypeScript: https://github.com/microsoft/TypeScript/blob/5b1897969769449217237aecbe364f823096c63e/src/compiler/core.ts\n// License: https://github.com/microsoft/TypeScript/blob/214df64/LICENSE.txt\n\nexport interface Pattern {\n  prefix: string;\n  suffix: string;\n}\n\nconst asterisk = 0x2a;\n\nfunction hasZeroOrOneAsteriskCharacter(str: string): boolean {\n  let seenAsterisk = false;\n  for (let i = 0; i < str.length; i++) {\n    if (str.charCodeAt(i) === asterisk) {\n      if (!seenAsterisk) {\n        seenAsterisk = true;\n      } else {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nfunction tryParsePattern(pattern: string): Pattern | undefined {\n  // This should be verified outside of here and a proper error thrown.\n  const indexOfStar = pattern.indexOf('*');\n  return indexOfStar === -1\n    ? undefined\n    : {\n        prefix: pattern.slice(0, indexOfStar),\n        suffix: pattern.slice(indexOfStar + 1),\n      };\n}\n\nfunction isPatternMatch({ prefix, suffix }: Pattern, candidate: string) {\n  return (\n    candidate.length >= prefix.length + suffix.length &&\n    candidate.startsWith(prefix) &&\n    candidate.endsWith(suffix)\n  );\n}\n\n/**\n * Return the object corresponding to the best pattern to match `candidate`.\n *\n * @internal\n */\nfunction findBestPatternMatch<T>(\n  values: readonly T[],\n  getPattern: (value: T) => Pattern,\n  candidate: string\n): T | undefined {\n  let matchedValue: T | undefined;\n  // use length of prefix as betterness criteria\n  let longestMatchPrefixLength = -1;\n\n  for (const v of values) {\n    const pattern = getPattern(v);\n    if (isPatternMatch(pattern, candidate) && pattern.prefix.length > longestMatchPrefixLength) {\n      longestMatchPrefixLength = pattern.prefix.length;\n      matchedValue = v;\n    }\n  }\n\n  return matchedValue;\n}\n\n/**\n * patternStrings contains both pattern strings (containing \"*\") and regular strings.\n * Return an exact match if possible, or a pattern match, or undefined.\n * (These are verified by verifyCompilerOptions to have 0 or 1 \"*\" characters.)\n */\nfunction matchPatternOrExact(\n  patternStrings: readonly string[],\n  candidate: string\n): string | Pattern | undefined {\n  const patterns: Pattern[] = [];\n  for (const patternString of patternStrings) {\n    if (!hasZeroOrOneAsteriskCharacter(patternString)) continue;\n    const pattern = tryParsePattern(patternString);\n    if (pattern) {\n      patterns.push(pattern);\n    } else if (patternString === candidate) {\n      // pattern was matched as is - no need to search further\n      return patternString;\n    }\n  }\n\n  return findBestPatternMatch(patterns, (_) => _, candidate);\n}\n\n/**\n * Given that candidate matches pattern, returns the text matching the '*'.\n * E.g.: matchedText(tryParsePattern(\"foo*baz\"), \"foobarbaz\") === \"bar\"\n */\nfunction matchedText(pattern: Pattern, candidate: string): string {\n  return candidate.substring(pattern.prefix.length, candidate.length - pattern.suffix.length);\n}\n\nfunction getStar(matchedPattern: string | Pattern, moduleName: string) {\n  return typeof matchedPattern === 'string' ? undefined : matchedText(matchedPattern, moduleName);\n}\n\nexport function matchTsConfigPathAlias(pathsKeys: string[], moduleName: string) {\n  // If the module name does not match any of the patterns in `paths` we hand off resolving to webpack\n  const matchedPattern = matchPatternOrExact(pathsKeys, moduleName);\n  if (!matchedPattern) {\n    return null;\n  }\n\n  return {\n    star: getStar(matchedPattern, moduleName),\n    text:\n      typeof matchedPattern === 'string'\n        ? matchedPattern\n        : `${matchedPattern.prefix}*${matchedPattern.suffix}`,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}