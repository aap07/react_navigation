{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nvar _slicedToArray2 = require(\"@babel/runtime/helpers/slicedToArray\");\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError('Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.');\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === 'string') return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === 'Object' && o.constructor) n = o.constructor.name;\n  if (n === 'Map' || n === 'Set') return Array.from(o);\n  if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : 'undefined' != typeof Symbol && arr[Symbol.iterator] || arr['@@iterator'];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nvar _require = require(\"../Utils\"),\n  getEnumName = _require.getEnumName,\n  toSafeCppString = _require.toSafeCppString;\nvar _require2 = require(\"./Utils\"),\n  createAliasResolver = _require2.createAliasResolver,\n  getModules = _require2.getModules,\n  getAreEnumMembersInteger = _require2.getAreEnumMembersInteger;\nvar _require3 = require(\"../Utils\"),\n  indent = _require3.indent;\nvar _require4 = require(\"../../parsers/parsers-commons\"),\n  unwrapNullable = _require4.unwrapNullable;\nvar ModuleClassDeclarationTemplate = function ModuleClassDeclarationTemplate(_ref3) {\n  var hasteModuleName = _ref3.hasteModuleName,\n    moduleProperties = _ref3.moduleProperties,\n    structs = _ref3.structs,\n    enums = _ref3.enums;\n  return `${enums}\n  ${structs}class JSI_EXPORT ${hasteModuleName}CxxSpecJSI : public TurboModule {\nprotected:\n  ${hasteModuleName}CxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);\n\npublic:\n  ${indent(moduleProperties.join('\\n'), 2)}\n\n};`;\n};\nvar ModuleSpecClassDeclarationTemplate = function ModuleSpecClassDeclarationTemplate(_ref4) {\n  var hasteModuleName = _ref4.hasteModuleName,\n    moduleName = _ref4.moduleName,\n    moduleProperties = _ref4.moduleProperties;\n  return `template <typename T>\nclass JSI_EXPORT ${hasteModuleName}CxxSpec : public TurboModule {\npublic:\n  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {\n    return delegate_.get(rt, propName);\n  }\n\nprotected:\n  ${hasteModuleName}CxxSpec(std::shared_ptr<CallInvoker> jsInvoker)\n    : TurboModule(\"${moduleName}\", jsInvoker),\n      delegate_(static_cast<T*>(this), jsInvoker) {}\n\nprivate:\n  class Delegate : public ${hasteModuleName}CxxSpecJSI {\n  public:\n    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :\n      ${hasteModuleName}CxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}\n\n    ${indent(moduleProperties.join('\\n'), 4)}\n\n  private:\n    T *instance_;\n  };\n\n  Delegate delegate_;\n};`;\n};\nvar FileTemplate = function FileTemplate(_ref5) {\n  var modules = _ref5.modules;\n  return `/**\n * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).\n *\n * Do not edit this file as changes may cause incorrect behavior and will be lost\n * once the code is regenerated.\n *\n * ${'@'}generated by codegen project: GenerateModuleH.js\n */\n\n#pragma once\n\n#include <ReactCommon/TurboModule.h>\n#include <react/bridging/Bridging.h>\n\nnamespace facebook {\nnamespace react {\n\n${modules.join('\\n\\n')}\n\n} // namespace react\n} // namespace facebook\n`;\n};\nfunction translatePrimitiveJSTypeToCpp(moduleName, nullableTypeAnnotation, optional, createErrorMessage, resolveAlias, enumMap) {\n  var _unwrapNullable = unwrapNullable(nullableTypeAnnotation),\n    _unwrapNullable2 = _slicedToArray(_unwrapNullable, 2),\n    typeAnnotation = _unwrapNullable2[0],\n    nullable = _unwrapNullable2[1];\n  var isRequired = !optional && !nullable;\n  var realTypeAnnotation = typeAnnotation;\n  if (realTypeAnnotation.type === 'TypeAliasTypeAnnotation') {\n    realTypeAnnotation = resolveAlias(realTypeAnnotation.name);\n  }\n  function wrap(type) {\n    return isRequired ? type : `std::optional<${type}>`;\n  }\n  switch (realTypeAnnotation.type) {\n    case 'ReservedTypeAnnotation':\n      switch (realTypeAnnotation.name) {\n        case 'RootTag':\n          return wrap('double');\n        default:\n          realTypeAnnotation.name;\n          throw new Error(createErrorMessage(realTypeAnnotation.name));\n      }\n    case 'VoidTypeAnnotation':\n      return 'void';\n    case 'StringTypeAnnotation':\n      return wrap('jsi::String');\n    case 'NumberTypeAnnotation':\n      return wrap('double');\n    case 'DoubleTypeAnnotation':\n      return wrap('double');\n    case 'FloatTypeAnnotation':\n      return wrap('double');\n    case 'Int32TypeAnnotation':\n      return wrap('int');\n    case 'BooleanTypeAnnotation':\n      return wrap('bool');\n    case 'EnumDeclaration':\n      switch (realTypeAnnotation.memberType) {\n        case 'NumberTypeAnnotation':\n          return getAreEnumMembersInteger(enumMap[realTypeAnnotation.name].members) ? wrap('int') : wrap('double');\n        case 'StringTypeAnnotation':\n          return wrap('jsi::String');\n        default:\n          throw new Error(createErrorMessage(realTypeAnnotation.type));\n      }\n    case 'GenericObjectTypeAnnotation':\n      return wrap('jsi::Object');\n    case 'UnionTypeAnnotation':\n      switch (typeAnnotation.memberType) {\n        case 'NumberTypeAnnotation':\n          return wrap('double');\n        case 'ObjectTypeAnnotation':\n          return wrap('jsi::Object');\n        case 'StringTypeAnnotation':\n          return wrap('jsi::String');\n        default:\n          throw new Error(createErrorMessage(realTypeAnnotation.type));\n      }\n    case 'ObjectTypeAnnotation':\n      return wrap('jsi::Object');\n    case 'ArrayTypeAnnotation':\n      return wrap('jsi::Array');\n    case 'FunctionTypeAnnotation':\n      return wrap('jsi::Function');\n    case 'PromiseTypeAnnotation':\n      return wrap('jsi::Value');\n    case 'MixedTypeAnnotation':\n      return wrap('jsi::Value');\n    default:\n      realTypeAnnotation.type;\n      throw new Error(createErrorMessage(realTypeAnnotation.type));\n  }\n}\nfunction createStructsString(moduleName, aliasMap, resolveAlias, enumMap) {\n  return Object.keys(aliasMap).map(function (alias) {\n    var value = aliasMap[alias];\n    if (value.properties.length === 0) {\n      return '';\n    }\n    var structName = `${moduleName}Base${alias}`;\n    var templateParameterWithTypename = value.properties.map(function (v, i) {\n      return 'typename P' + i;\n    }).join(', ');\n    var templateParameter = value.properties.map(function (v, i) {\n      return 'P' + i;\n    }).join(', ');\n    var paramemterConversion = value.properties.map(function (v, i) {\n      var translatedParam = translatePrimitiveJSTypeToCpp(moduleName, v.typeAnnotation, false, function (typeName) {\n        return `Unsupported type for param \"${v.name}\". Found: ${typeName}`;\n      }, resolveAlias, enumMap);\n      return `  static ${translatedParam} ${v.name}ToJs(jsi::Runtime &rt, P${i} value) {\n    return bridging::toJs(rt, value);\n  }`;\n    }).join('\\n');\n    return `#pragma mark - ${structName}\n\ntemplate <${templateParameterWithTypename}>\nstruct ${structName} {\n${value.properties.map(function (v, i) {\n      return '  P' + i + ' ' + v.name;\n    }).join(';\\n')};\n  bool operator==(const ${structName} &other) const {\n    return ${value.properties.map(function (v) {\n      return `${v.name} == other.${v.name}`;\n    }).join(' && ')};\n  }\n};\n\ntemplate <${templateParameterWithTypename}>\nstruct ${structName}Bridging {\n  static ${structName}<${templateParameter}> fromJs(\n      jsi::Runtime &rt,\n      const jsi::Object &value,\n      const std::shared_ptr<CallInvoker> &jsInvoker) {\n    ${structName}<${templateParameter}> result{\n${value.properties.map(function (v, i) {\n      return `      bridging::fromJs<P${i}>(rt, value.getProperty(rt, \"${v.name}\"), jsInvoker)`;\n    }).join(',\\n')}};\n    return result;\n  }\n\n#ifdef DEBUG\n${paramemterConversion}\n#endif\n\n  static jsi::Object toJs(\n    jsi::Runtime &rt,\n    const ${structName}<${templateParameter}> &value,\n    const std::shared_ptr<CallInvoker> &jsInvoker) {\n      auto result = facebook::jsi::Object(rt);\n      ${value.properties.map(function (v, i) {\n      if (v.optional) {\n        return `    if (value.${v.name}) {\n            result.setProperty(rt, \"${v.name}\", bridging::toJs(rt, value.${v.name}.value(), jsInvoker));\n          }`;\n      } else {\n        return `    result.setProperty(rt, \"${v.name}\", bridging::toJs(rt, value.${v.name}, jsInvoker));`;\n      }\n    }).join('\\n')}\n          return result;\n        }\n      };\n\n`;\n  }).join('\\n');\n}\nvar EnumTemplate = function EnumTemplate(_ref6) {\n  var enumName = _ref6.enumName,\n    values = _ref6.values,\n    fromCases = _ref6.fromCases,\n    toCases = _ref6.toCases,\n    nativeEnumMemberType = _ref6.nativeEnumMemberType;\n  var _ref = nativeEnumMemberType === 'std::string' ? ['const jsi::String &rawValue', 'std::string value = rawValue.utf8(rt);', 'jsi::String'] : ['const jsi::Value &rawValue', 'double value = (double)rawValue.asNumber();', 'jsi::Value'],\n    _ref2 = _slicedToArray(_ref, 3),\n    fromValue = _ref2[0],\n    fromValueConversion = _ref2[1],\n    toValue = _ref2[2];\n  return `\n#pragma mark - ${enumName}\n\nenum ${enumName} { ${values} };\n\ntemplate <>\nstruct Bridging<${enumName}> {\n  static ${enumName} fromJs(jsi::Runtime &rt, ${fromValue}) {\n    ${fromValueConversion}\n    ${fromCases}\n  }\n\n  static ${toValue} toJs(jsi::Runtime &rt, ${enumName} value) {\n    ${toCases}\n  }\n};`;\n};\nfunction generateEnum(moduleName, origEnumName, members, memberType) {\n  var enumName = getEnumName(moduleName, origEnumName);\n  var nativeEnumMemberType = memberType === 'StringTypeAnnotation' ? 'std::string' : getAreEnumMembersInteger(members) ? 'int32_t' : 'float';\n  var getMemberValueAppearance = function getMemberValueAppearance(value) {\n    return memberType === 'StringTypeAnnotation' ? `\"${value}\"` : `${value}${nativeEnumMemberType === 'float' ? 'f' : ''}`;\n  };\n  var fromCases = members.map(function (member) {\n    return `if (value == ${getMemberValueAppearance(member.value)}) {\n      return ${enumName}::${toSafeCppString(member.name)};\n    }`;\n  }).join(' else ') + ` else {\n      throw jsi::JSError(rt, \"No appropriate enum member found for value\");\n    }`;\n  var toCases = members.map(function (member) {\n    return `if (value == ${enumName}::${toSafeCppString(member.name)}) {\n      return bridging::toJs(rt, ${getMemberValueAppearance(member.value)});\n    }`;\n  }).join(' else ') + ` else {\n      throw jsi::JSError(rt, \"No appropriate enum member found for enum value\");\n    }`;\n  return EnumTemplate({\n    enumName: enumName,\n    values: members.map(function (member) {\n      return member.name;\n    }).join(', '),\n    fromCases: fromCases,\n    toCases: toCases,\n    nativeEnumMemberType: nativeEnumMemberType\n  });\n}\nfunction createEnums(moduleName, enumMap, resolveAlias) {\n  return Object.entries(enumMap).map(function (_ref7) {\n    var _ref8 = _slicedToArray2(_ref7, 2),\n      enumName = _ref8[0],\n      enumNode = _ref8[1];\n    return generateEnum(moduleName, enumName, enumNode.members, enumNode.memberType);\n  }).filter(Boolean).join('\\n');\n}\nfunction translatePropertyToCpp(moduleName, prop, resolveAlias, enumMap) {\n  var abstract = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var _unwrapNullable3 = unwrapNullable(prop.typeAnnotation),\n    _unwrapNullable4 = _slicedToArray(_unwrapNullable3, 1),\n    propTypeAnnotation = _unwrapNullable4[0];\n  var params = propTypeAnnotation.params.map(function (param) {\n    return `std::move(${param.name})`;\n  });\n  var paramTypes = propTypeAnnotation.params.map(function (param) {\n    var translatedParam = translatePrimitiveJSTypeToCpp(moduleName, param.typeAnnotation, param.optional, function (typeName) {\n      return `Unsupported type for param \"${param.name}\" in ${prop.name}. Found: ${typeName}`;\n    }, resolveAlias, enumMap);\n    return `${translatedParam} ${param.name}`;\n  });\n  var returnType = translatePrimitiveJSTypeToCpp(moduleName, propTypeAnnotation.returnTypeAnnotation, false, function (typeName) {\n    return `Unsupported return type for ${prop.name}. Found: ${typeName}`;\n  }, resolveAlias, enumMap);\n  paramTypes.unshift('jsi::Runtime &rt');\n  var method = `${returnType} ${prop.name}(${paramTypes.join(', ')})`;\n  if (abstract) {\n    return `virtual ${method} = 0;`;\n  }\n  return `${method} override {\n  static_assert(\n      bridging::getParameterCount(&T::${prop.name}) == ${paramTypes.length},\n      \"Expected ${prop.name}(...) to have ${paramTypes.length} parameters\");\n\n  return bridging::callFromJs<${returnType}>(\n      rt, &T::${prop.name}, jsInvoker_, ${['instance_'].concat(_toConsumableArray(params)).join(', ')});\n}`;\n}\nmodule.exports = {\n  generate: function generate(libraryName, schema, packageName) {\n    var assumeNonnull = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var nativeModules = getModules(schema);\n    var modules = Object.keys(nativeModules).flatMap(function (hasteModuleName) {\n      var _nativeModules$hasteM = nativeModules[hasteModuleName],\n        aliasMap = _nativeModules$hasteM.aliasMap,\n        enumMap = _nativeModules$hasteM.enumMap,\n        properties = _nativeModules$hasteM.spec.properties,\n        moduleName = _nativeModules$hasteM.moduleName;\n      var resolveAlias = createAliasResolver(aliasMap);\n      var structs = createStructsString(moduleName, aliasMap, resolveAlias, enumMap);\n      var enums = createEnums(moduleName, enumMap, resolveAlias);\n      return [ModuleClassDeclarationTemplate({\n        hasteModuleName: hasteModuleName,\n        moduleProperties: properties.map(function (prop) {\n          return translatePropertyToCpp(moduleName, prop, resolveAlias, enumMap, true);\n        }),\n        structs: structs,\n        enums: enums\n      }), ModuleSpecClassDeclarationTemplate({\n        hasteModuleName: hasteModuleName,\n        moduleName: moduleName,\n        moduleProperties: properties.map(function (prop) {\n          return translatePropertyToCpp(moduleName, prop, resolveAlias, enumMap);\n        })\n      })];\n    });\n    var fileName = `${libraryName}JSI.h`;\n    var replacedTemplate = FileTemplate({\n      modules: modules\n    });\n    return new Map([[fileName, replacedTemplate]]);\n  }\n};","map":{"version":3,"names":["_toConsumableArray","require","_slicedToArray2","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","len","length","arr2","_i","Symbol","iterator","_s","_e","_x","_r","_arr","_n","_d","next","done","push","value","err","return","isArray","_require","getEnumName","toSafeCppString","_require2","createAliasResolver","getModules","getAreEnumMembersInteger","_require3","indent","_require4","unwrapNullable","ModuleClassDeclarationTemplate","_ref3","hasteModuleName","moduleProperties","structs","enums","join","ModuleSpecClassDeclarationTemplate","_ref4","moduleName","FileTemplate","_ref5","modules","translatePrimitiveJSTypeToCpp","nullableTypeAnnotation","optional","createErrorMessage","resolveAlias","enumMap","_unwrapNullable","_unwrapNullable2","typeAnnotation","nullable","isRequired","realTypeAnnotation","type","wrap","Error","memberType","members","createStructsString","aliasMap","keys","map","alias","properties","structName","templateParameterWithTypename","v","templateParameter","paramemterConversion","translatedParam","typeName","EnumTemplate","_ref6","enumName","values","fromCases","toCases","nativeEnumMemberType","_ref","_ref2","fromValue","fromValueConversion","toValue","generateEnum","origEnumName","getMemberValueAppearance","member","createEnums","entries","_ref7","_ref8","enumNode","filter","Boolean","translatePropertyToCpp","prop","abstract","arguments","undefined","_unwrapNullable3","_unwrapNullable4","propTypeAnnotation","params","param","paramTypes","returnType","returnTypeAnnotation","unshift","method","concat","module","exports","generate","libraryName","schema","packageName","assumeNonnull","nativeModules","flatMap","_nativeModules$hasteM","spec","fileName","replacedTemplate","Map"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native/codegen/lib/generators/modules/GenerateModuleH.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\n'use strict';\n\nfunction _slicedToArray(arr, i) {\n  return (\n    _arrayWithHoles(arr) ||\n    _iterableToArrayLimit(arr, i) ||\n    _unsupportedIterableToArray(arr, i) ||\n    _nonIterableRest()\n  );\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\n    'Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',\n  );\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === 'string') return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === 'Object' && o.constructor) n = o.constructor.name;\n  if (n === 'Map' || n === 'Set') return Array.from(o);\n  if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n    return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i =\n    null == arr\n      ? null\n      : ('undefined' != typeof Symbol && arr[Symbol.iterator]) ||\n        arr['@@iterator'];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (((_x = (_i = _i.call(arr)).next), 0 === i)) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else\n        for (\n          ;\n          !(_n = (_s = _x.call(_i)).done) &&\n          (_arr.push(_s.value), _arr.length !== i);\n          _n = !0\n        );\n    } catch (err) {\n      (_d = !0), (_e = err);\n    } finally {\n      try {\n        if (!_n && null != _i.return && ((_r = _i.return()), Object(_r) !== _r))\n          return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nconst _require = require('../Utils'),\n  getEnumName = _require.getEnumName,\n  toSafeCppString = _require.toSafeCppString;\nconst _require2 = require('./Utils'),\n  createAliasResolver = _require2.createAliasResolver,\n  getModules = _require2.getModules,\n  getAreEnumMembersInteger = _require2.getAreEnumMembersInteger;\nconst _require3 = require('../Utils'),\n  indent = _require3.indent;\nconst _require4 = require('../../parsers/parsers-commons'),\n  unwrapNullable = _require4.unwrapNullable;\nconst ModuleClassDeclarationTemplate = ({\n  hasteModuleName,\n  moduleProperties,\n  structs,\n  enums,\n}) => {\n  return `${enums}\n  ${structs}class JSI_EXPORT ${hasteModuleName}CxxSpecJSI : public TurboModule {\nprotected:\n  ${hasteModuleName}CxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);\n\npublic:\n  ${indent(moduleProperties.join('\\n'), 2)}\n\n};`;\n};\nconst ModuleSpecClassDeclarationTemplate = ({\n  hasteModuleName,\n  moduleName,\n  moduleProperties,\n}) => {\n  return `template <typename T>\nclass JSI_EXPORT ${hasteModuleName}CxxSpec : public TurboModule {\npublic:\n  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {\n    return delegate_.get(rt, propName);\n  }\n\nprotected:\n  ${hasteModuleName}CxxSpec(std::shared_ptr<CallInvoker> jsInvoker)\n    : TurboModule(\"${moduleName}\", jsInvoker),\n      delegate_(static_cast<T*>(this), jsInvoker) {}\n\nprivate:\n  class Delegate : public ${hasteModuleName}CxxSpecJSI {\n  public:\n    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :\n      ${hasteModuleName}CxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}\n\n    ${indent(moduleProperties.join('\\n'), 4)}\n\n  private:\n    T *instance_;\n  };\n\n  Delegate delegate_;\n};`;\n};\nconst FileTemplate = ({modules}) => {\n  return `/**\n * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).\n *\n * Do not edit this file as changes may cause incorrect behavior and will be lost\n * once the code is regenerated.\n *\n * ${'@'}generated by codegen project: GenerateModuleH.js\n */\n\n#pragma once\n\n#include <ReactCommon/TurboModule.h>\n#include <react/bridging/Bridging.h>\n\nnamespace facebook {\nnamespace react {\n\n${modules.join('\\n\\n')}\n\n} // namespace react\n} // namespace facebook\n`;\n};\nfunction translatePrimitiveJSTypeToCpp(\n  moduleName,\n  nullableTypeAnnotation,\n  optional,\n  createErrorMessage,\n  resolveAlias,\n  enumMap,\n) {\n  const _unwrapNullable = unwrapNullable(nullableTypeAnnotation),\n    _unwrapNullable2 = _slicedToArray(_unwrapNullable, 2),\n    typeAnnotation = _unwrapNullable2[0],\n    nullable = _unwrapNullable2[1];\n  const isRequired = !optional && !nullable;\n  let realTypeAnnotation = typeAnnotation;\n  if (realTypeAnnotation.type === 'TypeAliasTypeAnnotation') {\n    realTypeAnnotation = resolveAlias(realTypeAnnotation.name);\n  }\n  function wrap(type) {\n    return isRequired ? type : `std::optional<${type}>`;\n  }\n  switch (realTypeAnnotation.type) {\n    case 'ReservedTypeAnnotation':\n      switch (realTypeAnnotation.name) {\n        case 'RootTag':\n          return wrap('double');\n        default:\n          realTypeAnnotation.name;\n          throw new Error(createErrorMessage(realTypeAnnotation.name));\n      }\n    case 'VoidTypeAnnotation':\n      return 'void';\n    case 'StringTypeAnnotation':\n      return wrap('jsi::String');\n    case 'NumberTypeAnnotation':\n      return wrap('double');\n    case 'DoubleTypeAnnotation':\n      return wrap('double');\n    case 'FloatTypeAnnotation':\n      return wrap('double');\n    case 'Int32TypeAnnotation':\n      return wrap('int');\n    case 'BooleanTypeAnnotation':\n      return wrap('bool');\n    case 'EnumDeclaration':\n      switch (realTypeAnnotation.memberType) {\n        case 'NumberTypeAnnotation':\n          return getAreEnumMembersInteger(\n            enumMap[realTypeAnnotation.name].members,\n          )\n            ? wrap('int')\n            : wrap('double');\n        case 'StringTypeAnnotation':\n          return wrap('jsi::String');\n        default:\n          throw new Error(createErrorMessage(realTypeAnnotation.type));\n      }\n    case 'GenericObjectTypeAnnotation':\n      return wrap('jsi::Object');\n    case 'UnionTypeAnnotation':\n      switch (typeAnnotation.memberType) {\n        case 'NumberTypeAnnotation':\n          return wrap('double');\n        case 'ObjectTypeAnnotation':\n          return wrap('jsi::Object');\n        case 'StringTypeAnnotation':\n          return wrap('jsi::String');\n        default:\n          throw new Error(createErrorMessage(realTypeAnnotation.type));\n      }\n    case 'ObjectTypeAnnotation':\n      return wrap('jsi::Object');\n    case 'ArrayTypeAnnotation':\n      return wrap('jsi::Array');\n    case 'FunctionTypeAnnotation':\n      return wrap('jsi::Function');\n    case 'PromiseTypeAnnotation':\n      return wrap('jsi::Value');\n    case 'MixedTypeAnnotation':\n      return wrap('jsi::Value');\n    default:\n      realTypeAnnotation.type;\n      throw new Error(createErrorMessage(realTypeAnnotation.type));\n  }\n}\nfunction createStructsString(moduleName, aliasMap, resolveAlias, enumMap) {\n  return Object.keys(aliasMap)\n    .map(alias => {\n      const value = aliasMap[alias];\n      if (value.properties.length === 0) {\n        return '';\n      }\n      const structName = `${moduleName}Base${alias}`;\n      const templateParameterWithTypename = value.properties\n        .map((v, i) => 'typename P' + i)\n        .join(', ');\n      const templateParameter = value.properties\n        .map((v, i) => 'P' + i)\n        .join(', ');\n      const paramemterConversion = value.properties\n        .map((v, i) => {\n          const translatedParam = translatePrimitiveJSTypeToCpp(\n            moduleName,\n            v.typeAnnotation,\n            false,\n            typeName =>\n              `Unsupported type for param \"${v.name}\". Found: ${typeName}`,\n            resolveAlias,\n            enumMap,\n          );\n          return `  static ${translatedParam} ${v.name}ToJs(jsi::Runtime &rt, P${i} value) {\n    return bridging::toJs(rt, value);\n  }`;\n        })\n        .join('\\n');\n      return `#pragma mark - ${structName}\n\ntemplate <${templateParameterWithTypename}>\nstruct ${structName} {\n${value.properties.map((v, i) => '  P' + i + ' ' + v.name).join(';\\n')};\n  bool operator==(const ${structName} &other) const {\n    return ${value.properties\n      .map(v => `${v.name} == other.${v.name}`)\n      .join(' && ')};\n  }\n};\n\ntemplate <${templateParameterWithTypename}>\nstruct ${structName}Bridging {\n  static ${structName}<${templateParameter}> fromJs(\n      jsi::Runtime &rt,\n      const jsi::Object &value,\n      const std::shared_ptr<CallInvoker> &jsInvoker) {\n    ${structName}<${templateParameter}> result{\n${value.properties\n  .map(\n    (v, i) =>\n      `      bridging::fromJs<P${i}>(rt, value.getProperty(rt, \"${v.name}\"), jsInvoker)`,\n  )\n  .join(',\\n')}};\n    return result;\n  }\n\n#ifdef DEBUG\n${paramemterConversion}\n#endif\n\n  static jsi::Object toJs(\n    jsi::Runtime &rt,\n    const ${structName}<${templateParameter}> &value,\n    const std::shared_ptr<CallInvoker> &jsInvoker) {\n      auto result = facebook::jsi::Object(rt);\n      ${value.properties\n        .map((v, i) => {\n          if (v.optional) {\n            return `    if (value.${v.name}) {\n            result.setProperty(rt, \"${v.name}\", bridging::toJs(rt, value.${v.name}.value(), jsInvoker));\n          }`;\n          } else {\n            return `    result.setProperty(rt, \"${v.name}\", bridging::toJs(rt, value.${v.name}, jsInvoker));`;\n          }\n        })\n        .join('\\n')}\n          return result;\n        }\n      };\n\n`;\n    })\n    .join('\\n');\n}\nconst EnumTemplate = ({\n  enumName,\n  values,\n  fromCases,\n  toCases,\n  nativeEnumMemberType,\n}) => {\n  const _ref =\n      nativeEnumMemberType === 'std::string'\n        ? [\n            'const jsi::String &rawValue',\n            'std::string value = rawValue.utf8(rt);',\n            'jsi::String',\n          ]\n        : [\n            'const jsi::Value &rawValue',\n            'double value = (double)rawValue.asNumber();',\n            'jsi::Value',\n          ],\n    _ref2 = _slicedToArray(_ref, 3),\n    fromValue = _ref2[0],\n    fromValueConversion = _ref2[1],\n    toValue = _ref2[2];\n  return `\n#pragma mark - ${enumName}\n\nenum ${enumName} { ${values} };\n\ntemplate <>\nstruct Bridging<${enumName}> {\n  static ${enumName} fromJs(jsi::Runtime &rt, ${fromValue}) {\n    ${fromValueConversion}\n    ${fromCases}\n  }\n\n  static ${toValue} toJs(jsi::Runtime &rt, ${enumName} value) {\n    ${toCases}\n  }\n};`;\n};\nfunction generateEnum(moduleName, origEnumName, members, memberType) {\n  const enumName = getEnumName(moduleName, origEnumName);\n  const nativeEnumMemberType =\n    memberType === 'StringTypeAnnotation'\n      ? 'std::string'\n      : getAreEnumMembersInteger(members)\n      ? 'int32_t'\n      : 'float';\n  const getMemberValueAppearance = value =>\n    memberType === 'StringTypeAnnotation'\n      ? `\"${value}\"`\n      : `${value}${nativeEnumMemberType === 'float' ? 'f' : ''}`;\n  const fromCases =\n    members\n      .map(\n        member => `if (value == ${getMemberValueAppearance(member.value)}) {\n      return ${enumName}::${toSafeCppString(member.name)};\n    }`,\n      )\n      .join(' else ') +\n    ` else {\n      throw jsi::JSError(rt, \"No appropriate enum member found for value\");\n    }`;\n  const toCases =\n    members\n      .map(\n        member => `if (value == ${enumName}::${toSafeCppString(member.name)}) {\n      return bridging::toJs(rt, ${getMemberValueAppearance(member.value)});\n    }`,\n      )\n      .join(' else ') +\n    ` else {\n      throw jsi::JSError(rt, \"No appropriate enum member found for enum value\");\n    }`;\n  return EnumTemplate({\n    enumName,\n    values: members.map(member => member.name).join(', '),\n    fromCases,\n    toCases,\n    nativeEnumMemberType,\n  });\n}\nfunction createEnums(moduleName, enumMap, resolveAlias) {\n  return Object.entries(enumMap)\n    .map(([enumName, enumNode]) => {\n      return generateEnum(\n        moduleName,\n        enumName,\n        enumNode.members,\n        enumNode.memberType,\n      );\n    })\n    .filter(Boolean)\n    .join('\\n');\n}\nfunction translatePropertyToCpp(\n  moduleName,\n  prop,\n  resolveAlias,\n  enumMap,\n  abstract = false,\n) {\n  const _unwrapNullable3 = unwrapNullable(prop.typeAnnotation),\n    _unwrapNullable4 = _slicedToArray(_unwrapNullable3, 1),\n    propTypeAnnotation = _unwrapNullable4[0];\n  const params = propTypeAnnotation.params.map(\n    param => `std::move(${param.name})`,\n  );\n  const paramTypes = propTypeAnnotation.params.map(param => {\n    const translatedParam = translatePrimitiveJSTypeToCpp(\n      moduleName,\n      param.typeAnnotation,\n      param.optional,\n      typeName =>\n        `Unsupported type for param \"${param.name}\" in ${prop.name}. Found: ${typeName}`,\n      resolveAlias,\n      enumMap,\n    );\n    return `${translatedParam} ${param.name}`;\n  });\n  const returnType = translatePrimitiveJSTypeToCpp(\n    moduleName,\n    propTypeAnnotation.returnTypeAnnotation,\n    false,\n    typeName => `Unsupported return type for ${prop.name}. Found: ${typeName}`,\n    resolveAlias,\n    enumMap,\n  );\n\n  // The first param will always be the runtime reference.\n  paramTypes.unshift('jsi::Runtime &rt');\n  const method = `${returnType} ${prop.name}(${paramTypes.join(', ')})`;\n  if (abstract) {\n    return `virtual ${method} = 0;`;\n  }\n  return `${method} override {\n  static_assert(\n      bridging::getParameterCount(&T::${prop.name}) == ${paramTypes.length},\n      \"Expected ${prop.name}(...) to have ${paramTypes.length} parameters\");\n\n  return bridging::callFromJs<${returnType}>(\n      rt, &T::${prop.name}, jsInvoker_, ${['instance_', ...params].join(', ')});\n}`;\n}\nmodule.exports = {\n  generate(libraryName, schema, packageName, assumeNonnull = false) {\n    const nativeModules = getModules(schema);\n    const modules = Object.keys(nativeModules).flatMap(hasteModuleName => {\n      const _nativeModules$hasteM = nativeModules[hasteModuleName],\n        aliasMap = _nativeModules$hasteM.aliasMap,\n        enumMap = _nativeModules$hasteM.enumMap,\n        properties = _nativeModules$hasteM.spec.properties,\n        moduleName = _nativeModules$hasteM.moduleName;\n      const resolveAlias = createAliasResolver(aliasMap);\n      const structs = createStructsString(\n        moduleName,\n        aliasMap,\n        resolveAlias,\n        enumMap,\n      );\n      const enums = createEnums(moduleName, enumMap, resolveAlias);\n      return [\n        ModuleClassDeclarationTemplate({\n          hasteModuleName,\n          moduleProperties: properties.map(prop =>\n            translatePropertyToCpp(\n              moduleName,\n              prop,\n              resolveAlias,\n              enumMap,\n              true,\n            ),\n          ),\n          structs,\n          enums,\n        }),\n        ModuleSpecClassDeclarationTemplate({\n          hasteModuleName,\n          moduleName,\n          moduleProperties: properties.map(prop =>\n            translatePropertyToCpp(moduleName, prop, resolveAlias, enumMap),\n          ),\n        }),\n      ];\n    });\n    const fileName = `${libraryName}JSI.h`;\n    const replacedTemplate = FileTemplate({\n      modules,\n    });\n    return new Map([[fileName, replacedTemplate]]);\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}