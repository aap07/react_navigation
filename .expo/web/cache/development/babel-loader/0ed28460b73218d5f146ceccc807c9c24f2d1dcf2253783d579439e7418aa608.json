{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nvar _require = require('stream'),\n  Duplex = _require.Duplex;\nvar _require2 = require('crypto'),\n  randomFillSync = _require2.randomFillSync;\nvar PerMessageDeflate = require(\"./permessage-deflate\");\nvar _require3 = require(\"./constants\"),\n  EMPTY_BUFFER = _require3.EMPTY_BUFFER;\nvar _require4 = require(\"./validation\"),\n  isValidStatusCode = _require4.isValidStatusCode;\nvar _require5 = require(\"./buffer-util\"),\n  applyMask = _require5.mask,\n  toBuffer = _require5.toBuffer;\nvar kByteLength = Symbol('kByteLength');\nvar maskBuffer = Buffer.alloc(4);\nvar Sender = function () {\n  function Sender(socket, extensions, generateMask) {\n    _classCallCheck(this, Sender);\n    this._extensions = extensions || {};\n    if (generateMask) {\n      this._generateMask = generateMask;\n      this._maskBuffer = Buffer.alloc(4);\n    }\n    this._socket = socket;\n    this._firstFragment = true;\n    this._compress = false;\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n  _createClass(Sender, [{\n    key: \"close\",\n    value: function close(code, data, mask, cb) {\n      var _options;\n      var buf;\n      if (code === undefined) {\n        buf = EMPTY_BUFFER;\n      } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n        throw new TypeError('First argument must be a valid error code number');\n      } else if (data === undefined || !data.length) {\n        buf = Buffer.allocUnsafe(2);\n        buf.writeUInt16BE(code, 0);\n      } else {\n        var length = Buffer.byteLength(data);\n        if (length > 123) {\n          throw new RangeError('The message must not be greater than 123 bytes');\n        }\n        buf = Buffer.allocUnsafe(2 + length);\n        buf.writeUInt16BE(code, 0);\n        if (typeof data === 'string') {\n          buf.write(data, 2);\n        } else {\n          buf.set(data, 2);\n        }\n      }\n      var options = (_options = {}, _defineProperty(_options, kByteLength, buf.length), _defineProperty(_options, \"fin\", true), _defineProperty(_options, \"generateMask\", this._generateMask), _defineProperty(_options, \"mask\", mask), _defineProperty(_options, \"maskBuffer\", this._maskBuffer), _defineProperty(_options, \"opcode\", 0x08), _defineProperty(_options, \"readOnly\", false), _defineProperty(_options, \"rsv1\", false), _options);\n      if (this._deflating) {\n        this.enqueue([this.dispatch, buf, false, options, cb]);\n      } else {\n        this.sendFrame(Sender.frame(buf, options), cb);\n      }\n    }\n  }, {\n    key: \"ping\",\n    value: function ping(data, mask, cb) {\n      var _options2;\n      var byteLength;\n      var readOnly;\n      if (typeof data === 'string') {\n        byteLength = Buffer.byteLength(data);\n        readOnly = false;\n      } else {\n        data = toBuffer(data);\n        byteLength = data.length;\n        readOnly = toBuffer.readOnly;\n      }\n      if (byteLength > 125) {\n        throw new RangeError('The data size must not be greater than 125 bytes');\n      }\n      var options = (_options2 = {}, _defineProperty(_options2, kByteLength, byteLength), _defineProperty(_options2, \"fin\", true), _defineProperty(_options2, \"generateMask\", this._generateMask), _defineProperty(_options2, \"mask\", mask), _defineProperty(_options2, \"maskBuffer\", this._maskBuffer), _defineProperty(_options2, \"opcode\", 0x09), _defineProperty(_options2, \"readOnly\", readOnly), _defineProperty(_options2, \"rsv1\", false), _options2);\n      if (this._deflating) {\n        this.enqueue([this.dispatch, data, false, options, cb]);\n      } else {\n        this.sendFrame(Sender.frame(data, options), cb);\n      }\n    }\n  }, {\n    key: \"pong\",\n    value: function pong(data, mask, cb) {\n      var _options3;\n      var byteLength;\n      var readOnly;\n      if (typeof data === 'string') {\n        byteLength = Buffer.byteLength(data);\n        readOnly = false;\n      } else {\n        data = toBuffer(data);\n        byteLength = data.length;\n        readOnly = toBuffer.readOnly;\n      }\n      if (byteLength > 125) {\n        throw new RangeError('The data size must not be greater than 125 bytes');\n      }\n      var options = (_options3 = {}, _defineProperty(_options3, kByteLength, byteLength), _defineProperty(_options3, \"fin\", true), _defineProperty(_options3, \"generateMask\", this._generateMask), _defineProperty(_options3, \"mask\", mask), _defineProperty(_options3, \"maskBuffer\", this._maskBuffer), _defineProperty(_options3, \"opcode\", 0x0a), _defineProperty(_options3, \"readOnly\", readOnly), _defineProperty(_options3, \"rsv1\", false), _options3);\n      if (this._deflating) {\n        this.enqueue([this.dispatch, data, false, options, cb]);\n      } else {\n        this.sendFrame(Sender.frame(data, options), cb);\n      }\n    }\n  }, {\n    key: \"send\",\n    value: function send(data, options, cb) {\n      var perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n      var opcode = options.binary ? 2 : 1;\n      var rsv1 = options.compress;\n      var byteLength;\n      var readOnly;\n      if (typeof data === 'string') {\n        byteLength = Buffer.byteLength(data);\n        readOnly = false;\n      } else {\n        data = toBuffer(data);\n        byteLength = data.length;\n        readOnly = toBuffer.readOnly;\n      }\n      if (this._firstFragment) {\n        this._firstFragment = false;\n        if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? 'server_no_context_takeover' : 'client_no_context_takeover']) {\n          rsv1 = byteLength >= perMessageDeflate._threshold;\n        }\n        this._compress = rsv1;\n      } else {\n        rsv1 = false;\n        opcode = 0;\n      }\n      if (options.fin) this._firstFragment = true;\n      if (perMessageDeflate) {\n        var _opts;\n        var opts = (_opts = {}, _defineProperty(_opts, kByteLength, byteLength), _defineProperty(_opts, \"fin\", options.fin), _defineProperty(_opts, \"generateMask\", this._generateMask), _defineProperty(_opts, \"mask\", options.mask), _defineProperty(_opts, \"maskBuffer\", this._maskBuffer), _defineProperty(_opts, \"opcode\", opcode), _defineProperty(_opts, \"readOnly\", readOnly), _defineProperty(_opts, \"rsv1\", rsv1), _opts);\n        if (this._deflating) {\n          this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n        } else {\n          this.dispatch(data, this._compress, opts, cb);\n        }\n      } else {\n        var _Sender$frame;\n        this.sendFrame(Sender.frame(data, (_Sender$frame = {}, _defineProperty(_Sender$frame, kByteLength, byteLength), _defineProperty(_Sender$frame, \"fin\", options.fin), _defineProperty(_Sender$frame, \"generateMask\", this._generateMask), _defineProperty(_Sender$frame, \"mask\", options.mask), _defineProperty(_Sender$frame, \"maskBuffer\", this._maskBuffer), _defineProperty(_Sender$frame, \"opcode\", opcode), _defineProperty(_Sender$frame, \"readOnly\", readOnly), _defineProperty(_Sender$frame, \"rsv1\", false), _Sender$frame)), cb);\n      }\n    }\n  }, {\n    key: \"dispatch\",\n    value: function dispatch(data, compress, options, cb) {\n      var _this = this;\n      if (!compress) {\n        this.sendFrame(Sender.frame(data, options), cb);\n        return;\n      }\n      var perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n      this._bufferedBytes += options[kByteLength];\n      this._deflating = true;\n      perMessageDeflate.compress(data, options.fin, function (_, buf) {\n        if (_this._socket.destroyed) {\n          var err = new Error('The socket was closed while data was being compressed');\n          if (typeof cb === 'function') cb(err);\n          for (var i = 0; i < _this._queue.length; i++) {\n            var params = _this._queue[i];\n            var callback = params[params.length - 1];\n            if (typeof callback === 'function') callback(err);\n          }\n          return;\n        }\n        _this._bufferedBytes -= options[kByteLength];\n        _this._deflating = false;\n        options.readOnly = false;\n        _this.sendFrame(Sender.frame(buf, options), cb);\n        _this.dequeue();\n      });\n    }\n  }, {\n    key: \"dequeue\",\n    value: function dequeue() {\n      while (!this._deflating && this._queue.length) {\n        var params = this._queue.shift();\n        this._bufferedBytes -= params[3][kByteLength];\n        Reflect.apply(params[0], this, params.slice(1));\n      }\n    }\n  }, {\n    key: \"enqueue\",\n    value: function enqueue(params) {\n      this._bufferedBytes += params[3][kByteLength];\n      this._queue.push(params);\n    }\n  }, {\n    key: \"sendFrame\",\n    value: function sendFrame(list, cb) {\n      if (list.length === 2) {\n        this._socket.cork();\n        this._socket.write(list[0]);\n        this._socket.write(list[1], cb);\n        this._socket.uncork();\n      } else {\n        this._socket.write(list[0], cb);\n      }\n    }\n  }], [{\n    key: \"frame\",\n    value: function frame(data, options) {\n      var mask;\n      var merge = false;\n      var offset = 2;\n      var skipMasking = false;\n      if (options.mask) {\n        mask = options.maskBuffer || maskBuffer;\n        if (options.generateMask) {\n          options.generateMask(mask);\n        } else {\n          randomFillSync(mask, 0, 4);\n        }\n        skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n        offset = 6;\n      }\n      var dataLength;\n      if (typeof data === 'string') {\n        if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {\n          dataLength = options[kByteLength];\n        } else {\n          data = Buffer.from(data);\n          dataLength = data.length;\n        }\n      } else {\n        dataLength = data.length;\n        merge = options.mask && options.readOnly && !skipMasking;\n      }\n      var payloadLength = dataLength;\n      if (dataLength >= 65536) {\n        offset += 8;\n        payloadLength = 127;\n      } else if (dataLength > 125) {\n        offset += 2;\n        payloadLength = 126;\n      }\n      var target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n      target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n      if (options.rsv1) target[0] |= 0x40;\n      target[1] = payloadLength;\n      if (payloadLength === 126) {\n        target.writeUInt16BE(dataLength, 2);\n      } else if (payloadLength === 127) {\n        target[2] = target[3] = 0;\n        target.writeUIntBE(dataLength, 4, 6);\n      }\n      if (!options.mask) return [target, data];\n      target[1] |= 0x80;\n      target[offset - 4] = mask[0];\n      target[offset - 3] = mask[1];\n      target[offset - 2] = mask[2];\n      target[offset - 1] = mask[3];\n      if (skipMasking) return [target, data];\n      if (merge) {\n        applyMask(data, mask, target, offset, dataLength);\n        return [target];\n      }\n      applyMask(data, mask, data, 0, dataLength);\n      return [target, data];\n    }\n  }]);\n  return Sender;\n}();\nmodule.exports = Sender;","map":{"version":3,"names":["_defineProperty","require","_classCallCheck","_createClass","_require","Duplex","_require2","randomFillSync","PerMessageDeflate","_require3","EMPTY_BUFFER","_require4","isValidStatusCode","_require5","applyMask","mask","toBuffer","kByteLength","Symbol","maskBuffer","Buffer","alloc","Sender","socket","extensions","generateMask","_extensions","_generateMask","_maskBuffer","_socket","_firstFragment","_compress","_bufferedBytes","_deflating","_queue","key","value","close","code","data","cb","_options","buf","undefined","TypeError","length","allocUnsafe","writeUInt16BE","byteLength","RangeError","write","set","options","enqueue","dispatch","sendFrame","frame","ping","_options2","readOnly","pong","_options3","send","perMessageDeflate","extensionName","opcode","binary","rsv1","compress","params","_isServer","_threshold","fin","_opts","opts","_Sender$frame","_this","_","destroyed","err","Error","i","callback","dequeue","shift","Reflect","apply","slice","push","list","cork","uncork","merge","offset","skipMasking","dataLength","from","payloadLength","target","writeUIntBE","module","exports"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@expo/cli/node_modules/ws/lib/sender.js"],"sourcesContent":["/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex\" }] */\n\n'use strict';\n\nconst { Duplex } = require('stream');\nconst { randomFillSync } = require('crypto');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst { EMPTY_BUFFER } = require('./constants');\nconst { isValidStatusCode } = require('./validation');\nconst { mask: applyMask, toBuffer } = require('./buffer-util');\n\nconst kByteLength = Symbol('kByteLength');\nconst maskBuffer = Buffer.alloc(4);\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {Duplex} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */\n  constructor(socket, extensions, generateMask) {\n    this._extensions = extensions || {};\n\n    if (generateMask) {\n      this._generateMask = generateMask;\n      this._maskBuffer = Buffer.alloc(4);\n    }\n\n    this._socket = socket;\n\n    this._firstFragment = true;\n    this._compress = false;\n\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */\n  static frame(data, options) {\n    let mask;\n    let merge = false;\n    let offset = 2;\n    let skipMasking = false;\n\n    if (options.mask) {\n      mask = options.maskBuffer || maskBuffer;\n\n      if (options.generateMask) {\n        options.generateMask(mask);\n      } else {\n        randomFillSync(mask, 0, 4);\n      }\n\n      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n      offset = 6;\n    }\n\n    let dataLength;\n\n    if (typeof data === 'string') {\n      if (\n        (!options.mask || skipMasking) &&\n        options[kByteLength] !== undefined\n      ) {\n        dataLength = options[kByteLength];\n      } else {\n        data = Buffer.from(data);\n        dataLength = data.length;\n      }\n    } else {\n      dataLength = data.length;\n      merge = options.mask && options.readOnly && !skipMasking;\n    }\n\n    let payloadLength = dataLength;\n\n    if (dataLength >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (dataLength > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(dataLength, 2);\n    } else if (payloadLength === 127) {\n      target[2] = target[3] = 0;\n      target.writeUIntBE(dataLength, 4, 6);\n    }\n\n    if (!options.mask) return [target, data];\n\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (skipMasking) return [target, data];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, dataLength);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, dataLength);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  close(code, data, mask, cb) {\n    let buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || !data.length) {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      const length = Buffer.byteLength(data);\n\n      if (length > 123) {\n        throw new RangeError('The message must not be greater than 123 bytes');\n      }\n\n      buf = Buffer.allocUnsafe(2 + length);\n      buf.writeUInt16BE(code, 0);\n\n      if (typeof data === 'string') {\n        buf.write(data, 2);\n      } else {\n        buf.set(data, 2);\n      }\n    }\n\n    const options = {\n      [kByteLength]: buf.length,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x08,\n      readOnly: false,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, buf, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(buf, options), cb);\n    }\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  ping(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x09,\n      readOnly,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  pong(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x0a,\n      readOnly,\n      rsv1: false\n    };\n\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (\n        rsv1 &&\n        perMessageDeflate &&\n        perMessageDeflate.params[\n          perMessageDeflate._isServer\n            ? 'server_no_context_takeover'\n            : 'client_no_context_takeover'\n        ]\n      ) {\n        rsv1 = byteLength >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    if (perMessageDeflate) {\n      const opts = {\n        [kByteLength]: byteLength,\n        fin: options.fin,\n        generateMask: this._generateMask,\n        mask: options.mask,\n        maskBuffer: this._maskBuffer,\n        opcode,\n        readOnly,\n        rsv1\n      };\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n      } else {\n        this.dispatch(data, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(\n        Sender.frame(data, {\n          [kByteLength]: byteLength,\n          fin: options.fin,\n          generateMask: this._generateMask,\n          mask: options.mask,\n          maskBuffer: this._maskBuffer,\n          opcode,\n          readOnly,\n          rsv1: false\n        }),\n        cb\n      );\n    }\n  }\n\n  /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    this._bufferedBytes += options[kByteLength];\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      if (this._socket.destroyed) {\n        const err = new Error(\n          'The socket was closed while data was being compressed'\n        );\n\n        if (typeof cb === 'function') cb(err);\n\n        for (let i = 0; i < this._queue.length; i++) {\n          const params = this._queue[i];\n          const callback = params[params.length - 1];\n\n          if (typeof callback === 'function') callback(err);\n        }\n\n        return;\n      }\n\n      this._bufferedBytes -= options[kByteLength];\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[3][kByteLength];\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[3][kByteLength];\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\n\nmodule.exports = Sender;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}