{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nvar _excluded = [\"config\", \"duplicates\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport chalk from 'chalk';\nimport glob from 'fast-glob';\nimport fs from 'fs-extra';\nimport { createRequire } from 'module';\nimport path from 'path';\nimport { requireAndResolveExpoModuleConfig } from \"../ExpoModuleConfig\";\nimport { mergeLinkingOptionsAsync, projectPackageJsonPath } from \"./mergeLinkingOptions\";\nvar EXPO_MODULE_CONFIG_FILENAMES = ['unimodule.json', 'expo-module.config.json'];\nexport function findModulesAsync(_x) {\n  return _findModulesAsync.apply(this, arguments);\n}\nfunction _findModulesAsync() {\n  _findModulesAsync = _asyncToGenerator(function* (providedOptions) {\n    var options = yield mergeLinkingOptionsAsync(providedOptions);\n    var results = new Map();\n    var nativeModuleNames = new Set();\n    var searchPaths = options.nativeModulesDir && fs.existsSync(options.nativeModulesDir) ? [options.nativeModulesDir].concat(_toConsumableArray(options.searchPaths)) : options.searchPaths;\n    for (var searchPath of searchPaths) {\n      var isNativeModulesDir = searchPath === options.nativeModulesDir;\n      var packageConfigPaths = yield findPackagesConfigPathsAsync(searchPath);\n      for (var packageConfigPath of packageConfigPaths) {\n        var _options$exclude;\n        var packagePath = yield fs.realpath(path.join(searchPath, path.dirname(packageConfigPath)));\n        var expoModuleConfig = requireAndResolveExpoModuleConfig(path.join(packagePath, path.basename(packageConfigPath)));\n        var _resolvePackageNameAn = resolvePackageNameAndVersion(packagePath, {\n            fallbackToDirName: isNativeModulesDir\n          }),\n          name = _resolvePackageNameAn.name,\n          version = _resolvePackageNameAn.version;\n        if (!isNativeModulesDir && (_options$exclude = options.exclude) != null && _options$exclude.includes(name) || !expoModuleConfig.supportsPlatform(options.platform)) {\n          continue;\n        }\n        var currentRevision = {\n          path: packagePath,\n          version: version,\n          config: expoModuleConfig\n        };\n        addRevisionToResults(results, name, currentRevision);\n        if (isNativeModulesDir && !nativeModuleNames.has(name)) {\n          nativeModuleNames.add(name);\n        }\n      }\n    }\n    var searchResults = Object.fromEntries(results.entries());\n    if (options.searchPaths.length <= 1) {\n      return searchResults;\n    }\n    return filterToProjectDependencies(searchResults, _objectSpread(_objectSpread({}, providedOptions), {}, {\n      alwaysIncludedPackagesNames: nativeModuleNames\n    }));\n  });\n  return _findModulesAsync.apply(this, arguments);\n}\nfunction configPriority(fullpath) {\n  return EXPO_MODULE_CONFIG_FILENAMES.indexOf(path.basename(fullpath));\n}\nfunction addRevisionToResults(results, name, revision) {\n  var _results$get, _results$get2, _results$get2$duplica;\n  if (!results.has(name)) {\n    results.set(name, _objectSpread(_objectSpread({}, revision), {}, {\n      duplicates: []\n    }));\n  } else if (((_results$get = results.get(name)) == null ? void 0 : _results$get.path) !== revision.path && (_results$get2 = results.get(name)) != null && (_results$get2$duplica = _results$get2.duplicates) != null && _results$get2$duplica.every(function (_ref) {\n    var path = _ref.path;\n    return path !== revision.path;\n  })) {\n    var _results$get3, _results$get3$duplica;\n    var config = revision.config,\n      duplicates = revision.duplicates,\n      duplicateEntry = _objectWithoutProperties(revision, _excluded);\n    (_results$get3 = results.get(name)) == null ? void 0 : (_results$get3$duplica = _results$get3.duplicates) == null ? void 0 : _results$get3$duplica.push(duplicateEntry);\n  }\n}\nfunction findPackagesConfigPathsAsync(_x2) {\n  return _findPackagesConfigPathsAsync.apply(this, arguments);\n}\nfunction _findPackagesConfigPathsAsync() {\n  _findPackagesConfigPathsAsync = _asyncToGenerator(function* (searchPath) {\n    var bracedFilenames = '{' + EXPO_MODULE_CONFIG_FILENAMES.join(',') + '}';\n    var paths = yield glob([`*/${bracedFilenames}`, `@*/*/${bracedFilenames}`, `./${bracedFilenames}`], {\n      cwd: searchPath\n    });\n    return Object.values(paths.reduce(function (acc, configPath) {\n      var dirname = path.dirname(configPath);\n      if (!acc[dirname] || configPriority(configPath) > configPriority(acc[dirname])) {\n        acc[dirname] = configPath;\n      }\n      return acc;\n    }, {}));\n  });\n  return _findPackagesConfigPathsAsync.apply(this, arguments);\n}\nfunction resolvePackageNameAndVersion(packagePath) {\n  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    fallbackToDirName = _ref2.fallbackToDirName;\n  try {\n    var _require = require(path.join(packagePath, 'package.json')),\n      name = _require.name,\n      version = _require.version;\n    return {\n      name: name,\n      version: version || 'UNVERSIONED'\n    };\n  } catch (e) {\n    if (fallbackToDirName) {\n      return {\n        name: path.basename(packagePath),\n        version: 'UNVERSIONED'\n      };\n    } else {\n      throw e;\n    }\n  }\n}\nfunction filterToProjectDependencies(results) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var filteredResults = {};\n  var visitedPackages = new Set();\n  for (var name of (_options$alwaysInclud = options.alwaysIncludedPackagesNames) != null ? _options$alwaysInclud : []) {\n    var _options$alwaysInclud;\n    if (results[name] && !visitedPackages.has(name)) {\n      filteredResults[name] = results[name];\n      visitedPackages.add(name);\n    }\n  }\n  function visitPackage(packageJsonPath) {\n    var packageJson = require(packageJsonPath);\n    if (visitedPackages.has(packageJson.name)) {\n      return;\n    }\n    visitedPackages.add(packageJson.name);\n    for (var dependencyName in packageJson.dependencies) {\n      var dependencyResult = results[dependencyName];\n      if (!filteredResults[dependencyName]) {\n        var dependencyPackageJsonPath = void 0;\n        if (dependencyResult) {\n          filteredResults[dependencyName] = dependencyResult;\n          dependencyPackageJsonPath = path.join(dependencyResult.path, 'package.json');\n        } else {\n          try {\n            var projectRequire = createRequire(packageJsonPath);\n            dependencyPackageJsonPath = projectRequire.resolve(`${dependencyName}/package.json`);\n          } catch (error) {\n            if (!options.silent && error.code !== 'ERR_PACKAGE_PATH_NOT_EXPORTED') {\n              console.warn(chalk.yellow(`⚠️  Cannot resolve the path to \"${dependencyName}\" package.`));\n            }\n            continue;\n          }\n        }\n        visitPackage(dependencyPackageJsonPath);\n      }\n    }\n  }\n  visitPackage(projectPackageJsonPath);\n  return filteredResults;\n}","map":{"version":3,"names":["chalk","glob","fs","createRequire","path","requireAndResolveExpoModuleConfig","mergeLinkingOptionsAsync","projectPackageJsonPath","EXPO_MODULE_CONFIG_FILENAMES","findModulesAsync","_x","_findModulesAsync","apply","arguments","_asyncToGenerator","providedOptions","options","results","Map","nativeModuleNames","Set","searchPaths","nativeModulesDir","existsSync","concat","_toConsumableArray","searchPath","isNativeModulesDir","packageConfigPaths","findPackagesConfigPathsAsync","packageConfigPath","_options$exclude","packagePath","realpath","join","dirname","expoModuleConfig","basename","_resolvePackageNameAn","resolvePackageNameAndVersion","fallbackToDirName","name","version","exclude","includes","supportsPlatform","platform","currentRevision","config","addRevisionToResults","has","add","searchResults","Object","fromEntries","entries","length","filterToProjectDependencies","_objectSpread","alwaysIncludedPackagesNames","configPriority","fullpath","indexOf","revision","_results$get","_results$get2","_results$get2$duplica","set","duplicates","get","every","_ref","_results$get3","_results$get3$duplica","duplicateEntry","_objectWithoutProperties","_excluded","push","_x2","_findPackagesConfigPathsAsync","bracedFilenames","paths","cwd","values","reduce","acc","configPath","_ref2","undefined","_require","require","e","filteredResults","visitedPackages","_options$alwaysInclud","visitPackage","packageJsonPath","packageJson","dependencyName","dependencies","dependencyResult","dependencyPackageJsonPath","projectRequire","resolve","error","silent","code","console","warn","yellow"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/expo-modules-autolinking/src/autolinking/findModules.ts"],"sourcesContent":["import chalk from 'chalk';\nimport glob from 'fast-glob';\nimport fs from 'fs-extra';\nimport { createRequire } from 'module';\nimport path from 'path';\n\nimport { requireAndResolveExpoModuleConfig } from '../ExpoModuleConfig';\nimport { PackageRevision, SearchOptions, SearchResults } from '../types';\nimport { mergeLinkingOptionsAsync, projectPackageJsonPath } from './mergeLinkingOptions';\n\n// Names of the config files. From lowest to highest priority.\nconst EXPO_MODULE_CONFIG_FILENAMES = ['unimodule.json', 'expo-module.config.json'];\n\n/**\n * Searches for modules to link based on given config.\n */\nexport async function findModulesAsync(providedOptions: SearchOptions): Promise<SearchResults> {\n  const options = await mergeLinkingOptionsAsync(providedOptions);\n  const results: Map<string, PackageRevision> = new Map();\n\n  const nativeModuleNames = new Set<string>();\n\n  // custom native modules should be resolved first so that they can override other modules\n  const searchPaths =\n    options.nativeModulesDir && fs.existsSync(options.nativeModulesDir)\n      ? [options.nativeModulesDir, ...options.searchPaths]\n      : options.searchPaths;\n\n  for (const searchPath of searchPaths) {\n    const isNativeModulesDir = searchPath === options.nativeModulesDir;\n\n    const packageConfigPaths = await findPackagesConfigPathsAsync(searchPath);\n\n    for (const packageConfigPath of packageConfigPaths) {\n      const packagePath = await fs.realpath(path.join(searchPath, path.dirname(packageConfigPath)));\n      const expoModuleConfig = requireAndResolveExpoModuleConfig(\n        path.join(packagePath, path.basename(packageConfigPath))\n      );\n\n      const { name, version } = resolvePackageNameAndVersion(packagePath, {\n        fallbackToDirName: isNativeModulesDir,\n      });\n\n      // we ignore the `exclude` option for custom native modules\n      if (\n        (!isNativeModulesDir && options.exclude?.includes(name)) ||\n        !expoModuleConfig.supportsPlatform(options.platform)\n      ) {\n        continue;\n      }\n\n      // add the current revision to the results\n      const currentRevision: PackageRevision = {\n        path: packagePath,\n        version,\n        config: expoModuleConfig,\n      };\n      addRevisionToResults(results, name, currentRevision);\n\n      // if the module is a native module, we need to add it to the nativeModuleNames set\n      if (isNativeModulesDir && !nativeModuleNames.has(name)) {\n        nativeModuleNames.add(name);\n      }\n    }\n  }\n\n  const searchResults: SearchResults = Object.fromEntries(results.entries());\n\n  // It doesn't make much sense to strip modules if there is only one search path.\n  // (excluding custom native modules path)\n  // Workspace root usually doesn't specify all its dependencies (see Expo Go),\n  // so in this case we should link everything.\n  if (options.searchPaths.length <= 1) {\n    return searchResults;\n  }\n\n  return filterToProjectDependencies(searchResults, {\n    ...providedOptions,\n    // Custom native modules are not filtered out\n    // when they're not specified in package.json dependencies.\n    alwaysIncludedPackagesNames: nativeModuleNames,\n  });\n}\n\n/**\n * Returns the priority of the config at given path. Higher number means higher priority.\n */\nfunction configPriority(fullpath: string): number {\n  return EXPO_MODULE_CONFIG_FILENAMES.indexOf(path.basename(fullpath));\n}\n\n/**\n * Adds {@link revision} to the {@link results} map\n * or to package duplicates if it already exists.\n * @param results [mutable] yet resolved packages map\n * @param name resolved package name\n * @param revision resolved package revision\n */\nfunction addRevisionToResults(\n  results: Map<string, PackageRevision>,\n  name: string,\n  revision: PackageRevision\n): void {\n  if (!results.has(name)) {\n    // The revision that was found first will be the main one.\n    // An array of duplicates and the config are needed only here.\n    results.set(name, {\n      ...revision,\n      duplicates: [],\n    });\n  } else if (\n    results.get(name)?.path !== revision.path &&\n    results.get(name)?.duplicates?.every(({ path }) => path !== revision.path)\n  ) {\n    const { config, duplicates, ...duplicateEntry } = revision;\n    results.get(name)?.duplicates?.push(duplicateEntry);\n  }\n}\n\n/**\n * Returns paths to the highest priority config files, relative to the {@link searchPath}.\n * @example\n * ```\n * // Given the following file exists: /foo/myapp/modules/mymodule/expo-module.config.json\n * await findPackagesConfigPathsAsync('/foo/myapp/modules');\n * // returns ['mymodule/expo-module.config.json']\n *\n * await findPackagesConfigPathsAsync('/foo/myapp/modules/mymodule');\n * // returns ['expo-module.config.json']\n * ```\n */\nasync function findPackagesConfigPathsAsync(searchPath: string): Promise<string[]> {\n  const bracedFilenames = '{' + EXPO_MODULE_CONFIG_FILENAMES.join(',') + '}';\n  const paths = await glob(\n    [`*/${bracedFilenames}`, `@*/*/${bracedFilenames}`, `./${bracedFilenames}`],\n    {\n      cwd: searchPath,\n    }\n  );\n\n  // If the package has multiple configs (e.g. `unimodule.json` and `expo-module.config.json` during the transition time)\n  // then we want to give `expo-module.config.json` the priority.\n  return Object.values(\n    paths.reduce<Record<string, string>>((acc, configPath) => {\n      const dirname = path.dirname(configPath);\n\n      if (!acc[dirname] || configPriority(configPath) > configPriority(acc[dirname])) {\n        acc[dirname] = configPath;\n      }\n      return acc;\n    }, {})\n  );\n}\n\n/**\n * Resolves package name and version for the given {@link packagePath} from its `package.json`.\n * if {@link fallbackToDirName} is true, it returns the dir name when `package.json` doesn't exist.\n * @returns object with `name` and `version` properties. `version` falls back to `UNVERSIONED` if cannot be resolved.\n */\nfunction resolvePackageNameAndVersion(\n  packagePath: string,\n  { fallbackToDirName }: { fallbackToDirName?: boolean } = {}\n): { name: string; version: string } {\n  try {\n    const { name, version } = require(path.join(packagePath, 'package.json'));\n    return { name, version: version || 'UNVERSIONED' };\n  } catch (e) {\n    if (fallbackToDirName) {\n      // we don't have the package.json name, so we'll use the directory name\n      return {\n        name: path.basename(packagePath),\n        version: 'UNVERSIONED',\n      };\n    } else {\n      throw e;\n    }\n  }\n}\n\n/**\n * Filters out packages that are not the dependencies of the project.\n */\nfunction filterToProjectDependencies(\n  results: SearchResults,\n  options: Pick<SearchOptions, 'silent'> & { alwaysIncludedPackagesNames?: Set<string> } = {}\n) {\n  const filteredResults: SearchResults = {};\n  const visitedPackages = new Set<string>();\n\n  // iterate through always included package names and add them to the visited packages\n  // if the results contains them\n  for (const name of options.alwaysIncludedPackagesNames ?? []) {\n    if (results[name] && !visitedPackages.has(name)) {\n      filteredResults[name] = results[name];\n      visitedPackages.add(name);\n    }\n  }\n\n  // Helper for traversing the dependency hierarchy.\n  function visitPackage(packageJsonPath: string) {\n    const packageJson = require(packageJsonPath);\n\n    // Prevent getting into the recursive loop.\n    if (visitedPackages.has(packageJson.name)) {\n      return;\n    }\n    visitedPackages.add(packageJson.name);\n\n    // Iterate over the dependencies to find transitive modules.\n    for (const dependencyName in packageJson.dependencies) {\n      const dependencyResult = results[dependencyName];\n\n      if (!filteredResults[dependencyName]) {\n        let dependencyPackageJsonPath: string;\n\n        if (dependencyResult) {\n          filteredResults[dependencyName] = dependencyResult;\n          dependencyPackageJsonPath = path.join(dependencyResult.path, 'package.json');\n        } else {\n          try {\n            /**\n             * Custom `require` that resolves from the current working dir instead of this script path.\n             * **Requires Node v12.2.0**\n             */\n            const projectRequire = createRequire(packageJsonPath);\n            dependencyPackageJsonPath = projectRequire.resolve(`${dependencyName}/package.json`);\n          } catch (error: any) {\n            // Some packages don't include package.json in its `exports` field,\n            // but none of our packages do that, so it seems fine to just ignore that type of error.\n            // Related issue: https://github.com/react-native-community/cli/issues/1168\n            if (!options.silent && error.code !== 'ERR_PACKAGE_PATH_NOT_EXPORTED') {\n              console.warn(\n                chalk.yellow(`⚠️  Cannot resolve the path to \"${dependencyName}\" package.`)\n              );\n            }\n            continue;\n          }\n        }\n\n        // Visit the dependency package.\n        visitPackage(dependencyPackageJsonPath);\n      }\n    }\n  }\n\n  // Visit project's package.\n  visitPackage(projectPackageJsonPath);\n\n  return filteredResults;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}