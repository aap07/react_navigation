{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _debug = _interopRequireDefault(require(\"debug\"));\nvar fs = _interopRequireWildcard(require(\"fs\"));\nvar path = _interopRequireWildcard(require(\"path\"));\nvar _util = require(\"util\");\nvar _errors = require(\"../../../../utils/errors\");\nvar _afcprotocol = require(\"../protocol/AFCProtocol\");\nvar _serviceClient = require(\"./ServiceClient\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nvar debug = (0, _debug).default(\"expo:apple-device:client:afc\");\nvar MAX_OPEN_FILES = 240;\nvar AFCClient = function (_serviceClient$Servic) {\n  _inherits(AFCClient, _serviceClient$Servic);\n  var _super = _createSuper(AFCClient);\n  function AFCClient(socket) {\n    var _this2;\n    _classCallCheck(this, AFCClient);\n    _this2 = _super.call(this, socket, new _afcprotocol.AFCProtocolClient(socket));\n    _this2.socket = socket;\n    return _this2;\n  }\n  _createClass(AFCClient, [{\n    key: \"getFileInfo\",\n    value: function () {\n      var _getFileInfo = _asyncToGenerator(function* (path1) {\n        debug(`getFileInfo: ${path1}`);\n        var response = yield this.protocolClient.sendMessage({\n          operation: _afcprotocol.AFC_OPS.GET_FILE_INFO,\n          data: toCString(path1)\n        });\n        debug(`getFileInfo:response: %O`, response);\n        var strings = [];\n        var currentString = \"\";\n        var tokens = response.data;\n        tokens.forEach(function (token) {\n          if (token === 0) {\n            strings.push(currentString);\n            currentString = \"\";\n          } else {\n            currentString += String.fromCharCode(token);\n          }\n        });\n        return strings;\n      });\n      function getFileInfo(_x) {\n        return _getFileInfo.apply(this, arguments);\n      }\n      return getFileInfo;\n    }()\n  }, {\n    key: \"writeFile\",\n    value: function () {\n      var _writeFile = _asyncToGenerator(function* (fd, data) {\n        debug(`writeFile: ${Array.prototype.toString.call(fd)} data size: ${data.length}`);\n        var response = yield this.protocolClient.sendMessage({\n          operation: _afcprotocol.AFC_OPS.FILE_WRITE,\n          data: fd,\n          payload: data\n        });\n        debug(`writeFile:response:`, response);\n        return response;\n      });\n      function writeFile(_x2, _x3) {\n        return _writeFile.apply(this, arguments);\n      }\n      return writeFile;\n    }()\n  }, {\n    key: \"openFile\",\n    value: function () {\n      var _openFile = _asyncToGenerator(function* (path2) {\n        debug(`openFile: ${path2}`);\n        var data = Buffer.alloc(8 + path2.length + 1);\n        data.writeUInt32LE(_afcprotocol.AFC_FILE_OPEN_FLAGS.WRONLY, 0);\n        toCString(path2).copy(data, 8);\n        var response = yield this.protocolClient.sendMessage({\n          operation: _afcprotocol.AFC_OPS.FILE_OPEN,\n          data: data\n        });\n        if (response.operation === _afcprotocol.AFC_OPS.FILE_OPEN_RES) {\n          return response.data;\n        }\n        throw new _errors.CommandError(\"APPLE_DEVICE_AFC\", `There was an unknown error opening file ${path2}, response: ${Array.prototype.toString.call(response.data)}`);\n      });\n      function openFile(_x4) {\n        return _openFile.apply(this, arguments);\n      }\n      return openFile;\n    }()\n  }, {\n    key: \"closeFile\",\n    value: function () {\n      var _closeFile = _asyncToGenerator(function* (fd) {\n        debug(`closeFile fd: ${Array.prototype.toString.call(fd)}`);\n        var response = yield this.protocolClient.sendMessage({\n          operation: _afcprotocol.AFC_OPS.FILE_CLOSE,\n          data: fd\n        });\n        debug(`closeFile:response:`, response);\n        return response;\n      });\n      function closeFile(_x5) {\n        return _closeFile.apply(this, arguments);\n      }\n      return closeFile;\n    }()\n  }, {\n    key: \"uploadFile\",\n    value: function () {\n      var _uploadFile = _asyncToGenerator(function* (srcPath, destPath) {\n        debug(`uploadFile: ${srcPath}, ${destPath}`);\n        var _yield$Promise$all = yield Promise.all([yield (0, _util).promisify(fs.readFile)(srcPath), yield this.openFile(destPath)]),\n          _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2),\n          srcFile = _yield$Promise$all2[0],\n          destFile = _yield$Promise$all2[1];\n        try {\n          yield this.writeFile(destFile, srcFile);\n          yield this.closeFile(destFile);\n        } catch (err) {\n          yield this.closeFile(destFile);\n          throw err;\n        }\n      });\n      function uploadFile(_x6, _x7) {\n        return _uploadFile.apply(this, arguments);\n      }\n      return uploadFile;\n    }()\n  }, {\n    key: \"makeDirectory\",\n    value: function () {\n      var _makeDirectory = _asyncToGenerator(function* (path3) {\n        debug(`makeDirectory: ${path3}`);\n        var response = yield this.protocolClient.sendMessage({\n          operation: _afcprotocol.AFC_OPS.MAKE_DIR,\n          data: toCString(path3)\n        });\n        debug(`makeDirectory:response:`, response);\n        return response;\n      });\n      function makeDirectory(_x8) {\n        return _makeDirectory.apply(this, arguments);\n      }\n      return makeDirectory;\n    }()\n  }, {\n    key: \"uploadDirectory\",\n    value: function () {\n      var _uploadDirectory = _asyncToGenerator(function* (srcPath, destPath) {\n        debug(`uploadDirectory: ${srcPath}`);\n        yield this.makeDirectory(destPath);\n        var numOpenFiles = 0;\n        var pendingFileUploads = [];\n        var _this = this;\n        return uploadDir(srcPath);\n        function uploadDir(_x11) {\n          return _uploadDir.apply(this, arguments);\n        }\n        function _uploadDir() {\n          _uploadDir = _asyncToGenerator(function* (dirPath) {\n            var promises = [];\n            var _loop = function* _loop() {\n              var filePath = path.join(dirPath, file);\n              var remotePath = path.join(destPath, path.relative(srcPath, filePath));\n              if (fs.lstatSync(filePath).isDirectory()) {\n                promises.push(_this.makeDirectory(remotePath).then(function () {\n                  return uploadDir(filePath);\n                }));\n              } else {\n                var resolve;\n                var reject;\n                var promise = new Promise(function (res, rej) {\n                  resolve = res;\n                  reject = rej;\n                });\n                promises.push(promise);\n                var uploadFile = function uploadFile() {\n                  var tries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n                  numOpenFiles++;\n                  _this.uploadFile(filePath, remotePath).then(function () {\n                    resolve();\n                    numOpenFiles--;\n                    var fn = pendingFileUploads.pop();\n                    if (fn) {\n                      fn();\n                    }\n                  }).catch(function (err) {\n                    if (err.status === _afcprotocol.AFC_STATUS.NO_RESOURCES && tries < 10) {\n                      debug(`Received NO_RESOURCES from AFC, retrying ${filePath} upload. ${tries}`);\n                      uploadFile(tries++);\n                    } else {\n                      numOpenFiles--;\n                      reject(err);\n                    }\n                  });\n                };\n                if (numOpenFiles < MAX_OPEN_FILES) {\n                  uploadFile();\n                } else {\n                  debug(`numOpenFiles >= ${MAX_OPEN_FILES}, adding to pending queue. Length: ${pendingFileUploads.length}`);\n                  pendingFileUploads.push(uploadFile);\n                }\n              }\n            };\n            for (var file of fs.readdirSync(dirPath)) {\n              yield* _loop();\n            }\n            yield Promise.all(promises);\n          });\n          return _uploadDir.apply(this, arguments);\n        }\n      });\n      function uploadDirectory(_x9, _x10) {\n        return _uploadDirectory.apply(this, arguments);\n      }\n      return uploadDirectory;\n    }()\n  }]);\n  return AFCClient;\n}(_serviceClient.ServiceClient);\nexports.AFCClient = AFCClient;\nfunction toCString(s) {\n  var buf = Buffer.alloc(s.length + 1);\n  var len = buf.write(s);\n  buf.writeUInt8(0, len);\n  return buf;\n}","map":{"version":3,"names":["_slicedToArray","require","_asyncToGenerator","_classCallCheck","_createClass","_inherits","_possibleConstructorReturn","_getPrototypeOf","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","constructor","Reflect","construct","arguments","apply","sham","Proxy","Boolean","prototype","valueOf","call","e","_debug","_interopRequireDefault","fs","_interopRequireWildcard","path","_util","_errors","_afcprotocol","_serviceClient","debug","default","MAX_OPEN_FILES","AFCClient","_serviceClient$Servic","_super","socket","_this2","AFCProtocolClient","key","value","_getFileInfo","path1","response","protocolClient","sendMessage","operation","AFC_OPS","GET_FILE_INFO","data","toCString","strings","currentString","tokens","forEach","token","push","String","fromCharCode","getFileInfo","_x","_writeFile","fd","Array","toString","length","FILE_WRITE","payload","writeFile","_x2","_x3","_openFile","path2","Buffer","alloc","writeUInt32LE","AFC_FILE_OPEN_FLAGS","WRONLY","copy","FILE_OPEN","FILE_OPEN_RES","CommandError","openFile","_x4","_closeFile","FILE_CLOSE","closeFile","_x5","_uploadFile","srcPath","destPath","_yield$Promise$all","Promise","all","promisify","readFile","_yield$Promise$all2","srcFile","destFile","err","uploadFile","_x6","_x7","_makeDirectory","path3","MAKE_DIR","makeDirectory","_x8","_uploadDirectory","numOpenFiles","pendingFileUploads","_this","uploadDir","_x11","_uploadDir","dirPath","promises","_loop","filePath","join","file","remotePath","relative","lstatSync","isDirectory","then","resolve","reject","promise","res","rej","tries","undefined","fn","pop","catch","status","AFC_STATUS","NO_RESOURCES","readdirSync","uploadDirectory","_x9","_x10","ServiceClient","s","buf","len","write","writeUInt8"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\cli\\src\\run\\ios\\appleDevice\\client\\AFCClient.ts"],"sourcesContent":["/**\n * Copyright (c) 2021 Expo, Inc.\n * Copyright (c) 2018 Drifty Co.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport Debug from 'debug';\nimport * as fs from 'fs';\nimport { Socket } from 'net';\nimport * as path from 'path';\nimport { promisify } from 'util';\n\nimport { CommandError } from '../../../../utils/errors';\nimport {\n  AFC_FILE_OPEN_FLAGS,\n  AFC_OPS,\n  AFC_STATUS,\n  AFCError,\n  AFCProtocolClient,\n  AFCResponse,\n} from '../protocol/AFCProtocol';\nimport { ServiceClient } from './ServiceClient';\n\nconst debug = Debug('expo:apple-device:client:afc');\nconst MAX_OPEN_FILES = 240;\n\nexport class AFCClient extends ServiceClient<AFCProtocolClient> {\n  constructor(public socket: Socket) {\n    super(socket, new AFCProtocolClient(socket));\n  }\n\n  async getFileInfo(path: string): Promise<string[]> {\n    debug(`getFileInfo: ${path}`);\n\n    const response = await this.protocolClient.sendMessage({\n      operation: AFC_OPS.GET_FILE_INFO,\n      data: toCString(path),\n    });\n    debug(`getFileInfo:response: %O`, response);\n\n    const strings: string[] = [];\n    let currentString = '';\n    const tokens = response.data;\n    tokens.forEach((token) => {\n      if (token === 0) {\n        strings.push(currentString);\n        currentString = '';\n      } else {\n        currentString += String.fromCharCode(token);\n      }\n    });\n    return strings;\n  }\n\n  async writeFile(fd: Buffer, data: Buffer): Promise<AFCResponse> {\n    debug(`writeFile: ${Array.prototype.toString.call(fd)} data size: ${data.length}`);\n\n    const response = await this.protocolClient.sendMessage({\n      operation: AFC_OPS.FILE_WRITE,\n      data: fd,\n      payload: data,\n    });\n\n    debug(`writeFile:response:`, response);\n    return response;\n  }\n\n  protected async openFile(path: string): Promise<Buffer> {\n    debug(`openFile: ${path}`);\n    // mode + path + null terminator\n    const data = Buffer.alloc(8 + path.length + 1);\n    // write mode\n    data.writeUInt32LE(AFC_FILE_OPEN_FLAGS.WRONLY, 0);\n    // then path to file\n    toCString(path).copy(data, 8);\n\n    const response = await this.protocolClient.sendMessage({\n      operation: AFC_OPS.FILE_OPEN,\n      data,\n    });\n\n    // debug(`openFile:response:`, response);\n\n    if (response.operation === AFC_OPS.FILE_OPEN_RES) {\n      return response.data;\n    }\n\n    throw new CommandError(\n      'APPLE_DEVICE_AFC',\n      `There was an unknown error opening file ${path}, response: ${Array.prototype.toString.call(\n        response.data\n      )}`\n    );\n  }\n\n  protected async closeFile(fd: Buffer): Promise<AFCResponse> {\n    debug(`closeFile fd: ${Array.prototype.toString.call(fd)}`);\n    const response = await this.protocolClient.sendMessage({\n      operation: AFC_OPS.FILE_CLOSE,\n      data: fd,\n    });\n\n    debug(`closeFile:response:`, response);\n    return response;\n  }\n\n  protected async uploadFile(srcPath: string, destPath: string): Promise<void> {\n    debug(`uploadFile: ${srcPath}, ${destPath}`);\n\n    // read local file and get fd of destination\n    const [srcFile, destFile] = await Promise.all([\n      await promisify(fs.readFile)(srcPath),\n      await this.openFile(destPath),\n    ]);\n\n    try {\n      await this.writeFile(destFile, srcFile);\n      await this.closeFile(destFile);\n    } catch (err) {\n      await this.closeFile(destFile);\n      throw err;\n    }\n  }\n\n  async makeDirectory(path: string): Promise<AFCResponse> {\n    debug(`makeDirectory: ${path}`);\n\n    const response = await this.protocolClient.sendMessage({\n      operation: AFC_OPS.MAKE_DIR,\n      data: toCString(path),\n    });\n\n    debug(`makeDirectory:response:`, response);\n    return response;\n  }\n\n  async uploadDirectory(srcPath: string, destPath: string): Promise<void> {\n    debug(`uploadDirectory: ${srcPath}`);\n    await this.makeDirectory(destPath);\n\n    // AFC doesn't seem to give out more than 240 file handles,\n    // so we delay any requests that would push us over until more open up\n    let numOpenFiles = 0;\n    const pendingFileUploads: (() => void)[] = [];\n    const _this = this;\n    return uploadDir(srcPath);\n\n    async function uploadDir(dirPath: string): Promise<void> {\n      const promises: Promise<void>[] = [];\n      for (const file of fs.readdirSync(dirPath)) {\n        const filePath = path.join(dirPath, file);\n        const remotePath = path.join(destPath, path.relative(srcPath, filePath));\n        if (fs.lstatSync(filePath).isDirectory()) {\n          promises.push(_this.makeDirectory(remotePath).then(() => uploadDir(filePath)));\n        } else {\n          // Create promise to add to promises array\n          // this way it can be resolved once a pending upload has finished\n          let resolve: (val?: any) => void;\n          let reject: (err: AFCError) => void;\n          const promise = new Promise<void>((res, rej) => {\n            resolve = res;\n            reject = rej;\n          });\n          promises.push(promise);\n\n          // wrap upload in a function in case we need to save it for later\n          const uploadFile = (tries = 0) => {\n            numOpenFiles++;\n            _this\n              .uploadFile(filePath, remotePath)\n              .then(() => {\n                resolve();\n                numOpenFiles--;\n                const fn = pendingFileUploads.pop();\n                if (fn) {\n                  fn();\n                }\n              })\n              .catch((err: AFCError) => {\n                // Couldn't get fd for whatever reason, try again\n                // # of retries is arbitrary and can be adjusted\n                if (err.status === AFC_STATUS.NO_RESOURCES && tries < 10) {\n                  debug(`Received NO_RESOURCES from AFC, retrying ${filePath} upload. ${tries}`);\n                  uploadFile(tries++);\n                } else {\n                  numOpenFiles--;\n                  reject(err);\n                }\n              });\n          };\n\n          if (numOpenFiles < MAX_OPEN_FILES) {\n            uploadFile();\n          } else {\n            debug(\n              `numOpenFiles >= ${MAX_OPEN_FILES}, adding to pending queue. Length: ${pendingFileUploads.length}`\n            );\n            pendingFileUploads.push(uploadFile);\n          }\n        }\n      }\n      await Promise.all(promises);\n    }\n  }\n}\n\nfunction toCString(s: string) {\n  const buf = Buffer.alloc(s.length + 1);\n  const len = buf.write(s);\n  buf.writeUInt8(0, len);\n  return buf;\n}\n"],"mappings":"AAOA;;AAAA,IAAAA,cAAA,GAAAC,OAAA;AAAA,IAAAC,iBAAA,GAAAD,OAAA;AAAA,IAAAE,eAAA,GAAAF,OAAA;AAAA,IAAAG,YAAA,GAAAH,OAAA;AAAA,IAAAI,SAAA,GAAAJ,OAAA;AAAA,IAAAK,0BAAA,GAAAL,OAAA;AAAA,IAAAM,eAAA,GAAAN,OAAA;AAAA,SAAAO,aAAAC,OAAA,QAAAC,yBAAA,GAAAC,yBAAA,oBAAAC,qBAAA,QAAAC,KAAA,GAAAN,eAAA,CAAAE,OAAA,GAAAK,MAAA,MAAAJ,yBAAA,QAAAK,SAAA,GAAAR,eAAA,OAAAS,WAAA,EAAAF,MAAA,GAAAG,OAAA,CAAAC,SAAA,CAAAL,KAAA,EAAAM,SAAA,EAAAJ,SAAA,YAAAD,MAAA,GAAAD,KAAA,CAAAO,KAAA,OAAAD,SAAA,YAAAb,0BAAA,OAAAQ,MAAA;AAAA,SAAAH,0BAAA,eAAAM,OAAA,qBAAAA,OAAA,CAAAC,SAAA,oBAAAD,OAAA,CAAAC,SAAA,CAAAG,IAAA,2BAAAC,KAAA,oCAAAC,OAAA,CAAAC,SAAA,CAAAC,OAAA,CAAAC,IAAA,CAAAT,OAAA,CAAAC,SAAA,CAAAK,OAAA,8CAAAI,CAAA;;;;AAAkB,IAAAC,MAAO,GAAAC,sBAAA,CAAA5B,OAAA,CAAP,OAAO;AACb,IAAA6B,EAAE,GAAAC,uBAAA,CAAA9B,OAAA,CAAM,IAAI,EAAV;AAEF,IAAA+B,IAAI,GAAAD,uBAAA,CAAA9B,OAAA,CAAM,MAAM,EAAZ;AACU,IAAAgC,KAAM,GAAAhC,OAAA,CAAN,MAAM;AAEH,IAAAiC,OAA0B,GAAAjC,OAAA;AAQhD,IAAAkC,YAAyB,GAAAlC,OAAA;AACF,IAAAmC,cAAiB,GAAAnC,OAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAE/C,IAAMoC,KAAK,GAAG,IAAAT,MAAK,EAAgCU,OAAhC,CAAC,8BAA8B,CAAC;AACnD,IAAMC,cAAc,GAAG,GAAG;AAAC,IAEdC,SAAS,aAAAC,qBAAA;EAAApC,SAAA,CAAAmC,SAAA,EAAAC,qBAAA;EAAA,IAAAC,MAAA,GAAAlC,YAAA,CAAAgC,SAAA;EACpB,SAAAA,UAAmBG,MAAc,EAAE;IAAA,IAAAC,MAAA;IAAAzC,eAAA,OAAAqC,SAAA;IACjCI,MAAA,GAAAF,MAAA,CAAAhB,IAAA,OAAMiB,MAAM,EAAE,IAAIR,YAAiB,CAAAU,iBAAA,CAACF,MAAM,CAAC;WAD1BA,MAAc,GAAdA,MAAc;IAAA,OAAAC,MAAA;;EAEhCxC,YAAA,CAAAoC,SAAA;IAAAM,GAAA;IAAAC,KAAA;MAAA,IAAAC,YAAA,GAAA9C,iBAAA,CAED,WAAkB+C,KAAY,EAAqB;QACjDZ,KAAK,CAAE,gBAAeY,KAAK,EAAC,CAAC;QAE7B,IAAMC,QAAQ,SAAS,IAAI,CAACC,cAAc,CAACC,WAAW,CAAC;UACrDC,SAAS,EAAElB,YAAO,CAAAmB,OAAA,CAACC,aAAa;UAChCC,IAAI,EAAEC,SAAS,CAACR,KAAI;SACrB,CAAC;QACFZ,KAAK,CAAE,0BAAyB,EAAEa,QAAQ,CAAC;QAE3C,IAAMQ,OAAO,GAAa,EAAE;QAC5B,IAAIC,aAAa,GAAG,EAAE;QACtB,IAAMC,MAAM,GAAGV,QAAQ,CAACM,IAAI;QAC5BI,MAAM,CAACC,OAAO,CAAC,UAACC,KAAK,EAAK;UACxB,IAAIA,KAAK,KAAK,CAAC,EAAE;YACfJ,OAAO,CAACK,IAAI,CAACJ,aAAa,CAAC;YAC3BA,aAAa,GAAG,EAAE;WACnB,MAAM;YACLA,aAAa,IAAIK,MAAM,CAACC,YAAY,CAACH,KAAK,CAAC;;SAE9C,CAAC;QACF,OAAOJ,OAAO;OACf;MAAA,SAAAQ,YAAAC,EAAA;QAAA,OAAAnB,YAAA,CAAA5B,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAA+C,WAAA;IAAA;EAAA;IAAApB,GAAA;IAAAC,KAAA;MAAA,IAAAqB,UAAA,GAAAlE,iBAAA,CAED,WAAgBmE,EAAU,EAAEb,IAAY,EAAwB;QAC9DnB,KAAK,CAAE,cAAaiC,KAAK,CAAC9C,SAAS,CAAC+C,QAAQ,CAAC7C,IAAI,CAAC2C,EAAE,CAAE,eAAcb,IAAI,CAACgB,MAAO,EAAC,CAAC;QAElF,IAAMtB,QAAQ,SAAS,IAAI,CAACC,cAAc,CAACC,WAAW,CAAC;UACrDC,SAAS,EAAElB,YAAO,CAAAmB,OAAA,CAACmB,UAAU;UAC7BjB,IAAI,EAAEa,EAAE;UACRK,OAAO,EAAElB;SACV,CAAC;QAEFnB,KAAK,CAAE,qBAAoB,EAAEa,QAAQ,CAAC;QACtC,OAAOA,QAAQ;OAChB;MAAA,SAAAyB,UAAAC,GAAA,EAAAC,GAAA;QAAA,OAAAT,UAAA,CAAAhD,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAAwD,SAAA;IAAA;EAAA;IAAA7B,GAAA;IAAAC,KAAA;MAAA,IAAA+B,SAAA,GAAA5E,iBAAA,CAED,WAAyB6E,KAAY,EAAmB;QACtD1C,KAAK,CAAE,aAAY0C,KAAK,EAAC,CAAC;QAE1B,IAAMvB,IAAI,GAAGwB,MAAM,CAACC,KAAK,CAAC,CAAC,GAAGF,KAAI,CAACP,MAAM,GAAG,CAAC,CAAC;QAE9ChB,IAAI,CAAC0B,aAAa,CAAC/C,YAAmB,CAAAgD,mBAAA,CAACC,MAAM,EAAE,CAAC,CAAC;QAEjD3B,SAAS,CAACsB,KAAI,CAAC,CAACM,IAAI,CAAC7B,IAAI,EAAE,CAAC,CAAC;QAE7B,IAAMN,QAAQ,SAAS,IAAI,CAACC,cAAc,CAACC,WAAW,CAAC;UACrDC,SAAS,EAAElB,YAAO,CAAAmB,OAAA,CAACgC,SAAS;UAC5B9B,IAAI,EAAJA;SACD,CAAC;QAIF,IAAIN,QAAQ,CAACG,SAAS,KAAKlB,YAAO,CAAAmB,OAAA,CAACiC,aAAa,EAAE;UAChD,OAAOrC,QAAQ,CAACM,IAAI;;QAGtB,MAAM,IAAItB,OAAY,CAAAsD,YAAA,CACpB,kBAAkB,EACjB,2CAA0CT,KAAK,eAAcT,KAAK,CAAC9C,SAAS,CAAC+C,QAAQ,CAAC7C,IAAI,CACzFwB,QAAQ,CAACM,IAAI,CACb,EAAC,CACJ;OACF;MAAA,SAAAiC,SAAAC,GAAA;QAAA,OAAAZ,SAAA,CAAA1D,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAAsE,QAAA;IAAA;EAAA;IAAA3C,GAAA;IAAAC,KAAA;MAAA,IAAA4C,UAAA,GAAAzF,iBAAA,CAED,WAA0BmE,EAAU,EAAwB;QAC1DhC,KAAK,CAAE,iBAAgBiC,KAAK,CAAC9C,SAAS,CAAC+C,QAAQ,CAAC7C,IAAI,CAAC2C,EAAE,CAAE,EAAC,CAAC;QAC3D,IAAMnB,QAAQ,SAAS,IAAI,CAACC,cAAc,CAACC,WAAW,CAAC;UACrDC,SAAS,EAAElB,YAAO,CAAAmB,OAAA,CAACsC,UAAU;UAC7BpC,IAAI,EAAEa;SACP,CAAC;QAEFhC,KAAK,CAAE,qBAAoB,EAAEa,QAAQ,CAAC;QACtC,OAAOA,QAAQ;OAChB;MAAA,SAAA2C,UAAAC,GAAA;QAAA,OAAAH,UAAA,CAAAvE,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAA0E,SAAA;IAAA;EAAA;IAAA/C,GAAA;IAAAC,KAAA;MAAA,IAAAgD,WAAA,GAAA7F,iBAAA,CAED,WAA2B8F,OAAe,EAAEC,QAAgB,EAAiB;QAC3E5D,KAAK,CAAE,eAAc2D,OAAQ,KAAIC,QAAS,EAAC,CAAC;QAG5C,IAAAC,kBAAA,SAAkCC,OAAO,CAACC,GAAG,CAAC,OACtC,IAAAnE,KAAS,EAAaoE,SAAb,CAACvE,EAAE,CAACwE,QAAQ,CAAC,CAACN,OAAO,CAAC,QAC/B,IAAI,CAACP,QAAQ,CAACQ,QAAQ,CAAC,CAC9B,CAAC;UAAAM,mBAAA,GAAAvG,cAAA,CAAAkG,kBAAA;UAHKM,OAAO,GAAAD,mBAAA;UAAEE,QAAQ,GAAAF,mBAAA;QAKxB,IAAI;UACF,MAAM,IAAI,CAAC5B,SAAS,CAAC8B,QAAQ,EAAED,OAAO,CAAC;UACvC,MAAM,IAAI,CAACX,SAAS,CAACY,QAAQ,CAAC;SAC/B,CAAC,OAAOC,GAAG,EAAE;UACZ,MAAM,IAAI,CAACb,SAAS,CAACY,QAAQ,CAAC;UAC9B,MAAMC,GAAG;;OAEZ;MAAA,SAAAC,WAAAC,GAAA,EAAAC,GAAA;QAAA,OAAAd,WAAA,CAAA3E,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAAwF,UAAA;IAAA;EAAA;IAAA7D,GAAA;IAAAC,KAAA;MAAA,IAAA+D,cAAA,GAAA5G,iBAAA,CAED,WAAoB6G,KAAY,EAAwB;QACtD1E,KAAK,CAAE,kBAAiB0E,KAAK,EAAC,CAAC;QAE/B,IAAM7D,QAAQ,SAAS,IAAI,CAACC,cAAc,CAACC,WAAW,CAAC;UACrDC,SAAS,EAAElB,YAAO,CAAAmB,OAAA,CAAC0D,QAAQ;UAC3BxD,IAAI,EAAEC,SAAS,CAACsD,KAAI;SACrB,CAAC;QAEF1E,KAAK,CAAE,yBAAwB,EAAEa,QAAQ,CAAC;QAC1C,OAAOA,QAAQ;OAChB;MAAA,SAAA+D,cAAAC,GAAA;QAAA,OAAAJ,cAAA,CAAA1F,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAA8F,aAAA;IAAA;EAAA;IAAAnE,GAAA;IAAAC,KAAA;MAAA,IAAAoE,gBAAA,GAAAjH,iBAAA,CAED,WAAsB8F,OAAe,EAAEC,QAAgB,EAAiB;QACtE5D,KAAK,CAAE,oBAAmB2D,OAAQ,EAAC,CAAC;QACpC,MAAM,IAAI,CAACiB,aAAa,CAAChB,QAAQ,CAAC;QAIlC,IAAImB,YAAY,GAAG,CAAC;QACpB,IAAMC,kBAAkB,GAAmB,EAAE;QAC7C,IAAMC,KAAK,GAAG,IAAI;QAClB,OAAOC,SAAS,CAACvB,OAAO,CAAC;QAAC,SAEXuB,SAASA,CAAAC,IAAA;UAAA,OAAAC,UAAA,CAAArG,KAAA,OAAAD,SAAA;QAAA;QAAA,SAAAsG,WAAA;UAAAA,UAAA,GAAAvH,iBAAA,CAAxB,WAAyBwH,OAAe,EAAiB;YACvD,IAAMC,QAAQ,GAAoB,EAAE;YAAC,IAAAC,KAAA,aAAAA,MAAA,EACO;cAC1C,IAAMC,QAAQ,GAAG7F,IAAI,CAAC8F,IAAI,CAACJ,OAAO,EAAEK,IAAI,CAAC;cACzC,IAAMC,UAAU,GAAGhG,IAAI,CAAC8F,IAAI,CAAC7B,QAAQ,EAAEjE,IAAI,CAACiG,QAAQ,CAACjC,OAAO,EAAE6B,QAAQ,CAAC,CAAC;cACxE,IAAI/F,EAAE,CAACoG,SAAS,CAACL,QAAQ,CAAC,CAACM,WAAW,EAAE,EAAE;gBACxCR,QAAQ,CAAC5D,IAAI,CAACuD,KAAK,CAACL,aAAa,CAACe,UAAU,CAAC,CAACI,IAAI,CAAC;kBAAA,OAAMb,SAAS,CAACM,QAAQ,CAAC;gBAAA,EAAC,CAAC;eAC/E,MAAM;gBAGL,IAAIQ,OAAO;gBACX,IAAIC,MAAM;gBACV,IAAMC,OAAO,GAAG,IAAIpC,OAAO,CAAO,UAACqC,GAAG,EAAEC,GAAG,EAAK;kBAC9CJ,OAAO,GAAGG,GAAG;kBACbF,MAAM,GAAGG,GAAG;iBACb,CAAC;gBACFd,QAAQ,CAAC5D,IAAI,CAACwE,OAAO,CAAC;gBAGtB,IAAM5B,UAAU,GAAG,SAAbA,UAAUA,CAAA,EAAkB;kBAAA,IAAd+B,KAAK,GAAAvH,SAAA,CAAAqD,MAAA,QAAArD,SAAA,QAAAwH,SAAA,GAAAxH,SAAA,MAAG,CAAC;kBAC3BiG,YAAY,EAAE;kBACdE,KAAK,CACFX,UAAU,CAACkB,QAAQ,EAAEG,UAAU,CAAC,CAChCI,IAAI,CAAC,YAAM;oBACVC,OAAO,EAAE;oBACTjB,YAAY,EAAE;oBACd,IAAMwB,EAAE,GAAGvB,kBAAkB,CAACwB,GAAG,EAAE;oBACnC,IAAID,EAAE,EAAE;sBACNA,EAAE,EAAE;;mBAEP,CAAC,CACDE,KAAK,CAAC,UAACpC,GAAa,EAAK;oBAGxB,IAAIA,GAAG,CAACqC,MAAM,KAAK5G,YAAU,CAAA6G,UAAA,CAACC,YAAY,IAAIP,KAAK,GAAG,EAAE,EAAE;sBACxDrG,KAAK,CAAE,4CAA2CwF,QAAS,YAAWa,KAAM,EAAC,CAAC;sBAC9E/B,UAAU,CAAC+B,KAAK,EAAE,CAAC;qBACpB,MAAM;sBACLtB,YAAY,EAAE;sBACdkB,MAAM,CAAC5B,GAAG,CAAC;;mBAEd,CAAC;iBACL;gBAED,IAAIU,YAAY,GAAG7E,cAAc,EAAE;kBACjCoE,UAAU,EAAE;iBACb,MAAM;kBACLtE,KAAK,CACF,mBAAkBE,cAAe,sCAAqC8E,kBAAkB,CAAC7C,MAAO,EAAC,CACnG;kBACD6C,kBAAkB,CAACtD,IAAI,CAAC4C,UAAU,CAAC;;;aAGxC;YAnDD,KAAK,IAAMoB,IAAI,IAAIjG,EAAE,CAACoH,WAAW,CAACxB,OAAO,CAAC;cAAA,OAAAE,KAAA;YAAA;YAoD1C,MAAMzB,OAAO,CAACC,GAAG,CAACuB,QAAQ,CAAC;WAC5B;UAAA,OAAAF,UAAA,CAAArG,KAAA,OAAAD,SAAA;QAAA;OACF;MAAA,SAAAgI,gBAAAC,GAAA,EAAAC,IAAA;QAAA,OAAAlC,gBAAA,CAAA/F,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAAgI,eAAA;IAAA;EAAA;EAAA,OAAA3G,SAAA;AAAA,EAjL4BJ,cAAa,CAAAkH,aAAA;QAA/B9G,SAAS,GAATA,SAAS;AAoLtB,SAASiB,SAASA,CAAC8F,CAAS,EAAE;EAC5B,IAAMC,GAAG,GAAGxE,MAAM,CAACC,KAAK,CAACsE,CAAC,CAAC/E,MAAM,GAAG,CAAC,CAAC;EACtC,IAAMiF,GAAG,GAAGD,GAAG,CAACE,KAAK,CAACH,CAAC,CAAC;EACxBC,GAAG,CAACG,UAAU,CAAC,CAAC,EAAEF,GAAG,CAAC;EACtB,OAAOD,GAAG"},"metadata":{},"sourceType":"script","externalDependencies":[]}