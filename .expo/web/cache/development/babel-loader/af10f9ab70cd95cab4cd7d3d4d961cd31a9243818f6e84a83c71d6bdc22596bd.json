{"ast":null,"code":"'use strict';\n\nvar _require = require(\"./errors\"),\n  MisnamedModuleInterfaceParserError = _require.MisnamedModuleInterfaceParserError,\n  UnsupportedFunctionReturnTypeAnnotationParserError = _require.UnsupportedFunctionReturnTypeAnnotationParserError,\n  ModuleInterfaceNotFoundParserError = _require.ModuleInterfaceNotFoundParserError,\n  MoreThanOneModuleRegistryCallsParserError = _require.MoreThanOneModuleRegistryCallsParserError,\n  UnusedModuleInterfaceParserError = _require.UnusedModuleInterfaceParserError,\n  IncorrectModuleRegistryCallArityParserError = _require.IncorrectModuleRegistryCallArityParserError,\n  IncorrectModuleRegistryCallTypeParameterParserError = _require.IncorrectModuleRegistryCallTypeParameterParserError,\n  IncorrectModuleRegistryCallArgumentTypeParserError = _require.IncorrectModuleRegistryCallArgumentTypeParserError,\n  UnsupportedObjectPropertyValueTypeAnnotationParserError = _require.UnsupportedObjectPropertyValueTypeAnnotationParserError,\n  UntypedModuleRegistryCallParserError = _require.UntypedModuleRegistryCallParserError,\n  UnsupportedModulePropertyParserError = _require.UnsupportedModulePropertyParserError,\n  MoreThanOneModuleInterfaceParserError = _require.MoreThanOneModuleInterfaceParserError,\n  UnsupportedFunctionParamTypeAnnotationParserError = _require.UnsupportedFunctionParamTypeAnnotationParserError,\n  UnsupportedArrayElementTypeAnnotationParserError = _require.UnsupportedArrayElementTypeAnnotationParserError;\nfunction throwIfModuleInterfaceIsMisnamed(nativeModuleName, moduleSpecId, parserType) {\n  if (moduleSpecId.name !== 'Spec') {\n    throw new MisnamedModuleInterfaceParserError(nativeModuleName, moduleSpecId, parserType);\n  }\n}\nfunction throwIfModuleInterfaceNotFound(numberOfModuleSpecs, nativeModuleName, ast, parserType) {\n  if (numberOfModuleSpecs === 0) {\n    throw new ModuleInterfaceNotFoundParserError(nativeModuleName, ast, parserType);\n  }\n}\nfunction throwIfMoreThanOneModuleRegistryCalls(hasteModuleName, callExpressions, callExpressionsLength) {\n  if (callExpressions.length > 1) {\n    throw new MoreThanOneModuleRegistryCallsParserError(hasteModuleName, callExpressions, callExpressionsLength);\n  }\n}\nfunction throwIfUnusedModuleInterfaceParserError(nativeModuleName, moduleSpec, callExpressions) {\n  if (callExpressions.length === 0) {\n    throw new UnusedModuleInterfaceParserError(nativeModuleName, moduleSpec);\n  }\n}\nfunction throwIfWrongNumberOfCallExpressionArgs(nativeModuleName, flowCallExpression, methodName, numberOfCallExpressionArgs) {\n  if (numberOfCallExpressionArgs !== 1) {\n    throw new IncorrectModuleRegistryCallArityParserError(nativeModuleName, flowCallExpression, methodName, numberOfCallExpressionArgs);\n  }\n}\nfunction throwIfIncorrectModuleRegistryCallTypeParameterParserError(nativeModuleName, typeArguments, methodName, moduleName, parser) {\n  function throwError() {\n    throw new IncorrectModuleRegistryCallTypeParameterParserError(nativeModuleName, typeArguments, methodName, moduleName);\n  }\n  if (parser.checkIfInvalidModule(typeArguments)) {\n    throwError();\n  }\n}\nfunction throwIfUnsupportedFunctionReturnTypeAnnotationParserError(nativeModuleName, returnTypeAnnotation, invalidReturnType, cxxOnly, returnType) {\n  if (!cxxOnly && returnType === 'FunctionTypeAnnotation') {\n    throw new UnsupportedFunctionReturnTypeAnnotationParserError(nativeModuleName, returnTypeAnnotation.returnType, 'FunctionTypeAnnotation');\n  }\n}\nfunction throwIfUntypedModule(typeArguments, hasteModuleName, callExpression, methodName, moduleName) {\n  if (typeArguments == null) {\n    throw new UntypedModuleRegistryCallParserError(hasteModuleName, callExpression, methodName, moduleName);\n  }\n}\nfunction throwIfModuleTypeIsUnsupported(nativeModuleName, propertyValue, propertyName, propertyValueType, parser) {\n  if (!parser.functionTypeAnnotation(propertyValueType)) {\n    throw new UnsupportedModulePropertyParserError(nativeModuleName, propertyValue, propertyName, propertyValueType, parser.language());\n  }\n}\nvar UnsupportedObjectPropertyTypeToInvalidPropertyValueTypeMap = {\n  FunctionTypeAnnotation: 'FunctionTypeAnnotation',\n  VoidTypeAnnotation: 'void',\n  PromiseTypeAnnotation: 'Promise'\n};\nfunction throwIfPropertyValueTypeIsUnsupported(moduleName, propertyValue, propertyKey, type) {\n  var invalidPropertyValueType = UnsupportedObjectPropertyTypeToInvalidPropertyValueTypeMap[type];\n  throw new UnsupportedObjectPropertyValueTypeAnnotationParserError(moduleName, propertyValue, propertyKey, invalidPropertyValueType);\n}\nfunction throwIfMoreThanOneModuleInterfaceParserError(nativeModuleName, moduleSpecs, parserType) {\n  if (moduleSpecs.length > 1) {\n    throw new MoreThanOneModuleInterfaceParserError(nativeModuleName, moduleSpecs, moduleSpecs.map(function (node) {\n      return node.id.name;\n    }), parserType);\n  }\n}\nfunction throwIfUnsupportedFunctionParamTypeAnnotationParserError(nativeModuleName, languageParamTypeAnnotation, paramName, paramTypeAnnotationType) {\n  throw new UnsupportedFunctionParamTypeAnnotationParserError(nativeModuleName, languageParamTypeAnnotation, paramName, paramTypeAnnotationType);\n}\nfunction throwIfArrayElementTypeAnnotationIsUnsupported(hasteModuleName, flowElementType, flowArrayType, type) {\n  var TypeMap = {\n    FunctionTypeAnnotation: 'FunctionTypeAnnotation',\n    VoidTypeAnnotation: 'void',\n    PromiseTypeAnnotation: 'Promise',\n    UnionTypeAnnotation: 'UnionTypeAnnotation'\n  };\n  if (type in TypeMap) {\n    throw new UnsupportedArrayElementTypeAnnotationParserError(hasteModuleName, flowElementType, flowArrayType, TypeMap[type]);\n  }\n}\nfunction throwIfIncorrectModuleRegistryCallArgument(nativeModuleName, callExpressionArg, methodName) {\n  if (callExpressionArg.type !== 'StringLiteral' && callExpressionArg.type !== 'Literal') {\n    var type = callExpressionArg.type;\n    throw new IncorrectModuleRegistryCallArgumentTypeParserError(nativeModuleName, callExpressionArg, methodName, type);\n  }\n}\nfunction throwIfPartialNotAnnotatingTypeParameter(typeAnnotation, types, parser) {\n  var annotatedElement = parser.extractAnnotatedElement(typeAnnotation, types);\n  if (!annotatedElement) {\n    throw new Error('Partials only support annotating a type parameter.');\n  }\n}\nfunction throwIfPartialWithMoreParameter(typeAnnotation) {\n  if (typeAnnotation.typeParameters.params.length !== 1) {\n    throw new Error('Partials only support annotating exactly one parameter.');\n  }\n}\nfunction throwIfMoreThanOneCodegenNativecommands(commandsTypeNames) {\n  if (commandsTypeNames.length > 1) {\n    throw new Error('codegenNativeCommands may only be called once in a file');\n  }\n}\nmodule.exports = {\n  throwIfModuleInterfaceIsMisnamed: throwIfModuleInterfaceIsMisnamed,\n  throwIfUnsupportedFunctionReturnTypeAnnotationParserError: throwIfUnsupportedFunctionReturnTypeAnnotationParserError,\n  throwIfModuleInterfaceNotFound: throwIfModuleInterfaceNotFound,\n  throwIfMoreThanOneModuleRegistryCalls: throwIfMoreThanOneModuleRegistryCalls,\n  throwIfPropertyValueTypeIsUnsupported: throwIfPropertyValueTypeIsUnsupported,\n  throwIfUnusedModuleInterfaceParserError: throwIfUnusedModuleInterfaceParserError,\n  throwIfWrongNumberOfCallExpressionArgs: throwIfWrongNumberOfCallExpressionArgs,\n  throwIfIncorrectModuleRegistryCallTypeParameterParserError: throwIfIncorrectModuleRegistryCallTypeParameterParserError,\n  throwIfUntypedModule: throwIfUntypedModule,\n  throwIfModuleTypeIsUnsupported: throwIfModuleTypeIsUnsupported,\n  throwIfMoreThanOneModuleInterfaceParserError: throwIfMoreThanOneModuleInterfaceParserError,\n  throwIfUnsupportedFunctionParamTypeAnnotationParserError: throwIfUnsupportedFunctionParamTypeAnnotationParserError,\n  throwIfArrayElementTypeAnnotationIsUnsupported: throwIfArrayElementTypeAnnotationIsUnsupported,\n  throwIfIncorrectModuleRegistryCallArgument: throwIfIncorrectModuleRegistryCallArgument,\n  throwIfPartialNotAnnotatingTypeParameter: throwIfPartialNotAnnotatingTypeParameter,\n  throwIfPartialWithMoreParameter: throwIfPartialWithMoreParameter,\n  throwIfMoreThanOneCodegenNativecommands: throwIfMoreThanOneCodegenNativecommands\n};","map":{"version":3,"names":["_require","require","MisnamedModuleInterfaceParserError","UnsupportedFunctionReturnTypeAnnotationParserError","ModuleInterfaceNotFoundParserError","MoreThanOneModuleRegistryCallsParserError","UnusedModuleInterfaceParserError","IncorrectModuleRegistryCallArityParserError","IncorrectModuleRegistryCallTypeParameterParserError","IncorrectModuleRegistryCallArgumentTypeParserError","UnsupportedObjectPropertyValueTypeAnnotationParserError","UntypedModuleRegistryCallParserError","UnsupportedModulePropertyParserError","MoreThanOneModuleInterfaceParserError","UnsupportedFunctionParamTypeAnnotationParserError","UnsupportedArrayElementTypeAnnotationParserError","throwIfModuleInterfaceIsMisnamed","nativeModuleName","moduleSpecId","parserType","name","throwIfModuleInterfaceNotFound","numberOfModuleSpecs","ast","throwIfMoreThanOneModuleRegistryCalls","hasteModuleName","callExpressions","callExpressionsLength","length","throwIfUnusedModuleInterfaceParserError","moduleSpec","throwIfWrongNumberOfCallExpressionArgs","flowCallExpression","methodName","numberOfCallExpressionArgs","throwIfIncorrectModuleRegistryCallTypeParameterParserError","typeArguments","moduleName","parser","throwError","checkIfInvalidModule","throwIfUnsupportedFunctionReturnTypeAnnotationParserError","returnTypeAnnotation","invalidReturnType","cxxOnly","returnType","throwIfUntypedModule","callExpression","throwIfModuleTypeIsUnsupported","propertyValue","propertyName","propertyValueType","functionTypeAnnotation","language","UnsupportedObjectPropertyTypeToInvalidPropertyValueTypeMap","FunctionTypeAnnotation","VoidTypeAnnotation","PromiseTypeAnnotation","throwIfPropertyValueTypeIsUnsupported","propertyKey","type","invalidPropertyValueType","throwIfMoreThanOneModuleInterfaceParserError","moduleSpecs","map","node","id","throwIfUnsupportedFunctionParamTypeAnnotationParserError","languageParamTypeAnnotation","paramName","paramTypeAnnotationType","throwIfArrayElementTypeAnnotationIsUnsupported","flowElementType","flowArrayType","TypeMap","UnionTypeAnnotation","throwIfIncorrectModuleRegistryCallArgument","callExpressionArg","throwIfPartialNotAnnotatingTypeParameter","typeAnnotation","types","annotatedElement","extractAnnotatedElement","Error","throwIfPartialWithMoreParameter","typeParameters","params","throwIfMoreThanOneCodegenNativecommands","commandsTypeNames","module","exports"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native/codegen/lib/parsers/error-utils.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\n'use strict';\n\nconst _require = require('./errors'),\n  MisnamedModuleInterfaceParserError =\n    _require.MisnamedModuleInterfaceParserError,\n  UnsupportedFunctionReturnTypeAnnotationParserError =\n    _require.UnsupportedFunctionReturnTypeAnnotationParserError,\n  ModuleInterfaceNotFoundParserError =\n    _require.ModuleInterfaceNotFoundParserError,\n  MoreThanOneModuleRegistryCallsParserError =\n    _require.MoreThanOneModuleRegistryCallsParserError,\n  UnusedModuleInterfaceParserError = _require.UnusedModuleInterfaceParserError,\n  IncorrectModuleRegistryCallArityParserError =\n    _require.IncorrectModuleRegistryCallArityParserError,\n  IncorrectModuleRegistryCallTypeParameterParserError =\n    _require.IncorrectModuleRegistryCallTypeParameterParserError,\n  IncorrectModuleRegistryCallArgumentTypeParserError =\n    _require.IncorrectModuleRegistryCallArgumentTypeParserError,\n  UnsupportedObjectPropertyValueTypeAnnotationParserError =\n    _require.UnsupportedObjectPropertyValueTypeAnnotationParserError,\n  UntypedModuleRegistryCallParserError =\n    _require.UntypedModuleRegistryCallParserError,\n  UnsupportedModulePropertyParserError =\n    _require.UnsupportedModulePropertyParserError,\n  MoreThanOneModuleInterfaceParserError =\n    _require.MoreThanOneModuleInterfaceParserError,\n  UnsupportedFunctionParamTypeAnnotationParserError =\n    _require.UnsupportedFunctionParamTypeAnnotationParserError,\n  UnsupportedArrayElementTypeAnnotationParserError =\n    _require.UnsupportedArrayElementTypeAnnotationParserError;\nfunction throwIfModuleInterfaceIsMisnamed(\n  nativeModuleName,\n  moduleSpecId,\n  parserType,\n) {\n  if (moduleSpecId.name !== 'Spec') {\n    throw new MisnamedModuleInterfaceParserError(\n      nativeModuleName,\n      moduleSpecId,\n      parserType,\n    );\n  }\n}\nfunction throwIfModuleInterfaceNotFound(\n  numberOfModuleSpecs,\n  nativeModuleName,\n  ast,\n  parserType,\n) {\n  if (numberOfModuleSpecs === 0) {\n    throw new ModuleInterfaceNotFoundParserError(\n      nativeModuleName,\n      ast,\n      parserType,\n    );\n  }\n}\nfunction throwIfMoreThanOneModuleRegistryCalls(\n  hasteModuleName,\n  callExpressions,\n  callExpressionsLength,\n) {\n  if (callExpressions.length > 1) {\n    throw new MoreThanOneModuleRegistryCallsParserError(\n      hasteModuleName,\n      callExpressions,\n      callExpressionsLength,\n    );\n  }\n}\nfunction throwIfUnusedModuleInterfaceParserError(\n  nativeModuleName,\n  moduleSpec,\n  callExpressions,\n) {\n  if (callExpressions.length === 0) {\n    throw new UnusedModuleInterfaceParserError(nativeModuleName, moduleSpec);\n  }\n}\nfunction throwIfWrongNumberOfCallExpressionArgs(\n  nativeModuleName,\n  flowCallExpression,\n  methodName,\n  numberOfCallExpressionArgs,\n) {\n  if (numberOfCallExpressionArgs !== 1) {\n    throw new IncorrectModuleRegistryCallArityParserError(\n      nativeModuleName,\n      flowCallExpression,\n      methodName,\n      numberOfCallExpressionArgs,\n    );\n  }\n}\nfunction throwIfIncorrectModuleRegistryCallTypeParameterParserError(\n  nativeModuleName,\n  typeArguments,\n  methodName,\n  moduleName,\n  parser,\n) {\n  function throwError() {\n    throw new IncorrectModuleRegistryCallTypeParameterParserError(\n      nativeModuleName,\n      typeArguments,\n      methodName,\n      moduleName,\n    );\n  }\n  if (parser.checkIfInvalidModule(typeArguments)) {\n    throwError();\n  }\n}\nfunction throwIfUnsupportedFunctionReturnTypeAnnotationParserError(\n  nativeModuleName,\n  returnTypeAnnotation,\n  invalidReturnType,\n  cxxOnly,\n  returnType,\n) {\n  if (!cxxOnly && returnType === 'FunctionTypeAnnotation') {\n    throw new UnsupportedFunctionReturnTypeAnnotationParserError(\n      nativeModuleName,\n      returnTypeAnnotation.returnType,\n      'FunctionTypeAnnotation',\n    );\n  }\n}\nfunction throwIfUntypedModule(\n  typeArguments,\n  hasteModuleName,\n  callExpression,\n  methodName,\n  moduleName,\n) {\n  if (typeArguments == null) {\n    throw new UntypedModuleRegistryCallParserError(\n      hasteModuleName,\n      callExpression,\n      methodName,\n      moduleName,\n    );\n  }\n}\nfunction throwIfModuleTypeIsUnsupported(\n  nativeModuleName,\n  propertyValue,\n  propertyName,\n  propertyValueType,\n  parser,\n) {\n  if (!parser.functionTypeAnnotation(propertyValueType)) {\n    throw new UnsupportedModulePropertyParserError(\n      nativeModuleName,\n      propertyValue,\n      propertyName,\n      propertyValueType,\n      parser.language(),\n    );\n  }\n}\nconst UnsupportedObjectPropertyTypeToInvalidPropertyValueTypeMap = {\n  FunctionTypeAnnotation: 'FunctionTypeAnnotation',\n  VoidTypeAnnotation: 'void',\n  PromiseTypeAnnotation: 'Promise',\n};\nfunction throwIfPropertyValueTypeIsUnsupported(\n  moduleName,\n  propertyValue,\n  propertyKey,\n  type,\n) {\n  const invalidPropertyValueType =\n    UnsupportedObjectPropertyTypeToInvalidPropertyValueTypeMap[type];\n  throw new UnsupportedObjectPropertyValueTypeAnnotationParserError(\n    moduleName,\n    propertyValue,\n    propertyKey,\n    invalidPropertyValueType,\n  );\n}\nfunction throwIfMoreThanOneModuleInterfaceParserError(\n  nativeModuleName,\n  moduleSpecs,\n  parserType,\n) {\n  if (moduleSpecs.length > 1) {\n    throw new MoreThanOneModuleInterfaceParserError(\n      nativeModuleName,\n      moduleSpecs,\n      moduleSpecs.map(node => node.id.name),\n      parserType,\n    );\n  }\n}\nfunction throwIfUnsupportedFunctionParamTypeAnnotationParserError(\n  nativeModuleName,\n  languageParamTypeAnnotation,\n  paramName,\n  paramTypeAnnotationType,\n) {\n  throw new UnsupportedFunctionParamTypeAnnotationParserError(\n    nativeModuleName,\n    languageParamTypeAnnotation,\n    paramName,\n    paramTypeAnnotationType,\n  );\n}\nfunction throwIfArrayElementTypeAnnotationIsUnsupported(\n  hasteModuleName,\n  flowElementType,\n  flowArrayType,\n  type,\n) {\n  const TypeMap = {\n    FunctionTypeAnnotation: 'FunctionTypeAnnotation',\n    VoidTypeAnnotation: 'void',\n    PromiseTypeAnnotation: 'Promise',\n    // TODO: Added as a work-around for now until TupleTypeAnnotation are fully supported in both flow and TS\n    // Right now they are partially treated as UnionTypeAnnotation\n    UnionTypeAnnotation: 'UnionTypeAnnotation',\n  };\n  if (type in TypeMap) {\n    throw new UnsupportedArrayElementTypeAnnotationParserError(\n      hasteModuleName,\n      flowElementType,\n      flowArrayType,\n      TypeMap[type],\n    );\n  }\n}\nfunction throwIfIncorrectModuleRegistryCallArgument(\n  nativeModuleName,\n  callExpressionArg,\n  methodName,\n) {\n  if (\n    callExpressionArg.type !== 'StringLiteral' &&\n    callExpressionArg.type !== 'Literal'\n  ) {\n    const type = callExpressionArg.type;\n    throw new IncorrectModuleRegistryCallArgumentTypeParserError(\n      nativeModuleName,\n      callExpressionArg,\n      methodName,\n      type,\n    );\n  }\n}\nfunction throwIfPartialNotAnnotatingTypeParameter(\n  typeAnnotation,\n  types,\n  parser,\n) {\n  const annotatedElement = parser.extractAnnotatedElement(\n    typeAnnotation,\n    types,\n  );\n  if (!annotatedElement) {\n    throw new Error('Partials only support annotating a type parameter.');\n  }\n}\nfunction throwIfPartialWithMoreParameter(typeAnnotation) {\n  if (typeAnnotation.typeParameters.params.length !== 1) {\n    throw new Error('Partials only support annotating exactly one parameter.');\n  }\n}\nfunction throwIfMoreThanOneCodegenNativecommands(commandsTypeNames) {\n  if (commandsTypeNames.length > 1) {\n    throw new Error('codegenNativeCommands may only be called once in a file');\n  }\n}\nmodule.exports = {\n  throwIfModuleInterfaceIsMisnamed,\n  throwIfUnsupportedFunctionReturnTypeAnnotationParserError,\n  throwIfModuleInterfaceNotFound,\n  throwIfMoreThanOneModuleRegistryCalls,\n  throwIfPropertyValueTypeIsUnsupported,\n  throwIfUnusedModuleInterfaceParserError,\n  throwIfWrongNumberOfCallExpressionArgs,\n  throwIfIncorrectModuleRegistryCallTypeParameterParserError,\n  throwIfUntypedModule,\n  throwIfModuleTypeIsUnsupported,\n  throwIfMoreThanOneModuleInterfaceParserError,\n  throwIfUnsupportedFunctionParamTypeAnnotationParserError,\n  throwIfArrayElementTypeAnnotationIsUnsupported,\n  throwIfIncorrectModuleRegistryCallArgument,\n  throwIfPartialNotAnnotatingTypeParameter,\n  throwIfPartialWithMoreParameter,\n  throwIfMoreThanOneCodegenNativecommands,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}