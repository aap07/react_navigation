{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getFilePathForExternalSource = exports.parsePodfileLock = exports.parsePodDependency = exports.loadPodfileLock = void 0;\nvar js_yaml_1 = require(\"js-yaml\");\nvar EXTERNAL_SOURCES_KEY = 'EXTERNAL SOURCES';\nfunction loadPodfileLock(str) {\n  var contents = js_yaml_1.load(str);\n  if (!contents || typeof contents !== 'object') {\n    return null;\n  }\n  return contents;\n}\nexports.loadPodfileLock = loadPodfileLock;\nexports.parsePodDependency = function (pod) {\n  if (typeof pod === 'string') {\n    var singleItemArrayBug = pod.match(/(.*)\\s-\\s(.*)/);\n    if (singleItemArrayBug === null || singleItemArrayBug === void 0 ? void 0 : singleItemArrayBug[2]) {\n      return exports.parsePodDependency(_defineProperty({}, singleItemArrayBug[1], singleItemArrayBug[2]));\n    }\n    return [splitPodNameVersion(pod)];\n  }\n  return Object.entries(pod).map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      k = _ref2[0],\n      v = _ref2[1];\n    var results = splitPodNameVersion(k);\n    if (Array.isArray(v)) {\n      return _objectSpread(_objectSpread({}, results), {}, {\n        dependencies: v.map(function (x) {\n          return exports.parsePodDependency(x);\n        }).flat()\n      });\n    } else if (typeof v === 'string') {\n      return _objectSpread(_objectSpread({}, results), {}, {\n        dependencies: exports.parsePodDependency(v)\n      });\n    }\n    return results;\n  });\n};\nfunction parsePodfileLock(fileContent) {\n  var _a;\n  var contents = (_a = loadPodfileLock(fileContent)) !== null && _a !== void 0 ? _a : loadPodfileLock(EXTERNAL_SOURCES_KEY + fileContent.split(EXTERNAL_SOURCES_KEY).slice(1));\n  if (!contents) {\n    return null;\n  }\n  var parsed = Object.entries(contents).reduce(function (acc, _ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n      key = _ref4[0],\n      value = _ref4[1];\n    return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, kebabCaseToCamelCase(rubyCaseToKebab(key)), value));\n  }, {});\n  if (Array.isArray(parsed.pods)) {\n    var parsedPods = parsed.pods.map(exports.parsePodDependency);\n    parsed.pods = parsedPods.flat();\n  }\n  return parsed;\n}\nexports.parsePodfileLock = parsePodfileLock;\nfunction splitPodNameVersion(pod) {\n  var _a;\n  var _pod$split = pod.split(' '),\n    _pod$split2 = _slicedToArray(_pod$split, 1),\n    name = _pod$split2[0];\n  return {\n    name: name,\n    version: (_a = pod.match(/\\((.*)\\)/)) === null || _a === void 0 ? void 0 : _a[1]\n  };\n}\nfunction rubyCaseToKebab(str) {\n  return str.toLowerCase().split(' ').join('-');\n}\nfunction kebabCaseToCamelCase(str) {\n  return str.replace(/-([a-z])/g, function (g) {\n    return g[1].toUpperCase();\n  });\n}\nfunction getFilePathForExternalSource(podLock, pod) {\n  var _a, _b, _c;\n  var source = (_a = podLock.externalSources) === null || _a === void 0 ? void 0 : _a[pod];\n  return (_c = (_b = source === null || source === void 0 ? void 0 : source[':podspec']) !== null && _b !== void 0 ? _b : source === null || source === void 0 ? void 0 : source[':path']) !== null && _c !== void 0 ? _c : null;\n}\nexports.getFilePathForExternalSource = getFilePathForExternalSource;","map":{"version":3,"names":["js_yaml_1","require","EXTERNAL_SOURCES_KEY","loadPodfileLock","str","contents","load","exports","parsePodDependency","pod","singleItemArrayBug","match","_defineProperty","splitPodNameVersion","Object","entries","map","_ref","_ref2","_slicedToArray","k","v","results","Array","isArray","_objectSpread","dependencies","x","flat","parsePodfileLock","fileContent","_a","split","slice","parsed","reduce","acc","_ref3","_ref4","key","value","kebabCaseToCamelCase","rubyCaseToKebab","pods","parsedPods","_pod$split","_pod$split2","name","version","toLowerCase","join","replace","g","toUpperCase","getFilePathForExternalSource","podLock","source","externalSources","_c","_b"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\xcpretty\\src\\utils\\parsePodfileLock.ts"],"sourcesContent":["import { load } from 'js-yaml';\n\nconst EXTERNAL_SOURCES_KEY = 'EXTERNAL SOURCES';\n\nexport interface PodDependency {\n  name: string;\n  version?: string;\n  dependencies?: PodDependency[];\n}\n\nexport interface ExternalSource {\n  /** \"../node_modules/react-native/third-party-podspecs/DoubleConversion.podspec\" */\n  ':podspec'?: string;\n  /** \"../node_modules/expo-application/ios\" */\n  ':path'?: string;\n}\n\nexport interface PodfileLock {\n  pods?: PodDependency[];\n  /** \"1.11.2\" */\n  cocoapods?: string;\n  externalSources?: Record<string, ExternalSource>;\n  /** 73e35020f8f5d49ffd32debe3c1bdd501f8029a6 */\n  podfileChecksum?: string;\n  /** { \"DoubleConversion\": \"cf9b38bf0b2d048436d9a82ad2abe1404f11e7de\" } */\n  specChecksums?: Record<string, string>;\n}\n\n/**\n * Parses a podfile.lock file from from YAML into a JSON object.\n *\n * @param str Podfile.lock file contents in YAML format.\n * @returns\n */\nexport function loadPodfileLock(str: string): null | Record<string, any> {\n  const contents = load(str);\n  if (!contents || typeof contents !== 'object') {\n    return null;\n  }\n  return contents;\n}\n\nexport const parsePodDependency = (\n  pod: string | Record<string, string | Record<string, any>>\n): PodDependency[] => {\n  if (typeof pod === 'string') {\n    // js-yaml fails to parse an array with a single item and instead formats it as a string divided by a `-` (hyphen).\n    // Here we match if a hyphen comes after a space. We use fake-nested-Podfile to test this hack.\n    const singleItemArrayBug = pod.match(/(.*)\\s-\\s(.*)/);\n    if (singleItemArrayBug?.[2]) {\n      return parsePodDependency({ [singleItemArrayBug[1]]: singleItemArrayBug[2] });\n    }\n\n    return [splitPodNameVersion(pod)];\n  }\n  return Object.entries(pod).map(([k, v]) => {\n    const results = splitPodNameVersion(k);\n\n    if (Array.isArray(v)) {\n      return {\n        ...results,\n        dependencies: v.map(x => parsePodDependency(x)).flat(),\n      };\n    } else if (typeof v === 'string') {\n      return {\n        ...results,\n        dependencies: parsePodDependency(v),\n      };\n    }\n\n    return results;\n  });\n};\n\nexport function parsePodfileLock(fileContent: string): PodfileLock | null {\n  const contents =\n    loadPodfileLock(fileContent) ??\n    loadPodfileLock(EXTERNAL_SOURCES_KEY + fileContent.split(EXTERNAL_SOURCES_KEY).slice(1));\n  if (!contents) {\n    return null;\n  }\n\n  const parsed = Object.entries(contents).reduce((acc, [key, value]) => {\n    return {\n      ...acc,\n      [kebabCaseToCamelCase(rubyCaseToKebab(key))]: value,\n    };\n  }, {}) as any;\n\n  if (Array.isArray(parsed.pods)) {\n    const parsedPods = parsed.pods.map(parsePodDependency);\n    parsed.pods = parsedPods.flat();\n  }\n\n  return parsed;\n}\n\nfunction splitPodNameVersion(pod: string): { name: string; version?: string } {\n  const [name] = pod.split(' ');\n  return { name, version: pod.match(/\\((.*)\\)/)?.[1] };\n}\n\nfunction rubyCaseToKebab(str: string) {\n  return str.toLowerCase().split(' ').join('-');\n}\n\nfunction kebabCaseToCamelCase(str: string) {\n  return str.replace(/-([a-z])/g, g => g[1].toUpperCase());\n}\n\nexport function getFilePathForExternalSource(podLock: PodfileLock, pod: string): string | null {\n  const source = podLock.externalSources?.[pod];\n  return source?.[':podspec'] ?? source?.[':path'] ?? null;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}