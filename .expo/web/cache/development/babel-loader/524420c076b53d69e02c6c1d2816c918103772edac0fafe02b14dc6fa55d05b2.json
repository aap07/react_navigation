{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\nvar path = _interopRequireWildcard(require(\"path\"));\nvar _slugify = _interopRequireDefault(require(\"slugify\"));\nvar _userSettings = _interopRequireDefault(require(\"../../api/user/UserSettings\"));\nvar _user = require(\"../../api/user/user\");\nvar Log = _interopRequireWildcard(require(\"../../log\"));\nvar _delay = require(\"../../utils/delay\");\nvar _env = require(\"../../utils/env\");\nvar _errors = require(\"../../utils/errors\");\nvar _ngrokResolver = require(\"../doctor/ngrok/NgrokResolver\");\nvar _adbReverse = require(\"../platforms/android/adbReverse\");\nvar _settings = require(\"../project/settings\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nvar debug = require(\"debug\")(\"expo:start:server:ngrok\");\nvar NGROK_CONFIG = {\n  authToken: \"5W1bR67GNbWcXqmxZzBG1_56GezNeaX6sSRvn8npeQ8\",\n  domain: \"exp.direct\"\n};\nvar TUNNEL_TIMEOUT = 10 * 1000;\nvar AsyncNgrok = function () {\n  function AsyncNgrok(projectRoot, port) {\n    _classCallCheck(this, AsyncNgrok);\n    this.projectRoot = projectRoot;\n    this.port = port;\n    this.serverUrl = null;\n    this.resolver = new _ngrokResolver.NgrokResolver(projectRoot);\n  }\n  _createClass(AsyncNgrok, [{\n    key: \"getActiveUrl\",\n    value: function getActiveUrl() {\n      return this.serverUrl;\n    }\n  }, {\n    key: \"_getIdentifyingUrlSegmentsAsync\",\n    value: function () {\n      var _getIdentifyingUrlSegmentsAsync2 = _asyncToGenerator(function* () {\n        var user = yield (0, _user).getUserAsync();\n        if ((user == null ? void 0 : user.__typename) === \"Robot\") {\n          throw new _errors.CommandError(\"NGROK_ROBOT\", \"Cannot use ngrok with a robot user.\");\n        }\n        var username = (0, _user).getActorDisplayName(user);\n        return [yield this.getProjectRandomnessAsync(), (0, _slugify).default(username), String(this.port)];\n      });\n      function _getIdentifyingUrlSegmentsAsync() {\n        return _getIdentifyingUrlSegmentsAsync2.apply(this, arguments);\n      }\n      return _getIdentifyingUrlSegmentsAsync;\n    }()\n  }, {\n    key: \"_getProjectHostnameAsync\",\n    value: function () {\n      var _getProjectHostnameAsync2 = _asyncToGenerator(function* () {\n        return [].concat(_toConsumableArray(yield this._getIdentifyingUrlSegmentsAsync()), [NGROK_CONFIG.domain]).join(\".\");\n      });\n      function _getProjectHostnameAsync() {\n        return _getProjectHostnameAsync2.apply(this, arguments);\n      }\n      return _getProjectHostnameAsync;\n    }()\n  }, {\n    key: \"_getProjectSubdomainAsync\",\n    value: function () {\n      var _getProjectSubdomainAsync2 = _asyncToGenerator(function* () {\n        return (yield this._getIdentifyingUrlSegmentsAsync()).join(\"-\");\n      });\n      function _getProjectSubdomainAsync() {\n        return _getProjectSubdomainAsync2.apply(this, arguments);\n      }\n      return _getProjectSubdomainAsync;\n    }()\n  }, {\n    key: \"startAsync\",\n    value: function () {\n      var _startAsync = _asyncToGenerator(function* () {\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          timeout = _ref.timeout;\n        yield this.resolver.resolveAsync({\n          prefersGlobalInstall: true\n        });\n        if ((0, _adbReverse).hasAdbReverseAsync()) {\n          if (!(yield (0, _adbReverse).startAdbReverseAsync([this.port]))) {\n            throw new _errors.CommandError(\"NGROK_ADB\", `Cannot start tunnel URL because \\`adb reverse\\` failed for the connected Android device(s).`);\n          }\n        }\n        this.serverUrl = yield this._connectToNgrokAsync({\n          timeout: timeout\n        });\n        debug(\"Tunnel URL:\", this.serverUrl);\n        Log.log(\"Tunnel ready.\");\n      });\n      function startAsync() {\n        return _startAsync.apply(this, arguments);\n      }\n      return startAsync;\n    }()\n  }, {\n    key: \"stopAsync\",\n    value: function () {\n      var _stopAsync = _asyncToGenerator(function* () {\n        var ref;\n        debug(\"Stopping Tunnel\");\n        yield (ref = this.resolver.get()) == null ? void 0 : ref.kill == null ? void 0 : ref.kill();\n        this.serverUrl = null;\n      });\n      function stopAsync() {\n        return _stopAsync.apply(this, arguments);\n      }\n      return stopAsync;\n    }()\n  }, {\n    key: \"_connectToNgrokAsync\",\n    value: function () {\n      var _connectToNgrokAsync2 = _asyncToGenerator(function* () {\n        var _this = this;\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var attempts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        yield this.stopAsync();\n        var instance = yield this.resolver.resolveAsync({\n          shouldPrompt: false,\n          autoInstall: false\n        });\n        var _timeout;\n        var results = yield (0, _delay).resolveWithTimeout(function () {\n          return _this.connectToNgrokInternalAsync(instance, attempts);\n        }, {\n          timeout: (_timeout = options.timeout) != null ? _timeout : TUNNEL_TIMEOUT,\n          errorMessage: \"ngrok tunnel took too long to connect.\"\n        });\n        if (typeof results === \"string\") {\n          return results;\n        }\n        yield (0, _delay).delayAsync(100);\n        return this._connectToNgrokAsync(options, attempts + 1);\n      });\n      function _connectToNgrokAsync() {\n        return _connectToNgrokAsync2.apply(this, arguments);\n      }\n      return _connectToNgrokAsync;\n    }()\n  }, {\n    key: \"_getConnectionPropsAsync\",\n    value: function () {\n      var _getConnectionPropsAsync2 = _asyncToGenerator(function* () {\n        var userDefinedSubdomain = _env.env.EXPO_TUNNEL_SUBDOMAIN;\n        if (userDefinedSubdomain) {\n          var subdomain = typeof userDefinedSubdomain === \"string\" ? userDefinedSubdomain : yield this._getProjectSubdomainAsync();\n          debug(\"Subdomain:\", subdomain);\n          return {\n            subdomain: subdomain\n          };\n        } else {\n          var hostname = yield this._getProjectHostnameAsync();\n          debug(\"Hostname:\", hostname);\n          return {\n            hostname: hostname\n          };\n        }\n      });\n      function _getConnectionPropsAsync() {\n        return _getConnectionPropsAsync2.apply(this, arguments);\n      }\n      return _getConnectionPropsAsync;\n    }()\n  }, {\n    key: \"connectToNgrokInternalAsync\",\n    value: function () {\n      var _connectToNgrokInternalAsync = _asyncToGenerator(function* (instance) {\n        var attempts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        try {\n          var configPath = path.join(_userSettings.default.getDirectory(), \"ngrok.yml\");\n          debug(\"Global config path:\", configPath);\n          var urlProps = yield this._getConnectionPropsAsync();\n          var url = yield instance.connect(_objectSpread(_objectSpread({}, urlProps), {}, {\n            authtoken: NGROK_CONFIG.authToken,\n            proto: \"http\",\n            configPath: configPath,\n            onStatusChange: function onStatusChange(status) {\n              if (status === \"closed\") {\n                Log.error(_chalk.default.red(\"Tunnel connection has been closed. This is often related to intermittent connection problems with the Ngrok servers. Restart the dev server to try connecting to Ngrok again.\"));\n              } else if (status === \"connected\") {\n                Log.log(\"Tunnel connected.\");\n              }\n            },\n            port: this.port\n          }));\n          return url;\n        } catch (error) {\n          var assertNgrok = function assertNgrok() {\n            if ((0, _ngrokResolver).isNgrokClientError(error)) {\n              var ref;\n              throw new _errors.CommandError(\"NGROK_CONNECT\", [error.body.msg, (ref = error.body.details) == null ? void 0 : ref.err].filter(Boolean).join(\"\\n\\n\"));\n            }\n            throw new _errors.CommandError(\"NGROK_CONNECT\", error.toString());\n          };\n          if (attempts >= 2) {\n            assertNgrok();\n          }\n          if ((0, _ngrokResolver).isNgrokClientError(error) && error.body.error_code === 103) {\n            if (typeof _env.env.EXPO_TUNNEL_SUBDOMAIN === \"string\") {\n              assertNgrok();\n            }\n            yield this._resetProjectRandomnessAsync();\n          }\n          return false;\n        }\n      });\n      function connectToNgrokInternalAsync(_x) {\n        return _connectToNgrokInternalAsync.apply(this, arguments);\n      }\n      return connectToNgrokInternalAsync;\n    }()\n  }, {\n    key: \"getProjectRandomnessAsync\",\n    value: function () {\n      var _getProjectRandomnessAsync = _asyncToGenerator(function* () {\n        var _yield$_settings$Proj = yield _settings.ProjectSettings.readAsync(this.projectRoot),\n          randomness = _yield$_settings$Proj.urlRandomness;\n        if (randomness) {\n          return randomness;\n        }\n        return yield this._resetProjectRandomnessAsync();\n      });\n      function getProjectRandomnessAsync() {\n        return _getProjectRandomnessAsync.apply(this, arguments);\n      }\n      return getProjectRandomnessAsync;\n    }()\n  }, {\n    key: \"_resetProjectRandomnessAsync\",\n    value: function () {\n      var _resetProjectRandomnessAsync2 = _asyncToGenerator(function* () {\n        var randomness = _crypto.default.randomBytes(5).toString(\"base64url\");\n        yield _settings.ProjectSettings.setAsync(this.projectRoot, {\n          urlRandomness: randomness\n        });\n        debug(\"Resetting project randomness:\", randomness);\n        return randomness;\n      });\n      function _resetProjectRandomnessAsync() {\n        return _resetProjectRandomnessAsync2.apply(this, arguments);\n      }\n      return _resetProjectRandomnessAsync;\n    }()\n  }]);\n  return AsyncNgrok;\n}();\nexports.AsyncNgrok = AsyncNgrok;","map":{"version":3,"names":["_defineProperty","require","_toConsumableArray","_asyncToGenerator","_classCallCheck","_createClass","ownKeys","e","r","t","Object","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","length","forEach","getOwnPropertyDescriptors","defineProperties","defineProperty","_chalk","_interopRequireDefault","_crypto","path","_interopRequireWildcard","_slugify","_userSettings","_user","Log","_delay","_env","_errors","_ngrokResolver","_adbReverse","_settings","debug","NGROK_CONFIG","authToken","domain","TUNNEL_TIMEOUT","AsyncNgrok","projectRoot","port","serverUrl","resolver","NgrokResolver","key","value","getActiveUrl","_getIdentifyingUrlSegmentsAsync2","user","getUserAsync","__typename","CommandError","username","getActorDisplayName","getProjectRandomnessAsync","default","String","_getIdentifyingUrlSegmentsAsync","_getProjectHostnameAsync2","concat","join","_getProjectHostnameAsync","_getProjectSubdomainAsync2","_getProjectSubdomainAsync","_startAsync","_ref","undefined","timeout","resolveAsync","prefersGlobalInstall","hasAdbReverseAsync","startAdbReverseAsync","_connectToNgrokAsync","log","startAsync","_stopAsync","ref","get","kill","stopAsync","_connectToNgrokAsync2","_this","options","attempts","instance","shouldPrompt","autoInstall","_timeout","results","resolveWithTimeout","connectToNgrokInternalAsync","errorMessage","delayAsync","_getConnectionPropsAsync2","userDefinedSubdomain","env","EXPO_TUNNEL_SUBDOMAIN","subdomain","hostname","_getConnectionPropsAsync","_connectToNgrokInternalAsync","configPath","getDirectory","urlProps","url","connect","authtoken","proto","onStatusChange","status","error","red","assertNgrok","isNgrokClientError","body","msg","details","err","Boolean","toString","error_code","_resetProjectRandomnessAsync","_x","_getProjectRandomnessAsync","_yield$_settings$Proj","ProjectSettings","readAsync","randomness","urlRandomness","_resetProjectRandomnessAsync2","randomBytes","setAsync"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\cli\\src\\start\\server\\AsyncNgrok.ts"],"sourcesContent":["import chalk from 'chalk';\nimport crypto from 'crypto';\nimport * as path from 'path';\nimport slugify from 'slugify';\n\nimport UserSettings from '../../api/user/UserSettings';\nimport { getActorDisplayName, getUserAsync } from '../../api/user/user';\nimport * as Log from '../../log';\nimport { delayAsync, resolveWithTimeout } from '../../utils/delay';\nimport { env } from '../../utils/env';\nimport { CommandError } from '../../utils/errors';\nimport { isNgrokClientError, NgrokInstance, NgrokResolver } from '../doctor/ngrok/NgrokResolver';\nimport { hasAdbReverseAsync, startAdbReverseAsync } from '../platforms/android/adbReverse';\nimport { ProjectSettings } from '../project/settings';\n\nconst debug = require('debug')('expo:start:server:ngrok') as typeof console.log;\n\nconst NGROK_CONFIG = {\n  authToken: '5W1bR67GNbWcXqmxZzBG1_56GezNeaX6sSRvn8npeQ8',\n  domain: 'exp.direct',\n};\n\nconst TUNNEL_TIMEOUT = 10 * 1000;\n\nexport class AsyncNgrok {\n  /** Resolves the best instance of ngrok, exposed for testing. */\n  resolver: NgrokResolver;\n\n  /** Info about the currently running instance of ngrok. */\n  private serverUrl: string | null = null;\n\n  constructor(private projectRoot: string, private port: number) {\n    this.resolver = new NgrokResolver(projectRoot);\n  }\n\n  public getActiveUrl(): string | null {\n    return this.serverUrl;\n  }\n\n  /** Exposed for testing. */\n  async _getIdentifyingUrlSegmentsAsync(): Promise<string[]> {\n    const user = await getUserAsync();\n    if (user?.__typename === 'Robot') {\n      throw new CommandError('NGROK_ROBOT', 'Cannot use ngrok with a robot user.');\n    }\n    const username = getActorDisplayName(user);\n\n    return [\n      // NOTE: https://github.com/expo/expo/pull/16556#discussion_r822944286\n      await this.getProjectRandomnessAsync(),\n      slugify(username),\n      // Use the port to distinguish between multiple tunnels (webpack, metro).\n      String(this.port),\n    ];\n  }\n\n  /** Exposed for testing. */\n  async _getProjectHostnameAsync(): Promise<string> {\n    return [...(await this._getIdentifyingUrlSegmentsAsync()), NGROK_CONFIG.domain].join('.');\n  }\n\n  /** Exposed for testing. */\n  async _getProjectSubdomainAsync(): Promise<string> {\n    return (await this._getIdentifyingUrlSegmentsAsync()).join('-');\n  }\n\n  /** Start ngrok on the given port for the project. */\n  async startAsync({ timeout }: { timeout?: number } = {}): Promise<void> {\n    // Ensure the instance is loaded first, this can linger so we should run it before the timeout.\n    await this.resolver.resolveAsync({\n      // For now, prefer global install since the package has native code (harder to install) and doesn't change very often.\n      prefersGlobalInstall: true,\n    });\n\n    // NOTE(EvanBacon): If the user doesn't have ADB installed,\n    // then skip attempting to reverse the port.\n    if (hasAdbReverseAsync()) {\n      // Ensure ADB reverse is running.\n      if (!(await startAdbReverseAsync([this.port]))) {\n        // TODO: Better error message.\n        throw new CommandError(\n          'NGROK_ADB',\n          `Cannot start tunnel URL because \\`adb reverse\\` failed for the connected Android device(s).`\n        );\n      }\n    }\n\n    this.serverUrl = await this._connectToNgrokAsync({ timeout });\n\n    debug('Tunnel URL:', this.serverUrl);\n    Log.log('Tunnel ready.');\n  }\n\n  /** Stop the ngrok process if it's running. */\n  public async stopAsync(): Promise<void> {\n    debug('Stopping Tunnel');\n\n    await this.resolver.get()?.kill?.();\n    this.serverUrl = null;\n  }\n\n  /** Exposed for testing. */\n  async _connectToNgrokAsync(\n    options: { timeout?: number } = {},\n    attempts: number = 0\n  ): Promise<string> {\n    // Attempt to stop any hanging processes, this increases the chances of a successful connection.\n    await this.stopAsync();\n\n    // Get the instance quietly or assert otherwise.\n    const instance = await this.resolver.resolveAsync({\n      shouldPrompt: false,\n      autoInstall: false,\n    });\n\n    // TODO(Bacon): Consider dropping the timeout functionality:\n    // https://github.com/expo/expo/pull/16556#discussion_r822307373\n    const results = await resolveWithTimeout(\n      () => this.connectToNgrokInternalAsync(instance, attempts),\n      {\n        timeout: options.timeout ?? TUNNEL_TIMEOUT,\n        errorMessage: 'ngrok tunnel took too long to connect.',\n      }\n    );\n    if (typeof results === 'string') {\n      return results;\n    }\n\n    // Wait 100ms and then try again\n    await delayAsync(100);\n\n    return this._connectToNgrokAsync(options, attempts + 1);\n  }\n\n  private async _getConnectionPropsAsync(): Promise<{ hostname?: string; subdomain?: string }> {\n    const userDefinedSubdomain = env.EXPO_TUNNEL_SUBDOMAIN;\n    if (userDefinedSubdomain) {\n      const subdomain =\n        typeof userDefinedSubdomain === 'string'\n          ? userDefinedSubdomain\n          : await this._getProjectSubdomainAsync();\n      debug('Subdomain:', subdomain);\n      return { subdomain };\n    } else {\n      const hostname = await this._getProjectHostnameAsync();\n      debug('Hostname:', hostname);\n      return { hostname };\n    }\n  }\n\n  private async connectToNgrokInternalAsync(\n    instance: NgrokInstance,\n    attempts: number = 0\n  ): Promise<string | false> {\n    try {\n      // Global config path.\n      const configPath = path.join(UserSettings.getDirectory(), 'ngrok.yml');\n      debug('Global config path:', configPath);\n      const urlProps = await this._getConnectionPropsAsync();\n\n      const url = await instance.connect({\n        ...urlProps,\n        authtoken: NGROK_CONFIG.authToken,\n        proto: 'http',\n        configPath,\n        onStatusChange(status) {\n          if (status === 'closed') {\n            Log.error(\n              chalk.red(\n                'Tunnel connection has been closed. This is often related to intermittent connection problems with the Ngrok servers. Restart the dev server to try connecting to Ngrok again.'\n              )\n            );\n          } else if (status === 'connected') {\n            Log.log('Tunnel connected.');\n          }\n        },\n        port: this.port,\n      });\n      return url;\n    } catch (error: any) {\n      const assertNgrok = () => {\n        if (isNgrokClientError(error)) {\n          throw new CommandError(\n            'NGROK_CONNECT',\n            [error.body.msg, error.body.details?.err].filter(Boolean).join('\\n\\n')\n          );\n        }\n        throw new CommandError('NGROK_CONNECT', error.toString());\n      };\n\n      // Attempt to connect 3 times\n      if (attempts >= 2) {\n        assertNgrok();\n      }\n\n      // Attempt to fix the issue\n      if (isNgrokClientError(error) && error.body.error_code === 103) {\n        // Assert early if a custom subdomain is used since it cannot\n        // be changed and retried. If the tunnel subdomain is a boolean\n        // then we can reset the randomness and try again.\n        if (typeof env.EXPO_TUNNEL_SUBDOMAIN === 'string') {\n          assertNgrok();\n        }\n        // Change randomness to avoid conflict if killing ngrok doesn't help\n        await this._resetProjectRandomnessAsync();\n      }\n\n      return false;\n    }\n  }\n\n  private async getProjectRandomnessAsync() {\n    const { urlRandomness: randomness } = await ProjectSettings.readAsync(this.projectRoot);\n    if (randomness) {\n      return randomness;\n    }\n    return await this._resetProjectRandomnessAsync();\n  }\n\n  async _resetProjectRandomnessAsync() {\n    const randomness = crypto.randomBytes(5).toString('base64url');\n    await ProjectSettings.setAsync(this.projectRoot, { urlRandomness: randomness });\n    debug('Resetting project randomness:', randomness);\n    return randomness;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}