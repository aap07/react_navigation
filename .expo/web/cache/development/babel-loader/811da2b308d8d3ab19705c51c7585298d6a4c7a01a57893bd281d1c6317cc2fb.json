{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nvar _toArray = require(\"@babel/runtime/helpers/toArray\");\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getServer = getServer;\nexports.logUnauthorized = logUnauthorized;\nexports.isPackageInstalledAsync = isPackageInstalledAsync;\nexports.launchActivityAsync = launchActivityAsync;\nexports.openAppIdAsync = openAppIdAsync;\nexports.openUrlAsync = openUrlAsync;\nexports.uninstallAsync = uninstallAsync;\nexports.getPackageInfoAsync = getPackageInfoAsync;\nexports.installAsync = installAsync;\nexports.adbArgs = adbArgs;\nexports.getAttachedDevicesAsync = getAttachedDevicesAsync;\nexports.getAdbNameForDeviceIdAsync = getAdbNameForDeviceIdAsync;\nexports.isDeviceBootedAsync = isDeviceBootedAsync;\nexports.isBootAnimationCompleteAsync = isBootAnimationCompleteAsync;\nexports.getDeviceABIsAsync = getDeviceABIsAsync;\nexports.getPropertyDataForDeviceAsync = getPropertyDataForDeviceAsync;\nexports.sanitizeAdbDeviceName = sanitizeAdbDeviceName;\nexports.DeviceABI = void 0;\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\nvar _os = _interopRequireDefault(require(\"os\"));\nvar Log = _interopRequireWildcard(require(\"../../../log\"));\nvar _errors = require(\"../../../utils/errors\");\nvar _link = require(\"../../../utils/link\");\nvar _adbserver = require(\"./ADBServer\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nvar debug = require(\"debug\")(\"expo:start:platforms:android:adb\");\nvar DeviceABI;\nexports.DeviceABI = DeviceABI;\n(function (DeviceABI) {\n  DeviceABI[\"arm\"] = \"arm\";\n  DeviceABI[\"arm64\"] = \"arm64\";\n  DeviceABI[\"x64\"] = \"x64\";\n  DeviceABI[\"x86\"] = \"x86\";\n  DeviceABI[\"armeabiV7a\"] = \"armeabi-v7a\";\n  DeviceABI[\"armeabi\"] = \"armeabi\";\n  DeviceABI[\"universal\"] = \"universal\";\n})(DeviceABI || (exports.DeviceABI = DeviceABI = {}));\nvar CANT_START_ACTIVITY_ERROR = \"Activity not started, unable to resolve Intent\";\nvar PROP_CPU_NAME = \"ro.product.cpu.abi\";\nvar PROP_CPU_ABI_LIST_NAME = \"ro.product.cpu.abilist\";\nvar PROP_BOOT_ANIMATION_STATE = \"init.svc.bootanim\";\nvar _server;\nfunction getServer() {\n  _server != null ? _server : _server = new _adbserver.ADBServer();\n  return _server;\n}\nfunction logUnauthorized(device) {\n  Log.warn(`\\nThis computer is not authorized for developing on ${_chalk.default.bold(device.name)}. ${_chalk.default.dim((0, _link).learnMore(\"https://expo.fyi/authorize-android-device\"))}`);\n}\nfunction isPackageInstalledAsync(_x, _x2) {\n  return _isPackageInstalledAsync.apply(this, arguments);\n}\nfunction _isPackageInstalledAsync() {\n  _isPackageInstalledAsync = _asyncToGenerator(function* (device, androidPackage) {\n    var packages = yield getServer().runAsync(adbArgs(device.pid, \"shell\", \"pm\", \"list\", \"packages\", androidPackage));\n    var lines = packages.split(/\\r?\\n/);\n    for (var i = 0; i < lines.length; i++) {\n      var line = lines[i].trim();\n      if (line === `package:${androidPackage}`) {\n        return true;\n      }\n    }\n    return false;\n  });\n  return _isPackageInstalledAsync.apply(this, arguments);\n}\nfunction launchActivityAsync(_x3, _x4) {\n  return _launchActivityAsync.apply(this, arguments);\n}\nfunction _launchActivityAsync() {\n  _launchActivityAsync = _asyncToGenerator(function* (device, _ref) {\n    var launchActivity = _ref.launchActivity;\n    return openAsync(adbArgs(device.pid, \"shell\", \"am\", \"start\", \"-f\", \"0x20000000\", \"-n\", launchActivity));\n  });\n  return _launchActivityAsync.apply(this, arguments);\n}\nfunction openAppIdAsync(_x5, _x6) {\n  return _openAppIdAsync.apply(this, arguments);\n}\nfunction _openAppIdAsync() {\n  _openAppIdAsync = _asyncToGenerator(function* (device, _ref2) {\n    var applicationId = _ref2.applicationId;\n    return openAsync(adbArgs(device.pid, \"shell\", \"monkey\", \"-p\", applicationId, \"-c\", \"android.intent.category.LAUNCHER\", \"1\"));\n  });\n  return _openAppIdAsync.apply(this, arguments);\n}\nfunction openUrlAsync(_x7, _x8) {\n  return _openUrlAsync.apply(this, arguments);\n}\nfunction _openUrlAsync() {\n  _openUrlAsync = _asyncToGenerator(function* (device, _ref3) {\n    var url = _ref3.url;\n    return openAsync(adbArgs(device.pid, \"shell\", \"am\", \"start\", \"-a\", \"android.intent.action.VIEW\", \"-d\", url.replace(/&/g, String.raw`\\&`)));\n  });\n  return _openUrlAsync.apply(this, arguments);\n}\nfunction openAsync(_x9) {\n  return _openAsync.apply(this, arguments);\n}\nfunction _openAsync() {\n  _openAsync = _asyncToGenerator(function* (args) {\n    var results = yield getServer().runAsync(args);\n    if (results.includes(CANT_START_ACTIVITY_ERROR) || results.match(/Error: Activity class .* does not exist\\./g)) {\n      throw new _errors.CommandError(\"APP_NOT_INSTALLED\", results.substring(results.indexOf(\"Error: \")));\n    }\n    return results;\n  });\n  return _openAsync.apply(this, arguments);\n}\nfunction uninstallAsync(_x10, _x11) {\n  return _uninstallAsync.apply(this, arguments);\n}\nfunction _uninstallAsync() {\n  _uninstallAsync = _asyncToGenerator(function* (device, _ref4) {\n    var appId = _ref4.appId;\n    return yield getServer().runAsync(adbArgs(device.pid, \"uninstall\", appId));\n  });\n  return _uninstallAsync.apply(this, arguments);\n}\nfunction getPackageInfoAsync(_x12, _x13) {\n  return _getPackageInfoAsync.apply(this, arguments);\n}\nfunction _getPackageInfoAsync() {\n  _getPackageInfoAsync = _asyncToGenerator(function* (device, _ref5) {\n    var appId = _ref5.appId;\n    return yield getServer().runAsync(adbArgs(device.pid, \"shell\", \"dumpsys\", \"package\", appId));\n  });\n  return _getPackageInfoAsync.apply(this, arguments);\n}\nfunction installAsync(_x14, _x15) {\n  return _installAsync.apply(this, arguments);\n}\nfunction _installAsync() {\n  _installAsync = _asyncToGenerator(function* (device, _ref6) {\n    var filePath = _ref6.filePath;\n    return yield getServer().runAsync(adbArgs(device.pid, \"install\", \"-r\", \"-d\", filePath));\n  });\n  return _installAsync.apply(this, arguments);\n}\nfunction adbArgs(pid) {\n  var args = [];\n  if (pid) {\n    args.push(\"-s\", pid);\n  }\n  for (var _len = arguments.length, options = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    options[_key - 1] = arguments[_key];\n  }\n  return args.concat(options);\n}\nfunction getAttachedDevicesAsync() {\n  return _getAttachedDevicesAsync.apply(this, arguments);\n}\nfunction _getAttachedDevicesAsync() {\n  _getAttachedDevicesAsync = _asyncToGenerator(function* () {\n    var output = yield getServer().runAsync([\"devices\", \"-l\"]);\n    var splitItems = output.trim().replace(/\\n$/, \"\").split(_os.default.EOL);\n    var attachedDevices = splitItems.slice(1, splitItems.length).map(function (line) {\n      var props = line.split(\" \").filter(Boolean);\n      var isAuthorized = props[1] !== \"unauthorized\";\n      var type = line.includes(\"emulator\") ? \"emulator\" : \"device\";\n      return {\n        props: props,\n        type: type,\n        isAuthorized: isAuthorized\n      };\n    }).filter(function (_ref7) {\n      var _ref7$props = _slicedToArray(_ref7.props, 1),\n        pid = _ref7$props[0];\n      return !!pid;\n    });\n    var devicePromises = attachedDevices.map(function () {\n      var _ref8 = _asyncToGenerator(function* (props) {\n        var type = props.type,\n          _props$props = _toArray(props.props),\n          pid = _props$props[0],\n          deviceInfo = _props$props.slice(1),\n          isAuthorized = props.isAuthorized;\n        var name = null;\n        if (type === \"device\") {\n          if (isAuthorized) {\n            var modelItem = deviceInfo.find(function (info) {\n              return info.includes(\"model:\");\n            });\n            if (modelItem) {\n              name = modelItem.replace(\"model:\", \"\");\n            }\n          }\n          if (!name) {\n            name = `Device ${pid}`;\n          }\n        } else {\n          var ref;\n          name = (ref = yield getAdbNameForDeviceIdAsync({\n            pid: pid\n          })) != null ? ref : \"\";\n        }\n        return {\n          pid: pid,\n          name: name,\n          type: type,\n          isAuthorized: isAuthorized,\n          isBooted: true\n        };\n      });\n      return function (_x21) {\n        return _ref8.apply(this, arguments);\n      };\n    }());\n    return Promise.all(devicePromises);\n  });\n  return _getAttachedDevicesAsync.apply(this, arguments);\n}\nfunction getAdbNameForDeviceIdAsync(_x16) {\n  return _getAdbNameForDeviceIdAsync.apply(this, arguments);\n}\nfunction _getAdbNameForDeviceIdAsync() {\n  _getAdbNameForDeviceIdAsync = _asyncToGenerator(function* (device) {\n    var results = yield getServer().runAsync(adbArgs(device.pid, \"emu\", \"avd\", \"name\"));\n    if (results.match(/could not connect to TCP port .*: Connection refused/)) {\n      throw new _errors.CommandError(\"EMULATOR_NOT_FOUND\", results);\n    }\n    var ref;\n    return (ref = sanitizeAdbDeviceName(results)) != null ? ref : null;\n  });\n  return _getAdbNameForDeviceIdAsync.apply(this, arguments);\n}\nfunction isDeviceBootedAsync() {\n  return _isDeviceBootedAsync.apply(this, arguments);\n}\nfunction _isDeviceBootedAsync() {\n  _isDeviceBootedAsync = _asyncToGenerator(function* () {\n    var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      name = _ref9.name;\n    var devices = yield getAttachedDevicesAsync();\n    if (!name) {\n      var ref;\n      return (ref = devices[0]) != null ? ref : null;\n    }\n    var ref1;\n    return (ref1 = devices.find(function (device) {\n      return device.name === name;\n    })) != null ? ref1 : null;\n  });\n  return _isDeviceBootedAsync.apply(this, arguments);\n}\nfunction isBootAnimationCompleteAsync(_x17) {\n  return _isBootAnimationCompleteAsync.apply(this, arguments);\n}\nfunction _isBootAnimationCompleteAsync() {\n  _isBootAnimationCompleteAsync = _asyncToGenerator(function* (pid) {\n    try {\n      var props = yield getPropertyDataForDeviceAsync({\n        pid: pid\n      }, PROP_BOOT_ANIMATION_STATE);\n      return !!props[PROP_BOOT_ANIMATION_STATE].match(/stopped/);\n    } catch (_unused) {\n      return false;\n    }\n  });\n  return _isBootAnimationCompleteAsync.apply(this, arguments);\n}\nfunction getDeviceABIsAsync(_x18) {\n  return _getDeviceABIsAsync.apply(this, arguments);\n}\nfunction _getDeviceABIsAsync() {\n  _getDeviceABIsAsync = _asyncToGenerator(function* (device) {\n    var cpuAbiList = (yield getPropertyDataForDeviceAsync(device, PROP_CPU_ABI_LIST_NAME))[PROP_CPU_ABI_LIST_NAME];\n    if (cpuAbiList) {\n      return cpuAbiList.trim().split(\",\");\n    }\n    var abi = (yield getPropertyDataForDeviceAsync(device, PROP_CPU_NAME))[PROP_CPU_NAME];\n    return [abi];\n  });\n  return _getDeviceABIsAsync.apply(this, arguments);\n}\nfunction getPropertyDataForDeviceAsync(_x19, _x20) {\n  return _getPropertyDataForDeviceAsync.apply(this, arguments);\n}\nfunction _getPropertyDataForDeviceAsync() {\n  _getPropertyDataForDeviceAsync = _asyncToGenerator(function* (device, prop) {\n    var propCommand = adbArgs.apply(void 0, _toConsumableArray([device.pid, \"shell\", \"getprop\", prop].filter(Boolean)));\n    try {\n      var results = yield getServer().getFileOutputAsync(propCommand);\n      if (prop) {\n        debug(`Property data: (device pid: ${device.pid}, prop: ${prop}, data: ${results})`);\n        return _defineProperty({}, prop, results);\n      }\n      var props = parseAdbDeviceProperties(results);\n      debug(`Parsed data:`, props);\n      return props;\n    } catch (error) {\n      throw new _errors.CommandError(`Failed to get properties for device (${device.pid}): ${error.message}`);\n    }\n  });\n  return _getPropertyDataForDeviceAsync.apply(this, arguments);\n}\nfunction parseAdbDeviceProperties(devicePropertiesString) {\n  var properties = {};\n  var propertyExp = /\\[(.*?)\\]: \\[(.*?)\\]/gm;\n  for (var match of devicePropertiesString.matchAll(propertyExp)) {\n    properties[match[1]] = match[2];\n  }\n  return properties;\n}\nfunction sanitizeAdbDeviceName(deviceName) {\n  return deviceName.trim().split(/[\\r\\n]+/).shift();\n}","map":{"version":3,"names":["_defineProperty","require","_toConsumableArray","_toArray","_slicedToArray","_asyncToGenerator","getServer","logUnauthorized","isPackageInstalledAsync","launchActivityAsync","openAppIdAsync","openUrlAsync","uninstallAsync","getPackageInfoAsync","installAsync","adbArgs","getAttachedDevicesAsync","getAdbNameForDeviceIdAsync","isDeviceBootedAsync","isBootAnimationCompleteAsync","getDeviceABIsAsync","getPropertyDataForDeviceAsync","sanitizeAdbDeviceName","_chalk","_interopRequireDefault","_os","Log","_interopRequireWildcard","_errors","_link","_adbserver","debug","DeviceABI","exports","CANT_START_ACTIVITY_ERROR","PROP_CPU_NAME","PROP_CPU_ABI_LIST_NAME","PROP_BOOT_ANIMATION_STATE","_server","ADBServer","device","warn","default","bold","name","dim","learnMore","_x","_x2","_isPackageInstalledAsync","apply","arguments","androidPackage","packages","runAsync","pid","lines","split","i","length","line","trim","_x3","_x4","_launchActivityAsync","_ref","launchActivity","openAsync","_x5","_x6","_openAppIdAsync","_ref2","applicationId","_x7","_x8","_openUrlAsync","_ref3","url","replace","String","raw","_x9","_openAsync","args","results","includes","match","CommandError","substring","indexOf","_x10","_x11","_uninstallAsync","_ref4","appId","_x12","_x13","_getPackageInfoAsync","_ref5","_x14","_x15","_installAsync","_ref6","filePath","push","_len","options","Array","_key","concat","_getAttachedDevicesAsync","output","splitItems","EOL","attachedDevices","slice","map","props","filter","Boolean","isAuthorized","type","_ref7","_ref7$props","devicePromises","_ref8","_props$props","deviceInfo","modelItem","find","info","ref","isBooted","_x21","Promise","all","_x16","_getAdbNameForDeviceIdAsync","_isDeviceBootedAsync","_ref9","undefined","devices","ref1","_x17","_isBootAnimationCompleteAsync","_unused","_x18","_getDeviceABIsAsync","cpuAbiList","abi","_x19","_x20","_getPropertyDataForDeviceAsync","prop","propCommand","getFileOutputAsync","parseAdbDeviceProperties","error","message","devicePropertiesString","properties","propertyExp","matchAll","deviceName","shift"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\cli\\src\\start\\platforms\\android\\adb.ts"],"sourcesContent":["import chalk from 'chalk';\nimport os from 'os';\n\nimport * as Log from '../../../log';\nimport { CommandError } from '../../../utils/errors';\nimport { learnMore } from '../../../utils/link';\nimport { ADBServer } from './ADBServer';\n\nconst debug = require('debug')('expo:start:platforms:android:adb') as typeof console.log;\n\nexport enum DeviceABI {\n  // The arch specific android target platforms are soft-deprecated.\n  // Instead of using TargetPlatform as a combination arch + platform\n  // the code will be updated to carry arch information in [DarwinArch]\n  // and [AndroidArch].\n  arm = 'arm',\n  arm64 = 'arm64',\n  x64 = 'x64',\n  x86 = 'x86',\n  armeabiV7a = 'armeabi-v7a',\n  armeabi = 'armeabi',\n  universal = 'universal',\n}\n\n/** Represents a connected Android device. */\nexport type Device = {\n  /** Process ID. */\n  pid?: string;\n  /** Name of the device, also used as the ID for opening devices. */\n  name: string;\n  /** Is emulator or connected device. */\n  type: 'emulator' | 'device';\n  /** Is the device booted (emulator). */\n  isBooted: boolean;\n  /** Is device authorized for developing. https://expo.fyi/authorize-android-device */\n  isAuthorized: boolean;\n};\n\ntype DeviceContext = Pick<Device, 'pid'>;\n\ntype DeviceProperties = Record<string, string>;\n\nconst CANT_START_ACTIVITY_ERROR = 'Activity not started, unable to resolve Intent';\n// http://developer.android.com/ndk/guides/abis.html\nconst PROP_CPU_NAME = 'ro.product.cpu.abi';\n\nconst PROP_CPU_ABI_LIST_NAME = 'ro.product.cpu.abilist';\n\n// Can sometimes be null\n// http://developer.android.com/ndk/guides/abis.html\nconst PROP_BOOT_ANIMATION_STATE = 'init.svc.bootanim';\n\nlet _server: ADBServer | null;\n\n/** Return the lazily loaded ADB server instance. */\nexport function getServer() {\n  _server ??= new ADBServer();\n  return _server;\n}\n\n/** Logs an FYI message about authorizing your device. */\nexport function logUnauthorized(device: Device) {\n  Log.warn(\n    `\\nThis computer is not authorized for developing on ${chalk.bold(device.name)}. ${chalk.dim(\n      learnMore('https://expo.fyi/authorize-android-device')\n    )}`\n  );\n}\n\n/** Returns true if the provided package name is installed on the provided Android device. */\nexport async function isPackageInstalledAsync(\n  device: DeviceContext,\n  androidPackage: string\n): Promise<boolean> {\n  const packages = await getServer().runAsync(\n    adbArgs(device.pid, 'shell', 'pm', 'list', 'packages', androidPackage)\n  );\n\n  const lines = packages.split(/\\r?\\n/);\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n    if (line === `package:${androidPackage}`) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * @param device.pid Process ID of the Android device to launch.\n * @param props.launchActivity Activity to launch `[application identifier]/.[main activity name]`, ex: `com.bacon.app/.MainActivity`\n */\nexport async function launchActivityAsync(\n  device: DeviceContext,\n  {\n    launchActivity,\n  }: {\n    launchActivity: string;\n  }\n) {\n  return openAsync(\n    adbArgs(\n      device.pid,\n      'shell',\n      'am',\n      'start',\n      // FLAG_ACTIVITY_SINGLE_TOP -- If set, the activity will not be launched if it is already running at the top of the history stack.\n      '-f',\n      '0x20000000',\n      // Activity to open first: com.bacon.app/.MainActivity\n      '-n',\n      launchActivity\n    )\n  );\n}\n\n/**\n * @param device.pid Process ID of the Android device to launch.\n * @param props.applicationId package name to launch.\n */\nexport async function openAppIdAsync(\n  device: DeviceContext,\n  {\n    applicationId,\n  }: {\n    applicationId: string;\n  }\n) {\n  return openAsync(\n    adbArgs(\n      device.pid,\n      'shell',\n      'monkey',\n      '-p',\n      applicationId,\n      '-c',\n      'android.intent.category.LAUNCHER',\n      '1'\n    )\n  );\n}\n\n/**\n * @param device.pid Process ID of the Android device to launch.\n * @param props.url URL to launch.\n */\nexport async function openUrlAsync(\n  device: DeviceContext,\n  {\n    url,\n  }: {\n    url: string;\n  }\n) {\n  return openAsync(\n    adbArgs(\n      device.pid,\n      'shell',\n      'am',\n      'start',\n      '-a',\n      'android.intent.action.VIEW',\n      '-d',\n      // ADB requires ampersands to be escaped.\n      url.replace(/&/g, String.raw`\\&`)\n    )\n  );\n}\n\n/** Runs a generic command watches for common errors in order to throw with an expected code. */\nasync function openAsync(args: string[]): Promise<string> {\n  const results = await getServer().runAsync(args);\n  if (\n    results.includes(CANT_START_ACTIVITY_ERROR) ||\n    results.match(/Error: Activity class .* does not exist\\./g)\n  ) {\n    throw new CommandError('APP_NOT_INSTALLED', results.substring(results.indexOf('Error: ')));\n  }\n  return results;\n}\n\n/** Uninstall an app given its Android package name. */\nexport async function uninstallAsync(\n  device: DeviceContext,\n  { appId }: { appId: string }\n): Promise<string> {\n  return await getServer().runAsync(adbArgs(device.pid, 'uninstall', appId));\n}\n\n/** Get package info from an app based on its Android package name. */\nexport async function getPackageInfoAsync(\n  device: DeviceContext,\n  { appId }: { appId: string }\n): Promise<string> {\n  return await getServer().runAsync(adbArgs(device.pid, 'shell', 'dumpsys', 'package', appId));\n}\n\n/** Install an app on a connected device. */\nexport async function installAsync(device: DeviceContext, { filePath }: { filePath: string }) {\n  // TODO: Handle the `INSTALL_FAILED_INSUFFICIENT_STORAGE` error.\n  return await getServer().runAsync(adbArgs(device.pid, 'install', '-r', '-d', filePath));\n}\n\n/** Format ADB args with process ID. */\nexport function adbArgs(pid: Device['pid'], ...options: string[]): string[] {\n  const args = [];\n  if (pid) {\n    args.push('-s', pid);\n  }\n  return args.concat(options);\n}\n\n// TODO: This is very expensive for some operations.\nexport async function getAttachedDevicesAsync(): Promise<Device[]> {\n  const output = await getServer().runAsync(['devices', '-l']);\n\n  const splitItems = output.trim().replace(/\\n$/, '').split(os.EOL);\n  // First line is `\"List of devices attached\"`, remove it\n  // @ts-ignore: todo\n  const attachedDevices: {\n    props: string[];\n    type: Device['type'];\n    isAuthorized: Device['isAuthorized'];\n  }[] = splitItems\n    .slice(1, splitItems.length)\n    .map((line) => {\n      // unauthorized: ['FA8251A00719', 'unauthorized', 'usb:338690048X', 'transport_id:5']\n      // authorized: ['FA8251A00719', 'device', 'usb:336592896X', 'product:walleye', 'model:Pixel_2', 'device:walleye', 'transport_id:4']\n      // emulator: ['emulator-5554', 'offline', 'transport_id:1']\n      const props = line.split(' ').filter(Boolean);\n\n      const isAuthorized = props[1] !== 'unauthorized';\n      const type = line.includes('emulator') ? 'emulator' : 'device';\n      return { props, type, isAuthorized };\n    })\n    .filter(({ props: [pid] }) => !!pid);\n\n  const devicePromises = attachedDevices.map<Promise<Device>>(async (props) => {\n    const {\n      type,\n      props: [pid, ...deviceInfo],\n      isAuthorized,\n    } = props;\n\n    let name: string | null = null;\n\n    if (type === 'device') {\n      if (isAuthorized) {\n        // Possibly formatted like `model:Pixel_2`\n        // Transform to `Pixel_2`\n        const modelItem = deviceInfo.find((info) => info.includes('model:'));\n        if (modelItem) {\n          name = modelItem.replace('model:', '');\n        }\n      }\n      // unauthorized devices don't have a name available to read\n      if (!name) {\n        // Device FA8251A00719\n        name = `Device ${pid}`;\n      }\n    } else {\n      // Given an emulator pid, get the emulator name which can be used to start the emulator later.\n      name = (await getAdbNameForDeviceIdAsync({ pid })) ?? '';\n    }\n\n    return {\n      pid,\n      name,\n      type,\n      isAuthorized,\n      isBooted: true,\n    };\n  });\n\n  return Promise.all(devicePromises);\n}\n\n/**\n * Return the Emulator name for an emulator ID, this can be used to determine if an emulator is booted.\n *\n * @param device.pid a value like `emulator-5554` from `abd devices`\n */\nexport async function getAdbNameForDeviceIdAsync(device: DeviceContext): Promise<string | null> {\n  const results = await getServer().runAsync(adbArgs(device.pid, 'emu', 'avd', 'name'));\n\n  if (results.match(/could not connect to TCP port .*: Connection refused/)) {\n    // Can also occur when the emulator does not exist.\n    throw new CommandError('EMULATOR_NOT_FOUND', results);\n  }\n\n  return sanitizeAdbDeviceName(results) ?? null;\n}\n\nexport async function isDeviceBootedAsync({\n  name,\n}: { name?: string } = {}): Promise<Device | null> {\n  const devices = await getAttachedDevicesAsync();\n\n  if (!name) {\n    return devices[0] ?? null;\n  }\n\n  return devices.find((device) => device.name === name) ?? null;\n}\n\n/**\n * Returns true when a device's splash screen animation has stopped.\n * This can be used to detect when a device is fully booted and ready to use.\n *\n * @param pid\n */\nexport async function isBootAnimationCompleteAsync(pid?: string): Promise<boolean> {\n  try {\n    const props = await getPropertyDataForDeviceAsync({ pid }, PROP_BOOT_ANIMATION_STATE);\n    return !!props[PROP_BOOT_ANIMATION_STATE].match(/stopped/);\n  } catch {\n    return false;\n  }\n}\n\n/** Get a list of ABIs for the provided device. */\nexport async function getDeviceABIsAsync(\n  device: Pick<Device, 'name' | 'pid'>\n): Promise<DeviceABI[]> {\n  const cpuAbiList = (await getPropertyDataForDeviceAsync(device, PROP_CPU_ABI_LIST_NAME))[\n    PROP_CPU_ABI_LIST_NAME\n  ];\n\n  if (cpuAbiList) {\n    return cpuAbiList.trim().split(',') as DeviceABI[];\n  }\n\n  const abi = (await getPropertyDataForDeviceAsync(device, PROP_CPU_NAME))[\n    PROP_CPU_NAME\n  ] as DeviceABI;\n  return [abi];\n}\n\nexport async function getPropertyDataForDeviceAsync(\n  device: DeviceContext,\n  prop?: string\n): Promise<DeviceProperties> {\n  // @ts-ignore\n  const propCommand = adbArgs(...[device.pid, 'shell', 'getprop', prop].filter(Boolean));\n  try {\n    // Prevent reading as UTF8.\n    const results = await getServer().getFileOutputAsync(propCommand);\n    // Like:\n    // [wifi.direct.interface]: [p2p-dev-wlan0]\n    // [wifi.interface]: [wlan0]\n\n    if (prop) {\n      debug(`Property data: (device pid: ${device.pid}, prop: ${prop}, data: ${results})`);\n      return {\n        [prop]: results,\n      };\n    }\n    const props = parseAdbDeviceProperties(results);\n\n    debug(`Parsed data:`, props);\n\n    return props;\n  } catch (error: any) {\n    // TODO: Ensure error has message and not stderr\n    throw new CommandError(`Failed to get properties for device (${device.pid}): ${error.message}`);\n  }\n}\n\nfunction parseAdbDeviceProperties(devicePropertiesString: string) {\n  const properties: DeviceProperties = {};\n  const propertyExp = /\\[(.*?)\\]: \\[(.*?)\\]/gm;\n  for (const match of devicePropertiesString.matchAll(propertyExp)) {\n    properties[match[1]] = match[2];\n  }\n  return properties;\n}\n\n/**\n * Sanitize the ADB device name to only get the actual device name.\n * On Windows, we need to do \\r, \\n, and \\r\\n filtering to get the name.\n */\nexport function sanitizeAdbDeviceName(deviceName: string) {\n  return deviceName\n    .trim()\n    .split(/[\\r\\n]+/)\n    .shift();\n}\n"],"mappings":"AAAA;;AAAA,IAAAA,eAAA,GAAAC,OAAA;AAAA,IAAAC,kBAAA,GAAAD,OAAA;AAAA,IAAAE,QAAA,GAAAF,OAAA;AAAA,IAAAG,cAAA,GAAAH,OAAA;AAAA,IAAAI,iBAAA,GAAAJ,OAAA;;;;QAuDgBK,SAAS,GAATA,SAAS;QAMTC,eAAe,GAAfA,eAAe;QASTC,uBAAuB,GAAvBA,uBAAuB;QAsBvBC,mBAAmB,GAAnBA,mBAAmB;QA4BnBC,cAAc,GAAdA,cAAc;QA0BdC,YAAY,GAAZA,YAAY;QAoCZC,cAAc,GAAdA,cAAc;QAQdC,mBAAmB,GAAnBA,mBAAmB;QAQnBC,YAAY,GAAZA,YAAY;QAMlBC,OAAO,GAAPA,OAAO;QASDC,uBAAuB,GAAvBA,uBAAuB;QAqEvBC,0BAA0B,GAA1BA,0BAA0B;QAW1BC,mBAAmB,GAAnBA,mBAAmB;QAkBnBC,4BAA4B,GAA5BA,4BAA4B;QAU5BC,kBAAkB,GAAlBA,kBAAkB;QAiBlBC,6BAA6B,GAA7BA,6BAA6B;QA2CnCC,qBAAqB,GAArBA,qBAAqB;;AA7XnB,IAAAC,MAAO,GAAAC,sBAAA,CAAAvB,OAAA,CAAP,OAAO;AACV,IAAAwB,GAAI,GAAAD,sBAAA,CAAAvB,OAAA,CAAJ,IAAI;AAEP,IAAAyB,GAAG,GAAAC,uBAAA,CAAA1B,OAAA,eAAoB,EAApB;AACc,IAAA2B,OAAuB,GAAA3B,OAAA;AAC1B,IAAA4B,KAAqB,GAAA5B,OAAA;AACrB,IAAA6B,UAAa,GAAA7B,OAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEvC,IAAM8B,KAAK,GAAG9B,OAAO,CAAC,OAAO,CAAC,CAAC,kCAAkC,CAAC;IAE3D+B,SAYN;;WAZWA,SAAS;EAATA,SAAS,CAKnB,KAAG,IAAH,KAAG;EALOA,SAAS,CAMnB,OAAK,IAAL,OAAK;EANKA,SAAS,CAOnB,KAAG,IAAH,KAAG;EAPOA,SAAS,CAQnB,KAAG,IAAH,KAAG;EAROA,SAAS,CASnB,YAAU,IAAG,aAAa;EAThBA,SAAS,CAUnB,SAAO,IAAP,SAAO;EAVGA,SAAS,CAWnB,WAAS,IAAT,WAAS;GAXCA,SAAS,KAAAC,OAAA,CAAAD,SAAA,GAATA,SAAS;AAgCrB,IAAME,yBAAyB,GAAG,gDAAgD;AAElF,IAAMC,aAAa,GAAG,oBAAoB;AAE1C,IAAMC,sBAAsB,GAAG,wBAAwB;AAIvD,IAAMC,yBAAyB,GAAG,mBAAmB;AAErD,IAAIC,OAAO;AAGJ,SAAShC,SAASA,CAAA,EAAG;EAC1BgC,OAAO,WAAPA,OAAO,GAAPA,OAAO,GAAK,IAAIR,UAAS,CAAAS,SAAA,EAAE;EAC3B,OAAOD,OAAO;;AAIT,SAAS/B,eAAeA,CAACiC,MAAc,EAAE;EAC9Cd,GAAG,CAACe,IAAI,CACL,uDAAsDlB,MAAK,CAAAmB,OAAA,CAACC,IAAI,CAACH,MAAM,CAACI,IAAI,CAAE,KAAIrB,MAAK,CAAAmB,OAAA,CAACG,GAAG,CAC1F,IAAAhB,KAAS,EAA6CiB,SAA7C,CAAC,2CAA2C,CAAC,CACtD,EAAC,CACJ;;AACF,SAGqBtC,uBAAuBA,CAAAuC,EAAA,EAAAC,GAAA;EAAA,OAAAC,wBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAF,yBAAA;EAAAA,wBAAA,GAAA5C,iBAAA,CAAtC,WACLmC,MAAqB,EACrBY,cAAsB,EACJ;IAClB,IAAMC,QAAQ,SAAS/C,SAAS,EAAE,CAACgD,QAAQ,CACzCvC,OAAO,CAACyB,MAAM,CAACe,GAAG,EAAE,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,UAAU,EAAEH,cAAc,CAAC,CACvE;IAED,IAAMI,KAAK,GAAGH,QAAQ,CAACI,KAAK,SAAS;IACrC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,KAAK,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;MACrC,IAAME,IAAI,GAAGJ,KAAK,CAACE,CAAC,CAAC,CAACG,IAAI,EAAE;MAC5B,IAAID,IAAI,KAAM,WAAUR,cAAe,EAAC,EAAE;QACxC,OAAO,IAAI;;;IAGf,OAAO,KAAK;GACb;EAAA,OAAAH,wBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAMqB1C,mBAAmBA,CAAAqD,GAAA,EAAAC,GAAA;EAAA,OAAAC,oBAAA,CAAAd,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAa,qBAAA;EAAAA,oBAAA,GAAA3D,iBAAA,CAAlC,WACLmC,MAAqB,EAAAyB,IAAA,EAMrB;IAAA,IAJEC,cAAc,GAAAD,IAAA,CAAdC,cAAc;IAKhB,OAAOC,SAAS,CACdpD,OAAO,CACLyB,MAAM,CAACe,GAAG,EACV,OAAO,EACP,IAAI,EACJ,OAAO,EAEP,IAAI,EACJ,YAAY,EAEZ,IAAI,EACJW,cAAc,CACf,CACF;GACF;EAAA,OAAAF,oBAAA,CAAAd,KAAA,OAAAC,SAAA;AAAA;AAAA,SAMqBzC,cAAcA,CAAA0D,GAAA,EAAAC,GAAA;EAAA,OAAAC,eAAA,CAAApB,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAmB,gBAAA;EAAAA,eAAA,GAAAjE,iBAAA,CAA7B,WACLmC,MAAqB,EAAA+B,KAAA,EAMrB;IAAA,IAJEC,aAAa,GAAAD,KAAA,CAAbC,aAAa;IAKf,OAAOL,SAAS,CACdpD,OAAO,CACLyB,MAAM,CAACe,GAAG,EACV,OAAO,EACP,QAAQ,EACR,IAAI,EACJiB,aAAa,EACb,IAAI,EACJ,kCAAkC,EAClC,GAAG,CACJ,CACF;GACF;EAAA,OAAAF,eAAA,CAAApB,KAAA,OAAAC,SAAA;AAAA;AAAA,SAMqBxC,YAAYA,CAAA8D,GAAA,EAAAC,GAAA;EAAA,OAAAC,aAAA,CAAAzB,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAwB,cAAA;EAAAA,aAAA,GAAAtE,iBAAA,CAA3B,WACLmC,MAAqB,EAAAoC,KAAA,EAMrB;IAAA,IAJEC,GAAG,GAAAD,KAAA,CAAHC,GAAG;IAKL,OAAOV,SAAS,CACdpD,OAAO,CACLyB,MAAM,CAACe,GAAG,EACV,OAAO,EACP,IAAI,EACJ,OAAO,EACP,IAAI,EACJ,4BAA4B,EAC5B,IAAI,EAEJsB,GAAG,CAACC,OAAO,OAAOC,MAAM,CAACC,GAAI,IAAG,CAAC,CAClC,CACF;GACF;EAAA,OAAAL,aAAA,CAAAzB,KAAA,OAAAC,SAAA;AAAA;AAAA,SAGcgB,SAASA,CAAAc,GAAA;EAAA,OAAAC,UAAA,CAAAhC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAA+B,WAAA;EAAAA,UAAA,GAAA7E,iBAAA,CAAxB,WAAyB8E,IAAc,EAAmB;IACxD,IAAMC,OAAO,SAAS9E,SAAS,EAAE,CAACgD,QAAQ,CAAC6B,IAAI,CAAC;IAChD,IACEC,OAAO,CAACC,QAAQ,CAACnD,yBAAyB,CAAC,IAC3CkD,OAAO,CAACE,KAAK,8CAA8C,EAC3D;MACA,MAAM,IAAI1D,OAAY,CAAA2D,YAAA,CAAC,mBAAmB,EAAEH,OAAO,CAACI,SAAS,CAACJ,OAAO,CAACK,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC;;IAE5F,OAAOL,OAAO;GACf;EAAA,OAAAF,UAAA,CAAAhC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAGqBvC,cAAcA,CAAA8E,IAAA,EAAAC,IAAA;EAAA,OAAAC,eAAA,CAAA1C,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAyC,gBAAA;EAAAA,eAAA,GAAAvF,iBAAA,CAA7B,WACLmC,MAAqB,EAAAqD,KAAA,EAEJ;IAAA,IADfC,KAAK,GAAAD,KAAA,CAALC,KAAK;IAEP,aAAaxF,SAAS,EAAE,CAACgD,QAAQ,CAACvC,OAAO,CAACyB,MAAM,CAACe,GAAG,EAAE,WAAW,EAAEuC,KAAK,CAAC,CAAC;GAC3E;EAAA,OAAAF,eAAA,CAAA1C,KAAA,OAAAC,SAAA;AAAA;AAAA,SAGqBtC,mBAAmBA,CAAAkF,IAAA,EAAAC,IAAA;EAAA,OAAAC,oBAAA,CAAA/C,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAA8C,qBAAA;EAAAA,oBAAA,GAAA5F,iBAAA,CAAlC,WACLmC,MAAqB,EAAA0D,KAAA,EAEJ;IAAA,IADfJ,KAAK,GAAAI,KAAA,CAALJ,KAAK;IAEP,aAAaxF,SAAS,EAAE,CAACgD,QAAQ,CAACvC,OAAO,CAACyB,MAAM,CAACe,GAAG,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,EAAEuC,KAAK,CAAC,CAAC;GAC7F;EAAA,OAAAG,oBAAA,CAAA/C,KAAA,OAAAC,SAAA;AAAA;AAAA,SAGqBrC,YAAYA,CAAAqF,IAAA,EAAAC,IAAA;EAAA,OAAAC,aAAA,CAAAnD,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAkD,cAAA;EAAAA,aAAA,GAAAhG,iBAAA,CAA3B,WAA4BmC,MAAqB,EAAA8D,KAAA,EAAsC;IAAA,IAAlCC,QAAQ,GAAAD,KAAA,CAARC,QAAQ;IAElE,aAAajG,SAAS,EAAE,CAACgD,QAAQ,CAACvC,OAAO,CAACyB,MAAM,CAACe,GAAG,EAAE,SAAS,EAAE,IAAI,EAAE,IAAI,EAAEgD,QAAQ,CAAC,CAAC;GACxF;EAAA,OAAAF,aAAA,CAAAnD,KAAA,OAAAC,SAAA;AAAA;AAGM,SAASpC,OAAOA,CAACwC,GAAkB,EAAkC;EAC1E,IAAM4B,IAAI,GAAG,EAAE;EACf,IAAI5B,GAAG,EAAE;IACP4B,IAAI,CAACqB,IAAI,CAAC,IAAI,EAAEjD,GAAG,CAAC;;EACrB,SAAAkD,IAAA,GAAAtD,SAAA,CAAAQ,MAAA,EAJ4C+C,OAAO,OAAAC,KAAA,CAAAF,IAAA,OAAAA,IAAA,WAAAG,IAAA,MAAAA,IAAA,GAAAH,IAAA,EAAAG,IAAA;IAAPF,OAAO,CAAAE,IAAA,QAAAzD,SAAA,CAAAyD,IAAA;EAAA;EAKpD,OAAOzB,IAAI,CAAC0B,MAAM,CAACH,OAAO,CAAC;;AAC5B,SAGqB1F,uBAAuBA,CAAA;EAAA,OAAA8F,wBAAA,CAAA5D,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAA2D,yBAAA;EAAAA,wBAAA,GAAAzG,iBAAA,CAAtC,aAA4D;IACjE,IAAM0G,MAAM,SAASzG,SAAS,EAAE,CAACgD,QAAQ,CAAC,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;IAE5D,IAAM0D,UAAU,GAAGD,MAAM,CAAClD,IAAI,EAAE,CAACiB,OAAO,QAAQ,EAAE,CAAC,CAACrB,KAAK,CAAChC,GAAE,CAAAiB,OAAA,CAACuE,GAAG,CAAC;IAGjE,IAAMC,eAAe,GAIfF,UAAU,CACbG,KAAK,CAAC,CAAC,EAAEH,UAAU,CAACrD,MAAM,CAAC,CAC3ByD,GAAG,CAAC,UAACxD,IAAI,EAAK;MAIb,IAAMyD,KAAK,GAAGzD,IAAI,CAACH,KAAK,CAAC,GAAG,CAAC,CAAC6D,MAAM,CAACC,OAAO,CAAC;MAE7C,IAAMC,YAAY,GAAGH,KAAK,CAAC,CAAC,CAAC,KAAK,cAAc;MAChD,IAAMI,IAAI,GAAG7D,IAAI,CAACyB,QAAQ,CAAC,UAAU,CAAC,GAAG,UAAU,GAAG,QAAQ;MAC9D,OAAO;QAAEgC,KAAK,EAALA,KAAK;QAAEI,IAAI,EAAJA,IAAI;QAAED,YAAY,EAAZA;OAAc;KACrC,CAAC,CACDF,MAAM,CAAC,UAAAI,KAAA;MAAA,IAAAC,WAAA,GAAAvH,cAAA,CAAAsH,KAAA,CAAGL,KAAK;QAAG9D,GAAG,GAAAoE,WAAA;MAAA,OAAQ,CAAC,CAACpE,GAAG;IAAA,EAAC;IAEtC,IAAMqE,cAAc,GAAGV,eAAe,CAACE,GAAG;MAAA,IAAAS,KAAA,GAAAxH,iBAAA,CAAkB,WAAOgH,KAAK,EAAK;QAC3E,IACEI,IAAI,GAGFJ,KAAK,CAHPI,IAAI;UAAAK,YAAA,GAAA3H,QAAA,CAGFkH,KAAK,CAFPA,KAAK;UAAG9D,GAAG,GAAAuE,YAAA;UAAKC,UAAU,GAAAD,YAAA,CAAAX,KAAA;UAC1BK,YAAY,GACVH,KAAK,CADPG,YAAY;QAGd,IAAI5E,IAAI,GAAkB,IAAI;QAE9B,IAAI6E,IAAI,KAAK,QAAQ,EAAE;UACrB,IAAID,YAAY,EAAE;YAGhB,IAAMQ,SAAS,GAAGD,UAAU,CAACE,IAAI,CAAC,UAACC,IAAI;cAAA,OAAKA,IAAI,CAAC7C,QAAQ,CAAC,QAAQ,CAAC;YAAA,EAAC;YACpE,IAAI2C,SAAS,EAAE;cACbpF,IAAI,GAAGoF,SAAS,CAAClD,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC;;;UAI1C,IAAI,CAAClC,IAAI,EAAE;YAETA,IAAI,GAAI,UAASW,GAAI,EAAC;;SAEzB,MAAM;cAEE4E,GAA2C;UAAlDvF,IAAI,GAAG,CAAAuF,GAA2C,SAApClH,0BAA0B,CAAC;YAAEsC,GAAG,EAAHA;WAAK,CAAC,YAA1C4E,GAA2C,GAAI,EAAE;;QAG1D,OAAO;UACL5E,GAAG,EAAHA,GAAG;UACHX,IAAI,EAAJA,IAAI;UACJ6E,IAAI,EAAJA,IAAI;UACJD,YAAY,EAAZA,YAAY;UACZY,QAAQ,EAAE;SACX;OACF;MAAA,iBAAAC,IAAA;QAAA,OAAAR,KAAA,CAAA3E,KAAA,OAAAC,SAAA;MAAA;IAAA,IAAC;IAEF,OAAOmF,OAAO,CAACC,GAAG,CAACX,cAAc,CAAC;GACnC;EAAA,OAAAd,wBAAA,CAAA5D,KAAA,OAAAC,SAAA;AAAA;AAAA,SAOqBlC,0BAA0BA,CAAAuH,IAAA;EAAA,OAAAC,2BAAA,CAAAvF,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAsF,4BAAA;EAAAA,2BAAA,GAAApI,iBAAA,CAAzC,WAA0CmC,MAAqB,EAA0B;IAC9F,IAAM4C,OAAO,SAAS9E,SAAS,EAAE,CAACgD,QAAQ,CAACvC,OAAO,CAACyB,MAAM,CAACe,GAAG,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;IAErF,IAAI6B,OAAO,CAACE,KAAK,wDAAwD,EAAE;MAEzE,MAAM,IAAI1D,OAAY,CAAA2D,YAAA,CAAC,oBAAoB,EAAEH,OAAO,CAAC;;QAGhD+C,GAA8B;IAArC,OAAO,CAAAA,GAA8B,GAA9B7G,qBAAqB,CAAC8D,OAAO,CAAC,YAA9B+C,GAA8B,GAAI,IAAI;GAC9C;EAAA,OAAAM,2BAAA,CAAAvF,KAAA,OAAAC,SAAA;AAAA;AAAA,SAEqBjC,mBAAmBA,CAAA;EAAA,OAAAwH,oBAAA,CAAAxF,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAuF,qBAAA;EAAAA,oBAAA,GAAArI,iBAAA,CAAlC,aAE4C;IAAA,IAAAsI,KAAA,GAAAxF,SAAA,CAAAQ,MAAA,QAAAR,SAAA,QAAAyF,SAAA,GAAAzF,SAAA,MAA5B,EAAE;MADvBP,IAAI,GAAA+F,KAAA,CAAJ/F,IAAI;IAEJ,IAAMiG,OAAO,SAAS7H,uBAAuB,EAAE;IAE/C,IAAI,CAAC4B,IAAI,EAAE;UACFuF,GAAU;MAAjB,OAAO,CAAAA,GAAU,GAAVU,OAAO,CAAC,CAAC,CAAC,YAAVV,GAAU,GAAI,IAAI;;QAGpBW,IAA8C;IAArD,OAAO,CAAAA,IAA8C,GAA9CD,OAAO,CAACZ,IAAI,CAAC,UAACzF,MAAM;MAAA,OAAKA,MAAM,CAACI,IAAI,KAAKA,IAAI;IAAA,EAAC,YAA9CkG,IAA8C,GAAI,IAAI;GAC9D;EAAA,OAAAJ,oBAAA,CAAAxF,KAAA,OAAAC,SAAA;AAAA;AAAA,SAQqBhC,4BAA4BA,CAAA4H,IAAA;EAAA,OAAAC,6BAAA,CAAA9F,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAA6F,8BAAA;EAAAA,6BAAA,GAAA3I,iBAAA,CAA3C,WAA4CkD,GAAY,EAAoB;IACjF,IAAI;MACF,IAAM8D,KAAK,SAAShG,6BAA6B,CAAC;QAAEkC,GAAG,EAAHA;OAAK,EAAElB,yBAAyB,CAAC;MACrF,OAAO,CAAC,CAACgF,KAAK,CAAChF,yBAAyB,CAAC,CAACiD,KAAK,WAAW;KAC3D,CAAC,OAAA2D,OAAA,EAAM;MACN,OAAO,KAAK;;GAEf;EAAA,OAAAD,6BAAA,CAAA9F,KAAA,OAAAC,SAAA;AAAA;AAAA,SAGqB/B,kBAAkBA,CAAA8H,IAAA;EAAA,OAAAC,mBAAA,CAAAjG,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAgG,oBAAA;EAAAA,mBAAA,GAAA9I,iBAAA,CAAjC,WACLmC,MAAoC,EACd;IACtB,IAAM4G,UAAU,GAAG,OAAO/H,6BAA6B,CAACmB,MAAM,EAAEJ,sBAAsB,CAAC,EACrFA,sBAAsB,CACvB;IAED,IAAIgH,UAAU,EAAE;MACd,OAAOA,UAAU,CAACvF,IAAI,EAAE,CAACJ,KAAK,CAAC,GAAG,CAAC;;IAGrC,IAAM4F,GAAG,GAAG,OAAOhI,6BAA6B,CAACmB,MAAM,EAAEL,aAAa,CAAC,EACrEA,aAAa,CACd;IACD,OAAO,CAACkH,GAAG,CAAC;GACb;EAAA,OAAAF,mBAAA,CAAAjG,KAAA,OAAAC,SAAA;AAAA;AAAA,SAEqB9B,6BAA6BA,CAAAiI,IAAA,EAAAC,IAAA;EAAA,OAAAC,8BAAA,CAAAtG,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAqG,+BAAA;EAAAA,8BAAA,GAAAnJ,iBAAA,CAA5C,WACLmC,MAAqB,EACrBiH,IAAa,EACc;IAE3B,IAAMC,WAAW,GAAG3I,OAAO,CAAAmC,KAAA,SAAAhD,kBAAA,CAAI,CAACsC,MAAM,CAACe,GAAG,EAAE,OAAO,EAAE,SAAS,EAAEkG,IAAI,CAAC,CAACnC,MAAM,CAACC,OAAO,CAAC,EAAC;IACtF,IAAI;MAEF,IAAMnC,OAAO,SAAS9E,SAAS,EAAE,CAACqJ,kBAAkB,CAACD,WAAW,CAAC;MAKjE,IAAID,IAAI,EAAE;QACR1H,KAAK,CAAE,+BAA8BS,MAAM,CAACe,GAAI,WAAUkG,IAAK,WAAUrE,OAAQ,GAAE,CAAC;QACpF,OAAApF,eAAA,KACGyJ,IAAI,EAAGrE,OAAO;;MAGnB,IAAMiC,KAAK,GAAGuC,wBAAwB,CAACxE,OAAO,CAAC;MAE/CrD,KAAK,CAAE,cAAa,EAAEsF,KAAK,CAAC;MAE5B,OAAOA,KAAK;KACb,CAAC,OAAOwC,KAAK,EAAO;MAEnB,MAAM,IAAIjI,OAAY,CAAA2D,YAAA,CAAE,wCAAuC/C,MAAM,CAACe,GAAI,MAAKsG,KAAK,CAACC,OAAQ,EAAC,CAAC;;GAElG;EAAA,OAAAN,8BAAA,CAAAtG,KAAA,OAAAC,SAAA;AAAA;AAED,SAASyG,wBAAwBA,CAACG,sBAA8B,EAAE;EAChE,IAAMC,UAAU,GAAqB,EAAE;EACvC,IAAMC,WAAW,2BAA2B;EAC5C,KAAK,IAAM3E,KAAK,IAAIyE,sBAAsB,CAACG,QAAQ,CAACD,WAAW,CAAC,EAAE;IAChED,UAAU,CAAC1E,KAAK,CAAC,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC;;EAEjC,OAAO0E,UAAU;;AAOZ,SAAS1I,qBAAqBA,CAAC6I,UAAkB,EAAE;EACxD,OAAOA,UAAU,CACdtG,IAAI,EAAE,CACNJ,KAAK,WAAW,CAChB2G,KAAK,EAAE"},"metadata":{},"sourceType":"script","externalDependencies":[]}