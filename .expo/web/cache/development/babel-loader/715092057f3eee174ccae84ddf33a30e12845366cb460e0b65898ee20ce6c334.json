{"ast":null,"code":"import _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nexport var VirtualizedList = function (_React$Component) {\n  _inherits(VirtualizedList, _React$Component);\n  var _super = _createSuper(VirtualizedList);\n  function VirtualizedList() {\n    _classCallCheck(this, VirtualizedList);\n    return _super.apply(this, arguments);\n  }\n  return _createClass(VirtualizedList);\n}(React.Component);","map":{"version":3,"names":["VirtualizedList","_React$Component","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","React","Component"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native/virtualized-lists/Lists/VirtualizedList.d.ts"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n */\n\nimport type * as React from 'react';\nimport type {\n  StyleProp,\n  ViewStyle,\n  ScrollViewProps,\n  LayoutChangeEvent,\n  View,\n  ScrollResponderMixin,\n  ScrollView,\n} from 'react-native';\n\nexport interface ViewToken {\n  item: any;\n  key: string;\n  index: number | null;\n  isViewable: boolean;\n  section?: any | undefined;\n}\n\nexport interface ViewabilityConfig {\n  /**\n   * Minimum amount of time (in milliseconds) that an item must be physically viewable before the\n   * viewability callback will be fired. A high number means that scrolling through content without\n   * stopping will not mark the content as viewable.\n   */\n  minimumViewTime?: number | undefined;\n\n  /**\n   * Percent of viewport that must be covered for a partially occluded item to count as\n   * \"viewable\", 0-100. Fully visible items are always considered viewable. A value of 0 means\n   * that a single pixel in the viewport makes the item viewable, and a value of 100 means that\n   * an item must be either entirely visible or cover the entire viewport to count as viewable.\n   */\n  viewAreaCoveragePercentThreshold?: number | undefined;\n\n  /**\n   * Similar to `viewAreaCoveragePercentThreshold`, but considers the percent of the item that is visible,\n   * rather than the fraction of the viewable area it covers.\n   */\n  itemVisiblePercentThreshold?: number | undefined;\n\n  /**\n   * Nothing is considered viewable until the user scrolls or `recordInteraction` is called after\n   * render.\n   */\n  waitForInteraction?: boolean | undefined;\n}\n\nexport interface ViewabilityConfigCallbackPair {\n  viewabilityConfig: ViewabilityConfig;\n  onViewableItemsChanged:\n    | ((info: {\n        viewableItems: Array<ViewToken>;\n        changed: Array<ViewToken>;\n      }) => void)\n    | null;\n}\n\nexport type ViewabilityConfigCallbackPairs = ViewabilityConfigCallbackPair[];\n\n/**\n * @see https://reactnative.dev/docs/flatlist#props\n */\n\nexport interface ListRenderItemInfo<ItemT> {\n  item: ItemT;\n\n  index: number;\n\n  separators: {\n    highlight: () => void;\n    unhighlight: () => void;\n    updateProps: (select: 'leading' | 'trailing', newProps: any) => void;\n  };\n}\n\nexport type ListRenderItem<ItemT> = (\n  info: ListRenderItemInfo<ItemT>,\n) => React.ReactElement | null;\n\nexport interface CellRendererProps<ItemT> {\n  cellKey: string;\n  children: React.ReactNode;\n  index: number;\n  item: ItemT;\n  onFocusCapture?: ((event: FocusEvent) => void) | undefined;\n  onLayout?: ((event: LayoutChangeEvent) => void) | undefined;\n  style: StyleProp<ViewStyle> | undefined;\n}\n\n/**\n * @see https://reactnative.dev/docs/virtualizedlist\n */\nexport class VirtualizedList<ItemT> extends React.Component<\n  VirtualizedListProps<ItemT>\n> {\n  scrollToEnd: (params?: {animated?: boolean | undefined}) => void;\n  scrollToIndex: (params: {\n    animated?: boolean | undefined;\n    index: number;\n    viewOffset?: number | undefined;\n    viewPosition?: number | undefined;\n  }) => void;\n  scrollToItem: (params: {\n    animated?: boolean | undefined;\n    item: ItemT;\n    viewOffset?: number | undefined;\n    viewPosition?: number | undefined;\n  }) => void;\n\n  /**\n   * Scroll to a specific content pixel offset in the list.\n   * Param `offset` expects the offset to scroll to. In case of horizontal is true, the\n   * offset is the x-value, in any other case the offset is the y-value.\n   * Param `animated` (true by default) defines whether the list should do an animation while scrolling.\n   */\n  scrollToOffset: (params: {\n    animated?: boolean | undefined;\n    offset: number;\n  }) => void;\n\n  recordInteraction: () => void;\n\n  getScrollRef: () =>\n    | React.ElementRef<typeof ScrollView>\n    | React.ElementRef<typeof View>\n    | null;\n\n  getScrollResponder: () => ScrollResponderMixin | null;\n}\n\n/**\n * @see https://reactnative.dev/docs/virtualizedlist#props\n */\n\nexport interface VirtualizedListProps<ItemT>\n  extends VirtualizedListWithoutRenderItemProps<ItemT> {\n  renderItem: ListRenderItem<ItemT> | null | undefined;\n}\n\nexport interface VirtualizedListWithoutRenderItemProps<ItemT>\n  extends ScrollViewProps {\n  /**\n   * Rendered in between each item, but not at the top or bottom\n   */\n  ItemSeparatorComponent?: React.ComponentType<any> | null | undefined;\n\n  /**\n   * Rendered when the list is empty. Can be a React Component Class, a render function, or\n   * a rendered element.\n   */\n  ListEmptyComponent?:\n    | React.ComponentType<any>\n    | React.ReactElement\n    | null\n    | undefined;\n\n  /**\n   * Rendered at the bottom of all the items. Can be a React Component Class, a render function, or\n   * a rendered element.\n   */\n  ListFooterComponent?:\n    | React.ComponentType<any>\n    | React.ReactElement\n    | null\n    | undefined;\n\n  /**\n   * Styling for internal View for ListFooterComponent\n   */\n  ListFooterComponentStyle?: StyleProp<ViewStyle> | undefined;\n\n  /**\n   * Rendered at the top of all the items. Can be a React Component Class, a render function, or\n   * a rendered element.\n   */\n  ListHeaderComponent?:\n    | React.ComponentType<any>\n    | React.ReactElement\n    | null\n    | undefined;\n\n  /**\n   * Styling for internal View for ListHeaderComponent\n   */\n  ListHeaderComponentStyle?: StyleProp<ViewStyle> | undefined;\n\n  /**\n   * The default accessor functions assume this is an Array<{key: string}> but you can override\n   * getItem, getItemCount, and keyExtractor to handle any type of index-based data.\n   */\n  data?: any | undefined;\n\n  /**\n   * `debug` will turn on extra logging and visual overlays to aid with debugging both usage and\n   * implementation, but with a significant perf hit.\n   */\n  debug?: boolean | undefined;\n\n  /**\n   * DEPRECATED: Virtualization provides significant performance and memory optimizations, but fully\n   * unmounts react instances that are outside of the render window. You should only need to disable\n   * this for debugging purposes.\n   */\n  disableVirtualization?: boolean | undefined;\n\n  /**\n   * A marker property for telling the list to re-render (since it implements `PureComponent`). If\n   * any of your `renderItem`, Header, Footer, etc. functions depend on anything outside of the\n   * `data` prop, stick it here and treat it immutably.\n   */\n  extraData?: any | undefined;\n\n  /**\n   * A generic accessor for extracting an item from any sort of data blob.\n   */\n  getItem?: ((data: any, index: number) => ItemT) | undefined;\n\n  /**\n   * Determines how many items are in the data blob.\n   */\n  getItemCount?: ((data: any) => number) | undefined;\n\n  getItemLayout?:\n    | ((\n        data: any,\n        index: number,\n      ) => {\n        length: number;\n        offset: number;\n        index: number;\n      })\n    | undefined;\n\n  horizontal?: boolean | null | undefined;\n\n  /**\n   * How many items to render in the initial batch. This should be enough to fill the screen but not\n   * much more. Note these items will never be unmounted as part of the windowed rendering in order\n   * to improve perceived performance of scroll-to-top actions.\n   */\n  initialNumToRender?: number | undefined;\n\n  /**\n   * Instead of starting at the top with the first item, start at `initialScrollIndex`. This\n   * disables the \"scroll to top\" optimization that keeps the first `initialNumToRender` items\n   * always rendered and immediately renders the items starting at this initial index. Requires\n   * `getItemLayout` to be implemented.\n   */\n  initialScrollIndex?: number | null | undefined;\n\n  /**\n   * Reverses the direction of scroll. Uses scale transforms of -1.\n   */\n  inverted?: boolean | null | undefined;\n\n  keyExtractor?: ((item: ItemT, index: number) => string) | undefined;\n\n  /**\n   * The maximum number of items to render in each incremental render batch. The more rendered at\n   * once, the better the fill rate, but responsiveness my suffer because rendering content may\n   * interfere with responding to button taps or other interactions.\n   */\n  maxToRenderPerBatch?: number | undefined;\n\n  /**\n   * Called once when the scroll position gets within within `onEndReachedThreshold`\n   * from the logical end of the list.\n   */\n  onEndReached?: ((info: {distanceFromEnd: number}) => void) | null | undefined;\n\n  /**\n   * How far from the end (in units of visible length of the list) the trailing edge of the\n   * list must be from the end of the content to trigger the `onEndReached` callback.\n   * Thus, a value of 0.5 will trigger `onEndReached` when the end of the content is\n   * within half the visible length of the list.\n   */\n  onEndReachedThreshold?: number | null | undefined;\n\n  onLayout?: ((event: LayoutChangeEvent) => void) | undefined;\n\n  /**\n   * If provided, a standard RefreshControl will be added for \"Pull to Refresh\" functionality. Make\n   * sure to also set the `refreshing` prop correctly.\n   */\n  onRefresh?: (() => void) | null | undefined;\n\n  /**\n   * Used to handle failures when scrolling to an index that has not been measured yet.\n   * Recommended action is to either compute your own offset and `scrollTo` it, or scroll as far\n   * as possible and then try again after more items have been rendered.\n   */\n  onScrollToIndexFailed?:\n    | ((info: {\n        index: number;\n        highestMeasuredFrameIndex: number;\n        averageItemLength: number;\n      }) => void)\n    | undefined;\n\n  /**\n   * Called once when the scroll position gets within within `onStartReachedThreshold`\n   * from the logical start of the list.\n   */\n  onStartReached?:\n    | ((info: {distanceFromStart: number}) => void)\n    | null\n    | undefined;\n\n  /**\n   * How far from the start (in units of visible length of the list) the leading edge of the\n   * list must be from the start of the content to trigger the `onStartReached` callback.\n   * Thus, a value of 0.5 will trigger `onStartReached` when the start of the content is\n   * within half the visible length of the list.\n   */\n  onStartReachedThreshold?: number | null | undefined;\n\n  /**\n   * Called when the viewability of rows changes, as defined by the\n   * `viewabilityConfig` prop.\n   */\n  onViewableItemsChanged?:\n    | ((info: {\n        viewableItems: Array<ViewToken>;\n        changed: Array<ViewToken>;\n      }) => void)\n    | null\n    | undefined;\n\n  /**\n   * Set this when offset is needed for the loading indicator to show correctly.\n   * @platform android\n   */\n  progressViewOffset?: number | undefined;\n\n  /**\n   * Set this true while waiting for new data from a refresh.\n   */\n  refreshing?: boolean | null | undefined;\n\n  /**\n   * Note: may have bugs (missing content) in some circumstances - use at your own risk.\n   *\n   * This may improve scroll performance for large lists.\n   */\n  removeClippedSubviews?: boolean | undefined;\n\n  /**\n   * Render a custom scroll component, e.g. with a differently styled `RefreshControl`.\n   */\n  renderScrollComponent?:\n    | ((props: ScrollViewProps) => React.ReactElement<ScrollViewProps>)\n    | undefined;\n\n  /**\n   * Amount of time between low-pri item render batches, e.g. for rendering items quite a ways off\n   * screen. Similar fill rate/responsiveness tradeoff as `maxToRenderPerBatch`.\n   */\n  updateCellsBatchingPeriod?: number | undefined;\n\n  viewabilityConfig?: ViewabilityConfig | undefined;\n\n  viewabilityConfigCallbackPairs?: ViewabilityConfigCallbackPairs | undefined;\n\n  /**\n   * Determines the maximum number of items rendered outside of the visible area, in units of\n   * visible lengths. So if your list fills the screen, then `windowSize={21}` (the default) will\n   * render the visible screen area plus up to 10 screens above and 10 below the viewport. Reducing\n   * this number will reduce memory consumption and may improve performance, but will increase the\n   * chance that fast scrolling may reveal momentary blank areas of unrendered content.\n   */\n  windowSize?: number | undefined;\n\n  /**\n   * CellRendererComponent allows customizing how cells rendered by\n   * `renderItem`/`ListItemComponent` are wrapped when placed into the\n   * underlying ScrollView. This component must accept event handlers which\n   * notify VirtualizedList of changes within the cell.\n   */\n  CellRendererComponent?:\n    | React.ComponentType<CellRendererProps<ItemT>>\n    | null\n    | undefined;\n}\n"],"mappings":";;;;;;;AAsGA,WAAaA,eAAe,aAAAC,gBAAA;EAAAC,SAAA,CAAAF,eAAA,EAAAC,gBAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,eAAA;EAAA,SAAAA,gBAAA;IAAAK,eAAA,OAAAL,eAAA;IAAA,OAAAG,MAAA,CAAAG,KAAA,OAAAC,SAAA;EAAA;EAAA,OAAAC,YAAA,CAAAR,eAAA;AAAA,EAAgBS,KAAK,CAACC,SAAS"},"metadata":{},"sourceType":"module","externalDependencies":[]}