{"ast":null,"code":"'use strict';\n\nvar _require = require(\"../utils.js\"),\n  getValueFromTypes = _require.getValueFromTypes;\nfunction buildCommandSchema(property, types) {\n  var name = property.key.name;\n  var optional = property.optional;\n  var value = getValueFromTypes(property.value, types);\n  var firstParam = value.params[0].typeAnnotation;\n  if (!(firstParam.id != null && firstParam.id.type === 'QualifiedTypeIdentifier' && firstParam.id.qualification.name === 'React' && firstParam.id.id.name === 'ElementRef')) {\n    throw new Error(`The first argument of method ${name} must be of type React.ElementRef<>`);\n  }\n  var params = value.params.slice(1).map(function (param) {\n    var paramName = param.name.name;\n    var paramValue = getValueFromTypes(param.typeAnnotation, types);\n    var type = paramValue.type === 'GenericTypeAnnotation' ? paramValue.id.name : paramValue.type;\n    var returnType;\n    switch (type) {\n      case 'RootTag':\n        returnType = {\n          type: 'ReservedTypeAnnotation',\n          name: 'RootTag'\n        };\n        break;\n      case 'BooleanTypeAnnotation':\n        returnType = {\n          type: 'BooleanTypeAnnotation'\n        };\n        break;\n      case 'Int32':\n        returnType = {\n          type: 'Int32TypeAnnotation'\n        };\n        break;\n      case 'Double':\n        returnType = {\n          type: 'DoubleTypeAnnotation'\n        };\n        break;\n      case 'Float':\n        returnType = {\n          type: 'FloatTypeAnnotation'\n        };\n        break;\n      case 'StringTypeAnnotation':\n        returnType = {\n          type: 'StringTypeAnnotation'\n        };\n        break;\n      default:\n        type;\n        throw new Error(`Unsupported param type for method \"${name}\", param \"${paramName}\". Found ${type}`);\n    }\n    return {\n      name: paramName,\n      optional: false,\n      typeAnnotation: returnType\n    };\n  });\n  return {\n    name: name,\n    optional: optional,\n    typeAnnotation: {\n      type: 'FunctionTypeAnnotation',\n      params: params,\n      returnTypeAnnotation: {\n        type: 'VoidTypeAnnotation'\n      }\n    }\n  };\n}\nfunction getCommands(commandTypeAST, types) {\n  return commandTypeAST.filter(function (property) {\n    return property.type === 'ObjectTypeProperty';\n  }).map(function (property) {\n    return buildCommandSchema(property, types);\n  }).filter(Boolean);\n}\nmodule.exports = {\n  getCommands: getCommands\n};","map":{"version":3,"names":["_require","require","getValueFromTypes","buildCommandSchema","property","types","name","key","optional","value","firstParam","params","typeAnnotation","id","type","qualification","Error","slice","map","param","paramName","paramValue","returnType","returnTypeAnnotation","getCommands","commandTypeAST","filter","Boolean","module","exports"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native/codegen/lib/parsers/flow/components/commands.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\n'use strict';\n\nconst _require = require('../utils.js'),\n  getValueFromTypes = _require.getValueFromTypes;\n\n// $FlowFixMe[unclear-type] there's no flowtype for ASTs\n\nfunction buildCommandSchema(property, types) {\n  const name = property.key.name;\n  const optional = property.optional;\n  const value = getValueFromTypes(property.value, types);\n  const firstParam = value.params[0].typeAnnotation;\n  if (\n    !(\n      firstParam.id != null &&\n      firstParam.id.type === 'QualifiedTypeIdentifier' &&\n      firstParam.id.qualification.name === 'React' &&\n      firstParam.id.id.name === 'ElementRef'\n    )\n  ) {\n    throw new Error(\n      `The first argument of method ${name} must be of type React.ElementRef<>`,\n    );\n  }\n  const params = value.params.slice(1).map(param => {\n    const paramName = param.name.name;\n    const paramValue = getValueFromTypes(param.typeAnnotation, types);\n    const type =\n      paramValue.type === 'GenericTypeAnnotation'\n        ? paramValue.id.name\n        : paramValue.type;\n    let returnType;\n    switch (type) {\n      case 'RootTag':\n        returnType = {\n          type: 'ReservedTypeAnnotation',\n          name: 'RootTag',\n        };\n        break;\n      case 'BooleanTypeAnnotation':\n        returnType = {\n          type: 'BooleanTypeAnnotation',\n        };\n        break;\n      case 'Int32':\n        returnType = {\n          type: 'Int32TypeAnnotation',\n        };\n        break;\n      case 'Double':\n        returnType = {\n          type: 'DoubleTypeAnnotation',\n        };\n        break;\n      case 'Float':\n        returnType = {\n          type: 'FloatTypeAnnotation',\n        };\n        break;\n      case 'StringTypeAnnotation':\n        returnType = {\n          type: 'StringTypeAnnotation',\n        };\n        break;\n      default:\n        type;\n        throw new Error(\n          `Unsupported param type for method \"${name}\", param \"${paramName}\". Found ${type}`,\n        );\n    }\n    return {\n      name: paramName,\n      optional: false,\n      typeAnnotation: returnType,\n    };\n  });\n  return {\n    name,\n    optional,\n    typeAnnotation: {\n      type: 'FunctionTypeAnnotation',\n      params,\n      returnTypeAnnotation: {\n        type: 'VoidTypeAnnotation',\n      },\n    },\n  };\n}\nfunction getCommands(commandTypeAST, types) {\n  return commandTypeAST\n    .filter(property => property.type === 'ObjectTypeProperty')\n    .map(property => buildCommandSchema(property, types))\n    .filter(Boolean);\n}\nmodule.exports = {\n  getCommands,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}