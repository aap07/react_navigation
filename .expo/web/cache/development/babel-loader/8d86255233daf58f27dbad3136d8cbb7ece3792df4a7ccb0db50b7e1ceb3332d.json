{"ast":null,"code":"import _toArray from \"@babel/runtime/helpers/toArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport { createNode } from \"../doc/createNode.js\";\nimport { isNode, isPair, isCollection, isScalar } from \"./identity.js\";\nimport { NodeBase } from \"./Node.js\";\nfunction collectionFromPath(schema, path, value) {\n  var v = value;\n  for (var i = path.length - 1; i >= 0; --i) {\n    var k = path[i];\n    if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {\n      var a = [];\n      a[k] = v;\n      v = a;\n    } else {\n      v = new Map([[k, v]]);\n    }\n  }\n  return createNode(v, undefined, {\n    aliasDuplicateObjects: false,\n    keepUndefined: false,\n    onAnchor: function onAnchor() {\n      throw new Error('This should not happen, please report a bug.');\n    },\n    schema: schema,\n    sourceObjects: new Map()\n  });\n}\nvar isEmptyPath = function isEmptyPath(path) {\n  return path == null || typeof path === 'object' && !!path[Symbol.iterator]().next().done;\n};\nvar Collection = function (_NodeBase) {\n  _inherits(Collection, _NodeBase);\n  var _super = _createSuper(Collection);\n  function Collection(type, schema) {\n    var _this;\n    _classCallCheck(this, Collection);\n    _this = _super.call(this, type);\n    Object.defineProperty(_assertThisInitialized(_this), 'schema', {\n      value: schema,\n      configurable: true,\n      enumerable: false,\n      writable: true\n    });\n    return _this;\n  }\n  _createClass(Collection, [{\n    key: \"clone\",\n    value: function clone(schema) {\n      var copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));\n      if (schema) copy.schema = schema;\n      copy.items = copy.items.map(function (it) {\n        return isNode(it) || isPair(it) ? it.clone(schema) : it;\n      });\n      if (this.range) copy.range = this.range.slice();\n      return copy;\n    }\n  }, {\n    key: \"addIn\",\n    value: function addIn(path, value) {\n      if (isEmptyPath(path)) this.add(value);else {\n        var _path = _toArray(path),\n          key = _path[0],\n          rest = _path.slice(1);\n        var node = this.get(key, true);\n        if (isCollection(node)) node.addIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n      }\n    }\n  }, {\n    key: \"deleteIn\",\n    value: function deleteIn(path) {\n      var _path2 = _toArray(path),\n        key = _path2[0],\n        rest = _path2.slice(1);\n      if (rest.length === 0) return this.delete(key);\n      var node = this.get(key, true);\n      if (isCollection(node)) return node.deleteIn(rest);else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n  }, {\n    key: \"getIn\",\n    value: function getIn(path, keepScalar) {\n      var _path3 = _toArray(path),\n        key = _path3[0],\n        rest = _path3.slice(1);\n      var node = this.get(key, true);\n      if (rest.length === 0) return !keepScalar && isScalar(node) ? node.value : node;else return isCollection(node) ? node.getIn(rest, keepScalar) : undefined;\n    }\n  }, {\n    key: \"hasAllNullValues\",\n    value: function hasAllNullValues(allowScalar) {\n      return this.items.every(function (node) {\n        if (!isPair(node)) return false;\n        var n = node.value;\n        return n == null || allowScalar && isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;\n      });\n    }\n  }, {\n    key: \"hasIn\",\n    value: function hasIn(path) {\n      var _path4 = _toArray(path),\n        key = _path4[0],\n        rest = _path4.slice(1);\n      if (rest.length === 0) return this.has(key);\n      var node = this.get(key, true);\n      return isCollection(node) ? node.hasIn(rest) : false;\n    }\n  }, {\n    key: \"setIn\",\n    value: function setIn(path, value) {\n      var _path5 = _toArray(path),\n        key = _path5[0],\n        rest = _path5.slice(1);\n      if (rest.length === 0) {\n        this.set(key, value);\n      } else {\n        var node = this.get(key, true);\n        if (isCollection(node)) node.setIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n      }\n    }\n  }]);\n  return Collection;\n}(NodeBase);\nCollection.maxFlowStringSingleLineLength = 60;\nexport { Collection, collectionFromPath, isEmptyPath };","map":{"version":3,"names":["createNode","isNode","isPair","isCollection","isScalar","NodeBase","collectionFromPath","schema","path","value","v","i","length","k","Number","isInteger","a","Map","undefined","aliasDuplicateObjects","keepUndefined","onAnchor","Error","sourceObjects","isEmptyPath","Symbol","iterator","next","done","Collection","_NodeBase","_inherits","_super","_createSuper","type","_this","_classCallCheck","call","Object","defineProperty","_assertThisInitialized","configurable","enumerable","writable","_createClass","key","clone","copy","create","getPrototypeOf","getOwnPropertyDescriptors","items","map","it","range","slice","addIn","add","_path","_toArray","rest","node","get","set","deleteIn","_path2","delete","getIn","keepScalar","_path3","hasAllNullValues","allowScalar","every","n","commentBefore","comment","tag","hasIn","_path4","has","setIn","_path5","maxFlowStringSingleLineLength"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native-community/cli-doctor/node_modules/yaml/browser/dist/nodes/Collection.js"],"sourcesContent":["import { createNode } from '../doc/createNode.js';\nimport { isNode, isPair, isCollection, isScalar } from './identity.js';\nimport { NodeBase } from './Node.js';\n\nfunction collectionFromPath(schema, path, value) {\n    let v = value;\n    for (let i = path.length - 1; i >= 0; --i) {\n        const k = path[i];\n        if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {\n            const a = [];\n            a[k] = v;\n            v = a;\n        }\n        else {\n            v = new Map([[k, v]]);\n        }\n    }\n    return createNode(v, undefined, {\n        aliasDuplicateObjects: false,\n        keepUndefined: false,\n        onAnchor: () => {\n            throw new Error('This should not happen, please report a bug.');\n        },\n        schema,\n        sourceObjects: new Map()\n    });\n}\n// Type guard is intentionally a little wrong so as to be more useful,\n// as it does not cover untypable empty non-string iterables (e.g. []).\nconst isEmptyPath = (path) => path == null ||\n    (typeof path === 'object' && !!path[Symbol.iterator]().next().done);\nclass Collection extends NodeBase {\n    constructor(type, schema) {\n        super(type);\n        Object.defineProperty(this, 'schema', {\n            value: schema,\n            configurable: true,\n            enumerable: false,\n            writable: true\n        });\n    }\n    /**\n     * Create a copy of this collection.\n     *\n     * @param schema - If defined, overwrites the original's schema\n     */\n    clone(schema) {\n        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));\n        if (schema)\n            copy.schema = schema;\n        copy.items = copy.items.map(it => isNode(it) || isPair(it) ? it.clone(schema) : it);\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /**\n     * Adds a value to the collection. For `!!map` and `!!omap` the value must\n     * be a Pair instance or a `{ key, value }` object, which may not have a key\n     * that already exists in the map.\n     */\n    addIn(path, value) {\n        if (isEmptyPath(path))\n            this.add(value);\n        else {\n            const [key, ...rest] = path;\n            const node = this.get(key, true);\n            if (isCollection(node))\n                node.addIn(rest, value);\n            else if (node === undefined && this.schema)\n                this.set(key, collectionFromPath(this.schema, rest, value));\n            else\n                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n        }\n    }\n    /**\n     * Removes a value from the collection.\n     * @returns `true` if the item was found and removed.\n     */\n    deleteIn(path) {\n        const [key, ...rest] = path;\n        if (rest.length === 0)\n            return this.delete(key);\n        const node = this.get(key, true);\n        if (isCollection(node))\n            return node.deleteIn(rest);\n        else\n            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n    /**\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    getIn(path, keepScalar) {\n        const [key, ...rest] = path;\n        const node = this.get(key, true);\n        if (rest.length === 0)\n            return !keepScalar && isScalar(node) ? node.value : node;\n        else\n            return isCollection(node) ? node.getIn(rest, keepScalar) : undefined;\n    }\n    hasAllNullValues(allowScalar) {\n        return this.items.every(node => {\n            if (!isPair(node))\n                return false;\n            const n = node.value;\n            return (n == null ||\n                (allowScalar &&\n                    isScalar(n) &&\n                    n.value == null &&\n                    !n.commentBefore &&\n                    !n.comment &&\n                    !n.tag));\n        });\n    }\n    /**\n     * Checks if the collection includes a value with the key `key`.\n     */\n    hasIn(path) {\n        const [key, ...rest] = path;\n        if (rest.length === 0)\n            return this.has(key);\n        const node = this.get(key, true);\n        return isCollection(node) ? node.hasIn(rest) : false;\n    }\n    /**\n     * Sets a value in this collection. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    setIn(path, value) {\n        const [key, ...rest] = path;\n        if (rest.length === 0) {\n            this.set(key, value);\n        }\n        else {\n            const node = this.get(key, true);\n            if (isCollection(node))\n                node.setIn(rest, value);\n            else if (node === undefined && this.schema)\n                this.set(key, collectionFromPath(this.schema, rest, value));\n            else\n                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n        }\n    }\n}\nCollection.maxFlowStringSingleLineLength = 60;\n\nexport { Collection, collectionFromPath, isEmptyPath };\n"],"mappings":";;;;;;;;;AAAA,SAASA,UAAU;AACnB,SAASC,MAAM,EAAEC,MAAM,EAAEC,YAAY,EAAEC,QAAQ;AAC/C,SAASC,QAAQ;AAEjB,SAASC,kBAAkBA,CAACC,MAAM,EAAEC,IAAI,EAAEC,KAAK,EAAE;EAC7C,IAAIC,CAAC,GAAGD,KAAK;EACb,KAAK,IAAIE,CAAC,GAAGH,IAAI,CAACI,MAAM,GAAG,CAAC,EAAED,CAAC,IAAI,CAAC,EAAE,EAAEA,CAAC,EAAE;IACvC,IAAME,CAAC,GAAGL,IAAI,CAACG,CAAC,CAAC;IACjB,IAAI,OAAOE,CAAC,KAAK,QAAQ,IAAIC,MAAM,CAACC,SAAS,CAACF,CAAC,CAAC,IAAIA,CAAC,IAAI,CAAC,EAAE;MACxD,IAAMG,CAAC,GAAG,EAAE;MACZA,CAAC,CAACH,CAAC,CAAC,GAAGH,CAAC;MACRA,CAAC,GAAGM,CAAC;IACT,CAAC,MACI;MACDN,CAAC,GAAG,IAAIO,GAAG,CAAC,CAAC,CAACJ,CAAC,EAAEH,CAAC,CAAC,CAAC,CAAC;IACzB;EACJ;EACA,OAAOV,UAAU,CAACU,CAAC,EAAEQ,SAAS,EAAE;IAC5BC,qBAAqB,EAAE,KAAK;IAC5BC,aAAa,EAAE,KAAK;IACpBC,QAAQ,EAAE,SAAAA,SAAA,EAAM;MACZ,MAAM,IAAIC,KAAK,CAAC,8CAA8C,CAAC;IACnE,CAAC;IACDf,MAAM,EAANA,MAAM;IACNgB,aAAa,EAAE,IAAIN,GAAG,CAAC;EAC3B,CAAC,CAAC;AACN;AAGA,IAAMO,WAAW,GAAG,SAAdA,WAAWA,CAAIhB,IAAI;EAAA,OAAKA,IAAI,IAAI,IAAI,IACrC,OAAOA,IAAI,KAAK,QAAQ,IAAI,CAAC,CAACA,IAAI,CAACiB,MAAM,CAACC,QAAQ,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC,CAACC,IAAK;AAAA;AAAC,IAClEC,UAAU,aAAAC,SAAA;EAAAC,SAAA,CAAAF,UAAA,EAAAC,SAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,UAAA;EACZ,SAAAA,WAAYK,IAAI,EAAE3B,MAAM,EAAE;IAAA,IAAA4B,KAAA;IAAAC,eAAA,OAAAP,UAAA;IACtBM,KAAA,GAAAH,MAAA,CAAAK,IAAA,OAAMH,IAAI;IACVI,MAAM,CAACC,cAAc,CAAAC,sBAAA,CAAAL,KAAA,GAAO,QAAQ,EAAE;MAClC1B,KAAK,EAAEF,MAAM;MACbkC,YAAY,EAAE,IAAI;MAClBC,UAAU,EAAE,KAAK;MACjBC,QAAQ,EAAE;IACd,CAAC,CAAC;IAAC,OAAAR,KAAA;EACP;EAACS,YAAA,CAAAf,UAAA;IAAAgB,GAAA;IAAApC,KAAA,EAMD,SAAAqC,MAAMvC,MAAM,EAAE;MACV,IAAMwC,IAAI,GAAGT,MAAM,CAACU,MAAM,CAACV,MAAM,CAACW,cAAc,CAAC,IAAI,CAAC,EAAEX,MAAM,CAACY,yBAAyB,CAAC,IAAI,CAAC,CAAC;MAC/F,IAAI3C,MAAM,EACNwC,IAAI,CAACxC,MAAM,GAAGA,MAAM;MACxBwC,IAAI,CAACI,KAAK,GAAGJ,IAAI,CAACI,KAAK,CAACC,GAAG,CAAC,UAAAC,EAAE;QAAA,OAAIpD,MAAM,CAACoD,EAAE,CAAC,IAAInD,MAAM,CAACmD,EAAE,CAAC,GAAGA,EAAE,CAACP,KAAK,CAACvC,MAAM,CAAC,GAAG8C,EAAE;MAAA,EAAC;MACnF,IAAI,IAAI,CAACC,KAAK,EACVP,IAAI,CAACO,KAAK,GAAG,IAAI,CAACA,KAAK,CAACC,KAAK,CAAC,CAAC;MACnC,OAAOR,IAAI;IACf;EAAC;IAAAF,GAAA;IAAApC,KAAA,EAMD,SAAA+C,MAAMhD,IAAI,EAAEC,KAAK,EAAE;MACf,IAAIe,WAAW,CAAChB,IAAI,CAAC,EACjB,IAAI,CAACiD,GAAG,CAAChD,KAAK,CAAC,CAAC,KACf;QACD,IAAAiD,KAAA,GAAAC,QAAA,CAAuBnD,IAAI;UAApBqC,GAAG,GAAAa,KAAA;UAAKE,IAAI,GAAAF,KAAA,CAAAH,KAAA;QACnB,IAAMM,IAAI,GAAG,IAAI,CAACC,GAAG,CAACjB,GAAG,EAAE,IAAI,CAAC;QAChC,IAAI1C,YAAY,CAAC0D,IAAI,CAAC,EAClBA,IAAI,CAACL,KAAK,CAACI,IAAI,EAAEnD,KAAK,CAAC,CAAC,KACvB,IAAIoD,IAAI,KAAK3C,SAAS,IAAI,IAAI,CAACX,MAAM,EACtC,IAAI,CAACwD,GAAG,CAAClB,GAAG,EAAEvC,kBAAkB,CAAC,IAAI,CAACC,MAAM,EAAEqD,IAAI,EAAEnD,KAAK,CAAC,CAAC,CAAC,KAE5D,MAAM,IAAIa,KAAK,CAAE,+BAA8BuB,GAAI,qBAAoBe,IAAK,EAAC,CAAC;MACtF;IACJ;EAAC;IAAAf,GAAA;IAAApC,KAAA,EAKD,SAAAuD,SAASxD,IAAI,EAAE;MACX,IAAAyD,MAAA,GAAAN,QAAA,CAAuBnD,IAAI;QAApBqC,GAAG,GAAAoB,MAAA;QAAKL,IAAI,GAAAK,MAAA,CAAAV,KAAA;MACnB,IAAIK,IAAI,CAAChD,MAAM,KAAK,CAAC,EACjB,OAAO,IAAI,CAACsD,MAAM,CAACrB,GAAG,CAAC;MAC3B,IAAMgB,IAAI,GAAG,IAAI,CAACC,GAAG,CAACjB,GAAG,EAAE,IAAI,CAAC;MAChC,IAAI1C,YAAY,CAAC0D,IAAI,CAAC,EAClB,OAAOA,IAAI,CAACG,QAAQ,CAACJ,IAAI,CAAC,CAAC,KAE3B,MAAM,IAAItC,KAAK,CAAE,+BAA8BuB,GAAI,qBAAoBe,IAAK,EAAC,CAAC;IACtF;EAAC;IAAAf,GAAA;IAAApC,KAAA,EAMD,SAAA0D,MAAM3D,IAAI,EAAE4D,UAAU,EAAE;MACpB,IAAAC,MAAA,GAAAV,QAAA,CAAuBnD,IAAI;QAApBqC,GAAG,GAAAwB,MAAA;QAAKT,IAAI,GAAAS,MAAA,CAAAd,KAAA;MACnB,IAAMM,IAAI,GAAG,IAAI,CAACC,GAAG,CAACjB,GAAG,EAAE,IAAI,CAAC;MAChC,IAAIe,IAAI,CAAChD,MAAM,KAAK,CAAC,EACjB,OAAO,CAACwD,UAAU,IAAIhE,QAAQ,CAACyD,IAAI,CAAC,GAAGA,IAAI,CAACpD,KAAK,GAAGoD,IAAI,CAAC,KAEzD,OAAO1D,YAAY,CAAC0D,IAAI,CAAC,GAAGA,IAAI,CAACM,KAAK,CAACP,IAAI,EAAEQ,UAAU,CAAC,GAAGlD,SAAS;IAC5E;EAAC;IAAA2B,GAAA;IAAApC,KAAA,EACD,SAAA6D,iBAAiBC,WAAW,EAAE;MAC1B,OAAO,IAAI,CAACpB,KAAK,CAACqB,KAAK,CAAC,UAAAX,IAAI,EAAI;QAC5B,IAAI,CAAC3D,MAAM,CAAC2D,IAAI,CAAC,EACb,OAAO,KAAK;QAChB,IAAMY,CAAC,GAAGZ,IAAI,CAACpD,KAAK;QACpB,OAAQgE,CAAC,IAAI,IAAI,IACZF,WAAW,IACRnE,QAAQ,CAACqE,CAAC,CAAC,IACXA,CAAC,CAAChE,KAAK,IAAI,IAAI,IACf,CAACgE,CAAC,CAACC,aAAa,IAChB,CAACD,CAAC,CAACE,OAAO,IACV,CAACF,CAAC,CAACG,GAAI;MACnB,CAAC,CAAC;IACN;EAAC;IAAA/B,GAAA;IAAApC,KAAA,EAID,SAAAoE,MAAMrE,IAAI,EAAE;MACR,IAAAsE,MAAA,GAAAnB,QAAA,CAAuBnD,IAAI;QAApBqC,GAAG,GAAAiC,MAAA;QAAKlB,IAAI,GAAAkB,MAAA,CAAAvB,KAAA;MACnB,IAAIK,IAAI,CAAChD,MAAM,KAAK,CAAC,EACjB,OAAO,IAAI,CAACmE,GAAG,CAAClC,GAAG,CAAC;MACxB,IAAMgB,IAAI,GAAG,IAAI,CAACC,GAAG,CAACjB,GAAG,EAAE,IAAI,CAAC;MAChC,OAAO1C,YAAY,CAAC0D,IAAI,CAAC,GAAGA,IAAI,CAACgB,KAAK,CAACjB,IAAI,CAAC,GAAG,KAAK;IACxD;EAAC;IAAAf,GAAA;IAAApC,KAAA,EAKD,SAAAuE,MAAMxE,IAAI,EAAEC,KAAK,EAAE;MACf,IAAAwE,MAAA,GAAAtB,QAAA,CAAuBnD,IAAI;QAApBqC,GAAG,GAAAoC,MAAA;QAAKrB,IAAI,GAAAqB,MAAA,CAAA1B,KAAA;MACnB,IAAIK,IAAI,CAAChD,MAAM,KAAK,CAAC,EAAE;QACnB,IAAI,CAACmD,GAAG,CAAClB,GAAG,EAAEpC,KAAK,CAAC;MACxB,CAAC,MACI;QACD,IAAMoD,IAAI,GAAG,IAAI,CAACC,GAAG,CAACjB,GAAG,EAAE,IAAI,CAAC;QAChC,IAAI1C,YAAY,CAAC0D,IAAI,CAAC,EAClBA,IAAI,CAACmB,KAAK,CAACpB,IAAI,EAAEnD,KAAK,CAAC,CAAC,KACvB,IAAIoD,IAAI,KAAK3C,SAAS,IAAI,IAAI,CAACX,MAAM,EACtC,IAAI,CAACwD,GAAG,CAAClB,GAAG,EAAEvC,kBAAkB,CAAC,IAAI,CAACC,MAAM,EAAEqD,IAAI,EAAEnD,KAAK,CAAC,CAAC,CAAC,KAE5D,MAAM,IAAIa,KAAK,CAAE,+BAA8BuB,GAAI,qBAAoBe,IAAK,EAAC,CAAC;MACtF;IACJ;EAAC;EAAA,OAAA/B,UAAA;AAAA,EAhHoBxB,QAAQ;AAkHjCwB,UAAU,CAACqD,6BAA6B,GAAG,EAAE;AAE7C,SAASrD,UAAU,EAAEvB,kBAAkB,EAAEkB,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}