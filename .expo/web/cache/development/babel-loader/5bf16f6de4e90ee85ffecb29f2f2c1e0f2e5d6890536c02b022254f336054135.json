{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nvar _toArray = require(\"@babel/runtime/helpers/toArray\");\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isOSType = isOSType;\nexports.getContainerPathAsync = getContainerPathAsync;\nexports.getInfoPlistValueAsync = getInfoPlistValueAsync;\nexports.openUrlAsync = openUrlAsync;\nexports.openAppIdAsync = openAppIdAsync;\nexports.bootAsync = bootAsync;\nexports.getBootedSimulatorsAsync = getBootedSimulatorsAsync;\nexports.isDeviceBootedAsync = isDeviceBootedAsync;\nexports.bootDeviceAsync = bootDeviceAsync;\nexports.installAsync = installAsync;\nexports.uninstallAsync = uninstallAsync;\nexports.getDevicesAsync = getDevicesAsync;\nexports.simctlAsync = simctlAsync;\nvar _spawnAsync = _interopRequireDefault(require(\"@expo/spawn-async\"));\nvar Log = _interopRequireWildcard(require(\"../../../log\"));\nvar _errors = require(\"../../../utils/errors\");\nvar _xcrun = require(\"./xcrun\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nfunction isOSType(value) {\n  if (!value || typeof value !== \"string\") return false;\n  var knownTypes = [\"iOS\", \"tvOS\", \"watchOS\", \"macOS\"];\n  if (!knownTypes.includes(value)) {\n    Log.warn(`Unknown OS type: ${value}. Expected one of: ${knownTypes.join(\", \")}`);\n  }\n  return true;\n}\nfunction getContainerPathAsync(_x, _x2) {\n  return _getContainerPathAsync.apply(this, arguments);\n}\nfunction _getContainerPathAsync() {\n  _getContainerPathAsync = _asyncToGenerator(function* (device, _ref) {\n    var appId = _ref.appId;\n    try {\n      var _yield$simctlAsync = yield simctlAsync([\"get_app_container\", resolveId(device), appId]),\n        stdout = _yield$simctlAsync.stdout;\n      return stdout.trim();\n    } catch (error) {\n      var ref;\n      if ((ref = error.stderr) == null ? void 0 : ref.match(/No such file or directory/)) {\n        return null;\n      }\n      throw error;\n    }\n  });\n  return _getContainerPathAsync.apply(this, arguments);\n}\nfunction getInfoPlistValueAsync(_x3, _x4) {\n  return _getInfoPlistValueAsync.apply(this, arguments);\n}\nfunction _getInfoPlistValueAsync() {\n  _getInfoPlistValueAsync = _asyncToGenerator(function* (device, _ref2) {\n    var appId = _ref2.appId,\n      key = _ref2.key;\n    var containerPath = yield getContainerPathAsync(device, {\n      appId: appId\n    });\n    if (containerPath) {\n      try {\n        var _yield$default = yield (0, _spawnAsync).default(\"defaults\", [\"read\", `${containerPath}/Info`, key], {\n            stdio: \"pipe\"\n          }),\n          output = _yield$default.output;\n        return output.join(\"\\n\").trim();\n      } catch (_unused) {\n        return null;\n      }\n    }\n    return null;\n  });\n  return _getInfoPlistValueAsync.apply(this, arguments);\n}\nfunction openUrlAsync(_x5, _x6) {\n  return _openUrlAsync.apply(this, arguments);\n}\nfunction _openUrlAsync() {\n  _openUrlAsync = _asyncToGenerator(function* (device, options) {\n    try {\n      yield simctlAsync([\"openurl\", resolveId(device), options.url]);\n    } catch (error) {\n      var ref;\n      if (!((ref = error.stderr) == null ? void 0 : ref.match(/Unable to lookup in current state: Shut/))) {\n        throw error;\n      }\n      yield bootDeviceAsync({\n        udid: resolveId(device)\n      });\n      return yield openUrlAsync(device, options);\n    }\n  });\n  return _openUrlAsync.apply(this, arguments);\n}\nfunction openAppIdAsync(_x7, _x8) {\n  return _openAppIdAsync.apply(this, arguments);\n}\nfunction _openAppIdAsync() {\n  _openAppIdAsync = _asyncToGenerator(function* (device, options) {\n    var results = yield openAppIdInternalAsync(device, options);\n    if (results.status === 4) {\n      throw new _errors.CommandError(\"APP_NOT_INSTALLED\", results.stderr);\n    }\n    return results;\n  });\n  return _openAppIdAsync.apply(this, arguments);\n}\nfunction openAppIdInternalAsync(_x9, _x10) {\n  return _openAppIdInternalAsync.apply(this, arguments);\n}\nfunction _openAppIdInternalAsync() {\n  _openAppIdInternalAsync = _asyncToGenerator(function* (device, options) {\n    try {\n      return yield simctlAsync([\"launch\", resolveId(device), options.appId]);\n    } catch (error) {\n      if (\"status\" in error) {\n        return error;\n      }\n      throw error;\n    }\n  });\n  return _openAppIdInternalAsync.apply(this, arguments);\n}\nfunction bootAsync(_x11) {\n  return _bootAsync.apply(this, arguments);\n}\nfunction _bootAsync() {\n  _bootAsync = _asyncToGenerator(function* (device) {\n    yield bootDeviceAsync(device);\n    return isDeviceBootedAsync(device);\n  });\n  return _bootAsync.apply(this, arguments);\n}\nfunction getBootedSimulatorsAsync() {\n  return _getBootedSimulatorsAsync.apply(this, arguments);\n}\nfunction _getBootedSimulatorsAsync() {\n  _getBootedSimulatorsAsync = _asyncToGenerator(function* () {\n    var simulatorDeviceInfo = yield getRuntimesAsync(\"devices\");\n    return Object.values(simulatorDeviceInfo.devices).flatMap(function (runtime) {\n      return runtime.filter(function (device) {\n        return device.state === \"Booted\";\n      });\n    });\n  });\n  return _getBootedSimulatorsAsync.apply(this, arguments);\n}\nfunction isDeviceBootedAsync(_x12) {\n  return _isDeviceBootedAsync.apply(this, arguments);\n}\nfunction _isDeviceBootedAsync() {\n  _isDeviceBootedAsync = _asyncToGenerator(function* (device) {\n    var devices = yield getBootedSimulatorsAsync();\n    if (device.udid) {\n      var ref;\n      return (ref = devices.find(function (bootedDevice) {\n        return bootedDevice.udid === device.udid;\n      })) != null ? ref : null;\n    }\n    var ref1;\n    return (ref1 = devices[0]) != null ? ref1 : null;\n  });\n  return _isDeviceBootedAsync.apply(this, arguments);\n}\nfunction bootDeviceAsync(_x13) {\n  return _bootDeviceAsync.apply(this, arguments);\n}\nfunction _bootDeviceAsync() {\n  _bootDeviceAsync = _asyncToGenerator(function* (device) {\n    try {\n      yield simctlAsync([\"boot\", device.udid]);\n    } catch (error) {\n      var ref;\n      if (!((ref = error.stderr) == null ? void 0 : ref.match(/Unable to boot device in current state: Booted/))) {\n        throw error;\n      }\n    }\n  });\n  return _bootDeviceAsync.apply(this, arguments);\n}\nfunction installAsync(_x14, _x15) {\n  return _installAsync.apply(this, arguments);\n}\nfunction _installAsync() {\n  _installAsync = _asyncToGenerator(function* (device, options) {\n    return simctlAsync([\"install\", resolveId(device), options.filePath]);\n  });\n  return _installAsync.apply(this, arguments);\n}\nfunction uninstallAsync(_x16, _x17) {\n  return _uninstallAsync.apply(this, arguments);\n}\nfunction _uninstallAsync() {\n  _uninstallAsync = _asyncToGenerator(function* (device, options) {\n    return simctlAsync([\"uninstall\", resolveId(device), options.appId]);\n  });\n  return _uninstallAsync.apply(this, arguments);\n}\nfunction parseSimControlJSONResults(input) {\n  try {\n    return JSON.parse(input);\n  } catch (error) {\n    if (error.message.includes(\"Unexpected token\")) {\n      Log.error(`Apple's simctl returned malformed JSON:\\n${input}`);\n    }\n    throw error;\n  }\n}\nfunction getRuntimesAsync(_x18, _x19) {\n  return _getRuntimesAsync.apply(this, arguments);\n}\nfunction _getRuntimesAsync() {\n  _getRuntimesAsync = _asyncToGenerator(function* (type, query) {\n    var result = yield simctlAsync([\"list\", type, \"--json\", query]);\n    var info = parseSimControlJSONResults(result.stdout);\n    for (var runtime of Object.keys(info.devices)) {\n      var runtimeSuffix = runtime.split(\"com.apple.CoreSimulator.SimRuntime.\").pop();\n      var _runtimeSuffix$split = runtimeSuffix.split(\"-\"),\n        _runtimeSuffix$split2 = _toArray(_runtimeSuffix$split),\n        osType = _runtimeSuffix$split2[0],\n        osVersionComponents = _runtimeSuffix$split2.slice(1);\n      var osVersion = osVersionComponents.join(\".\");\n      var sims = info.devices[runtime];\n      for (var device of sims) {\n        device.runtime = runtime;\n        device.osVersion = osVersion;\n        device.windowName = `${device.name} (${osVersion})`;\n        device.osType = osType;\n      }\n    }\n    return info;\n  });\n  return _getRuntimesAsync.apply(this, arguments);\n}\nfunction getDevicesAsync() {\n  return _getDevicesAsync.apply(this, arguments);\n}\nfunction _getDevicesAsync() {\n  _getDevicesAsync = _asyncToGenerator(function* () {\n    var simulatorDeviceInfo = yield getRuntimesAsync(\"devices\");\n    return Object.values(simulatorDeviceInfo.devices).flat();\n  });\n  return _getDevicesAsync.apply(this, arguments);\n}\nfunction simctlAsync(_x20, _x21) {\n  return _simctlAsync.apply(this, arguments);\n}\nfunction _simctlAsync() {\n  _simctlAsync = _asyncToGenerator(function* (args, options) {\n    return (0, _xcrun).xcrunAsync([\"simctl\"].concat(_toConsumableArray(args)), options);\n  });\n  return _simctlAsync.apply(this, arguments);\n}\nfunction resolveId(device) {\n  var _udid;\n  return (_udid = device.udid) != null ? _udid : \"booted\";\n}","map":{"version":3,"names":["_toConsumableArray","require","_toArray","_asyncToGenerator","isOSType","getContainerPathAsync","getInfoPlistValueAsync","openUrlAsync","openAppIdAsync","bootAsync","getBootedSimulatorsAsync","isDeviceBootedAsync","bootDeviceAsync","installAsync","uninstallAsync","getDevicesAsync","simctlAsync","_spawnAsync","_interopRequireDefault","Log","_interopRequireWildcard","_errors","_xcrun","value","knownTypes","includes","warn","join","_x","_x2","_getContainerPathAsync","apply","arguments","device","_ref","appId","_yield$simctlAsync","resolveId","stdout","trim","error","ref","stderr","match","_x3","_x4","_getInfoPlistValueAsync","_ref2","key","containerPath","_yield$default","default","stdio","output","_unused","_x5","_x6","_openUrlAsync","options","url","udid","_x7","_x8","_openAppIdAsync","results","openAppIdInternalAsync","status","CommandError","_x9","_x10","_openAppIdInternalAsync","_x11","_bootAsync","_getBootedSimulatorsAsync","simulatorDeviceInfo","getRuntimesAsync","Object","values","devices","flatMap","runtime","filter","state","_x12","_isDeviceBootedAsync","find","bootedDevice","ref1","_x13","_bootDeviceAsync","_x14","_x15","_installAsync","filePath","_x16","_x17","_uninstallAsync","parseSimControlJSONResults","input","JSON","parse","message","_x18","_x19","_getRuntimesAsync","type","query","result","info","keys","runtimeSuffix","split","pop","_runtimeSuffix$split","_runtimeSuffix$split2","osType","osVersionComponents","slice","osVersion","sims","windowName","name","_getDevicesAsync","flat","_x20","_x21","_simctlAsync","args","xcrunAsync","concat","_udid"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\cli\\src\\start\\platforms\\ios\\simctl.ts"],"sourcesContent":["import spawnAsync, { SpawnOptions, SpawnResult } from '@expo/spawn-async';\n\nimport * as Log from '../../../log';\nimport { CommandError } from '../../../utils/errors';\nimport { xcrunAsync } from './xcrun';\n\ntype DeviceState = 'Shutdown' | 'Booted';\n\nexport type OSType = 'iOS' | 'tvOS' | 'watchOS' | 'macOS';\n\nexport type Device = {\n  availabilityError?: 'runtime profile not found';\n  /** '/Users/name/Library/Developer/CoreSimulator/Devices/00E55DC0-0364-49DF-9EC6-77BE587137D4/data' */\n  dataPath: string;\n  /** @example `2811236352` */\n  dataPathSize?: number;\n  /** '/Users/name/Library/Logs/CoreSimulator/00E55DC0-0364-49DF-9EC6-77BE587137D4' */\n  logPath: string;\n  /** @example `479232` */\n  logPathSize?: number;\n  /** '00E55DC0-0364-49DF-9EC6-77BE587137D4' */\n  udid: string;\n  /** 'com.apple.CoreSimulator.SimRuntime.iOS-15-1' */\n  runtime: string;\n  /** If the device is \"available\" which generally means that the OS files haven't been deleted (this can happen when Xcode updates).  */\n  isAvailable: boolean;\n  /** 'com.apple.CoreSimulator.SimDeviceType.iPhone-13-Pro' */\n  deviceTypeIdentifier: string;\n  state: DeviceState;\n  /** 'iPhone 13 Pro' */\n  name: string;\n  /** Type of OS the device uses. */\n  osType: OSType;\n  /** '15.1' */\n  osVersion: string;\n  /** 'iPhone 13 Pro (15.1)' */\n  windowName: string;\n};\n\ntype SimulatorDeviceList = {\n  devices: {\n    [runtime: string]: Device[];\n  };\n};\n\ntype DeviceContext = Pick<Device, 'udid'>;\n\n/** Returns true if the given value is an `OSType`, if we don't recognize the value we continue anyways but warn. */\nexport function isOSType(value: any): value is OSType {\n  if (!value || typeof value !== 'string') return false;\n\n  const knownTypes = ['iOS', 'tvOS', 'watchOS', 'macOS'];\n  if (!knownTypes.includes(value)) {\n    Log.warn(`Unknown OS type: ${value}. Expected one of: ${knownTypes.join(', ')}`);\n  }\n  return true;\n}\n\n/**\n * Returns the local path for the installed tar.app. Returns null when the app isn't installed.\n *\n * @param device context for selecting a device.\n * @param props.appId bundle identifier for app.\n * @returns local file path to installed app binary, e.g. '/Users/evanbacon/Library/Developer/CoreSimulator/Devices/EFEEA6EF-E3F5-4EDE-9B72-29EAFA7514AE/data/Containers/Bundle/Application/FA43A0C6-C2AD-442D-B8B1-EAF3E88CF3BF/Exponent-2.21.3.tar.app'\n */\nexport async function getContainerPathAsync(\n  device: Partial<DeviceContext>,\n  {\n    appId,\n  }: {\n    appId: string;\n  }\n): Promise<string | null> {\n  try {\n    const { stdout } = await simctlAsync(['get_app_container', resolveId(device), appId]);\n    return stdout.trim();\n  } catch (error: any) {\n    if (error.stderr?.match(/No such file or directory/)) {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/** Return a value from an installed app's Info.plist. */\nexport async function getInfoPlistValueAsync(\n  device: Partial<DeviceContext>,\n  {\n    appId,\n    key,\n  }: {\n    appId: string;\n    key: string;\n  }\n): Promise<string | null> {\n  const containerPath = await getContainerPathAsync(device, { appId });\n  if (containerPath) {\n    try {\n      const { output } = await spawnAsync('defaults', ['read', `${containerPath}/Info`, key], {\n        stdio: 'pipe',\n      });\n      return output.join('\\n').trim();\n    } catch {\n      return null;\n    }\n  }\n  return null;\n}\n\n/** Open a URL on a device. The url can have any protocol. */\nexport async function openUrlAsync(\n  device: Partial<DeviceContext>,\n  options: { url: string }\n): Promise<void> {\n  try {\n    // Skip logging since this is likely to fail.\n    await simctlAsync(['openurl', resolveId(device), options.url]);\n  } catch (error: any) {\n    if (!error.stderr?.match(/Unable to lookup in current state: Shut/)) {\n      throw error;\n    }\n\n    // If the device was in a weird in-between state (\"Shutting Down\" or \"Shutdown\"), then attempt to reboot it and try again.\n    // This can happen when quitting the Simulator app, and immediately pressing `i` to reopen the project.\n\n    // First boot the simulator\n    await bootDeviceAsync({ udid: resolveId(device) });\n\n    // Finally, try again...\n    return await openUrlAsync(device, options);\n  }\n}\n\n/** Open a simulator using a bundle identifier. If no app with a matching bundle identifier is installed then an error will be thrown. */\nexport async function openAppIdAsync(\n  device: Partial<DeviceContext>,\n  options: {\n    appId: string;\n  }\n): Promise<SpawnResult> {\n  const results = await openAppIdInternalAsync(device, options);\n  // Similar to 194, this is a conformance issue which indicates that the given device has no app that can handle our launch request.\n  if (results.status === 4) {\n    throw new CommandError('APP_NOT_INSTALLED', results.stderr);\n  }\n  return results;\n}\nasync function openAppIdInternalAsync(\n  device: Partial<DeviceContext>,\n  options: {\n    appId: string;\n  }\n): Promise<SpawnResult> {\n  try {\n    return await simctlAsync(['launch', resolveId(device), options.appId]);\n  } catch (error: any) {\n    if ('status' in error) {\n      return error;\n    }\n    throw error;\n  }\n}\n\n// This will only boot in headless mode if the Simulator app is not running.\nexport async function bootAsync(device: DeviceContext): Promise<Device | null> {\n  await bootDeviceAsync(device);\n  return isDeviceBootedAsync(device);\n}\n\n/** Returns a list of devices whose current state is 'Booted' as an array. */\nexport async function getBootedSimulatorsAsync(): Promise<Device[]> {\n  const simulatorDeviceInfo = await getRuntimesAsync('devices');\n  return Object.values(simulatorDeviceInfo.devices).flatMap((runtime) =>\n    runtime.filter((device) => device.state === 'Booted')\n  );\n}\n\n/** Returns the current device if its state is 'Booted'. */\nexport async function isDeviceBootedAsync(device: Partial<DeviceContext>): Promise<Device | null> {\n  // Simulators can be booted even if the app isn't running :(\n  const devices = await getBootedSimulatorsAsync();\n  if (device.udid) {\n    return devices.find((bootedDevice) => bootedDevice.udid === device.udid) ?? null;\n  }\n\n  return devices[0] ?? null;\n}\n\n/** Boot a device. */\nexport async function bootDeviceAsync(device: DeviceContext): Promise<void> {\n  try {\n    // Skip logging since this is likely to fail.\n    await simctlAsync(['boot', device.udid]);\n  } catch (error: any) {\n    if (!error.stderr?.match(/Unable to boot device in current state: Booted/)) {\n      throw error;\n    }\n  }\n}\n\n/** Install a binary file on the device. */\nexport async function installAsync(\n  device: Partial<DeviceContext>,\n  options: {\n    /** Local absolute file path to an app binary that is built and provisioned for iOS simulators. */\n    filePath: string;\n  }\n): Promise<any> {\n  return simctlAsync(['install', resolveId(device), options.filePath]);\n}\n\n/** Uninstall an app from the provided device. */\nexport async function uninstallAsync(\n  device: Partial<DeviceContext>,\n  options: {\n    /** Bundle identifier */\n    appId: string;\n  }\n): Promise<any> {\n  return simctlAsync(['uninstall', resolveId(device), options.appId]);\n}\n\nfunction parseSimControlJSONResults(input: string): any {\n  try {\n    return JSON.parse(input);\n  } catch (error: any) {\n    // Nov 15, 2020: Observed this can happen when opening the simulator and the simulator prompts the user to update the xcode command line tools.\n    // Unexpected token I in JSON at position 0\n    if (error.message.includes('Unexpected token')) {\n      Log.error(`Apple's simctl returned malformed JSON:\\n${input}`);\n    }\n    throw error;\n  }\n}\n\n/** Get all runtime devices given a certain type. */\nasync function getRuntimesAsync(\n  type: 'devices' | 'devicetypes' | 'runtimes' | 'pairs',\n  query?: string | 'available'\n): Promise<SimulatorDeviceList> {\n  const result = await simctlAsync(['list', type, '--json', query]);\n  const info = parseSimControlJSONResults(result.stdout) as SimulatorDeviceList;\n\n  for (const runtime of Object.keys(info.devices)) {\n    // Given a string like 'com.apple.CoreSimulator.SimRuntime.tvOS-13-4'\n    const runtimeSuffix = runtime.split('com.apple.CoreSimulator.SimRuntime.').pop()!;\n    // Create an array [tvOS, 13, 4]\n    const [osType, ...osVersionComponents] = runtimeSuffix.split('-');\n    // Join the end components [13, 4] -> '13.4'\n    const osVersion = osVersionComponents.join('.');\n    const sims = info.devices[runtime];\n    for (const device of sims) {\n      device.runtime = runtime;\n      device.osVersion = osVersion;\n      device.windowName = `${device.name} (${osVersion})`;\n      device.osType = osType as OSType;\n    }\n  }\n  return info;\n}\n\n/** Return a list of iOS simulators. */\nexport async function getDevicesAsync(): Promise<Device[]> {\n  const simulatorDeviceInfo = await getRuntimesAsync('devices');\n  return Object.values(simulatorDeviceInfo.devices).flat();\n}\n\n/** Run a `simctl` command. */\nexport async function simctlAsync(\n  args: (string | undefined)[],\n  options?: SpawnOptions\n): Promise<SpawnResult> {\n  return xcrunAsync(['simctl', ...args], options);\n}\n\nfunction resolveId(device: Partial<DeviceContext>): string {\n  return device.udid ?? 'booted';\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}