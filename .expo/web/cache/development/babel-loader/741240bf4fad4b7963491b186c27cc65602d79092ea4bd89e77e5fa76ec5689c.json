{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveSearchPathsAsync = exports.mergeLinkingOptionsAsync = exports.projectPackageJsonPath = void 0;\nvar find_up_1 = __importDefault(require(\"find-up\"));\nvar fs_extra_1 = __importDefault(require(\"fs-extra\"));\nvar path_1 = __importDefault(require(\"path\"));\nexports.projectPackageJsonPath = find_up_1.default.sync('package.json', {\n  cwd: process.cwd()\n});\nif (!exports.projectPackageJsonPath) {\n  throw new Error(`Couldn't find \"package.json\" up from path \"${process.cwd()}\"`);\n}\nfunction mergeLinkingOptionsAsync(_x) {\n  return _mergeLinkingOptionsAsync.apply(this, arguments);\n}\nfunction _mergeLinkingOptionsAsync() {\n  _mergeLinkingOptionsAsync = _asyncToGenerator(function* (providedOptions) {\n    var _packageJson$expo;\n    var packageJson = require(exports.projectPackageJsonPath);\n    var baseOptions = (_packageJson$expo = packageJson.expo) == null ? void 0 : _packageJson$expo.autolinking;\n    var platformOptions = providedOptions.platform && (baseOptions == null ? void 0 : baseOptions[providedOptions.platform]);\n    var finalOptions = Object.assign({}, baseOptions, platformOptions, providedOptions);\n    finalOptions.searchPaths = yield resolveSearchPathsAsync(finalOptions.searchPaths, process.cwd());\n    finalOptions.nativeModulesDir = yield resolveNativeModulesDirAsync(finalOptions.nativeModulesDir, process.cwd());\n    return finalOptions;\n  });\n  return _mergeLinkingOptionsAsync.apply(this, arguments);\n}\nexports.mergeLinkingOptionsAsync = mergeLinkingOptionsAsync;\nfunction resolveSearchPathsAsync(_x2, _x3) {\n  return _resolveSearchPathsAsync.apply(this, arguments);\n}\nfunction _resolveSearchPathsAsync() {\n  _resolveSearchPathsAsync = _asyncToGenerator(function* (searchPaths, cwd) {\n    return searchPaths && searchPaths.length > 0 ? searchPaths.map(function (searchPath) {\n      return path_1.default.resolve(cwd, searchPath);\n    }) : yield findDefaultPathsAsync(cwd);\n  });\n  return _resolveSearchPathsAsync.apply(this, arguments);\n}\nexports.resolveSearchPathsAsync = resolveSearchPathsAsync;\nfunction findDefaultPathsAsync(_x4) {\n  return _findDefaultPathsAsync.apply(this, arguments);\n}\nfunction _findDefaultPathsAsync() {\n  _findDefaultPathsAsync = _asyncToGenerator(function* (cwd) {\n    var paths = [];\n    var dir = cwd;\n    var pkgJsonPath;\n    while (pkgJsonPath = yield (0, find_up_1.default)('package.json', {\n      cwd: dir\n    })) {\n      dir = path_1.default.dirname(path_1.default.dirname(pkgJsonPath));\n      paths.push(path_1.default.join(pkgJsonPath, '..', 'node_modules'));\n      if (path_1.default.dirname(dir) === dir) {\n        break;\n      }\n    }\n    return paths;\n  });\n  return _findDefaultPathsAsync.apply(this, arguments);\n}\nfunction resolveNativeModulesDirAsync(_x5, _x6) {\n  return _resolveNativeModulesDirAsync.apply(this, arguments);\n}\nfunction _resolveNativeModulesDirAsync() {\n  _resolveNativeModulesDirAsync = _asyncToGenerator(function* (nativeModulesDir, cwd) {\n    var packageJsonPath = yield (0, find_up_1.default)('package.json', {\n      cwd: cwd\n    });\n    var projectRoot = packageJsonPath != null ? path_1.default.join(packageJsonPath, '..') : cwd;\n    var resolvedPath = path_1.default.resolve(projectRoot, nativeModulesDir || 'modules');\n    return fs_extra_1.default.existsSync(resolvedPath) ? resolvedPath : null;\n  });\n  return _resolveNativeModulesDirAsync.apply(this, arguments);\n}","map":{"version":3,"names":["find_up_1","__importDefault","require","fs_extra_1","path_1","exports","projectPackageJsonPath","default","sync","cwd","process","Error","mergeLinkingOptionsAsync","_x","_mergeLinkingOptionsAsync","apply","arguments","_asyncToGenerator","providedOptions","_packageJson$expo","packageJson","baseOptions","expo","autolinking","platformOptions","platform","finalOptions","Object","assign","searchPaths","resolveSearchPathsAsync","nativeModulesDir","resolveNativeModulesDirAsync","_x2","_x3","_resolveSearchPathsAsync","length","map","searchPath","resolve","findDefaultPathsAsync","_x4","_findDefaultPathsAsync","paths","dir","pkgJsonPath","dirname","push","join","_x5","_x6","_resolveNativeModulesDirAsync","packageJsonPath","projectRoot","resolvedPath","existsSync"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\expo-modules-autolinking\\src\\autolinking\\mergeLinkingOptions.ts"],"sourcesContent":["import findUp from 'find-up';\nimport fs from 'fs-extra';\nimport path from 'path';\n\nimport { SearchOptions } from '../types';\n\n/**\n * Path to the `package.json` of the closest project in the current working dir.\n */\nexport const projectPackageJsonPath = findUp.sync('package.json', { cwd: process.cwd() }) as string;\n\n// This won't happen in usual scenarios, but we need to unwrap the optional path :)\nif (!projectPackageJsonPath) {\n  throw new Error(`Couldn't find \"package.json\" up from path \"${process.cwd()}\"`);\n}\n\n/**\n * Merges autolinking options from different sources (the later the higher priority)\n * - options defined in package.json's `expo.autolinking` field\n * - platform-specific options from the above (e.g. `expo.autolinking.ios`)\n * - options provided to the CLI command\n */\nexport async function mergeLinkingOptionsAsync<OptionsType extends SearchOptions>(\n  providedOptions: OptionsType\n): Promise<OptionsType> {\n  const packageJson = require(projectPackageJsonPath);\n  const baseOptions = packageJson.expo?.autolinking;\n  const platformOptions = providedOptions.platform && baseOptions?.[providedOptions.platform];\n  const finalOptions = Object.assign(\n    {},\n    baseOptions,\n    platformOptions,\n    providedOptions\n  ) as OptionsType;\n\n  // Makes provided paths absolute or falls back to default paths if none was provided.\n  finalOptions.searchPaths = await resolveSearchPathsAsync(finalOptions.searchPaths, process.cwd());\n\n  finalOptions.nativeModulesDir = await resolveNativeModulesDirAsync(\n    finalOptions.nativeModulesDir,\n    process.cwd()\n  );\n\n  return finalOptions;\n}\n\n/**\n * Resolves autolinking search paths. If none is provided, it accumulates all node_modules when\n * going up through the path components. This makes workspaces work out-of-the-box without any configs.\n */\nexport async function resolveSearchPathsAsync(\n  searchPaths: string[] | null,\n  cwd: string\n): Promise<string[]> {\n  return searchPaths && searchPaths.length > 0\n    ? searchPaths.map((searchPath) => path.resolve(cwd, searchPath))\n    : await findDefaultPathsAsync(cwd);\n}\n\n/**\n * Looks up for workspace's `node_modules` paths.\n */\nasync function findDefaultPathsAsync(cwd: string): Promise<string[]> {\n  const paths = [];\n  let dir = cwd;\n  let pkgJsonPath: string | undefined;\n\n  while ((pkgJsonPath = await findUp('package.json', { cwd: dir }))) {\n    dir = path.dirname(path.dirname(pkgJsonPath));\n    paths.push(path.join(pkgJsonPath, '..', 'node_modules'));\n\n    // This stops the infinite loop when the package.json is placed at the root dir.\n    if (path.dirname(dir) === dir) {\n      break;\n    }\n  }\n  return paths;\n}\n\n/**\n * Finds the real path to custom native modules directory.\n * - When {@link cwd} is inside the project directory, the path is searched relatively\n * to the project root (directory with the `package.json` file).\n * - When {@link cwd} is outside project directory (no `package.json` found), it is relative to\n * the current working directory (the {@link cwd} param).\n *\n * @param nativeModulesDir path to custom native modules directory. Defaults to `\"./modules\"` if null.\n * @param cwd current working directory\n * @returns resolved native modules directory or `null` if it is not found or doesn't exist.\n */\nasync function resolveNativeModulesDirAsync(\n  nativeModulesDir: string | null | undefined,\n  cwd: string\n): Promise<string | null> {\n  const packageJsonPath = await findUp('package.json', { cwd });\n  const projectRoot = packageJsonPath != null ? path.join(packageJsonPath, '..') : cwd;\n  const resolvedPath = path.resolve(projectRoot, nativeModulesDir || 'modules');\n  return fs.existsSync(resolvedPath) ? resolvedPath : null;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}