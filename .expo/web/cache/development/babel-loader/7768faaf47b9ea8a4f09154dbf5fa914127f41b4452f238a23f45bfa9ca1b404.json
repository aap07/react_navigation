{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nvar _objectWithoutProperties = require(\"@babel/runtime/helpers/objectWithoutProperties\");\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nvar _excluded = [\"nextMod\"],\n  _excluded2 = [\"modRequest\"],\n  _excluded3 = [\"modName\"],\n  _excluded4 = [\"platform\", \"providers\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertModResults = assertModResults;\nexports.createBaseMod = createBaseMod;\nexports.createPlatformBaseMod = createPlatformBaseMod;\nexports.provider = provider;\nexports.withGeneratedBaseMods = withGeneratedBaseMods;\nfunction _debug() {\n  var data = _interopRequireDefault(require(\"debug\"));\n  _debug = function _debug() {\n    return data;\n  };\n  return data;\n}\nfunction _withMod() {\n  var data = require(\"./withMod\");\n  _withMod = function _withMod() {\n    return data;\n  };\n  return data;\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar debug = (0, _debug().default)('expo:config-plugins:base-mods');\nfunction createBaseMod(_ref) {\n  var methodName = _ref.methodName,\n    platform = _ref.platform,\n    modName = _ref.modName,\n    getFilePath = _ref.getFilePath,\n    read = _ref.read,\n    write = _ref.write,\n    isIntrospective = _ref.isIntrospective;\n  var withUnknown = function withUnknown(config, _props) {\n    var _props$skipEmptyMod, _props$saveToInternal;\n    var props = _props || {};\n    return (0, _withMod().withBaseMod)(config, {\n      platform: platform,\n      mod: modName,\n      skipEmptyMod: (_props$skipEmptyMod = props.skipEmptyMod) !== null && _props$skipEmptyMod !== void 0 ? _props$skipEmptyMod : true,\n      saveToInternal: (_props$saveToInternal = props.saveToInternal) !== null && _props$saveToInternal !== void 0 ? _props$saveToInternal : false,\n      isProvider: true,\n      isIntrospective: isIntrospective,\n      action: function () {\n        var _action = _asyncToGenerator(function* (_ref2) {\n          var _ref2$modRequest = _ref2.modRequest,\n            nextMod = _ref2$modRequest.nextMod,\n            modRequest = _objectWithoutProperties(_ref2$modRequest, _excluded),\n            config = _objectWithoutProperties(_ref2, _excluded2);\n          try {\n            var results = _objectSpread(_objectSpread({}, config), {}, {\n              modRequest: modRequest\n            });\n            var filePath = yield getFilePath(results, props);\n            debug(`mods.${platform}.${modName}: file path: ${filePath || '[skipped]'}`);\n            var modResults = yield read(filePath, results, props);\n            results = yield nextMod(_objectSpread(_objectSpread({}, results), {}, {\n              modResults: modResults,\n              modRequest: modRequest\n            }));\n            assertModResults(results, modRequest.platform, modRequest.modName);\n            yield write(filePath, results, props);\n            return results;\n          } catch (error) {\n            error.message = `[${platform}.${modName}]: ${methodName}: ${error.message}`;\n            throw error;\n          }\n        });\n        function action(_x) {\n          return _action.apply(this, arguments);\n        }\n        return action;\n      }()\n    });\n  };\n  if (methodName) {\n    Object.defineProperty(withUnknown, 'name', {\n      value: methodName\n    });\n  }\n  return withUnknown;\n}\nfunction assertModResults(results, platformName, modName) {\n  var ensuredResults = results;\n  if (!ensuredResults || typeof ensuredResults !== 'object' || !(ensuredResults !== null && ensuredResults !== void 0 && ensuredResults.mods)) {\n    throw new Error(`Mod \\`mods.${platformName}.${modName}\\` evaluated to an object that is not a valid project config. Instead got: ${JSON.stringify(ensuredResults)}`);\n  }\n  return ensuredResults;\n}\nfunction upperFirst(name) {\n  return name.charAt(0).toUpperCase() + name.slice(1);\n}\nfunction createPlatformBaseMod(_ref3) {\n  var modName = _ref3.modName,\n    props = _objectWithoutProperties(_ref3, _excluded3);\n  var methodName = `with${upperFirst(props.platform)}${upperFirst(modName)}BaseMod`;\n  return createBaseMod(_objectSpread({\n    methodName: methodName,\n    modName: modName\n  }, props));\n}\nfunction provider(props) {\n  return props;\n}\nfunction withGeneratedBaseMods(config, _ref4) {\n  var platform = _ref4.platform,\n    providers = _ref4.providers,\n    props = _objectWithoutProperties(_ref4, _excluded4);\n  return Object.entries(providers).reduce(function (config, _ref5) {\n    var _ref6 = _slicedToArray(_ref5, 2),\n      modName = _ref6[0],\n      value = _ref6[1];\n    var baseMod = createPlatformBaseMod(_objectSpread({\n      platform: platform,\n      modName: modName\n    }, value));\n    return baseMod(config, props);\n  }, config);\n}","map":{"version":3,"names":["_debug","data","_interopRequireDefault","require","_withMod","obj","__esModule","default","debug","createBaseMod","_ref","methodName","platform","modName","getFilePath","read","write","isIntrospective","withUnknown","config","_props","_props$skipEmptyMod","_props$saveToInternal","props","withBaseMod","mod","skipEmptyMod","saveToInternal","isProvider","action","_action","_asyncToGenerator","_ref2","_ref2$modRequest","modRequest","nextMod","_objectWithoutProperties","_excluded","_excluded2","results","_objectSpread","filePath","modResults","assertModResults","error","message","_x","apply","arguments","Object","defineProperty","value","platformName","ensuredResults","mods","Error","JSON","stringify","upperFirst","name","charAt","toUpperCase","slice","createPlatformBaseMod","_ref3","_excluded3","provider","withGeneratedBaseMods","_ref4","providers","_excluded4","entries","reduce","_ref5","_ref6","_slicedToArray","baseMod"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\config-plugins\\src\\plugins\\createBaseMod.ts"],"sourcesContent":["import Debug from 'debug';\n\nimport {\n  ConfigPlugin,\n  ExportedConfig,\n  ExportedConfigWithProps,\n  ModPlatform,\n} from '../Plugin.types';\nimport { BaseModOptions, withBaseMod } from './withMod';\n\nconst debug = Debug('expo:config-plugins:base-mods');\n\nexport type ForwardedBaseModOptions = Partial<\n  Pick<BaseModOptions, 'saveToInternal' | 'skipEmptyMod'>\n>;\n\nexport type BaseModProviderMethods<\n  ModType,\n  Props extends ForwardedBaseModOptions = ForwardedBaseModOptions\n> = {\n  getFilePath: (config: ExportedConfigWithProps<ModType>, props: Props) => Promise<string> | string;\n  read: (\n    filePath: string,\n    config: ExportedConfigWithProps<ModType>,\n    props: Props\n  ) => Promise<ModType> | ModType;\n  write: (\n    filePath: string,\n    config: ExportedConfigWithProps<ModType>,\n    props: Props\n  ) => Promise<void> | void;\n  /**\n   * If the mod supports introspection, and avoids making any filesystem modifications during compilation.\n   * By enabling, this mod, and all of its descendants will be run in introspection mode.\n   * This should only be used for static files like JSON or XML, and not for application files that require regexes,\n   * or complex static files that require other files to be generated like Xcode `.pbxproj`.\n   */\n  isIntrospective?: boolean;\n};\n\nexport type CreateBaseModProps<\n  ModType,\n  Props extends ForwardedBaseModOptions = ForwardedBaseModOptions\n> = {\n  methodName: string;\n  platform: ModPlatform;\n  modName: string;\n} & BaseModProviderMethods<ModType, Props>;\n\nexport function createBaseMod<\n  ModType,\n  Props extends ForwardedBaseModOptions = ForwardedBaseModOptions\n>({\n  methodName,\n  platform,\n  modName,\n  getFilePath,\n  read,\n  write,\n  isIntrospective,\n}: CreateBaseModProps<ModType, Props>): ConfigPlugin<Props | void> {\n  const withUnknown: ConfigPlugin<Props | void> = (config, _props) => {\n    const props = _props || ({} as Props);\n    return withBaseMod<ModType>(config, {\n      platform,\n      mod: modName,\n      skipEmptyMod: props.skipEmptyMod ?? true,\n      saveToInternal: props.saveToInternal ?? false,\n      isProvider: true,\n      isIntrospective,\n      async action({ modRequest: { nextMod, ...modRequest }, ...config }) {\n        try {\n          let results: ExportedConfigWithProps<ModType> = {\n            ...config,\n            modRequest,\n          };\n\n          const filePath = await getFilePath(results, props);\n          debug(`mods.${platform}.${modName}: file path: ${filePath || '[skipped]'}`);\n          const modResults = await read(filePath, results, props);\n\n          results = await nextMod!({\n            ...results,\n            modResults,\n            modRequest,\n          });\n\n          assertModResults(results, modRequest.platform, modRequest.modName);\n\n          await write(filePath, results, props);\n          return results;\n        } catch (error: any) {\n          error.message = `[${platform}.${modName}]: ${methodName}: ${error.message}`;\n          throw error;\n        }\n      },\n    });\n  };\n\n  if (methodName) {\n    Object.defineProperty(withUnknown, 'name', {\n      value: methodName,\n    });\n  }\n\n  return withUnknown;\n}\n\nexport function assertModResults(results: any, platformName: string, modName: string) {\n  // If the results came from a mod, they'd be in the form of [config, data].\n  // Ensure the results are an array and omit the data since it should've been written by a data provider plugin.\n  const ensuredResults = results;\n\n  // Sanity check to help locate non compliant mods.\n  if (!ensuredResults || typeof ensuredResults !== 'object' || !ensuredResults?.mods) {\n    throw new Error(\n      `Mod \\`mods.${platformName}.${modName}\\` evaluated to an object that is not a valid project config. Instead got: ${JSON.stringify(\n        ensuredResults\n      )}`\n    );\n  }\n  return ensuredResults;\n}\n\nfunction upperFirst(name: string): string {\n  return name.charAt(0).toUpperCase() + name.slice(1);\n}\n\nexport function createPlatformBaseMod<\n  ModType,\n  Props extends ForwardedBaseModOptions = ForwardedBaseModOptions\n>({ modName, ...props }: Omit<CreateBaseModProps<ModType, Props>, 'methodName'>) {\n  // Generate the function name to ensure it's uniform and also to improve stack traces.\n  const methodName = `with${upperFirst(props.platform)}${upperFirst(modName)}BaseMod`;\n  return createBaseMod<ModType, Props>({\n    methodName,\n    modName,\n    ...props,\n  });\n}\n\n/** A TS wrapper for creating provides */\nexport function provider<ModType, Props extends ForwardedBaseModOptions = ForwardedBaseModOptions>(\n  props: BaseModProviderMethods<ModType, Props>\n) {\n  return props;\n}\n\n/** Plugin to create and append base mods from file providers */\nexport function withGeneratedBaseMods<ModName extends string>(\n  config: ExportedConfig,\n  {\n    platform,\n    providers,\n    ...props\n  }: ForwardedBaseModOptions & {\n    /** Officially supports `'ios' | 'android'` (`ModPlatform`). Arbitrary strings are supported for adding out-of-tree platforms. */\n    platform: ModPlatform & string;\n    providers: Partial<Record<ModName, BaseModProviderMethods<any, any>>>;\n  }\n): ExportedConfig {\n  return Object.entries(providers).reduce((config, [modName, value]) => {\n    const baseMod = createPlatformBaseMod({ platform, modName, ...(value as any) });\n    return baseMod(config, props);\n  }, config);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}