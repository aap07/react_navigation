{"ast":null,"code":"import _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nvar LinuxPlatform = _createClass(function LinuxPlatform() {\n  _classCallCheck(this, LinuxPlatform);\n});\nexport { LinuxPlatform as default };","map":{"version":3,"names":["LinuxPlatform","_createClass","_classCallCheck","default"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@expo/devcert/dist/platforms/linux.d.ts"],"sourcesContent":["import { Options } from '../index';\nimport { Platform } from '.';\nexport default class LinuxPlatform implements Platform {\n    private FIREFOX_NSS_DIR;\n    private CHROME_NSS_DIR;\n    private FIREFOX_BIN_PATH;\n    private CHROME_BIN_PATH;\n    private HOST_FILE_PATH;\n    /**\n     * Linux is surprisingly difficult. There seems to be multiple system-wide\n     * repositories for certs, so we copy ours to each. However, Firefox does it's\n     * usual separate trust store. Plus Chrome relies on the NSS tooling (like\n     * Firefox), but uses the user's NSS database, unlike Firefox (which uses a\n     * separate Mozilla one). And since Chrome doesn't prompt the user with a GUI\n     * flow when opening certs, if we can't use certutil to install our certificate\n     * into the user's NSS database, we're out of luck.\n     */\n    addToTrustStores(certificatePath: string, options?: Options): Promise<void>;\n    removeFromTrustStores(certificatePath: string): void;\n    addDomainToHostFileIfMissing(domain: string): Promise<void>;\n    deleteProtectedFiles(filepath: string): void;\n    readProtectedFile(filepath: string): Promise<string>;\n    writeProtectedFile(filepath: string, contents: string): Promise<void>;\n    private isFirefoxInstalled;\n    private isChromeInstalled;\n}\n"],"mappings":";;IAEqBA,aAAa,GAAAC,YAAA,UAAAD,cAAA;EAAAE,eAAA,OAAAF,aAAA;AAAA;AAAA,SAAbA,aAAa,IAAAG,OAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}