{"ast":null,"code":"import { Scalar } from \"../../nodes/Scalar.js\";\nimport { stringifyString } from \"../../stringify/stringifyString.js\";\nvar binary = {\n  identify: function identify(value) {\n    return value instanceof Uint8Array;\n  },\n  default: false,\n  tag: 'tag:yaml.org,2002:binary',\n  resolve: function resolve(src, onError) {\n    if (typeof Buffer === 'function') {\n      return Buffer.from(src, 'base64');\n    } else if (typeof atob === 'function') {\n      var str = atob(src.replace(/[\\n\\r]/g, ''));\n      var buffer = new Uint8Array(str.length);\n      for (var i = 0; i < str.length; ++i) buffer[i] = str.charCodeAt(i);\n      return buffer;\n    } else {\n      onError('This environment does not support reading binary tags; either Buffer or atob is required');\n      return src;\n    }\n  },\n  stringify: function stringify(_ref, ctx, onComment, onChompKeep) {\n    var comment = _ref.comment,\n      type = _ref.type,\n      value = _ref.value;\n    var buf = value;\n    var str;\n    if (typeof Buffer === 'function') {\n      str = buf instanceof Buffer ? buf.toString('base64') : Buffer.from(buf.buffer).toString('base64');\n    } else if (typeof btoa === 'function') {\n      var s = '';\n      for (var i = 0; i < buf.length; ++i) s += String.fromCharCode(buf[i]);\n      str = btoa(s);\n    } else {\n      throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\n    }\n    if (!type) type = Scalar.BLOCK_LITERAL;\n    if (type !== Scalar.QUOTE_DOUBLE) {\n      var lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);\n      var n = Math.ceil(str.length / lineWidth);\n      var lines = new Array(n);\n      for (var _i = 0, o = 0; _i < n; ++_i, o += lineWidth) {\n        lines[_i] = str.substr(o, lineWidth);\n      }\n      str = lines.join(type === Scalar.BLOCK_LITERAL ? '\\n' : ' ');\n    }\n    return stringifyString({\n      comment: comment,\n      type: type,\n      value: str\n    }, ctx, onComment, onChompKeep);\n  }\n};\nexport { binary };","map":{"version":3,"names":["Scalar","stringifyString","binary","identify","value","Uint8Array","default","tag","resolve","src","onError","Buffer","from","atob","str","replace","buffer","length","i","charCodeAt","stringify","_ref","ctx","onComment","onChompKeep","comment","type","buf","toString","btoa","s","String","fromCharCode","Error","BLOCK_LITERAL","QUOTE_DOUBLE","lineWidth","Math","max","options","indent","minContentWidth","n","ceil","lines","Array","o","substr","join"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native-community/cli-doctor/node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js"],"sourcesContent":["import { Scalar } from '../../nodes/Scalar.js';\nimport { stringifyString } from '../../stringify/stringifyString.js';\n\nconst binary = {\n    identify: value => value instanceof Uint8Array,\n    default: false,\n    tag: 'tag:yaml.org,2002:binary',\n    /**\n     * Returns a Buffer in node and an Uint8Array in browsers\n     *\n     * To use the resulting buffer as an image, you'll want to do something like:\n     *\n     *   const blob = new Blob([buffer], { type: 'image/jpeg' })\n     *   document.querySelector('#photo').src = URL.createObjectURL(blob)\n     */\n    resolve(src, onError) {\n        if (typeof Buffer === 'function') {\n            return Buffer.from(src, 'base64');\n        }\n        else if (typeof atob === 'function') {\n            // On IE 11, atob() can't handle newlines\n            const str = atob(src.replace(/[\\n\\r]/g, ''));\n            const buffer = new Uint8Array(str.length);\n            for (let i = 0; i < str.length; ++i)\n                buffer[i] = str.charCodeAt(i);\n            return buffer;\n        }\n        else {\n            onError('This environment does not support reading binary tags; either Buffer or atob is required');\n            return src;\n        }\n    },\n    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {\n        const buf = value; // checked earlier by binary.identify()\n        let str;\n        if (typeof Buffer === 'function') {\n            str =\n                buf instanceof Buffer\n                    ? buf.toString('base64')\n                    : Buffer.from(buf.buffer).toString('base64');\n        }\n        else if (typeof btoa === 'function') {\n            let s = '';\n            for (let i = 0; i < buf.length; ++i)\n                s += String.fromCharCode(buf[i]);\n            str = btoa(s);\n        }\n        else {\n            throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\n        }\n        if (!type)\n            type = Scalar.BLOCK_LITERAL;\n        if (type !== Scalar.QUOTE_DOUBLE) {\n            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);\n            const n = Math.ceil(str.length / lineWidth);\n            const lines = new Array(n);\n            for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {\n                lines[i] = str.substr(o, lineWidth);\n            }\n            str = lines.join(type === Scalar.BLOCK_LITERAL ? '\\n' : ' ');\n        }\n        return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);\n    }\n};\n\nexport { binary };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}