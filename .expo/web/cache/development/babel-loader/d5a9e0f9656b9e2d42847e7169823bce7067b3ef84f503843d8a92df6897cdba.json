{"ast":null,"code":"'use strict';\n\nvar _require = require('util'),\n  inspect = _require.inspect;\nmodule.exports = function sub(pattern) {\n  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    values[_key - 1] = arguments[_key];\n  }\n  var regex = /%(?:(%)|(-)?(\\*)?(?:\\((\\w+)\\))?([A-Za-z]))/g;\n  var result = pattern.replace(regex, function (_, is_literal, is_left_align, is_padded, name, format) {\n    if (is_literal) return '%';\n    var padded_count = 0;\n    if (is_padded) {\n      if (values.length === 0) throw new TypeError('not enough arguments for format string');\n      padded_count = values.shift();\n      if (!Number.isInteger(padded_count)) throw new TypeError('* wants int');\n    }\n    var str;\n    if (name !== undefined) {\n      var dict = values[0];\n      if (typeof dict !== 'object' || dict === null) throw new TypeError('format requires a mapping');\n      if (!(name in dict)) throw new TypeError(`no such key: '${name}'`);\n      str = dict[name];\n    } else {\n      if (values.length === 0) throw new TypeError('not enough arguments for format string');\n      str = values.shift();\n    }\n    switch (format) {\n      case 's':\n        str = String(str);\n        break;\n      case 'r':\n        str = inspect(str);\n        break;\n      case 'd':\n      case 'i':\n        if (typeof str !== 'number') {\n          throw new TypeError(`%${format} format: a number is required, not ${typeof str}`);\n        }\n        str = String(str.toFixed(0));\n        break;\n      default:\n        throw new TypeError(`unsupported format character '${format}'`);\n    }\n    if (padded_count > 0) {\n      return is_left_align ? str.padEnd(padded_count) : str.padStart(padded_count);\n    } else {\n      return str;\n    }\n  });\n  if (values.length) {\n    if (values.length === 1 && typeof values[0] === 'object' && values[0] !== null) {} else {\n      throw new TypeError('not all arguments converted during string formatting');\n    }\n  }\n  return result;\n};","map":{"version":3,"names":["_require","require","inspect","module","exports","sub","pattern","_len","arguments","length","values","Array","_key","regex","result","replace","_","is_literal","is_left_align","is_padded","name","format","padded_count","TypeError","shift","Number","isInteger","str","undefined","dict","String","toFixed","padEnd","padStart"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@expo/xcpretty/node_modules/argparse/lib/sub.js"],"sourcesContent":["// Limited implementation of python % string operator, supports only %s and %r for now\n// (other formats are not used here, but may appear in custom templates)\n\n'use strict'\n\nconst { inspect } = require('util')\n\n\nmodule.exports = function sub(pattern, ...values) {\n    let regex = /%(?:(%)|(-)?(\\*)?(?:\\((\\w+)\\))?([A-Za-z]))/g\n\n    let result = pattern.replace(regex, function (_, is_literal, is_left_align, is_padded, name, format) {\n        if (is_literal) return '%'\n\n        let padded_count = 0\n        if (is_padded) {\n            if (values.length === 0) throw new TypeError('not enough arguments for format string')\n            padded_count = values.shift()\n            if (!Number.isInteger(padded_count)) throw new TypeError('* wants int')\n        }\n\n        let str\n        if (name !== undefined) {\n            let dict = values[0]\n            if (typeof dict !== 'object' || dict === null) throw new TypeError('format requires a mapping')\n            if (!(name in dict)) throw new TypeError(`no such key: '${name}'`)\n            str = dict[name]\n        } else {\n            if (values.length === 0) throw new TypeError('not enough arguments for format string')\n            str = values.shift()\n        }\n\n        switch (format) {\n            case 's':\n                str = String(str)\n                break\n            case 'r':\n                str = inspect(str)\n                break\n            case 'd':\n            case 'i':\n                if (typeof str !== 'number') {\n                    throw new TypeError(`%${format} format: a number is required, not ${typeof str}`)\n                }\n                str = String(str.toFixed(0))\n                break\n            default:\n                throw new TypeError(`unsupported format character '${format}'`)\n        }\n\n        if (padded_count > 0) {\n            return is_left_align ? str.padEnd(padded_count) : str.padStart(padded_count)\n        } else {\n            return str\n        }\n    })\n\n    if (values.length) {\n        if (values.length === 1 && typeof values[0] === 'object' && values[0] !== null) {\n            // mapping\n        } else {\n            throw new TypeError('not all arguments converted during string formatting')\n        }\n    }\n\n    return result\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}