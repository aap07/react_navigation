{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseBuffer = exports.parseFile = exports.UID = exports.maxObjectCount = exports.maxObjectSize = void 0;\nvar fs_1 = __importDefault(require(\"fs\"));\nvar debug = false;\nexports.maxObjectSize = 100 * 1000 * 1000;\nexports.maxObjectCount = 32768;\nvar EPOCH = 978307200000;\nvar UID = _createClass(function UID(_UID) {\n  _classCallCheck(this, UID);\n  this.UID = _UID;\n});\nexports.UID = UID;\nfunction parseFile(_x) {\n  return _parseFile.apply(this, arguments);\n}\nfunction _parseFile() {\n  _parseFile = _asyncToGenerator(function* (fileNameOrBuffer) {\n    if (Buffer.isBuffer(fileNameOrBuffer)) {\n      return exports.parseBuffer(fileNameOrBuffer);\n    }\n    var data = yield fs_1.default.promises.readFile(fileNameOrBuffer);\n    return exports.parseBuffer(data);\n  });\n  return _parseFile.apply(this, arguments);\n}\nexports.parseFile = parseFile;\n;\nvar parseBuffer = function parseBuffer(buffer) {\n  var header = buffer.slice(0, 'bplist'.length).toString('utf8');\n  if (header !== 'bplist') {\n    throw new Error(\"Invalid binary plist. Expected 'bplist' at offset 0.\");\n  }\n  var trailer = buffer.slice(buffer.length - 32, buffer.length);\n  var offsetSize = trailer.readUInt8(6);\n  if (debug) {\n    console.log('offsetSize: ' + offsetSize);\n  }\n  var objectRefSize = trailer.readUInt8(7);\n  if (debug) {\n    console.log('objectRefSize: ' + objectRefSize);\n  }\n  var numObjects = readUInt64BE(trailer, 8);\n  if (debug) {\n    console.log('numObjects: ' + numObjects);\n  }\n  var topObject = readUInt64BE(trailer, 16);\n  if (debug) {\n    console.log('topObject: ' + topObject);\n  }\n  var offsetTableOffset = readUInt64BE(trailer, 24);\n  if (debug) {\n    console.log('offsetTableOffset: ' + offsetTableOffset);\n  }\n  if (numObjects > exports.maxObjectCount) {\n    throw new Error('maxObjectCount exceeded');\n  }\n  var offsetTable = [];\n  for (var i = 0; i < numObjects; i++) {\n    var offsetBytes = buffer.slice(offsetTableOffset + i * offsetSize, offsetTableOffset + (i + 1) * offsetSize);\n    offsetTable[i] = readUInt(offsetBytes, 0);\n    if (debug) {\n      console.log('Offset for Object #' + i + ' is ' + offsetTable[i] + ' [' + offsetTable[i].toString(16) + ']');\n    }\n  }\n  function parseObject(tableOffset) {\n    var offset = offsetTable[tableOffset];\n    var type = buffer[offset];\n    var objType = (type & 0xf0) >> 4;\n    var objInfo = type & 0x0f;\n    switch (objType) {\n      case 0x0:\n        return parseSimple();\n      case 0x1:\n        return parseInteger();\n      case 0x8:\n        return parseUID();\n      case 0x2:\n        return parseReal();\n      case 0x3:\n        return parseDate();\n      case 0x4:\n        return parseData();\n      case 0x5:\n        return parsePlistString();\n      case 0x6:\n        return parsePlistString(true);\n      case 0xa:\n        return parseArray();\n      case 0xd:\n        return parseDictionary();\n      default:\n        throw new Error('Unhandled type 0x' + objType.toString(16));\n    }\n    function parseSimple() {\n      switch (objInfo) {\n        case 0x0:\n          return null;\n        case 0x8:\n          return false;\n        case 0x9:\n          return true;\n        case 0xf:\n          return null;\n        default:\n          throw new Error('Unhandled simple type 0x' + objType.toString(16));\n      }\n    }\n    function bufferToHexString(buffer) {\n      var str = '';\n      var i;\n      for (i = 0; i < buffer.length; i++) {\n        if (buffer[i] != 0x00) {\n          break;\n        }\n      }\n      for (; i < buffer.length; i++) {\n        var part = '00' + buffer[i].toString(16);\n        str += part.substr(part.length - 2);\n      }\n      return str;\n    }\n    function parseInteger() {\n      var length = Math.pow(2, objInfo);\n      if (length < exports.maxObjectSize) {\n        var data = buffer.slice(offset + 1, offset + 1 + length);\n        if (length === 16) {\n          var str = bufferToHexString(data);\n          return BigInt(str);\n        }\n        return data.reduce(function (acc, curr) {\n          acc <<= 8;\n          acc |= curr & 255;\n          return acc;\n        });\n      } else {\n        throw new Error('Too little heap space available! Wanted to read ' + length + ' bytes, but only ' + exports.maxObjectSize + ' are available.');\n      }\n    }\n    function parseUID() {\n      var length = objInfo + 1;\n      if (length < exports.maxObjectSize) {\n        return new UID(readUInt(buffer.slice(offset + 1, offset + 1 + length)));\n      }\n      throw new Error('Too little heap space available! Wanted to read ' + length + ' bytes, but only ' + exports.maxObjectSize + ' are available.');\n    }\n    function parseReal() {\n      var length = Math.pow(2, objInfo);\n      if (length < exports.maxObjectSize) {\n        var realBuffer = buffer.slice(offset + 1, offset + 1 + length);\n        if (length === 4) {\n          return realBuffer.readFloatBE(0);\n        }\n        if (length === 8) {\n          return realBuffer.readDoubleBE(0);\n        }\n      } else {\n        throw new Error('Too little heap space available! Wanted to read ' + length + ' bytes, but only ' + exports.maxObjectSize + ' are available.');\n      }\n      return null;\n    }\n    function parseDate() {\n      if (objInfo != 0x3) {\n        console.error('Unknown date type :' + objInfo + '. Parsing anyway...');\n      }\n      var dateBuffer = buffer.slice(offset + 1, offset + 9);\n      return new Date(EPOCH + 1000 * dateBuffer.readDoubleBE(0));\n    }\n    function parseData() {\n      var dataoffset = 1;\n      var length = objInfo;\n      if (objInfo == 0xf) {\n        var int_type = buffer[offset + 1];\n        var intType = (int_type & 0xf0) / 0x10;\n        if (intType != 0x1) {\n          console.error('0x4: UNEXPECTED LENGTH-INT TYPE! ' + intType);\n        }\n        var intInfo = int_type & 0x0f;\n        var intLength = Math.pow(2, intInfo);\n        dataoffset = 2 + intLength;\n        if (intLength < 3) {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        } else {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        }\n      }\n      if (length < exports.maxObjectSize) {\n        return buffer.slice(offset + dataoffset, offset + dataoffset + length);\n      }\n      throw new Error('Too little heap space available! Wanted to read ' + length + ' bytes, but only ' + exports.maxObjectSize + ' are available.');\n    }\n    function parsePlistString(isUtf16) {\n      isUtf16 = isUtf16 || 0;\n      var enc = 'utf8';\n      var length = objInfo;\n      var stroffset = 1;\n      if (objInfo == 0xf) {\n        var int_type = buffer[offset + 1];\n        var intType = (int_type & 0xf0) / 0x10;\n        if (intType != 0x1) {\n          console.error('UNEXPECTED LENGTH-INT TYPE! ' + intType);\n        }\n        var intInfo = int_type & 0x0f;\n        var intLength = Math.pow(2, intInfo);\n        stroffset = 2 + intLength;\n        if (intLength < 3) {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        } else {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        }\n      }\n      length *= isUtf16 + 1;\n      if (length < exports.maxObjectSize) {\n        var plistString = Buffer.from(buffer.slice(offset + stroffset, offset + stroffset + length));\n        if (isUtf16) {\n          plistString = swapBytes(plistString);\n          enc = 'ucs2';\n        }\n        return plistString.toString(enc);\n      }\n      throw new Error('Too little heap space available! Wanted to read ' + length + ' bytes, but only ' + exports.maxObjectSize + ' are available.');\n    }\n    function parseArray() {\n      var length = objInfo;\n      var arrayoffset = 1;\n      if (objInfo == 0xf) {\n        var int_type = buffer[offset + 1];\n        var intType = (int_type & 0xf0) / 0x10;\n        if (intType != 0x1) {\n          console.error('0xa: UNEXPECTED LENGTH-INT TYPE! ' + intType);\n        }\n        var intInfo = int_type & 0x0f;\n        var intLength = Math.pow(2, intInfo);\n        arrayoffset = 2 + intLength;\n        if (intLength < 3) {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        } else {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        }\n      }\n      if (length * objectRefSize > exports.maxObjectSize) {\n        throw new Error('Too little heap space available!');\n      }\n      var array = [];\n      for (var _i = 0; _i < length; _i++) {\n        var objRef = readUInt(buffer.slice(offset + arrayoffset + _i * objectRefSize, offset + arrayoffset + (_i + 1) * objectRefSize));\n        array[_i] = parseObject(objRef);\n      }\n      return array;\n    }\n    function parseDictionary() {\n      var length = objInfo;\n      var dictoffset = 1;\n      if (objInfo == 0xf) {\n        var int_type = buffer[offset + 1];\n        var intType = (int_type & 0xf0) / 0x10;\n        if (intType != 0x1) {\n          console.error('0xD: UNEXPECTED LENGTH-INT TYPE! ' + intType);\n        }\n        var intInfo = int_type & 0x0f;\n        var intLength = Math.pow(2, intInfo);\n        dictoffset = 2 + intLength;\n        if (intLength < 3) {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        } else {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        }\n      }\n      if (length * 2 * objectRefSize > exports.maxObjectSize) {\n        throw new Error('Too little heap space available!');\n      }\n      if (debug) {\n        console.log('Parsing dictionary #' + tableOffset);\n      }\n      var dict = {};\n      for (var _i2 = 0; _i2 < length; _i2++) {\n        var keyRef = readUInt(buffer.slice(offset + dictoffset + _i2 * objectRefSize, offset + dictoffset + (_i2 + 1) * objectRefSize));\n        var valRef = readUInt(buffer.slice(offset + dictoffset + length * objectRefSize + _i2 * objectRefSize, offset + dictoffset + length * objectRefSize + (_i2 + 1) * objectRefSize));\n        var key = parseObject(keyRef);\n        var val = parseObject(valRef);\n        if (debug) {\n          console.log('  DICT #' + tableOffset + ': Mapped ' + key + ' to ' + val);\n        }\n        dict[key] = val;\n      }\n      return dict;\n    }\n  }\n  return [parseObject(topObject)];\n};\nexports.parseBuffer = parseBuffer;\nfunction readUInt(buffer) {\n  var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  start = start || 0;\n  var l = 0;\n  for (var i = start; i < buffer.length; i++) {\n    l <<= 8;\n    l |= buffer[i] & 0xff;\n  }\n  return l;\n}\nfunction readUInt64BE(buffer, start) {\n  var data = buffer.slice(start, start + 8);\n  return data.readUInt32BE(4, 8);\n}\nfunction swapBytes(buffer) {\n  var len = buffer.length;\n  for (var i = 0; i < len; i += 2) {\n    var a = buffer[i];\n    buffer[i] = buffer[i + 1];\n    buffer[i + 1] = a;\n  }\n  return buffer;\n}","map":{"version":3,"names":["fs_1","__importDefault","require","debug","exports","maxObjectSize","maxObjectCount","EPOCH","UID","_createClass","_classCallCheck","parseFile","_x","_parseFile","apply","arguments","_asyncToGenerator","fileNameOrBuffer","Buffer","isBuffer","parseBuffer","data","default","promises","readFile","buffer","header","slice","length","toString","Error","trailer","offsetSize","readUInt8","console","log","objectRefSize","numObjects","readUInt64BE","topObject","offsetTableOffset","offsetTable","i","offsetBytes","readUInt","parseObject","tableOffset","offset","type","objType","objInfo","parseSimple","parseInteger","parseUID","parseReal","parseDate","parseData","parsePlistString","parseArray","parseDictionary","bufferToHexString","str","part","substr","Math","pow","BigInt","reduce","acc","curr","realBuffer","readFloatBE","readDoubleBE","error","dateBuffer","Date","dataoffset","int_type","intType","intInfo","intLength","isUtf16","enc","stroffset","plistString","from","swapBytes","arrayoffset","array","objRef","dictoffset","dict","keyRef","valRef","key","val","start","undefined","l","readUInt32BE","len","a"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\plist\\src\\osxBinary.ts"],"sourcesContent":["// adapted from https://github.com/3breadt/dd-plist\nimport fs from 'fs';\n\nimport { PlistValue } from '.';\n\nconst debug = false;\n\nexport const maxObjectSize = 100 * 1000 * 1000; // 100Meg\nexport const maxObjectCount = 32768;\n\n// EPOCH = new SimpleDateFormat(\"yyyy MM dd zzz\").parse(\"2001 01 01 GMT\").getTime();\n// ...but that's annoying in a static initializer because it can throw exceptions, ick.\n// So we just hardcode the correct value.\nconst EPOCH = 978307200000;\n\n// UID object definition\n\nexport class UID {\n  constructor(public UID: number) {}\n}\n\nexport async function parseFile(fileNameOrBuffer: string | Buffer) {\n  if (Buffer.isBuffer(fileNameOrBuffer)) {\n    return parseBuffer(fileNameOrBuffer);\n  }\n\n  const data = await fs.promises.readFile(fileNameOrBuffer);\n  return parseBuffer(data);\n};\n\nexport const parseBuffer = (buffer: Buffer) => {\n  // check header\n  const header = buffer.slice(0, 'bplist'.length).toString('utf8');\n  if (header !== 'bplist') {\n    throw new Error(\"Invalid binary plist. Expected 'bplist' at offset 0.\");\n  }\n\n  // Handle trailer, last 32 bytes of the file\n  const trailer = buffer.slice(buffer.length - 32, buffer.length);\n  // 6 null bytes (index 0 to 5)\n  const offsetSize = trailer.readUInt8(6);\n  if (debug) {\n    console.log('offsetSize: ' + offsetSize);\n  }\n  const objectRefSize = trailer.readUInt8(7);\n  if (debug) {\n    console.log('objectRefSize: ' + objectRefSize);\n  }\n  const numObjects = readUInt64BE(trailer, 8);\n  if (debug) {\n    console.log('numObjects: ' + numObjects);\n  }\n  const topObject = readUInt64BE(trailer, 16);\n  if (debug) {\n    console.log('topObject: ' + topObject);\n  }\n  const offsetTableOffset = readUInt64BE(trailer, 24);\n  if (debug) {\n    console.log('offsetTableOffset: ' + offsetTableOffset);\n  }\n\n  if (numObjects > exports.maxObjectCount) {\n    throw new Error('maxObjectCount exceeded');\n  }\n\n  // Handle offset table\n  const offsetTable: number[] = [];\n\n  for (let i = 0; i < numObjects; i++) {\n    const offsetBytes = buffer.slice(\n      offsetTableOffset + i * offsetSize,\n      offsetTableOffset + (i + 1) * offsetSize\n    );\n    offsetTable[i] = readUInt(offsetBytes, 0);\n    if (debug) {\n      console.log(\n        'Offset for Object #' +\n          i +\n          ' is ' +\n          offsetTable[i] +\n          ' [' +\n          offsetTable[i].toString(16) +\n          ']'\n      );\n    }\n  }\n\n  // Parses an object inside the currently parsed binary property list.\n  // For the format specification check\n  // <a href=\"https://www.opensource.apple.com/source/CF/CF-635/CFBinaryPList.c\">\n  // Apple's binary property list parser implementation</a>.\n  function parseObject(tableOffset: number): PlistValue | null | UID {\n    const offset = offsetTable[tableOffset];\n    const type = buffer[offset];\n    const objType = (type & 0xf0) >> 4; //First  4 bits\n    const objInfo = type & 0x0f; //Second 4 bits\n    switch (objType) {\n      case 0x0:\n        return parseSimple();\n      case 0x1:\n        return parseInteger();\n      case 0x8:\n        return parseUID();\n      case 0x2:\n        return parseReal();\n      case 0x3:\n        return parseDate();\n      case 0x4:\n        return parseData();\n      case 0x5: // ASCII\n        return parsePlistString();\n      case 0x6: // UTF-16\n        return parsePlistString(true);\n      case 0xa:\n        return parseArray();\n      case 0xd:\n        return parseDictionary();\n      default:\n        throw new Error('Unhandled type 0x' + objType.toString(16));\n    }\n\n    function parseSimple(): boolean | null {\n      //Simple\n      switch (objInfo) {\n        case 0x0: // null\n          return null;\n        case 0x8: // false\n          return false;\n        case 0x9: // true\n          return true;\n        case 0xf: // filler byte\n          return null;\n        default:\n          throw new Error('Unhandled simple type 0x' + objType.toString(16));\n      }\n    }\n\n    function bufferToHexString(buffer: Buffer) {\n      let str = '';\n      let i;\n      for (i = 0; i < buffer.length; i++) {\n        if (buffer[i] != 0x00) {\n          break;\n        }\n      }\n      for (; i < buffer.length; i++) {\n        const part = '00' + buffer[i].toString(16);\n        str += part.substr(part.length - 2);\n      }\n      return str;\n    }\n\n    function parseInteger(): number | BigInt {\n      const length = Math.pow(2, objInfo);\n      if (length < exports.maxObjectSize) {\n        const data = buffer.slice(offset + 1, offset + 1 + length);\n        if (length === 16) {\n          const str = bufferToHexString(data);\n          return BigInt(str) // bigInt(str, 16);\n        }\n        return data.reduce((acc, curr) => {\n          acc <<= 8;\n          acc |= curr & 255;\n          return acc;\n        });\n      } else {\n        throw new Error(\n          'Too little heap space available! Wanted to read ' +\n            length +\n            ' bytes, but only ' +\n            exports.maxObjectSize +\n            ' are available.'\n        );\n      }\n    }\n\n    function parseUID() {\n      const length = objInfo + 1;\n      if (length < exports.maxObjectSize) {\n        return new UID(readUInt(buffer.slice(offset + 1, offset + 1 + length)));\n      }\n      throw new Error(\n        'Too little heap space available! Wanted to read ' +\n          length +\n          ' bytes, but only ' +\n          exports.maxObjectSize +\n          ' are available.'\n      );\n    }\n\n    function parseReal(): number | null {\n      const length = Math.pow(2, objInfo);\n      if (length < exports.maxObjectSize) {\n        const realBuffer = buffer.slice(offset + 1, offset + 1 + length);\n        if (length === 4) {\n          return realBuffer.readFloatBE(0);\n        }\n        if (length === 8) {\n          return realBuffer.readDoubleBE(0);\n        }\n      } else {\n        throw new Error(\n          'Too little heap space available! Wanted to read ' +\n            length +\n            ' bytes, but only ' +\n            exports.maxObjectSize +\n            ' are available.'\n        );\n      }\n      return null;\n    }\n\n    function parseDate() {\n      if (objInfo != 0x3) {\n        console.error('Unknown date type :' + objInfo + '. Parsing anyway...');\n      }\n      const dateBuffer = buffer.slice(offset + 1, offset + 9);\n      return new Date(EPOCH + 1000 * dateBuffer.readDoubleBE(0));\n    }\n\n    function parseData() {\n      let dataoffset = 1;\n      let length = objInfo;\n      if (objInfo == 0xf) {\n        const int_type = buffer[offset + 1];\n        const intType = (int_type & 0xf0) / 0x10;\n        if (intType != 0x1) {\n          console.error('0x4: UNEXPECTED LENGTH-INT TYPE! ' + intType);\n        }\n        const intInfo = int_type & 0x0f;\n        const intLength = Math.pow(2, intInfo);\n        dataoffset = 2 + intLength;\n        if (intLength < 3) {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        } else {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        }\n      }\n      if (length < exports.maxObjectSize) {\n        return buffer.slice(offset + dataoffset, offset + dataoffset + length);\n      }\n      throw new Error(\n        'Too little heap space available! Wanted to read ' +\n          length +\n          ' bytes, but only ' +\n          exports.maxObjectSize +\n          ' are available.'\n      );\n    }\n\n    function parsePlistString(isUtf16?: number): string {\n      isUtf16 = isUtf16 || 0;\n      let enc = 'utf8';\n      let length = objInfo;\n      let stroffset = 1;\n      if (objInfo == 0xf) {\n        const int_type = buffer[offset + 1];\n        const intType = (int_type & 0xf0) / 0x10;\n        if (intType != 0x1) {\n          console.error('UNEXPECTED LENGTH-INT TYPE! ' + intType);\n        }\n        const intInfo = int_type & 0x0f;\n        const intLength = Math.pow(2, intInfo);\n        stroffset = 2 + intLength;\n        if (intLength < 3) {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        } else {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        }\n      }\n      // length is String length -> to get byte length multiply by 2, as 1 character takes 2 bytes in UTF-16\n      length *= isUtf16 + 1;\n      if (length < exports.maxObjectSize) {\n        let plistString = Buffer.from(\n          buffer.slice(offset + stroffset, offset + stroffset + length)\n        );\n        if (isUtf16) {\n          plistString = swapBytes(plistString);\n          enc = 'ucs2';\n        }\n        return plistString.toString(enc);\n      }\n      throw new Error(\n        'Too little heap space available! Wanted to read ' +\n          length +\n          ' bytes, but only ' +\n          exports.maxObjectSize +\n          ' are available.'\n      );\n    }\n\n    function parseArray() {\n      let length = objInfo;\n      let arrayoffset = 1;\n      if (objInfo == 0xf) {\n        const int_type = buffer[offset + 1];\n        const intType = (int_type & 0xf0) / 0x10;\n        if (intType != 0x1) {\n          console.error('0xa: UNEXPECTED LENGTH-INT TYPE! ' + intType);\n        }\n        const intInfo = int_type & 0x0f;\n        const intLength = Math.pow(2, intInfo);\n        arrayoffset = 2 + intLength;\n        if (intLength < 3) {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        } else {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        }\n      }\n      if (length * objectRefSize > exports.maxObjectSize) {\n        throw new Error('Too little heap space available!');\n      }\n      const array: (PlistValue | UID | null)[] = [];\n      for (let i = 0; i < length; i++) {\n        const objRef = readUInt(\n          buffer.slice(\n            offset + arrayoffset + i * objectRefSize,\n            offset + arrayoffset + (i + 1) * objectRefSize\n          )\n        );\n        array[i] = parseObject(objRef);\n      }\n      return array;\n    }\n\n    function parseDictionary() {\n      let length = objInfo;\n      let dictoffset = 1;\n      if (objInfo == 0xf) {\n        const int_type = buffer[offset + 1];\n        const intType = (int_type & 0xf0) / 0x10;\n        if (intType != 0x1) {\n          console.error('0xD: UNEXPECTED LENGTH-INT TYPE! ' + intType);\n        }\n        const intInfo = int_type & 0x0f;\n        const intLength = Math.pow(2, intInfo);\n        dictoffset = 2 + intLength;\n        if (intLength < 3) {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        } else {\n          length = readUInt(buffer.slice(offset + 2, offset + 2 + intLength));\n        }\n      }\n      if (length * 2 * objectRefSize > exports.maxObjectSize) {\n        throw new Error('Too little heap space available!');\n      }\n      if (debug) {\n        console.log('Parsing dictionary #' + tableOffset);\n      }\n      const dict: Record<string, PlistValue | UID | null> = {};\n      for (let i = 0; i < length; i++) {\n        const keyRef = readUInt(\n          buffer.slice(\n            offset + dictoffset + i * objectRefSize,\n            offset + dictoffset + (i + 1) * objectRefSize\n          )\n        );\n        const valRef = readUInt(\n          buffer.slice(\n            offset + dictoffset + length * objectRefSize + i * objectRefSize,\n            offset + dictoffset + length * objectRefSize + (i + 1) * objectRefSize\n          )\n        );\n        const key = parseObject(keyRef);\n        const val = parseObject(valRef);\n        if (debug) {\n          console.log('  DICT #' + tableOffset + ': Mapped ' + key + ' to ' + val);\n        }\n        dict[key] = val;\n      }\n      return dict;\n    }\n  }\n\n  return [parseObject(topObject)];\n});\n\nfunction readUInt(buffer: Buffer, start: number = 0): number {\n  start = start || 0;\n\n  let l = 0;\n  for (let i = start; i < buffer.length; i++) {\n    l <<= 8;\n    l |= buffer[i] & 0xff;\n  }\n  return l;\n}\n\n// we're just going to toss the high order bits because javascript doesn't have 64-bit ints\nfunction readUInt64BE(buffer: Buffer, start: number) {\n  const data = buffer.slice(start, start + 8);\n  return data.readUInt32BE(4, 8);\n}\n\nfunction swapBytes(buffer: Buffer) {\n  const len = buffer.length;\n  for (let i = 0; i < len; i += 2) {\n    const a = buffer[i];\n    buffer[i] = buffer[i + 1];\n    buffer[i + 1] = a;\n  }\n  return buffer;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}