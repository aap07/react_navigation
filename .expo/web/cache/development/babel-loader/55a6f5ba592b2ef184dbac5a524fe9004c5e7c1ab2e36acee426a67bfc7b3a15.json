{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { State } from \"../../State\";\nimport { PointerType } from \"../interfaces\";\nimport PointerTracker from \"./PointerTracker\";\nimport { isPointerInBounds } from \"../utils\";\nvar GestureHandlerOrchestrator = function () {\n  function GestureHandlerOrchestrator() {\n    _classCallCheck(this, GestureHandlerOrchestrator);\n    this.gestureHandlers = [];\n    this.awaitingHandlers = [];\n    this.handlersToCancel = [];\n    this.handlingChangeSemaphore = 0;\n    this.activationIndex = 0;\n  }\n  _createClass(GestureHandlerOrchestrator, [{\n    key: \"scheduleFinishedHandlersCleanup\",\n    value: function scheduleFinishedHandlersCleanup() {\n      if (this.handlingChangeSemaphore === 0) {\n        this.cleanupFinishedHandlers();\n      }\n    }\n  }, {\n    key: \"cleanHandler\",\n    value: function cleanHandler(handler) {\n      handler.reset();\n      handler.setActive(false);\n      handler.setAwaiting(false);\n      handler.setActivationIndex(Number.MAX_VALUE);\n    }\n  }, {\n    key: \"removeHandlerFromOrchestrator\",\n    value: function removeHandlerFromOrchestrator(handler) {\n      this.gestureHandlers.splice(this.gestureHandlers.indexOf(handler), 1);\n      this.awaitingHandlers.splice(this.awaitingHandlers.indexOf(handler), 1);\n      this.handlersToCancel.splice(this.handlersToCancel.indexOf(handler), 1);\n    }\n  }, {\n    key: \"cleanupFinishedHandlers\",\n    value: function cleanupFinishedHandlers() {\n      for (var i = this.gestureHandlers.length - 1; i >= 0; --i) {\n        var handler = this.gestureHandlers[i];\n        if (!handler) {\n          continue;\n        }\n        if (this.isFinished(handler.getState()) && !handler.isAwaiting()) {\n          this.gestureHandlers.splice(i, 1);\n          this.cleanHandler(handler);\n        }\n      }\n    }\n  }, {\n    key: \"hasOtherHandlerToWaitFor\",\n    value: function hasOtherHandlerToWaitFor(handler) {\n      var _this = this;\n      var hasToWait = false;\n      this.gestureHandlers.forEach(function (otherHandler) {\n        if (otherHandler && !_this.isFinished(otherHandler.getState()) && _this.shouldHandlerWaitForOther(handler, otherHandler)) {\n          hasToWait = true;\n          return;\n        }\n      });\n      return hasToWait;\n    }\n  }, {\n    key: \"tryActivate\",\n    value: function tryActivate(handler) {\n      if (this.hasOtherHandlerToWaitFor(handler)) {\n        this.addAwaitingHandler(handler);\n      } else if (handler.getState() !== State.CANCELLED && handler.getState() !== State.FAILED) {\n        if (this.shouldActivate(handler)) {\n          this.makeActive(handler);\n        } else {\n          switch (handler.getState()) {\n            case State.ACTIVE:\n              handler.fail();\n              break;\n            case State.BEGAN:\n              handler.cancel();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"shouldActivate\",\n    value: function shouldActivate(handler) {\n      for (var otherHandler of this.gestureHandlers) {\n        if (this.shouldHandlerBeCancelledBy(handler, otherHandler)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"cleanupAwaitingHandlers\",\n    value: function cleanupAwaitingHandlers(handler) {\n      for (var i = 0; i < this.awaitingHandlers.length; ++i) {\n        if (!this.awaitingHandlers[i].isAwaiting() && this.shouldHandlerWaitForOther(this.awaitingHandlers[i], handler)) {\n          this.cleanHandler(this.awaitingHandlers[i]);\n          this.awaitingHandlers.splice(i, 1);\n        }\n      }\n    }\n  }, {\n    key: \"onHandlerStateChange\",\n    value: function onHandlerStateChange(handler, newState, oldState, sendIfDisabled) {\n      var _this2 = this;\n      if (!handler.isEnabled() && !sendIfDisabled) {\n        return;\n      }\n      this.handlingChangeSemaphore += 1;\n      if (this.isFinished(newState)) {\n        this.awaitingHandlers.forEach(function (otherHandler) {\n          if (_this2.shouldHandlerWaitForOther(otherHandler, handler)) {\n            if (newState === State.END) {\n              otherHandler == null ? void 0 : otherHandler.cancel();\n              if (otherHandler.getState() === State.END) {\n                otherHandler.sendEvent(State.CANCELLED, State.BEGAN);\n              }\n              otherHandler == null ? void 0 : otherHandler.setAwaiting(false);\n            } else {\n              _this2.tryActivate(otherHandler);\n            }\n          }\n        });\n      }\n      if (newState === State.ACTIVE) {\n        this.tryActivate(handler);\n      } else if (oldState === State.ACTIVE || oldState === State.END) {\n        if (handler.isActive()) {\n          handler.sendEvent(newState, oldState);\n        } else if (oldState === State.ACTIVE && (newState === State.CANCELLED || newState === State.FAILED)) {\n          handler.sendEvent(newState, State.BEGAN);\n        }\n      } else if (oldState !== State.UNDETERMINED || newState !== State.CANCELLED) {\n        handler.sendEvent(newState, oldState);\n      }\n      this.handlingChangeSemaphore -= 1;\n      this.scheduleFinishedHandlersCleanup();\n      if (this.awaitingHandlers.indexOf(handler) < 0) {\n        this.cleanupAwaitingHandlers(handler);\n      }\n    }\n  }, {\n    key: \"makeActive\",\n    value: function makeActive(handler) {\n      var _this3 = this;\n      var currentState = handler.getState();\n      handler.setActive(true);\n      handler.setShouldResetProgress(true);\n      handler.setActivationIndex(this.activationIndex++);\n      this.gestureHandlers.forEach(function (otherHandler) {\n        if (_this3.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n          _this3.handlersToCancel.push(otherHandler);\n        }\n      });\n      for (var i = this.handlersToCancel.length - 1; i >= 0; --i) {\n        var _this$handlersToCance;\n        (_this$handlersToCance = this.handlersToCancel[i]) == null ? void 0 : _this$handlersToCance.cancel();\n      }\n      this.awaitingHandlers.forEach(function (otherHandler) {\n        if (_this3.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n          otherHandler == null ? void 0 : otherHandler.cancel();\n          otherHandler == null ? void 0 : otherHandler.setAwaiting(true);\n        }\n      });\n      handler.sendEvent(State.ACTIVE, State.BEGAN);\n      if (currentState !== State.ACTIVE) {\n        handler.sendEvent(State.END, State.ACTIVE);\n        if (currentState !== State.END) {\n          handler.sendEvent(State.UNDETERMINED, State.END);\n        }\n      }\n      if (handler.isAwaiting()) {\n        handler.setAwaiting(false);\n        for (var _i = 0; _i < this.awaitingHandlers.length; ++_i) {\n          if (this.awaitingHandlers[_i] === handler) {\n            this.awaitingHandlers.splice(_i, 1);\n          }\n        }\n      }\n      this.handlersToCancel = [];\n    }\n  }, {\n    key: \"addAwaitingHandler\",\n    value: function addAwaitingHandler(handler) {\n      var alreadyExists = false;\n      this.awaitingHandlers.forEach(function (otherHandler) {\n        if (otherHandler === handler) {\n          alreadyExists = true;\n          return;\n        }\n      });\n      if (alreadyExists) {\n        return;\n      }\n      this.awaitingHandlers.push(handler);\n      handler.setAwaiting(true);\n      handler.setActivationIndex(this.activationIndex++);\n    }\n  }, {\n    key: \"recordHandlerIfNotPresent\",\n    value: function recordHandlerIfNotPresent(handler) {\n      var alreadyExists = false;\n      this.gestureHandlers.forEach(function (otherHandler) {\n        if (otherHandler === handler) {\n          alreadyExists = true;\n          return;\n        }\n      });\n      if (alreadyExists) {\n        return;\n      }\n      this.gestureHandlers.push(handler);\n      handler.setActive(false);\n      handler.setAwaiting(false);\n      handler.setActivationIndex(Number.MAX_SAFE_INTEGER);\n    }\n  }, {\n    key: \"shouldHandlerWaitForOther\",\n    value: function shouldHandlerWaitForOther(handler, otherHandler) {\n      return handler !== otherHandler && (handler.shouldWaitForHandlerFailure(otherHandler) || otherHandler.shouldRequireToWaitForFailure(handler));\n    }\n  }, {\n    key: \"canRunSimultaneously\",\n    value: function canRunSimultaneously(gh1, gh2) {\n      return gh1 === gh2 || gh1.shouldRecognizeSimultaneously(gh2) || gh2.shouldRecognizeSimultaneously(gh1);\n    }\n  }, {\n    key: \"shouldHandlerBeCancelledBy\",\n    value: function shouldHandlerBeCancelledBy(handler, otherHandler) {\n      if (this.canRunSimultaneously(handler, otherHandler)) {\n        return false;\n      }\n      if (handler !== otherHandler && (handler.isAwaiting() || handler.getState() === State.ACTIVE)) {\n        return handler.shouldBeCancelledByOther(otherHandler);\n      }\n      var handlerPointers = handler.getTrackedPointersID();\n      var otherPointers = otherHandler.getTrackedPointersID();\n      if (!PointerTracker.shareCommonPointers(handlerPointers, otherPointers) && handler.getView() !== otherHandler.getView()) {\n        return this.checkOverlap(handler, otherHandler);\n      }\n      return true;\n    }\n  }, {\n    key: \"checkOverlap\",\n    value: function checkOverlap(handler, otherHandler) {\n      var handlerPointers = handler.getTrackedPointersID();\n      var otherPointers = otherHandler.getTrackedPointersID();\n      var overlap = false;\n      handlerPointers.forEach(function (pointer) {\n        var handlerX = handler.getTracker().getLastX(pointer);\n        var handlerY = handler.getTracker().getLastY(pointer);\n        if (isPointerInBounds(handler.getView(), {\n          x: handlerX,\n          y: handlerY\n        }) && isPointerInBounds(otherHandler.getView(), {\n          x: handlerX,\n          y: handlerY\n        })) {\n          overlap = true;\n        }\n      });\n      otherPointers.forEach(function (pointer) {\n        var otherX = otherHandler.getTracker().getLastX(pointer);\n        var otherY = otherHandler.getTracker().getLastY(pointer);\n        if (isPointerInBounds(handler.getView(), {\n          x: otherX,\n          y: otherY\n        }) && isPointerInBounds(otherHandler.getView(), {\n          x: otherX,\n          y: otherY\n        })) {\n          overlap = true;\n        }\n      });\n      return overlap;\n    }\n  }, {\n    key: \"isFinished\",\n    value: function isFinished(state) {\n      return state === State.END || state === State.FAILED || state === State.CANCELLED;\n    }\n  }, {\n    key: \"cancelMouseAndPenGestures\",\n    value: function cancelMouseAndPenGestures(currentHandler) {\n      this.gestureHandlers.forEach(function (handler) {\n        if (handler.getPointerType() !== PointerType.MOUSE && handler.getPointerType() !== PointerType.PEN) {\n          return;\n        }\n        if (handler !== currentHandler) {\n          handler.cancel();\n        } else {\n          handler.getTracker().resetTracker();\n        }\n      });\n    }\n  }], [{\n    key: \"getInstance\",\n    value: function getInstance() {\n      if (!GestureHandlerOrchestrator.instance) {\n        GestureHandlerOrchestrator.instance = new GestureHandlerOrchestrator();\n      }\n      return GestureHandlerOrchestrator.instance;\n    }\n  }]);\n  return GestureHandlerOrchestrator;\n}();\nexport { GestureHandlerOrchestrator as default };","map":{"version":3,"names":["State","PointerType","PointerTracker","isPointerInBounds","GestureHandlerOrchestrator","_classCallCheck","gestureHandlers","awaitingHandlers","handlersToCancel","handlingChangeSemaphore","activationIndex","_createClass","key","value","scheduleFinishedHandlersCleanup","cleanupFinishedHandlers","cleanHandler","handler","reset","setActive","setAwaiting","setActivationIndex","Number","MAX_VALUE","removeHandlerFromOrchestrator","splice","indexOf","i","length","isFinished","getState","isAwaiting","hasOtherHandlerToWaitFor","_this","hasToWait","forEach","otherHandler","shouldHandlerWaitForOther","tryActivate","addAwaitingHandler","CANCELLED","FAILED","shouldActivate","makeActive","ACTIVE","fail","BEGAN","cancel","shouldHandlerBeCancelledBy","cleanupAwaitingHandlers","onHandlerStateChange","newState","oldState","sendIfDisabled","_this2","isEnabled","END","sendEvent","isActive","UNDETERMINED","_this3","currentState","setShouldResetProgress","push","_this$handlersToCance","alreadyExists","recordHandlerIfNotPresent","MAX_SAFE_INTEGER","shouldWaitForHandlerFailure","shouldRequireToWaitForFailure","canRunSimultaneously","gh1","gh2","shouldRecognizeSimultaneously","shouldBeCancelledByOther","handlerPointers","getTrackedPointersID","otherPointers","shareCommonPointers","getView","checkOverlap","overlap","pointer","handlerX","getTracker","getLastX","handlerY","getLastY","x","y","otherX","otherY","state","cancelMouseAndPenGestures","currentHandler","getPointerType","MOUSE","PEN","resetTracker","getInstance","instance","default"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/react-native-gesture-handler/src/web/tools/GestureHandlerOrchestrator.ts"],"sourcesContent":["import { State } from '../../State';\nimport { PointerType } from '../interfaces';\n\nimport GestureHandler from '../handlers/GestureHandler';\nimport PointerTracker from './PointerTracker';\nimport { isPointerInBounds } from '../utils';\n\nexport default class GestureHandlerOrchestrator {\n  private static instance: GestureHandlerOrchestrator;\n\n  private gestureHandlers: GestureHandler[] = [];\n  private awaitingHandlers: GestureHandler[] = [];\n  private handlersToCancel: GestureHandler[] = [];\n\n  private handlingChangeSemaphore = 0;\n  private activationIndex = 0;\n\n  // Private beacuse of Singleton\n  // eslint-disable-next-line no-useless-constructor, @typescript-eslint/no-empty-function\n  private constructor() {}\n\n  private scheduleFinishedHandlersCleanup(): void {\n    if (this.handlingChangeSemaphore === 0) {\n      this.cleanupFinishedHandlers();\n    }\n  }\n\n  private cleanHandler(handler: GestureHandler): void {\n    handler.reset();\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_VALUE);\n  }\n\n  public removeHandlerFromOrchestrator(handler: GestureHandler): void {\n    this.gestureHandlers.splice(this.gestureHandlers.indexOf(handler), 1);\n    this.awaitingHandlers.splice(this.awaitingHandlers.indexOf(handler), 1);\n    this.handlersToCancel.splice(this.handlersToCancel.indexOf(handler), 1);\n  }\n\n  private cleanupFinishedHandlers(): void {\n    for (let i = this.gestureHandlers.length - 1; i >= 0; --i) {\n      const handler = this.gestureHandlers[i];\n\n      if (!handler) {\n        continue;\n      }\n      if (this.isFinished(handler.getState()) && !handler.isAwaiting()) {\n        this.gestureHandlers.splice(i, 1);\n\n        this.cleanHandler(handler);\n      }\n    }\n  }\n\n  private hasOtherHandlerToWaitFor(handler: GestureHandler): boolean {\n    let hasToWait = false;\n    this.gestureHandlers.forEach((otherHandler) => {\n      if (\n        otherHandler &&\n        !this.isFinished(otherHandler.getState()) &&\n        this.shouldHandlerWaitForOther(handler, otherHandler)\n      ) {\n        hasToWait = true;\n        return;\n      }\n    });\n\n    return hasToWait;\n  }\n\n  private tryActivate(handler: GestureHandler): void {\n    if (this.hasOtherHandlerToWaitFor(handler)) {\n      this.addAwaitingHandler(handler);\n    } else if (\n      handler.getState() !== State.CANCELLED &&\n      handler.getState() !== State.FAILED\n    ) {\n      if (this.shouldActivate(handler)) {\n        this.makeActive(handler);\n      } else {\n        switch (handler.getState()) {\n          case State.ACTIVE:\n            handler.fail();\n            break;\n          case State.BEGAN:\n            handler.cancel();\n        }\n      }\n    }\n  }\n\n  private shouldActivate(handler: GestureHandler): boolean {\n    for (const otherHandler of this.gestureHandlers) {\n      if (this.shouldHandlerBeCancelledBy(handler, otherHandler)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private cleanupAwaitingHandlers(handler: GestureHandler): void {\n    for (let i = 0; i < this.awaitingHandlers.length; ++i) {\n      if (\n        !this.awaitingHandlers[i].isAwaiting() &&\n        this.shouldHandlerWaitForOther(this.awaitingHandlers[i], handler)\n      ) {\n        this.cleanHandler(this.awaitingHandlers[i]);\n        this.awaitingHandlers.splice(i, 1);\n      }\n    }\n  }\n\n  public onHandlerStateChange(\n    handler: GestureHandler,\n    newState: State,\n    oldState: State,\n    sendIfDisabled?: boolean\n  ): void {\n    if (!handler.isEnabled() && !sendIfDisabled) {\n      return;\n    }\n\n    this.handlingChangeSemaphore += 1;\n\n    if (this.isFinished(newState)) {\n      this.awaitingHandlers.forEach((otherHandler) => {\n        if (this.shouldHandlerWaitForOther(otherHandler, handler)) {\n          if (newState === State.END) {\n            otherHandler?.cancel();\n            if (otherHandler.getState() === State.END) {\n              // Handle edge case, where discrete gestures end immediately after activation thus\n              // their state is set to END and when the gesture they are waiting for activates they\n              // should be cancelled, however `cancel` was never sent as gestures were already in the END state.\n              // Send synthetic BEGAN -> CANCELLED to properly handle JS logic\n              otherHandler.sendEvent(State.CANCELLED, State.BEGAN);\n            }\n            otherHandler?.setAwaiting(false);\n          } else {\n            this.tryActivate(otherHandler);\n          }\n        }\n      });\n    }\n\n    if (newState === State.ACTIVE) {\n      this.tryActivate(handler);\n    } else if (oldState === State.ACTIVE || oldState === State.END) {\n      if (handler.isActive()) {\n        handler.sendEvent(newState, oldState);\n      } else if (\n        oldState === State.ACTIVE &&\n        (newState === State.CANCELLED || newState === State.FAILED)\n      ) {\n        handler.sendEvent(newState, State.BEGAN);\n      }\n    } else if (\n      oldState !== State.UNDETERMINED ||\n      newState !== State.CANCELLED\n    ) {\n      handler.sendEvent(newState, oldState);\n    }\n\n    this.handlingChangeSemaphore -= 1;\n\n    this.scheduleFinishedHandlersCleanup();\n\n    if (this.awaitingHandlers.indexOf(handler) < 0) {\n      this.cleanupAwaitingHandlers(handler);\n    }\n  }\n\n  private makeActive(handler: GestureHandler): void {\n    const currentState = handler.getState();\n\n    handler.setActive(true);\n    handler.setShouldResetProgress(true);\n    handler.setActivationIndex(this.activationIndex++);\n\n    this.gestureHandlers.forEach((otherHandler) => {\n      // Order of arguments is correct - we check whether current handler should cancel existing handlers\n\n      if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n        this.handlersToCancel.push(otherHandler);\n      }\n    });\n\n    for (let i = this.handlersToCancel.length - 1; i >= 0; --i) {\n      this.handlersToCancel[i]?.cancel();\n    }\n    this.awaitingHandlers.forEach((otherHandler) => {\n      if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n        otherHandler?.cancel();\n        otherHandler?.setAwaiting(true);\n      }\n    });\n\n    handler.sendEvent(State.ACTIVE, State.BEGAN);\n\n    if (currentState !== State.ACTIVE) {\n      handler.sendEvent(State.END, State.ACTIVE);\n      if (currentState !== State.END) {\n        handler.sendEvent(State.UNDETERMINED, State.END);\n      }\n    }\n\n    if (handler.isAwaiting()) {\n      handler.setAwaiting(false);\n      for (let i = 0; i < this.awaitingHandlers.length; ++i) {\n        if (this.awaitingHandlers[i] === handler) {\n          this.awaitingHandlers.splice(i, 1);\n        }\n      }\n    }\n\n    this.handlersToCancel = [];\n  }\n\n  private addAwaitingHandler(handler: GestureHandler): void {\n    let alreadyExists = false;\n\n    this.awaitingHandlers.forEach((otherHandler) => {\n      if (otherHandler === handler) {\n        alreadyExists = true;\n        return;\n      }\n    });\n\n    if (alreadyExists) {\n      return;\n    }\n\n    this.awaitingHandlers.push(handler);\n\n    handler.setAwaiting(true);\n    handler.setActivationIndex(this.activationIndex++);\n  }\n\n  public recordHandlerIfNotPresent(handler: GestureHandler): void {\n    let alreadyExists = false;\n\n    this.gestureHandlers.forEach((otherHandler) => {\n      if (otherHandler === handler) {\n        alreadyExists = true;\n        return;\n      }\n    });\n\n    if (alreadyExists) {\n      return;\n    }\n\n    this.gestureHandlers.push(handler);\n\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_SAFE_INTEGER);\n  }\n\n  private shouldHandlerWaitForOther(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    return (\n      handler !== otherHandler &&\n      (handler.shouldWaitForHandlerFailure(otherHandler) ||\n        otherHandler.shouldRequireToWaitForFailure(handler))\n    );\n  }\n\n  private canRunSimultaneously(\n    gh1: GestureHandler,\n    gh2: GestureHandler\n  ): boolean {\n    return (\n      gh1 === gh2 ||\n      gh1.shouldRecognizeSimultaneously(gh2) ||\n      gh2.shouldRecognizeSimultaneously(gh1)\n    );\n  }\n\n  private shouldHandlerBeCancelledBy(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    if (this.canRunSimultaneously(handler, otherHandler)) {\n      return false;\n    }\n\n    if (\n      handler !== otherHandler &&\n      (handler.isAwaiting() || handler.getState() === State.ACTIVE)\n    ) {\n      // For now it always returns false\n      return handler.shouldBeCancelledByOther(otherHandler);\n    }\n\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    if (\n      !PointerTracker.shareCommonPointers(handlerPointers, otherPointers) &&\n      handler.getView() !== otherHandler.getView()\n    ) {\n      return this.checkOverlap(handler, otherHandler);\n    }\n\n    return true;\n  }\n\n  private checkOverlap(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    // If handlers don't have common pointers, default return value is false.\n    // However, if at least on pointer overlaps with both handlers, we return true\n    // This solves issue in overlapping parents example\n\n    // TODO: Find better way to handle that issue, for example by activation order and handler cancelling\n\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    let overlap = false;\n\n    handlerPointers.forEach((pointer: number) => {\n      const handlerX: number = handler.getTracker().getLastX(pointer);\n      const handlerY: number = handler.getTracker().getLastY(pointer);\n\n      if (\n        isPointerInBounds(handler.getView(), { x: handlerX, y: handlerY }) &&\n        isPointerInBounds(otherHandler.getView(), { x: handlerX, y: handlerY })\n      ) {\n        overlap = true;\n      }\n    });\n\n    otherPointers.forEach((pointer: number) => {\n      const otherX: number = otherHandler.getTracker().getLastX(pointer);\n      const otherY: number = otherHandler.getTracker().getLastY(pointer);\n\n      if (\n        isPointerInBounds(handler.getView(), { x: otherX, y: otherY }) &&\n        isPointerInBounds(otherHandler.getView(), { x: otherX, y: otherY })\n      ) {\n        overlap = true;\n      }\n    });\n\n    return overlap;\n  }\n\n  private isFinished(state: State): boolean {\n    return (\n      state === State.END || state === State.FAILED || state === State.CANCELLED\n    );\n  }\n\n  // This function is called when handler receives touchdown event\n  // If handler is using mouse or pen as a pointer and any handler receives touch event,\n  // mouse/pen event dissappears - it doesn't send onPointerCancel nor onPointerUp (and others)\n  // This became a problem because handler was left at active state without any signal to end or fail\n  // To handle this, when new touch event is received, we loop through active handlers and check which type of\n  // pointer they're using. If there are any handler with mouse/pen as a pointer, we cancel them\n  public cancelMouseAndPenGestures(currentHandler: GestureHandler): void {\n    this.gestureHandlers.forEach((handler: GestureHandler) => {\n      if (\n        handler.getPointerType() !== PointerType.MOUSE &&\n        handler.getPointerType() !== PointerType.PEN\n      ) {\n        return;\n      }\n\n      if (handler !== currentHandler) {\n        handler.cancel();\n      } else {\n        // Handler that received touch event should have its pointer tracker reset\n        // This allows handler to smoothly change from mouse/pen to touch\n        // The drawback is, that when we try to use mouse/pen one more time, it doesn't send onPointerDown at the first time\n        // so it is required to click two times to get handler to work\n        //\n        // However, handler will receive manually created onPointerEnter that is triggered in EventManager in onPointerMove method.\n        // There may be possibility to use that fact to make handler respond properly to first mouse click\n        handler.getTracker().resetTracker();\n      }\n    });\n  }\n\n  public static getInstance(): GestureHandlerOrchestrator {\n    if (!GestureHandlerOrchestrator.instance) {\n      GestureHandlerOrchestrator.instance = new GestureHandlerOrchestrator();\n    }\n\n    return GestureHandlerOrchestrator.instance;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}