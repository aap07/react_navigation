{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nvar _assertThisInitialized = require(\"@babel/runtime/helpers/assertThisInitialized\");\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nvar EventEmitter = require('events');\nvar http = require('http');\nvar _require = require('stream'),\n  Duplex = _require.Duplex;\nvar _require2 = require('crypto'),\n  createHash = _require2.createHash;\nvar extension = require(\"./extension\");\nvar PerMessageDeflate = require(\"./permessage-deflate\");\nvar subprotocol = require(\"./subprotocol\");\nvar WebSocket = require(\"./websocket\");\nvar _require3 = require(\"./constants\"),\n  GUID = _require3.GUID,\n  kWebSocket = _require3.kWebSocket;\nvar keyRegex = /^[+/0-9A-Za-z]{22}==$/;\nvar RUNNING = 0;\nvar CLOSING = 1;\nvar CLOSED = 2;\nvar WebSocketServer = function (_EventEmitter) {\n  _inherits(WebSocketServer, _EventEmitter);\n  var _super = _createSuper(WebSocketServer);\n  function WebSocketServer(options, callback) {\n    var _this;\n    _classCallCheck(this, WebSocketServer);\n    _this = _super.call(this);\n    options = _objectSpread({\n      maxPayload: 100 * 1024 * 1024,\n      skipUTF8Validation: false,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null,\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      WebSocket: WebSocket\n    }, options);\n    if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {\n      throw new TypeError('One and only one of the \"port\", \"server\", or \"noServer\" options ' + 'must be specified');\n    }\n    if (options.port != null) {\n      _this._server = http.createServer(function (req, res) {\n        var body = http.STATUS_CODES[426];\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      _this._server.listen(options.port, options.host, options.backlog, callback);\n    } else if (options.server) {\n      _this._server = options.server;\n    }\n    if (_this._server) {\n      var emitConnection = _this.emit.bind(_assertThisInitialized(_this), 'connection');\n      _this._removeListeners = addListeners(_this._server, {\n        listening: _this.emit.bind(_assertThisInitialized(_this), 'listening'),\n        error: _this.emit.bind(_assertThisInitialized(_this), 'error'),\n        upgrade: function upgrade(req, socket, head) {\n          _this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) {\n      _this.clients = new Set();\n      _this._shouldEmitClose = false;\n    }\n    _this.options = options;\n    _this._state = RUNNING;\n    return _this;\n  }\n  _createClass(WebSocketServer, [{\n    key: \"address\",\n    value: function address() {\n      if (this.options.noServer) {\n        throw new Error('The server is operating in \"noServer\" mode');\n      }\n      if (!this._server) return null;\n      return this._server.address();\n    }\n  }, {\n    key: \"close\",\n    value: function close(cb) {\n      var _this2 = this;\n      if (this._state === CLOSED) {\n        if (cb) {\n          this.once('close', function () {\n            cb(new Error('The server is not running'));\n          });\n        }\n        process.nextTick(emitClose, this);\n        return;\n      }\n      if (cb) this.once('close', cb);\n      if (this._state === CLOSING) return;\n      this._state = CLOSING;\n      if (this.options.noServer || this.options.server) {\n        if (this._server) {\n          this._removeListeners();\n          this._removeListeners = this._server = null;\n        }\n        if (this.clients) {\n          if (!this.clients.size) {\n            process.nextTick(emitClose, this);\n          } else {\n            this._shouldEmitClose = true;\n          }\n        } else {\n          process.nextTick(emitClose, this);\n        }\n      } else {\n        var server = this._server;\n        this._removeListeners();\n        this._removeListeners = this._server = null;\n        server.close(function () {\n          emitClose(_this2);\n        });\n      }\n    }\n  }, {\n    key: \"shouldHandle\",\n    value: function shouldHandle(req) {\n      if (this.options.path) {\n        var index = req.url.indexOf('?');\n        var pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n        if (pathname !== this.options.path) return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"handleUpgrade\",\n    value: function handleUpgrade(req, socket, head, cb) {\n      var _this3 = this;\n      socket.on('error', socketOnError);\n      var key = req.headers['sec-websocket-key'];\n      var version = +req.headers['sec-websocket-version'];\n      if (req.method !== 'GET') {\n        var message = 'Invalid HTTP method';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n        return;\n      }\n      if (req.headers.upgrade.toLowerCase() !== 'websocket') {\n        var _message = 'Invalid Upgrade header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, _message);\n        return;\n      }\n      if (!key || !keyRegex.test(key)) {\n        var _message2 = 'Missing or invalid Sec-WebSocket-Key header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, _message2);\n        return;\n      }\n      if (version !== 8 && version !== 13) {\n        var _message3 = 'Missing or invalid Sec-WebSocket-Version header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, _message3);\n        return;\n      }\n      if (!this.shouldHandle(req)) {\n        abortHandshake(socket, 400);\n        return;\n      }\n      var secWebSocketProtocol = req.headers['sec-websocket-protocol'];\n      var protocols = new Set();\n      if (secWebSocketProtocol !== undefined) {\n        try {\n          protocols = subprotocol.parse(secWebSocketProtocol);\n        } catch (err) {\n          var _message4 = 'Invalid Sec-WebSocket-Protocol header';\n          abortHandshakeOrEmitwsClientError(this, req, socket, 400, _message4);\n          return;\n        }\n      }\n      var secWebSocketExtensions = req.headers['sec-websocket-extensions'];\n      var extensions = {};\n      if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {\n        var perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);\n        try {\n          var offers = extension.parse(secWebSocketExtensions);\n          if (offers[PerMessageDeflate.extensionName]) {\n            perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n            extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n          }\n        } catch (err) {\n          var _message5 = 'Invalid or unacceptable Sec-WebSocket-Extensions header';\n          abortHandshakeOrEmitwsClientError(this, req, socket, 400, _message5);\n          return;\n        }\n      }\n      if (this.options.verifyClient) {\n        var info = {\n          origin: req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n          secure: !!(req.socket.authorized || req.socket.encrypted),\n          req: req\n        };\n        if (this.options.verifyClient.length === 2) {\n          this.options.verifyClient(info, function (verified, code, message, headers) {\n            if (!verified) {\n              return abortHandshake(socket, code || 401, message, headers);\n            }\n            _this3.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n          });\n          return;\n        }\n        if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n      }\n      this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n    }\n  }, {\n    key: \"completeUpgrade\",\n    value: function completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n      var _this4 = this;\n      if (!socket.readable || !socket.writable) return socket.destroy();\n      if (socket[kWebSocket]) {\n        throw new Error('server.handleUpgrade() was called more than once with the same ' + 'socket, possibly due to a misconfiguration');\n      }\n      if (this._state > RUNNING) return abortHandshake(socket, 503);\n      var digest = createHash('sha1').update(key + GUID).digest('base64');\n      var headers = ['HTTP/1.1 101 Switching Protocols', 'Upgrade: websocket', 'Connection: Upgrade', `Sec-WebSocket-Accept: ${digest}`];\n      var ws = new this.options.WebSocket(null);\n      if (protocols.size) {\n        var protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;\n        if (protocol) {\n          headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n          ws._protocol = protocol;\n        }\n      }\n      if (extensions[PerMessageDeflate.extensionName]) {\n        var params = extensions[PerMessageDeflate.extensionName].params;\n        var value = extension.format(_defineProperty({}, PerMessageDeflate.extensionName, [params]));\n        headers.push(`Sec-WebSocket-Extensions: ${value}`);\n        ws._extensions = extensions;\n      }\n      this.emit('headers', headers, req);\n      socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n      socket.removeListener('error', socketOnError);\n      ws.setSocket(socket, head, {\n        maxPayload: this.options.maxPayload,\n        skipUTF8Validation: this.options.skipUTF8Validation\n      });\n      if (this.clients) {\n        this.clients.add(ws);\n        ws.on('close', function () {\n          _this4.clients.delete(ws);\n          if (_this4._shouldEmitClose && !_this4.clients.size) {\n            process.nextTick(emitClose, _this4);\n          }\n        });\n      }\n      cb(ws, req);\n    }\n  }]);\n  return WebSocketServer;\n}(EventEmitter);\nmodule.exports = WebSocketServer;\nfunction addListeners(server, map) {\n  for (var event of Object.keys(map)) server.on(event, map[event]);\n  return function removeListeners() {\n    for (var _event of Object.keys(map)) {\n      server.removeListener(_event, map[_event]);\n    }\n  };\n}\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit('close');\n}\nfunction socketOnError() {\n  this.destroy();\n}\nfunction abortHandshake(socket, code, message, headers) {\n  message = message || http.STATUS_CODES[code];\n  headers = _objectSpread({\n    Connection: 'close',\n    'Content-Type': 'text/html',\n    'Content-Length': Buffer.byteLength(message)\n  }, headers);\n  socket.once('finish', socket.destroy);\n  socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` + Object.keys(headers).map(function (h) {\n    return `${h}: ${headers[h]}`;\n  }).join('\\r\\n') + '\\r\\n\\r\\n' + message);\n}\nfunction abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\n  if (server.listenerCount('wsClientError')) {\n    var err = new Error(message);\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n    server.emit('wsClientError', err, socket, req);\n  } else {\n    abortHandshake(socket, code, message);\n  }\n}","map":{"version":3,"names":["_defineProperty","require","_classCallCheck","_createClass","_assertThisInitialized","_inherits","_possibleConstructorReturn","_getPrototypeOf","ownKeys","e","r","t","Object","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","length","forEach","getOwnPropertyDescriptors","defineProperties","defineProperty","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","constructor","Reflect","construct","sham","Proxy","Boolean","prototype","valueOf","call","EventEmitter","http","_require","Duplex","_require2","createHash","extension","PerMessageDeflate","subprotocol","WebSocket","_require3","GUID","kWebSocket","keyRegex","RUNNING","CLOSING","CLOSED","WebSocketServer","_EventEmitter","_super","options","callback","_this","maxPayload","skipUTF8Validation","perMessageDeflate","handleProtocols","clientTracking","verifyClient","noServer","backlog","server","host","path","port","TypeError","_server","createServer","req","res","body","STATUS_CODES","writeHead","end","listen","emitConnection","emit","bind","_removeListeners","addListeners","listening","error","upgrade","socket","head","handleUpgrade","clients","Set","_shouldEmitClose","_state","key","value","address","Error","close","cb","_this2","once","process","nextTick","emitClose","size","shouldHandle","index","url","indexOf","pathname","slice","_this3","on","socketOnError","headers","version","method","message","abortHandshakeOrEmitwsClientError","toLowerCase","test","abortHandshake","secWebSocketProtocol","protocols","undefined","parse","err","secWebSocketExtensions","extensions","offers","extensionName","accept","info","origin","secure","authorized","encrypted","verified","code","completeUpgrade","_this4","readable","writable","destroy","digest","update","ws","protocol","values","next","_protocol","params","format","_extensions","write","concat","join","removeListener","setSocket","add","delete","module","exports","map","event","removeListeners","Connection","Buffer","byteLength","h","listenerCount","captureStackTrace"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@expo/cli/node_modules/ws/lib/websocket-server.js"],"sourcesContent":["/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex$\" }] */\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst http = require('http');\nconst { Duplex } = require('stream');\nconst { createHash } = require('crypto');\n\nconst extension = require('./extension');\nconst PerMessageDeflate = require('./permessage-deflate');\nconst subprotocol = require('./subprotocol');\nconst WebSocket = require('./websocket');\nconst { GUID, kWebSocket } = require('./constants');\n\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\n\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n\n    options = {\n      maxPayload: 100 * 1024 * 1024,\n      skipUTF8Validation: false,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null, // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      WebSocket,\n      ...options\n    };\n\n    if (\n      (options.port == null && !options.server && !options.noServer) ||\n      (options.port != null && (options.server || options.noServer)) ||\n      (options.server && options.noServer)\n    ) {\n      throw new TypeError(\n        'One and only one of the \"port\", \"server\", or \"noServer\" options ' +\n          'must be specified'\n      );\n    }\n\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(\n        options.port,\n        options.host,\n        options.backlog,\n        callback\n      );\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, 'connection');\n\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) {\n      this.clients = new Set();\n      this._shouldEmitClose = false;\n    }\n\n    this.options = options;\n    this._state = RUNNING;\n  }\n\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n\n    if (!this._server) return null;\n    return this._server.address();\n  }\n\n  /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb) {\n        this.once('close', () => {\n          cb(new Error('The server is not running'));\n        });\n      }\n\n      process.nextTick(emitClose, this);\n      return;\n    }\n\n    if (cb) this.once('close', cb);\n\n    if (this._state === CLOSING) return;\n    this._state = CLOSING;\n\n    if (this.options.noServer || this.options.server) {\n      if (this._server) {\n        this._removeListeners();\n        this._removeListeners = this._server = null;\n      }\n\n      if (this.clients) {\n        if (!this.clients.size) {\n          process.nextTick(emitClose, this);\n        } else {\n          this._shouldEmitClose = true;\n        }\n      } else {\n        process.nextTick(emitClose, this);\n      }\n    } else {\n      const server = this._server;\n\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n\n      //\n      // The HTTP/S server was created internally. Close it, and rely on its\n      // `'close'` event.\n      //\n      server.close(() => {\n        emitClose(this);\n      });\n    }\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n\n      if (pathname !== this.options.path) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n\n    const key = req.headers['sec-websocket-key'];\n    const version = +req.headers['sec-websocket-version'];\n\n    if (req.method !== 'GET') {\n      const message = 'Invalid HTTP method';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n      return;\n    }\n\n    if (req.headers.upgrade.toLowerCase() !== 'websocket') {\n      const message = 'Invalid Upgrade header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (!key || !keyRegex.test(key)) {\n      const message = 'Missing or invalid Sec-WebSocket-Key header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (version !== 8 && version !== 13) {\n      const message = 'Missing or invalid Sec-WebSocket-Version header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (!this.shouldHandle(req)) {\n      abortHandshake(socket, 400);\n      return;\n    }\n\n    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];\n    let protocols = new Set();\n\n    if (secWebSocketProtocol !== undefined) {\n      try {\n        protocols = subprotocol.parse(secWebSocketProtocol);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Protocol header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];\n    const extensions = {};\n\n    if (\n      this.options.perMessageDeflate &&\n      secWebSocketExtensions !== undefined\n    ) {\n      const perMessageDeflate = new PerMessageDeflate(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n\n      try {\n        const offers = extension.parse(secWebSocketExtensions);\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        const message =\n          'Invalid or unacceptable Sec-WebSocket-Extensions header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin:\n          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n\n          this.completeUpgrade(\n            extensions,\n            key,\n            protocols,\n            req,\n            socket,\n            head,\n            cb\n          );\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    if (socket[kWebSocket]) {\n      throw new Error(\n        'server.handleUpgrade() was called more than once with the same ' +\n          'socket, possibly due to a misconfiguration'\n      );\n    }\n\n    if (this._state > RUNNING) return abortHandshake(socket, 503);\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    const headers = [\n      'HTTP/1.1 101 Switching Protocols',\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${digest}`\n    ];\n\n    const ws = new this.options.WebSocket(null);\n\n    if (protocols.size) {\n      //\n      // Optionally call external protocol selection handler.\n      //\n      const protocol = this.options.handleProtocols\n        ? this.options.handleProtocols(protocols, req)\n        : protocols.values().next().value;\n\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws._protocol = protocol;\n      }\n    }\n\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n\n    ws.setSocket(socket, head, {\n      maxPayload: this.options.maxPayload,\n      skipUTF8Validation: this.options.skipUTF8Validation\n    });\n\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => {\n        this.clients.delete(ws);\n\n        if (this._shouldEmitClose && !this.clients.size) {\n          process.nextTick(emitClose, this);\n        }\n      });\n    }\n\n    cb(ws, req);\n  }\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when\n *     called\n * @private\n */\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit('close');\n}\n\n/**\n * Handle socket errors.\n *\n * @private\n */\nfunction socketOnError() {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake(socket, code, message, headers) {\n  //\n  // The socket is writable unless the user destroyed or ended it before calling\n  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user\n  // error. Handling this does not make much sense as the worst that can happen\n  // is that some of the data written by the user might be discarded due to the\n  // call to `socket.end()` below, which triggers an `'error'` event that in\n  // turn causes the socket to be destroyed.\n  //\n  message = message || http.STATUS_CODES[code];\n  headers = {\n    Connection: 'close',\n    'Content-Type': 'text/html',\n    'Content-Length': Buffer.byteLength(message),\n    ...headers\n  };\n\n  socket.once('finish', socket.destroy);\n\n  socket.end(\n    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` +\n      Object.keys(headers)\n        .map((h) => `${h}: ${headers[h]}`)\n        .join('\\r\\n') +\n      '\\r\\n\\r\\n' +\n      message\n  );\n}\n\n/**\n * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least\n * one listener for it, otherwise call `abortHandshake()`.\n *\n * @param {WebSocketServer} server The WebSocket server\n * @param {http.IncomingMessage} req The request object\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} message The HTTP response body\n * @private\n */\nfunction abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\n  if (server.listenerCount('wsClientError')) {\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n\n    server.emit('wsClientError', err, socket, req);\n  } else {\n    abortHandshake(socket, code, message);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}