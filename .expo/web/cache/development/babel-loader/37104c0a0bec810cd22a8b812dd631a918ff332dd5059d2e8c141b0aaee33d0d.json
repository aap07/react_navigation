{"ast":null,"code":"'use strict';\n\nvar _require = require(\"../utils.js\"),\n  getValueFromTypes = _require.getValueFromTypes;\nfunction getProperties(typeName, types) {\n  var typeAlias = types[typeName];\n  try {\n    return typeAlias.right.typeParameters.params[0].properties;\n  } catch (e) {\n    throw new Error(`Failed to find type definition for \"${typeName}\", please check that you have a valid codegen flow file`);\n  }\n}\nfunction getTypeAnnotationForArray(name, typeAnnotation, defaultValue, types, buildSchema) {\n  var extractedTypeAnnotation = getValueFromTypes(typeAnnotation, types);\n  if (extractedTypeAnnotation.type === 'NullableTypeAnnotation') {\n    throw new Error('Nested optionals such as \"$ReadOnlyArray<?boolean>\" are not supported, please declare optionals at the top level of value definitions as in \"?$ReadOnlyArray<boolean>\"');\n  }\n  if (extractedTypeAnnotation.type === 'GenericTypeAnnotation' && extractedTypeAnnotation.id.name === 'WithDefault') {\n    throw new Error('Nested defaults such as \"$ReadOnlyArray<WithDefault<boolean, false>>\" are not supported, please declare defaults at the top level of value definitions as in \"WithDefault<$ReadOnlyArray<boolean>, false>\"');\n  }\n  if (extractedTypeAnnotation.type === 'GenericTypeAnnotation') {\n    var objectType = getValueFromTypes(extractedTypeAnnotation, types);\n    if (objectType.id.name === '$ReadOnly') {\n      return {\n        type: 'ObjectTypeAnnotation',\n        properties: flattenProperties(objectType.typeParameters.params[0].properties, types).map(function (prop) {\n          return buildSchema(prop, types);\n        }).filter(Boolean)\n      };\n    }\n    if (objectType.id.name === '$ReadOnlyArray') {\n      var nestedObjectType = getValueFromTypes(objectType.typeParameters.params[0], types);\n      return {\n        type: 'ArrayTypeAnnotation',\n        elementType: {\n          type: 'ObjectTypeAnnotation',\n          properties: flattenProperties(nestedObjectType.typeParameters.params[0].properties, types).map(function (prop) {\n            return buildSchema(prop, types);\n          }).filter(Boolean)\n        }\n      };\n    }\n  }\n  var type = extractedTypeAnnotation.type === 'GenericTypeAnnotation' ? extractedTypeAnnotation.id.name : extractedTypeAnnotation.type;\n  switch (type) {\n    case 'ImageSource':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'ImageSourcePrimitive'\n      };\n    case 'ImageRequest':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'ImageRequestPrimitive'\n      };\n    case 'ColorValue':\n    case 'ProcessedColorValue':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'ColorPrimitive'\n      };\n    case 'PointValue':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'PointPrimitive'\n      };\n    case 'EdgeInsetsValue':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'EdgeInsetsPrimitive'\n      };\n    case 'DimensionValue':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'DimensionPrimitive'\n      };\n    case 'Stringish':\n      return {\n        type: 'StringTypeAnnotation'\n      };\n    case 'Int32':\n      return {\n        type: 'Int32TypeAnnotation'\n      };\n    case 'Double':\n      return {\n        type: 'DoubleTypeAnnotation'\n      };\n    case 'Float':\n      return {\n        type: 'FloatTypeAnnotation'\n      };\n    case 'BooleanTypeAnnotation':\n      return {\n        type: 'BooleanTypeAnnotation'\n      };\n    case 'StringTypeAnnotation':\n      return {\n        type: 'StringTypeAnnotation'\n      };\n    case 'UnionTypeAnnotation':\n      typeAnnotation.types.reduce(function (lastType, currType) {\n        if (lastType && currType.type !== lastType.type) {\n          throw new Error(`Mixed types are not supported (see \"${name}\")`);\n        }\n        return currType;\n      });\n      if (defaultValue === null) {\n        throw new Error(`A default enum value is required for \"${name}\"`);\n      }\n      var unionType = typeAnnotation.types[0].type;\n      if (unionType === 'StringLiteralTypeAnnotation') {\n        return {\n          type: 'StringEnumTypeAnnotation',\n          default: defaultValue,\n          options: typeAnnotation.types.map(function (option) {\n            return option.value;\n          })\n        };\n      } else if (unionType === 'NumberLiteralTypeAnnotation') {\n        throw new Error(`Arrays of int enums are not supported (see: \"${name}\")`);\n      } else {\n        throw new Error(`Unsupported union type for \"${name}\", received \"${unionType}\"`);\n      }\n    default:\n      type;\n      throw new Error(`Unknown property type for \"${name}\": ${type}`);\n  }\n}\nfunction flattenProperties(typeDefinition, types) {\n  return typeDefinition.map(function (property) {\n    if (property.type === 'ObjectTypeProperty') {\n      return property;\n    } else if (property.type === 'ObjectTypeSpreadProperty') {\n      return flattenProperties(getProperties(property.argument.id.name, types), types);\n    }\n  }).reduce(function (acc, item) {\n    if (Array.isArray(item)) {\n      item.forEach(function (prop) {\n        verifyPropNotAlreadyDefined(acc, prop);\n      });\n      return acc.concat(item);\n    } else {\n      verifyPropNotAlreadyDefined(acc, item);\n      acc.push(item);\n      return acc;\n    }\n  }, []).filter(Boolean);\n}\nfunction verifyPropNotAlreadyDefined(props, needleProp) {\n  var propName = needleProp.key.name;\n  var foundProp = props.some(function (prop) {\n    return prop.key.name === propName;\n  });\n  if (foundProp) {\n    throw new Error(`A prop was already defined with the name ${propName}`);\n  }\n}\nfunction getTypeAnnotation(name, annotation, defaultValue, withNullDefault, types, buildSchema) {\n  var typeAnnotation = getValueFromTypes(annotation, types);\n  if (typeAnnotation.type === 'GenericTypeAnnotation' && typeAnnotation.id.name === '$ReadOnlyArray') {\n    return {\n      type: 'ArrayTypeAnnotation',\n      elementType: getTypeAnnotationForArray(name, typeAnnotation.typeParameters.params[0], defaultValue, types, buildSchema)\n    };\n  }\n  if (typeAnnotation.type === 'GenericTypeAnnotation' && typeAnnotation.id.name === '$ReadOnly') {\n    return {\n      type: 'ObjectTypeAnnotation',\n      properties: flattenProperties(typeAnnotation.typeParameters.params[0].properties, types).map(function (prop) {\n        return buildSchema(prop, types);\n      }).filter(Boolean)\n    };\n  }\n  var type = typeAnnotation.type === 'GenericTypeAnnotation' ? typeAnnotation.id.name : typeAnnotation.type;\n  switch (type) {\n    case 'ImageSource':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'ImageSourcePrimitive'\n      };\n    case 'ImageRequest':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'ImageRequestPrimitive'\n      };\n    case 'ColorValue':\n    case 'ProcessedColorValue':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'ColorPrimitive'\n      };\n    case 'ColorArrayValue':\n      return {\n        type: 'ArrayTypeAnnotation',\n        elementType: {\n          type: 'ReservedPropTypeAnnotation',\n          name: 'ColorPrimitive'\n        }\n      };\n    case 'PointValue':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'PointPrimitive'\n      };\n    case 'EdgeInsetsValue':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'EdgeInsetsPrimitive'\n      };\n    case 'DimensionValue':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'DimensionPrimitive'\n      };\n    case 'Int32':\n      return {\n        type: 'Int32TypeAnnotation',\n        default: defaultValue ? defaultValue : 0\n      };\n    case 'Double':\n      return {\n        type: 'DoubleTypeAnnotation',\n        default: defaultValue ? defaultValue : 0\n      };\n    case 'Float':\n      return {\n        type: 'FloatTypeAnnotation',\n        default: withNullDefault ? defaultValue : defaultValue ? defaultValue : 0\n      };\n    case 'BooleanTypeAnnotation':\n      return {\n        type: 'BooleanTypeAnnotation',\n        default: withNullDefault ? defaultValue : defaultValue == null ? false : defaultValue\n      };\n    case 'StringTypeAnnotation':\n      if (typeof defaultValue !== 'undefined') {\n        return {\n          type: 'StringTypeAnnotation',\n          default: defaultValue\n        };\n      }\n      throw new Error(`A default string (or null) is required for \"${name}\"`);\n    case 'Stringish':\n      if (typeof defaultValue !== 'undefined') {\n        return {\n          type: 'StringTypeAnnotation',\n          default: defaultValue\n        };\n      }\n      throw new Error(`A default string (or null) is required for \"${name}\"`);\n    case 'UnionTypeAnnotation':\n      typeAnnotation.types.reduce(function (lastType, currType) {\n        if (lastType && currType.type !== lastType.type) {\n          throw new Error(`Mixed types are not supported (see \"${name}\").`);\n        }\n        return currType;\n      });\n      if (defaultValue === null) {\n        throw new Error(`A default enum value is required for \"${name}\"`);\n      }\n      var unionType = typeAnnotation.types[0].type;\n      if (unionType === 'StringLiteralTypeAnnotation') {\n        return {\n          type: 'StringEnumTypeAnnotation',\n          default: defaultValue,\n          options: typeAnnotation.types.map(function (option) {\n            return option.value;\n          })\n        };\n      } else if (unionType === 'NumberLiteralTypeAnnotation') {\n        return {\n          type: 'Int32EnumTypeAnnotation',\n          default: defaultValue,\n          options: typeAnnotation.types.map(function (option) {\n            return option.value;\n          })\n        };\n      } else {\n        throw new Error(`Unsupported union type for \"${name}\", received \"${unionType}\"`);\n      }\n    case 'ObjectTypeAnnotation':\n      throw new Error(`Cannot use \"${type}\" type annotation for \"${name}\": object types must be declared using $ReadOnly<>`);\n    case 'NumberTypeAnnotation':\n      throw new Error(`Cannot use \"${type}\" type annotation for \"${name}\": must use a specific numeric type like Int32, Double, or Float`);\n    case 'UnsafeMixed':\n      return {\n        type: 'MixedTypeAnnotation'\n      };\n    default:\n      type;\n      throw new Error(`Unknown property type for \"${name}\": \"${type}\" in the State`);\n  }\n}\nfunction getSchemaInfo(property, types) {\n  var name = property.key.name;\n  var value = getValueFromTypes(property.value, types);\n  var typeAnnotation = value.type === 'NullableTypeAnnotation' ? value.typeAnnotation : value;\n  var optional = value.type === 'NullableTypeAnnotation' || property.optional || value.type === 'GenericTypeAnnotation' && typeAnnotation.id.name === 'WithDefault';\n  if (!property.optional && value.type === 'GenericTypeAnnotation' && typeAnnotation.id.name === 'WithDefault') {\n    throw new Error(`key ${name} must be optional if used with WithDefault<> annotation`);\n  }\n  if (value.type === 'NullableTypeAnnotation' && typeAnnotation.type === 'GenericTypeAnnotation' && typeAnnotation.id.name === 'WithDefault') {\n    throw new Error('WithDefault<> is optional and does not need to be marked as optional. Please remove the ? annotation in front of it.');\n  }\n  var type = typeAnnotation.type;\n  if (type === 'GenericTypeAnnotation' && (typeAnnotation.id.name === 'DirectEventHandler' || typeAnnotation.id.name === 'BubblingEventHandler')) {\n    return null;\n  }\n  if (name === 'style' && type === 'GenericTypeAnnotation' && typeAnnotation.id.name === 'ViewStyleProp') {\n    return null;\n  }\n  var defaultValue = null;\n  var withNullDefault = false;\n  if (type === 'GenericTypeAnnotation' && typeAnnotation.id.name === 'WithDefault') {\n    if (typeAnnotation.typeParameters.params.length === 1) {\n      throw new Error(`WithDefault requires two parameters, did you forget to provide a default value for \"${name}\"?`);\n    }\n    defaultValue = typeAnnotation.typeParameters.params[1].value;\n    var defaultValueType = typeAnnotation.typeParameters.params[1].type;\n    typeAnnotation = typeAnnotation.typeParameters.params[0];\n    type = typeAnnotation.type === 'GenericTypeAnnotation' ? typeAnnotation.id.name : typeAnnotation.type;\n    if (defaultValueType === 'NullLiteralTypeAnnotation') {\n      defaultValue = null;\n      withNullDefault = true;\n    }\n  }\n  return {\n    name: name,\n    optional: optional,\n    typeAnnotation: typeAnnotation,\n    defaultValue: defaultValue,\n    withNullDefault: withNullDefault\n  };\n}\nmodule.exports = {\n  getProperties: getProperties,\n  getSchemaInfo: getSchemaInfo,\n  getTypeAnnotation: getTypeAnnotation,\n  flattenProperties: flattenProperties\n};","map":{"version":3,"names":["_require","require","getValueFromTypes","getProperties","typeName","types","typeAlias","right","typeParameters","params","properties","e","Error","getTypeAnnotationForArray","name","typeAnnotation","defaultValue","buildSchema","extractedTypeAnnotation","type","id","objectType","flattenProperties","map","prop","filter","Boolean","nestedObjectType","elementType","reduce","lastType","currType","unionType","default","options","option","value","typeDefinition","property","argument","acc","item","Array","isArray","forEach","verifyPropNotAlreadyDefined","concat","push","props","needleProp","propName","key","foundProp","some","getTypeAnnotation","annotation","withNullDefault","getSchemaInfo","optional","length","defaultValueType","module","exports"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native/codegen/lib/parsers/flow/components/componentsUtils.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\n'use strict';\n\nconst _require = require('../utils.js'),\n  getValueFromTypes = _require.getValueFromTypes;\nfunction getProperties(typeName, types) {\n  const typeAlias = types[typeName];\n  try {\n    return typeAlias.right.typeParameters.params[0].properties;\n  } catch (e) {\n    throw new Error(\n      `Failed to find type definition for \"${typeName}\", please check that you have a valid codegen flow file`,\n    );\n  }\n}\nfunction getTypeAnnotationForArray(\n  name,\n  typeAnnotation,\n  defaultValue,\n  types,\n  buildSchema,\n) {\n  const extractedTypeAnnotation = getValueFromTypes(typeAnnotation, types);\n  if (extractedTypeAnnotation.type === 'NullableTypeAnnotation') {\n    throw new Error(\n      'Nested optionals such as \"$ReadOnlyArray<?boolean>\" are not supported, please declare optionals at the top level of value definitions as in \"?$ReadOnlyArray<boolean>\"',\n    );\n  }\n  if (\n    extractedTypeAnnotation.type === 'GenericTypeAnnotation' &&\n    extractedTypeAnnotation.id.name === 'WithDefault'\n  ) {\n    throw new Error(\n      'Nested defaults such as \"$ReadOnlyArray<WithDefault<boolean, false>>\" are not supported, please declare defaults at the top level of value definitions as in \"WithDefault<$ReadOnlyArray<boolean>, false>\"',\n    );\n  }\n  if (extractedTypeAnnotation.type === 'GenericTypeAnnotation') {\n    // Resolve the type alias if it's not defined inline\n    const objectType = getValueFromTypes(extractedTypeAnnotation, types);\n    if (objectType.id.name === '$ReadOnly') {\n      return {\n        type: 'ObjectTypeAnnotation',\n        properties: flattenProperties(\n          objectType.typeParameters.params[0].properties,\n          types,\n        )\n          .map(prop => buildSchema(prop, types))\n          .filter(Boolean),\n      };\n    }\n    if (objectType.id.name === '$ReadOnlyArray') {\n      // We need to go yet another level deeper to resolve\n      // types that may be defined in a type alias\n      const nestedObjectType = getValueFromTypes(\n        objectType.typeParameters.params[0],\n        types,\n      );\n      return {\n        type: 'ArrayTypeAnnotation',\n        elementType: {\n          type: 'ObjectTypeAnnotation',\n          properties: flattenProperties(\n            nestedObjectType.typeParameters.params[0].properties,\n            types,\n          )\n            .map(prop => buildSchema(prop, types))\n            .filter(Boolean),\n        },\n      };\n    }\n  }\n  const type =\n    extractedTypeAnnotation.type === 'GenericTypeAnnotation'\n      ? extractedTypeAnnotation.id.name\n      : extractedTypeAnnotation.type;\n  switch (type) {\n    case 'ImageSource':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'ImageSourcePrimitive',\n      };\n    case 'ImageRequest':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'ImageRequestPrimitive',\n      };\n    case 'ColorValue':\n    case 'ProcessedColorValue':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'ColorPrimitive',\n      };\n    case 'PointValue':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'PointPrimitive',\n      };\n    case 'EdgeInsetsValue':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'EdgeInsetsPrimitive',\n      };\n    case 'DimensionValue':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'DimensionPrimitive',\n      };\n    case 'Stringish':\n      return {\n        type: 'StringTypeAnnotation',\n      };\n    case 'Int32':\n      return {\n        type: 'Int32TypeAnnotation',\n      };\n    case 'Double':\n      return {\n        type: 'DoubleTypeAnnotation',\n      };\n    case 'Float':\n      return {\n        type: 'FloatTypeAnnotation',\n      };\n    case 'BooleanTypeAnnotation':\n      return {\n        type: 'BooleanTypeAnnotation',\n      };\n    case 'StringTypeAnnotation':\n      return {\n        type: 'StringTypeAnnotation',\n      };\n    case 'UnionTypeAnnotation':\n      typeAnnotation.types.reduce((lastType, currType) => {\n        if (lastType && currType.type !== lastType.type) {\n          throw new Error(`Mixed types are not supported (see \"${name}\")`);\n        }\n        return currType;\n      });\n      if (defaultValue === null) {\n        throw new Error(`A default enum value is required for \"${name}\"`);\n      }\n      const unionType = typeAnnotation.types[0].type;\n      if (unionType === 'StringLiteralTypeAnnotation') {\n        return {\n          type: 'StringEnumTypeAnnotation',\n          default: defaultValue,\n          options: typeAnnotation.types.map(option => option.value),\n        };\n      } else if (unionType === 'NumberLiteralTypeAnnotation') {\n        throw new Error(\n          `Arrays of int enums are not supported (see: \"${name}\")`,\n        );\n      } else {\n        throw new Error(\n          `Unsupported union type for \"${name}\", received \"${unionType}\"`,\n        );\n      }\n    default:\n      type;\n      throw new Error(`Unknown property type for \"${name}\": ${type}`);\n  }\n}\nfunction flattenProperties(typeDefinition, types) {\n  return typeDefinition\n    .map(property => {\n      if (property.type === 'ObjectTypeProperty') {\n        return property;\n      } else if (property.type === 'ObjectTypeSpreadProperty') {\n        return flattenProperties(\n          getProperties(property.argument.id.name, types),\n          types,\n        );\n      }\n    })\n    .reduce((acc, item) => {\n      if (Array.isArray(item)) {\n        item.forEach(prop => {\n          verifyPropNotAlreadyDefined(acc, prop);\n        });\n        return acc.concat(item);\n      } else {\n        verifyPropNotAlreadyDefined(acc, item);\n        acc.push(item);\n        return acc;\n      }\n    }, [])\n    .filter(Boolean);\n}\nfunction verifyPropNotAlreadyDefined(props, needleProp) {\n  const propName = needleProp.key.name;\n  const foundProp = props.some(prop => prop.key.name === propName);\n  if (foundProp) {\n    throw new Error(`A prop was already defined with the name ${propName}`);\n  }\n}\nfunction getTypeAnnotation(\n  name,\n  annotation,\n  defaultValue,\n  withNullDefault,\n  types,\n  buildSchema,\n) {\n  const typeAnnotation = getValueFromTypes(annotation, types);\n  if (\n    typeAnnotation.type === 'GenericTypeAnnotation' &&\n    typeAnnotation.id.name === '$ReadOnlyArray'\n  ) {\n    return {\n      type: 'ArrayTypeAnnotation',\n      elementType: getTypeAnnotationForArray(\n        name,\n        typeAnnotation.typeParameters.params[0],\n        defaultValue,\n        types,\n        buildSchema,\n      ),\n    };\n  }\n  if (\n    typeAnnotation.type === 'GenericTypeAnnotation' &&\n    typeAnnotation.id.name === '$ReadOnly'\n  ) {\n    return {\n      type: 'ObjectTypeAnnotation',\n      properties: flattenProperties(\n        typeAnnotation.typeParameters.params[0].properties,\n        types,\n      )\n        .map(prop => buildSchema(prop, types))\n        .filter(Boolean),\n    };\n  }\n  const type =\n    typeAnnotation.type === 'GenericTypeAnnotation'\n      ? typeAnnotation.id.name\n      : typeAnnotation.type;\n  switch (type) {\n    case 'ImageSource':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'ImageSourcePrimitive',\n      };\n    case 'ImageRequest':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'ImageRequestPrimitive',\n      };\n    case 'ColorValue':\n    case 'ProcessedColorValue':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'ColorPrimitive',\n      };\n    case 'ColorArrayValue':\n      return {\n        type: 'ArrayTypeAnnotation',\n        elementType: {\n          type: 'ReservedPropTypeAnnotation',\n          name: 'ColorPrimitive',\n        },\n      };\n    case 'PointValue':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'PointPrimitive',\n      };\n    case 'EdgeInsetsValue':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'EdgeInsetsPrimitive',\n      };\n    case 'DimensionValue':\n      return {\n        type: 'ReservedPropTypeAnnotation',\n        name: 'DimensionPrimitive',\n      };\n    case 'Int32':\n      return {\n        type: 'Int32TypeAnnotation',\n        default: defaultValue ? defaultValue : 0,\n      };\n    case 'Double':\n      return {\n        type: 'DoubleTypeAnnotation',\n        default: defaultValue ? defaultValue : 0,\n      };\n    case 'Float':\n      return {\n        type: 'FloatTypeAnnotation',\n        default: withNullDefault\n          ? defaultValue\n          : defaultValue\n          ? defaultValue\n          : 0,\n      };\n    case 'BooleanTypeAnnotation':\n      return {\n        type: 'BooleanTypeAnnotation',\n        default: withNullDefault\n          ? defaultValue\n          : defaultValue == null\n          ? false\n          : defaultValue,\n      };\n    case 'StringTypeAnnotation':\n      if (typeof defaultValue !== 'undefined') {\n        return {\n          type: 'StringTypeAnnotation',\n          default: defaultValue,\n        };\n      }\n      throw new Error(`A default string (or null) is required for \"${name}\"`);\n    case 'Stringish':\n      if (typeof defaultValue !== 'undefined') {\n        return {\n          type: 'StringTypeAnnotation',\n          default: defaultValue,\n        };\n      }\n      throw new Error(`A default string (or null) is required for \"${name}\"`);\n    case 'UnionTypeAnnotation':\n      typeAnnotation.types.reduce((lastType, currType) => {\n        if (lastType && currType.type !== lastType.type) {\n          throw new Error(`Mixed types are not supported (see \"${name}\").`);\n        }\n        return currType;\n      });\n      if (defaultValue === null) {\n        throw new Error(`A default enum value is required for \"${name}\"`);\n      }\n      const unionType = typeAnnotation.types[0].type;\n      if (unionType === 'StringLiteralTypeAnnotation') {\n        return {\n          type: 'StringEnumTypeAnnotation',\n          default: defaultValue,\n          options: typeAnnotation.types.map(option => option.value),\n        };\n      } else if (unionType === 'NumberLiteralTypeAnnotation') {\n        return {\n          type: 'Int32EnumTypeAnnotation',\n          default: defaultValue,\n          options: typeAnnotation.types.map(option => option.value),\n        };\n      } else {\n        throw new Error(\n          `Unsupported union type for \"${name}\", received \"${unionType}\"`,\n        );\n      }\n    case 'ObjectTypeAnnotation':\n      throw new Error(\n        `Cannot use \"${type}\" type annotation for \"${name}\": object types must be declared using $ReadOnly<>`,\n      );\n    case 'NumberTypeAnnotation':\n      throw new Error(\n        `Cannot use \"${type}\" type annotation for \"${name}\": must use a specific numeric type like Int32, Double, or Float`,\n      );\n    case 'UnsafeMixed':\n      return {\n        type: 'MixedTypeAnnotation',\n      };\n    default:\n      type;\n      throw new Error(\n        `Unknown property type for \"${name}\": \"${type}\" in the State`,\n      );\n  }\n}\nfunction getSchemaInfo(property, types) {\n  const name = property.key.name;\n  const value = getValueFromTypes(property.value, types);\n  let typeAnnotation =\n    value.type === 'NullableTypeAnnotation' ? value.typeAnnotation : value;\n  const optional =\n    value.type === 'NullableTypeAnnotation' ||\n    property.optional ||\n    (value.type === 'GenericTypeAnnotation' &&\n      typeAnnotation.id.name === 'WithDefault');\n  if (\n    !property.optional &&\n    value.type === 'GenericTypeAnnotation' &&\n    typeAnnotation.id.name === 'WithDefault'\n  ) {\n    throw new Error(\n      `key ${name} must be optional if used with WithDefault<> annotation`,\n    );\n  }\n  if (\n    value.type === 'NullableTypeAnnotation' &&\n    typeAnnotation.type === 'GenericTypeAnnotation' &&\n    typeAnnotation.id.name === 'WithDefault'\n  ) {\n    throw new Error(\n      'WithDefault<> is optional and does not need to be marked as optional. Please remove the ? annotation in front of it.',\n    );\n  }\n  let type = typeAnnotation.type;\n  if (\n    type === 'GenericTypeAnnotation' &&\n    (typeAnnotation.id.name === 'DirectEventHandler' ||\n      typeAnnotation.id.name === 'BubblingEventHandler')\n  ) {\n    return null;\n  }\n  if (\n    name === 'style' &&\n    type === 'GenericTypeAnnotation' &&\n    typeAnnotation.id.name === 'ViewStyleProp'\n  ) {\n    return null;\n  }\n  let defaultValue = null;\n  let withNullDefault = false;\n  if (\n    type === 'GenericTypeAnnotation' &&\n    typeAnnotation.id.name === 'WithDefault'\n  ) {\n    if (typeAnnotation.typeParameters.params.length === 1) {\n      throw new Error(\n        `WithDefault requires two parameters, did you forget to provide a default value for \"${name}\"?`,\n      );\n    }\n    defaultValue = typeAnnotation.typeParameters.params[1].value;\n    const defaultValueType = typeAnnotation.typeParameters.params[1].type;\n    typeAnnotation = typeAnnotation.typeParameters.params[0];\n    type =\n      typeAnnotation.type === 'GenericTypeAnnotation'\n        ? typeAnnotation.id.name\n        : typeAnnotation.type;\n    if (defaultValueType === 'NullLiteralTypeAnnotation') {\n      defaultValue = null;\n      withNullDefault = true;\n    }\n  }\n  return {\n    name,\n    optional,\n    typeAnnotation,\n    defaultValue,\n    withNullDefault,\n  };\n}\n\n// $FlowFixMe[unclear-type] there's no flowtype for ASTs\n\nmodule.exports = {\n  getProperties,\n  getSchemaInfo,\n  getTypeAnnotation,\n  flattenProperties,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}