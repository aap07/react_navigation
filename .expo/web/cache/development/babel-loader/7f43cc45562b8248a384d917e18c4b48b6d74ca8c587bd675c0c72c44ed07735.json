{"ast":null,"code":"import _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nvar Analytics = _createClass(function Analytics() {\n  _classCallCheck(this, Analytics);\n});\nexport { Analytics as default };\nexport {};","map":{"version":3,"names":["Analytics","_createClass","_classCallCheck","default"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@expo/rudder-sdk-node/index.d.ts"],"sourcesContent":["import bunyan from '@expo/bunyan';\nexport declare type AnalyticsMessage = AnalyticsIdentity & {\n    context?: {\n        [key: string]: unknown;\n    };\n    integrations?: {\n        [destination: string]: boolean;\n    };\n    properties?: {\n        [key: string]: unknown;\n    };\n    timestamp?: Date;\n    [key: string]: unknown;\n};\nexport declare type AnalyticsIdentity = {\n    userId: string;\n} | {\n    userId?: string;\n    anonymousId: string;\n};\nexport declare type AnalyticsMessageCallback = (error?: Error) => void;\nexport declare type AnalyticsFlushCallback = (flushResponses: FlushResponse[]) => void;\ndeclare type FlushResponse = {\n    error?: Error;\n    data: {\n        batch: AnalyticsPayload[];\n        sentAt: Date;\n    };\n};\ndeclare type AnalyticsPayload = {\n    messageId: string;\n    _metadata: any;\n    context: any;\n    type: string;\n    originalTimestamp: Date;\n    [key: string]: any;\n};\nexport default class Analytics {\n    private readonly enable;\n    private inFlightFlush;\n    private readonly queue;\n    private readonly writeKey;\n    private readonly host;\n    private readonly timeout;\n    private readonly flushAt;\n    private readonly flushInterval;\n    private readonly maxFlushSizeInBytes;\n    private readonly maxQueueLength;\n    private readonly flushCallbacks;\n    private readonly flushResponses;\n    private finalMessageId;\n    private flushed;\n    private timer;\n    private readonly logger;\n    /**\n     * Initialize a new `Analytics` instance with your RudderStack project's `writeKey` and an\n     * optional dictionary of options.\n     */\n    constructor(writeKey: string, dataPlaneURL: string, { enable, timeout, flushAt, flushInterval, maxFlushSizeInBytes, // defaults to ~3.9mb\n    maxQueueLength, logLevel, }?: {\n        enable?: boolean;\n        /**\n         * The network timeout (in milliseconds) for how long to wait for a request to complete when\n         * sending messages to the data plane. Omit or specify 0 or a negative value to disable\n         * timeouts.\n         */\n        timeout?: number;\n        flushAt?: number;\n        flushInterval?: number;\n        maxFlushSizeInBytes?: number;\n        maxQueueLength?: number;\n        logLevel?: bunyan.LogLevel;\n    });\n    /**\n     * Sends an \"identify\" message that associates traits with a user.\n     */\n    identify(message: AnalyticsMessage & {\n        traits?: {\n            [key: string]: unknown;\n        };\n    }, callback?: AnalyticsMessageCallback): Analytics;\n    traits?: {\n        [key: string]: unknown;\n    };\n    /**\n     * Sends a \"group\" message that identifies this user with a group.\n     */\n    group(message: AnalyticsMessage & {\n        groupId: string;\n        traits?: {\n            [key: string]: unknown;\n        };\n    }, callback?: AnalyticsMessageCallback): Analytics;\n    /**\n     * Sends a \"track\" event that records an action.\n     */\n    track(message: AnalyticsMessage & {\n        event: string;\n    }, callback?: AnalyticsMessageCallback): Analytics;\n    /**\n     * Sends a \"page\" event that records a page view on a website.\n     */\n    page(message: AnalyticsMessage & {\n        name: string;\n    }, callback?: AnalyticsMessageCallback): Analytics;\n    /**\n     * Sends a \"screen\" event that records a screen view in an app.\n     */\n    screen(message: AnalyticsMessage, callback?: AnalyticsMessageCallback): Analytics;\n    /**\n     * Sends an \"alias\" message that associates one ID with another.\n     */\n    alias(message: {\n        previousId: string;\n        traits?: {\n            [key: string]: unknown;\n        };\n    } & AnalyticsIdentity, callback?: AnalyticsMessageCallback): Analytics;\n    private validate;\n    /**\n     * Adds a message of the specified type to the queue and flushes the queue if appropriate.\n     */\n    private enqueue;\n    /**\n     * Flushes the message queue to the server immediately if a flush is not already in progress.\n     */\n    flush(callback?: AnalyticsFlushCallback): Promise<FlushResponse[]>;\n    /**\n     * Flushes messages from the message queue to the server immediately. After the flush has finished,\n     * this checks for pending flushes and executes them. All data is rolled up into a single FlushResponse.\n     */\n    private executeFlush;\n    /**\n     * Calculates the amount of time to wait before retrying a request, given the number of prior\n     * retries (excluding the initial attempt).\n     *\n     * @param priorRetryCount the number of prior retries, starting from zero\n     */\n    private getExponentialDelay;\n    /**\n     * Returns whether to retry a request that failed with the given error or returned the given\n     * response.\n     */\n    private isErrorRetryable;\n    private nullFlushResponse;\n}\nexport {};\n"],"mappings":";;IAqCqBA,SAAS,GAAAC,YAAA,UAAAD,UAAA;EAAAE,eAAA,OAAAF,SAAA;AAAA;AAAA,SAATA,SAAS,IAAAG,OAAA;AA6G9B"},"metadata":{},"sourceType":"module","externalDependencies":[]}