{"ast":null,"code":"import { isNode } from \"../nodes/identity.js\";\nimport { Scalar } from \"../nodes/Scalar.js\";\nimport { YAMLMap } from \"../nodes/YAMLMap.js\";\nimport { YAMLSeq } from \"../nodes/YAMLSeq.js\";\nimport { resolveBlockMap } from \"./resolve-block-map.js\";\nimport { resolveBlockSeq } from \"./resolve-block-seq.js\";\nimport { resolveFlowCollection } from \"./resolve-flow-collection.js\";\nfunction resolveCollection(CN, ctx, token, onError, tagName, tag) {\n  var coll = token.type === 'block-map' ? resolveBlockMap(CN, ctx, token, onError, tag) : token.type === 'block-seq' ? resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection(CN, ctx, token, onError, tag);\n  var Coll = coll.constructor;\n  if (tagName === '!' || tagName === Coll.tagName) {\n    coll.tag = Coll.tagName;\n    return coll;\n  }\n  if (tagName) coll.tag = tagName;\n  return coll;\n}\nfunction composeCollection(CN, ctx, token, tagToken, onError) {\n  var _tag$resolve, _tag;\n  var tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, function (msg) {\n    return onError(tagToken, 'TAG_RESOLVE_FAILED', msg);\n  });\n  var expType = token.type === 'block-map' ? 'map' : token.type === 'block-seq' ? 'seq' : token.start.source === '{' ? 'map' : 'seq';\n  if (!tagToken || !tagName || tagName === '!' || tagName === YAMLMap.tagName && expType === 'map' || tagName === YAMLSeq.tagName && expType === 'seq' || !expType) {\n    return resolveCollection(CN, ctx, token, onError, tagName);\n  }\n  var tag = ctx.schema.tags.find(function (t) {\n    return t.tag === tagName && t.collection === expType;\n  });\n  if (!tag) {\n    var kt = ctx.schema.knownTags[tagName];\n    if (kt && kt.collection === expType) {\n      ctx.schema.tags.push(Object.assign({}, kt, {\n        default: false\n      }));\n      tag = kt;\n    } else {\n      if (kt != null && kt.collection) {\n        onError(tagToken, 'BAD_COLLECTION_TYPE', `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);\n      } else {\n        onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);\n      }\n      return resolveCollection(CN, ctx, token, onError, tagName);\n    }\n  }\n  var coll = resolveCollection(CN, ctx, token, onError, tagName, tag);\n  var res = (_tag$resolve = tag.resolve == null ? void 0 : tag.resolve(coll, function (msg) {\n    return onError(tagToken, 'TAG_RESOLVE_FAILED', msg);\n  }, ctx.options)) != null ? _tag$resolve : coll;\n  var node = isNode(res) ? res : new Scalar(res);\n  node.range = coll.range;\n  node.tag = tagName;\n  if ((_tag = tag) != null && _tag.format) node.format = tag.format;\n  return node;\n}\nexport { composeCollection };","map":{"version":3,"names":["isNode","Scalar","YAMLMap","YAMLSeq","resolveBlockMap","resolveBlockSeq","resolveFlowCollection","resolveCollection","CN","ctx","token","onError","tagName","tag","coll","type","Coll","constructor","composeCollection","tagToken","_tag$resolve","_tag","directives","source","msg","expType","start","schema","tags","find","t","collection","kt","knownTags","push","Object","assign","default","res","resolve","options","node","range","format"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native-community/cli-doctor/node_modules/yaml/browser/dist/compose/compose-collection.js"],"sourcesContent":["import { isNode } from '../nodes/identity.js';\nimport { Scalar } from '../nodes/Scalar.js';\nimport { YAMLMap } from '../nodes/YAMLMap.js';\nimport { YAMLSeq } from '../nodes/YAMLSeq.js';\nimport { resolveBlockMap } from './resolve-block-map.js';\nimport { resolveBlockSeq } from './resolve-block-seq.js';\nimport { resolveFlowCollection } from './resolve-flow-collection.js';\n\nfunction resolveCollection(CN, ctx, token, onError, tagName, tag) {\n    const coll = token.type === 'block-map'\n        ? resolveBlockMap(CN, ctx, token, onError, tag)\n        : token.type === 'block-seq'\n            ? resolveBlockSeq(CN, ctx, token, onError, tag)\n            : resolveFlowCollection(CN, ctx, token, onError, tag);\n    const Coll = coll.constructor;\n    // If we got a tagName matching the class, or the tag name is '!',\n    // then use the tagName from the node class used to create it.\n    if (tagName === '!' || tagName === Coll.tagName) {\n        coll.tag = Coll.tagName;\n        return coll;\n    }\n    if (tagName)\n        coll.tag = tagName;\n    return coll;\n}\nfunction composeCollection(CN, ctx, token, tagToken, onError) {\n    const tagName = !tagToken\n        ? null\n        : ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));\n    const expType = token.type === 'block-map'\n        ? 'map'\n        : token.type === 'block-seq'\n            ? 'seq'\n            : token.start.source === '{'\n                ? 'map'\n                : 'seq';\n    // shortcut: check if it's a generic YAMLMap or YAMLSeq\n    // before jumping into the custom tag logic.\n    if (!tagToken ||\n        !tagName ||\n        tagName === '!' ||\n        (tagName === YAMLMap.tagName && expType === 'map') ||\n        (tagName === YAMLSeq.tagName && expType === 'seq') ||\n        !expType) {\n        return resolveCollection(CN, ctx, token, onError, tagName);\n    }\n    let tag = ctx.schema.tags.find(t => t.tag === tagName && t.collection === expType);\n    if (!tag) {\n        const kt = ctx.schema.knownTags[tagName];\n        if (kt && kt.collection === expType) {\n            ctx.schema.tags.push(Object.assign({}, kt, { default: false }));\n            tag = kt;\n        }\n        else {\n            if (kt?.collection) {\n                onError(tagToken, 'BAD_COLLECTION_TYPE', `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);\n            }\n            else {\n                onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);\n            }\n            return resolveCollection(CN, ctx, token, onError, tagName);\n        }\n    }\n    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);\n    const res = tag.resolve?.(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options) ?? coll;\n    const node = isNode(res)\n        ? res\n        : new Scalar(res);\n    node.range = coll.range;\n    node.tag = tagName;\n    if (tag?.format)\n        node.format = tag.format;\n    return node;\n}\n\nexport { composeCollection };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}