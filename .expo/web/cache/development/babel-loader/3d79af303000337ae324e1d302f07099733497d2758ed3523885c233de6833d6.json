{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _assert = _interopRequireDefault(require(\"assert\"));\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\nvar Log = _interopRequireWildcard(require(\"../../../log\"));\nvar _errors = require(\"../../../utils/errors\");\nvar _url = require(\"../../../utils/url\");\nvar _deviceManager = require(\"../DeviceManager\");\nvar _expoGoInstaller = require(\"../ExpoGoInstaller\");\nvar _activateWindow = require(\"./activateWindow\");\nvar AndroidDebugBridge = _interopRequireWildcard(require(\"./adb\"));\nvar _emulator = require(\"./emulator\");\nvar _getDevices = require(\"./getDevices\");\nvar _promptAndroidDevice = require(\"./promptAndroidDevice\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nvar EXPO_GO_APPLICATION_IDENTIFIER = \"host.exp.exponent\";\nvar AndroidDeviceManager = function (_deviceManager$Device) {\n  _inherits(AndroidDeviceManager, _deviceManager$Device);\n  var _super = _createSuper(AndroidDeviceManager);\n  function AndroidDeviceManager() {\n    _classCallCheck(this, AndroidDeviceManager);\n    return _super.apply(this, arguments);\n  }\n  _createClass(AndroidDeviceManager, [{\n    key: \"name\",\n    get: function get() {\n      return this.device.name;\n    }\n  }, {\n    key: \"identifier\",\n    get: function get() {\n      var _pid;\n      return (_pid = this.device.pid) != null ? _pid : \"unknown\";\n    }\n  }, {\n    key: \"getAppVersionAsync\",\n    value: function () {\n      var _getAppVersionAsync = _asyncToGenerator(function* (applicationId) {\n        var ref;\n        var info = yield AndroidDebugBridge.getPackageInfoAsync(this.device, {\n          appId: applicationId\n        });\n        var regex = /versionName=([0-9.]+)/;\n        var ref1;\n        return (ref1 = (ref = regex.exec(info)) == null ? void 0 : ref[1]) != null ? ref1 : null;\n      });\n      function getAppVersionAsync(_x) {\n        return _getAppVersionAsync.apply(this, arguments);\n      }\n      return getAppVersionAsync;\n    }()\n  }, {\n    key: \"attemptToStartAsync\",\n    value: function () {\n      var _attemptToStartAsync = _asyncToGenerator(function* () {\n        if (!(yield AndroidDebugBridge.isDeviceBootedAsync(this.device))) {\n          this.device = yield (0, _emulator).startDeviceAsync(this.device);\n        }\n        if (this.device.isAuthorized === false) {\n          AndroidDebugBridge.logUnauthorized(this.device);\n          return null;\n        }\n        return this.device;\n      });\n      function attemptToStartAsync() {\n        return _attemptToStartAsync.apply(this, arguments);\n      }\n      return attemptToStartAsync;\n    }()\n  }, {\n    key: \"startAsync\",\n    value: function () {\n      var _startAsync = _asyncToGenerator(function* () {\n        var device = yield this.attemptToStartAsync();\n        (0, _assert).default(device, `Failed to boot emulator.`);\n        return this.device;\n      });\n      function startAsync() {\n        return _startAsync.apply(this, arguments);\n      }\n      return startAsync;\n    }()\n  }, {\n    key: \"installAppAsync\",\n    value: function () {\n      var _installAppAsync = _asyncToGenerator(function* (binaryPath) {\n        yield AndroidDebugBridge.installAsync(this.device, {\n          filePath: binaryPath\n        });\n      });\n      function installAppAsync(_x2) {\n        return _installAppAsync.apply(this, arguments);\n      }\n      return installAppAsync;\n    }()\n  }, {\n    key: \"uninstallAppAsync\",\n    value: function () {\n      var _uninstallAppAsync = _asyncToGenerator(function* (appId) {\n        var isInstalled = yield this.isAppInstalledAsync(appId);\n        if (!isInstalled) {\n          return;\n        }\n        try {\n          yield AndroidDebugBridge.uninstallAsync(this.device, {\n            appId: appId\n          });\n        } catch (e) {\n          Log.error(`Could not uninstall app \"${appId}\" from your device, please uninstall it manually and try again.`);\n          throw e;\n        }\n      });\n      function uninstallAppAsync(_x3) {\n        return _uninstallAppAsync.apply(this, arguments);\n      }\n      return uninstallAppAsync;\n    }()\n  }, {\n    key: \"launchActivityAsync\",\n    value: function () {\n      var _launchActivityAsync = _asyncToGenerator(function* (launchActivity) {\n        try {\n          return yield AndroidDebugBridge.launchActivityAsync(this.device, {\n            launchActivity: launchActivity\n          });\n        } catch (error) {\n          var errorMessage = `Couldn't open Android app with activity \"${launchActivity}\" on device \"${this.name}\".`;\n          if (error instanceof _errors.CommandError && error.code === \"APP_NOT_INSTALLED\") {\n            errorMessage += `\\nThe app might not be installed, try installing it with: ${_chalk.default.bold(`npx expo run:android -d ${this.name}`)}`;\n          }\n          errorMessage += _chalk.default.gray(`\\n${error.message}`);\n          error.message = errorMessage;\n          throw error;\n        }\n      });\n      function launchActivityAsync(_x4) {\n        return _launchActivityAsync.apply(this, arguments);\n      }\n      return launchActivityAsync;\n    }()\n  }, {\n    key: \"isAppInstalledAsync\",\n    value: function () {\n      var _isAppInstalledAsync = _asyncToGenerator(function* (applicationId) {\n        return yield AndroidDebugBridge.isPackageInstalledAsync(this.device, applicationId);\n      });\n      function isAppInstalledAsync(_x5) {\n        return _isAppInstalledAsync.apply(this, arguments);\n      }\n      return isAppInstalledAsync;\n    }()\n  }, {\n    key: \"openUrlAsync\",\n    value: function () {\n      var _openUrlAsync = _asyncToGenerator(function* (url) {\n        if (!(0, _url).validateUrl(url, {\n          requireProtocol: true\n        })) {\n          yield this.launchActivityAsync(url);\n          return;\n        }\n        var parsed = new URL(url);\n        if (parsed.protocol === \"exp:\") {\n          yield AndroidDebugBridge.openAppIdAsync({\n            pid: this.device.pid\n          }, {\n            applicationId: EXPO_GO_APPLICATION_IDENTIFIER\n          });\n        }\n        yield AndroidDebugBridge.openUrlAsync({\n          pid: this.device.pid\n        }, {\n          url: url\n        });\n      });\n      function openUrlAsync(_x6) {\n        return _openUrlAsync.apply(this, arguments);\n      }\n      return openUrlAsync;\n    }()\n  }, {\n    key: \"activateWindowAsync\",\n    value: function () {\n      var _activateWindowAsync = _asyncToGenerator(function* () {\n        yield (0, _activateWindow).activateWindowAsync(this.device);\n      });\n      function activateWindowAsync() {\n        return _activateWindowAsync.apply(this, arguments);\n      }\n      return activateWindowAsync;\n    }()\n  }, {\n    key: \"ensureExpoGoAsync\",\n    value: function () {\n      var _ensureExpoGoAsync = _asyncToGenerator(function* (sdkVersion) {\n        var installer = new _expoGoInstaller.ExpoGoInstaller(\"android\", EXPO_GO_APPLICATION_IDENTIFIER, sdkVersion);\n        return installer.ensureAsync(this);\n      });\n      function ensureExpoGoAsync(_x7) {\n        return _ensureExpoGoAsync.apply(this, arguments);\n      }\n      return ensureExpoGoAsync;\n    }()\n  }], [{\n    key: \"resolveFromNameAsync\",\n    value: function () {\n      var _resolveFromNameAsync = _asyncToGenerator(function* (name) {\n        var devices = yield (0, _getDevices).getDevicesAsync();\n        var device1 = devices.find(function (device) {\n          return device.name === name;\n        });\n        if (!device1) {\n          throw new _errors.CommandError(\"Could not find device with name: \" + name);\n        }\n        return AndroidDeviceManager.resolveAsync({\n          device: device1,\n          shouldPrompt: false\n        });\n      });\n      function resolveFromNameAsync(_x8) {\n        return _resolveFromNameAsync.apply(this, arguments);\n      }\n      return resolveFromNameAsync;\n    }()\n  }, {\n    key: \"resolveAsync\",\n    value: function () {\n      var _resolveAsync = _asyncToGenerator(function* () {\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          device = _ref.device,\n          shouldPrompt = _ref.shouldPrompt;\n        if (device) {\n          var manager = new AndroidDeviceManager(device);\n          if (!(yield manager.attemptToStartAsync())) {\n            throw new _errors.AbortCommandError();\n          }\n          return manager;\n        }\n        var devices = yield (0, _getDevices).getDevicesAsync();\n        var _device = shouldPrompt ? yield (0, _promptAndroidDevice).promptForDeviceAsync(devices) : devices[0];\n        return AndroidDeviceManager.resolveAsync({\n          device: _device,\n          shouldPrompt: false\n        });\n      });\n      function resolveAsync() {\n        return _resolveAsync.apply(this, arguments);\n      }\n      return resolveAsync;\n    }()\n  }]);\n  return AndroidDeviceManager;\n}(_deviceManager.DeviceManager);\nexports.AndroidDeviceManager = AndroidDeviceManager;","map":{"version":3,"names":["_asyncToGenerator","require","_classCallCheck","_createClass","_inherits","_possibleConstructorReturn","_getPrototypeOf","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","constructor","Reflect","construct","arguments","apply","sham","Proxy","Boolean","prototype","valueOf","call","e","_assert","_interopRequireDefault","_chalk","Log","_interopRequireWildcard","_errors","_url","_deviceManager","_expoGoInstaller","_activateWindow","AndroidDebugBridge","_emulator","_getDevices","_promptAndroidDevice","EXPO_GO_APPLICATION_IDENTIFIER","AndroidDeviceManager","_deviceManager$Device","_super","key","get","device","name","_pid","pid","value","_getAppVersionAsync","applicationId","ref","info","getPackageInfoAsync","appId","regex","ref1","exec","getAppVersionAsync","_x","_attemptToStartAsync","isDeviceBootedAsync","startDeviceAsync","isAuthorized","logUnauthorized","attemptToStartAsync","_startAsync","default","startAsync","_installAppAsync","binaryPath","installAsync","filePath","installAppAsync","_x2","_uninstallAppAsync","isInstalled","isAppInstalledAsync","uninstallAsync","error","uninstallAppAsync","_x3","_launchActivityAsync","launchActivity","launchActivityAsync","errorMessage","CommandError","code","bold","gray","message","_x4","_isAppInstalledAsync","isPackageInstalledAsync","_x5","_openUrlAsync","url","validateUrl","requireProtocol","parsed","URL","protocol","openAppIdAsync","openUrlAsync","_x6","_activateWindowAsync","activateWindowAsync","_ensureExpoGoAsync","sdkVersion","installer","ExpoGoInstaller","ensureAsync","ensureExpoGoAsync","_x7","_resolveFromNameAsync","devices","getDevicesAsync","device1","find","resolveAsync","shouldPrompt","resolveFromNameAsync","_x8","_resolveAsync","_ref","length","undefined","manager","AbortCommandError","_device","promptForDeviceAsync","DeviceManager"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\cli\\src\\start\\platforms\\android\\AndroidDeviceManager.ts"],"sourcesContent":["import assert from 'assert';\nimport chalk from 'chalk';\n\nimport * as Log from '../../../log';\nimport { AbortCommandError, CommandError } from '../../../utils/errors';\nimport { validateUrl } from '../../../utils/url';\nimport { DeviceManager } from '../DeviceManager';\nimport { ExpoGoInstaller } from '../ExpoGoInstaller';\nimport { BaseResolveDeviceProps } from '../PlatformManager';\nimport { activateWindowAsync } from './activateWindow';\nimport * as AndroidDebugBridge from './adb';\nimport { startDeviceAsync } from './emulator';\nimport { getDevicesAsync } from './getDevices';\nimport { promptForDeviceAsync } from './promptAndroidDevice';\n\nconst EXPO_GO_APPLICATION_IDENTIFIER = 'host.exp.exponent';\n\nexport class AndroidDeviceManager extends DeviceManager<AndroidDebugBridge.Device> {\n  static async resolveFromNameAsync(name: string): Promise<AndroidDeviceManager> {\n    const devices = await getDevicesAsync();\n    const device = devices.find((device) => device.name === name);\n\n    if (!device) {\n      throw new CommandError('Could not find device with name: ' + name);\n    }\n    return AndroidDeviceManager.resolveAsync({ device, shouldPrompt: false });\n  }\n\n  static async resolveAsync({\n    device,\n    shouldPrompt,\n  }: BaseResolveDeviceProps<AndroidDebugBridge.Device> = {}): Promise<AndroidDeviceManager> {\n    if (device) {\n      const manager = new AndroidDeviceManager(device);\n      if (!(await manager.attemptToStartAsync())) {\n        throw new AbortCommandError();\n      }\n      return manager;\n    }\n\n    const devices = await getDevicesAsync();\n    const _device = shouldPrompt ? await promptForDeviceAsync(devices) : devices[0];\n    return AndroidDeviceManager.resolveAsync({ device: _device, shouldPrompt: false });\n  }\n\n  get name() {\n    // TODO: Maybe strip `_` from the device name?\n    return this.device.name;\n  }\n\n  get identifier(): string {\n    return this.device.pid ?? 'unknown';\n  }\n\n  async getAppVersionAsync(applicationId: string): Promise<string | null> {\n    const info = await AndroidDebugBridge.getPackageInfoAsync(this.device, {\n      appId: applicationId,\n    });\n\n    const regex = /versionName=([0-9.]+)/;\n    return regex.exec(info)?.[1] ?? null;\n  }\n\n  protected async attemptToStartAsync(): Promise<AndroidDebugBridge.Device | null> {\n    // TODO: Add a light-weight method for checking since a device could disconnect.\n    if (!(await AndroidDebugBridge.isDeviceBootedAsync(this.device))) {\n      this.device = await startDeviceAsync(this.device);\n    }\n\n    if (this.device.isAuthorized === false) {\n      AndroidDebugBridge.logUnauthorized(this.device);\n      return null;\n    }\n\n    return this.device;\n  }\n\n  async startAsync(): Promise<AndroidDebugBridge.Device> {\n    const device = await this.attemptToStartAsync();\n    assert(device, `Failed to boot emulator.`);\n    return this.device;\n  }\n\n  async installAppAsync(binaryPath: string) {\n    await AndroidDebugBridge.installAsync(this.device, {\n      filePath: binaryPath,\n    });\n  }\n\n  async uninstallAppAsync(appId: string) {\n    // we need to check if the app is installed, else we might bump into \"Failure [DELETE_FAILED_INTERNAL_ERROR]\"\n    const isInstalled = await this.isAppInstalledAsync(appId);\n    if (!isInstalled) {\n      return;\n    }\n\n    try {\n      await AndroidDebugBridge.uninstallAsync(this.device, {\n        appId,\n      });\n    } catch (e) {\n      Log.error(\n        `Could not uninstall app \"${appId}\" from your device, please uninstall it manually and try again.`\n      );\n      throw e;\n    }\n  }\n\n  /**\n   * @param launchActivity Activity to launch `[application identifier]/.[main activity name]`, ex: `com.bacon.app/.MainActivity`\n   */\n  async launchActivityAsync(launchActivity: string): Promise<string> {\n    try {\n      return await AndroidDebugBridge.launchActivityAsync(this.device, {\n        launchActivity,\n      });\n    } catch (error: any) {\n      let errorMessage = `Couldn't open Android app with activity \"${launchActivity}\" on device \"${this.name}\".`;\n      if (error instanceof CommandError && error.code === 'APP_NOT_INSTALLED') {\n        errorMessage += `\\nThe app might not be installed, try installing it with: ${chalk.bold(\n          `npx expo run:android -d ${this.name}`\n        )}`;\n      }\n      errorMessage += chalk.gray(`\\n${error.message}`);\n      error.message = errorMessage;\n      throw error;\n    }\n  }\n\n  async isAppInstalledAsync(applicationId: string) {\n    return await AndroidDebugBridge.isPackageInstalledAsync(this.device, applicationId);\n  }\n\n  async openUrlAsync(url: string) {\n    // Non-compliant URLs will be treated as application identifiers.\n    if (!validateUrl(url, { requireProtocol: true })) {\n      await this.launchActivityAsync(url);\n      return;\n    }\n\n    const parsed = new URL(url);\n\n    if (parsed.protocol === 'exp:') {\n      // NOTE(brentvatne): temporary workaround! launch Expo Go first, then\n      // launch the project!\n      // https://github.com/expo/expo/issues/7772\n      // adb shell monkey -p host.exp.exponent -c android.intent.category.LAUNCHER 1\n      // Note: this is not needed in Expo Development Client, it only applies to Expo Go\n      await AndroidDebugBridge.openAppIdAsync(\n        { pid: this.device.pid },\n        { applicationId: EXPO_GO_APPLICATION_IDENTIFIER }\n      );\n    }\n\n    await AndroidDebugBridge.openUrlAsync({ pid: this.device.pid }, { url });\n  }\n\n  async activateWindowAsync() {\n    // Bring the emulator window to the front on macos devices.\n    await activateWindowAsync(this.device);\n  }\n\n  async ensureExpoGoAsync(sdkVersion?: string): Promise<boolean> {\n    const installer = new ExpoGoInstaller('android', EXPO_GO_APPLICATION_IDENTIFIER, sdkVersion);\n    return installer.ensureAsync(this);\n  }\n}\n"],"mappings":"AAAA;;AAAA,IAAAA,iBAAA,GAAAC,OAAA;AAAA,IAAAC,eAAA,GAAAD,OAAA;AAAA,IAAAE,YAAA,GAAAF,OAAA;AAAA,IAAAG,SAAA,GAAAH,OAAA;AAAA,IAAAI,0BAAA,GAAAJ,OAAA;AAAA,IAAAK,eAAA,GAAAL,OAAA;AAAA,SAAAM,aAAAC,OAAA,QAAAC,yBAAA,GAAAC,yBAAA,oBAAAC,qBAAA,QAAAC,KAAA,GAAAN,eAAA,CAAAE,OAAA,GAAAK,MAAA,MAAAJ,yBAAA,QAAAK,SAAA,GAAAR,eAAA,OAAAS,WAAA,EAAAF,MAAA,GAAAG,OAAA,CAAAC,SAAA,CAAAL,KAAA,EAAAM,SAAA,EAAAJ,SAAA,YAAAD,MAAA,GAAAD,KAAA,CAAAO,KAAA,OAAAD,SAAA,YAAAb,0BAAA,OAAAQ,MAAA;AAAA,SAAAH,0BAAA,eAAAM,OAAA,qBAAAA,OAAA,CAAAC,SAAA,oBAAAD,OAAA,CAAAC,SAAA,CAAAG,IAAA,2BAAAC,KAAA,oCAAAC,OAAA,CAAAC,SAAA,CAAAC,OAAA,CAAAC,IAAA,CAAAT,OAAA,CAAAC,SAAA,CAAAK,OAAA,8CAAAI,CAAA;;;;AAAmB,IAAAC,OAAQ,GAAAC,sBAAA,CAAA3B,OAAA,CAAR,QAAQ;AACT,IAAA4B,MAAO,GAAAD,sBAAA,CAAA3B,OAAA,CAAP,OAAO;AAEb,IAAA6B,GAAG,GAAAC,uBAAA,CAAA9B,OAAA,eAAoB,EAApB;AACiC,IAAA+B,OAAuB,GAAA/B,OAAA;AAC3C,IAAAgC,IAAoB,GAAAhC,OAAA;AAClB,IAAAiC,cAAkB,GAAAjC,OAAA;AAChB,IAAAkC,gBAAoB,GAAAlC,OAAA;AAEhB,IAAAmC,eAAkB,GAAAnC,OAAA;AAC1C,IAAAoC,kBAAkB,GAAAN,uBAAA,CAAA9B,OAAA,QAAa,EAAb;AACG,IAAAqC,SAAY,GAAArC,OAAA;AACb,IAAAsC,WAAc,GAAAtC,OAAA;AACT,IAAAuC,oBAAuB,GAAAvC,OAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAE5D,IAAMwC,8BAA8B,GAAG,mBAAmB;AAAC,IAE9CC,oBAAoB,aAAAC,qBAAA;EAAAvC,SAAA,CAAAsC,oBAAA,EAAAC,qBAAA;EAAA,IAAAC,MAAA,GAAArC,YAAA,CAAAmC,oBAAA;EAAA,SAAAA,qBAAA;IAAAxC,eAAA,OAAAwC,oBAAA;IAAA,OAAAE,MAAA,CAAAzB,KAAA,OAAAD,SAAA;EAAA;EAAAf,YAAA,CAAAuC,oBAAA;IAAAG,GAAA;IAAAC,GAAA,EA4B/B,SAAAA,IAAA,EAAW;MAET,OAAO,IAAI,CAACC,MAAM,CAACC,IAAI;;EACxB;IAAAH,GAAA;IAAAC,GAAA,EAED,SAAAA,IAAA,EAAyB;UAChBG,IAAe;MAAtB,OAAO,CAAAA,IAAe,GAAf,IAAI,CAACF,MAAM,CAACG,GAAG,YAAfD,IAAe,GAAI,SAAS;;EACpC;IAAAJ,GAAA;IAAAM,KAAA;MAAA,IAAAC,mBAAA,GAAApD,iBAAA,CAED,WAAyBqD,aAAqB,EAA0B;YAM/DC,GAAgB;QALvB,IAAMC,IAAI,SAASlB,kBAAkB,CAACmB,mBAAmB,CAAC,IAAI,CAACT,MAAM,EAAE;UACrEU,KAAK,EAAEJ;SACR,CAAC;QAEF,IAAMK,KAAK,0BAA0B;YAC9BC,IAAqB;QAA5B,OAAO,CAAAA,IAAqB,GAArB,CAAAL,GAAgB,GAAhBI,KAAK,CAACE,IAAI,CAACL,IAAI,CAAC,SAAK,GAArB,MAAqB,GAArBD,GAAgB,CAAG,CAAC,CAAC,YAArBK,IAAqB,GAAI,IAAI;OACrC;MAAA,SAAAE,mBAAAC,EAAA;QAAA,OAAAV,mBAAA,CAAAjC,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAA2C,kBAAA;IAAA;EAAA;IAAAhB,GAAA;IAAAM,KAAA;MAAA,IAAAY,oBAAA,GAAA/D,iBAAA,CAED,aAAiF;QAE/E,IAAI,QAAQqC,kBAAkB,CAAC2B,mBAAmB,CAAC,IAAI,CAACjB,MAAM,CAAC,GAAG;UAChE,IAAI,CAACA,MAAM,SAAS,IAAAT,SAAgB,EAAa2B,gBAAb,CAAC,IAAI,CAAClB,MAAM,CAAC;;QAGnD,IAAI,IAAI,CAACA,MAAM,CAACmB,YAAY,KAAK,KAAK,EAAE;UACtC7B,kBAAkB,CAAC8B,eAAe,CAAC,IAAI,CAACpB,MAAM,CAAC;UAC/C,OAAO,IAAI;;QAGb,OAAO,IAAI,CAACA,MAAM;OACnB;MAAA,SAAAqB,oBAAA;QAAA,OAAAL,oBAAA,CAAA5C,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAAkD,mBAAA;IAAA;EAAA;IAAAvB,GAAA;IAAAM,KAAA;MAAA,IAAAkB,WAAA,GAAArE,iBAAA,CAED,aAAuD;QACrD,IAAM+C,MAAM,SAAS,IAAI,CAACqB,mBAAmB,EAAE;QAC/C,IAAAzC,OAAM,EAAoC2C,OAApC,CAACvB,MAAM,EAAG,0BAAyB,CAAC;QAC1C,OAAO,IAAI,CAACA,MAAM;OACnB;MAAA,SAAAwB,WAAA;QAAA,OAAAF,WAAA,CAAAlD,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAAqD,UAAA;IAAA;EAAA;IAAA1B,GAAA;IAAAM,KAAA;MAAA,IAAAqB,gBAAA,GAAAxE,iBAAA,CAED,WAAsByE,UAAkB,EAAE;QACxC,MAAMpC,kBAAkB,CAACqC,YAAY,CAAC,IAAI,CAAC3B,MAAM,EAAE;UACjD4B,QAAQ,EAAEF;SACX,CAAC;OACH;MAAA,SAAAG,gBAAAC,GAAA;QAAA,OAAAL,gBAAA,CAAArD,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAA0D,eAAA;IAAA;EAAA;IAAA/B,GAAA;IAAAM,KAAA;MAAA,IAAA2B,kBAAA,GAAA9E,iBAAA,CAED,WAAwByD,KAAa,EAAE;QAErC,IAAMsB,WAAW,SAAS,IAAI,CAACC,mBAAmB,CAACvB,KAAK,CAAC;QACzD,IAAI,CAACsB,WAAW,EAAE;UAChB;;QAGF,IAAI;UACF,MAAM1C,kBAAkB,CAAC4C,cAAc,CAAC,IAAI,CAAClC,MAAM,EAAE;YACnDU,KAAK,EAALA;WACD,CAAC;SACH,CAAC,OAAO/B,CAAC,EAAE;UACVI,GAAG,CAACoD,KAAK,CACN,4BAA2BzB,KAAM,iEAAgE,CACnG;UACD,MAAM/B,CAAC;;OAEV;MAAA,SAAAyD,kBAAAC,GAAA;QAAA,OAAAN,kBAAA,CAAA3D,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAAiE,iBAAA;IAAA;EAAA;IAAAtC,GAAA;IAAAM,KAAA;MAAA,IAAAkC,oBAAA,GAAArF,iBAAA,CAKD,WAA0BsF,cAAsB,EAAmB;QACjE,IAAI;UACF,aAAajD,kBAAkB,CAACkD,mBAAmB,CAAC,IAAI,CAACxC,MAAM,EAAE;YAC/DuC,cAAc,EAAdA;WACD,CAAC;SACH,CAAC,OAAOJ,KAAK,EAAO;UACnB,IAAIM,YAAY,GAAI,4CAA2CF,cAAe,gBAAe,IAAI,CAACtC,IAAK,IAAG;UAC1G,IAAIkC,KAAK,YAAYlD,OAAY,CAAAyD,YAAA,IAAIP,KAAK,CAACQ,IAAI,KAAK,mBAAmB,EAAE;YACvEF,YAAY,IAAK,6DAA4D3D,MAAK,CAAAyC,OAAA,CAACqB,IAAI,CACpF,2BAA0B,IAAI,CAAC3C,IAAK,EAAC,CACtC,EAAC;;UAELwC,YAAY,IAAI3D,MAAK,CAAAyC,OAAA,CAACsB,IAAI,CAAE,KAAIV,KAAK,CAACW,OAAQ,EAAC,CAAC;UAChDX,KAAK,CAACW,OAAO,GAAGL,YAAY;UAC5B,MAAMN,KAAK;;OAEd;MAAA,SAAAK,oBAAAO,GAAA;QAAA,OAAAT,oBAAA,CAAAlE,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAAqE,mBAAA;IAAA;EAAA;IAAA1C,GAAA;IAAAM,KAAA;MAAA,IAAA4C,oBAAA,GAAA/F,iBAAA,CAED,WAA0BqD,aAAqB,EAAE;QAC/C,aAAahB,kBAAkB,CAAC2D,uBAAuB,CAAC,IAAI,CAACjD,MAAM,EAAEM,aAAa,CAAC;OACpF;MAAA,SAAA2B,oBAAAiB,GAAA;QAAA,OAAAF,oBAAA,CAAA5E,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAA8D,mBAAA;IAAA;EAAA;IAAAnC,GAAA;IAAAM,KAAA;MAAA,IAAA+C,aAAA,GAAAlG,iBAAA,CAED,WAAmBmG,GAAW,EAAE;QAE9B,IAAI,CAAC,IAAAlE,IAAW,EAAgCmE,WAAhC,CAACD,GAAG,EAAE;UAAEE,eAAe,EAAE;SAAM,CAAC,EAAE;UAChD,MAAM,IAAI,CAACd,mBAAmB,CAACY,GAAG,CAAC;UACnC;;QAGF,IAAMG,MAAM,GAAG,IAAIC,GAAG,CAACJ,GAAG,CAAC;QAE3B,IAAIG,MAAM,CAACE,QAAQ,KAAK,MAAM,EAAE;UAM9B,MAAMnE,kBAAkB,CAACoE,cAAc,CACrC;YAAEvD,GAAG,EAAE,IAAI,CAACH,MAAM,CAACG;WAAK,EACxB;YAAEG,aAAa,EAAEZ;WAAgC,CAClD;;QAGH,MAAMJ,kBAAkB,CAACqE,YAAY,CAAC;UAAExD,GAAG,EAAE,IAAI,CAACH,MAAM,CAACG;SAAK,EAAE;UAAEiD,GAAG,EAAHA;SAAK,CAAC;OACzE;MAAA,SAAAO,aAAAC,GAAA;QAAA,OAAAT,aAAA,CAAA/E,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAAwF,YAAA;IAAA;EAAA;IAAA7D,GAAA;IAAAM,KAAA;MAAA,IAAAyD,oBAAA,GAAA5G,iBAAA,CAED,aAA4B;QAE1B,MAAM,IAAAoC,eAAmB,EAAayE,mBAAb,CAAC,IAAI,CAAC9D,MAAM,CAAC;OACvC;MAAA,SAAA8D,oBAAA;QAAA,OAAAD,oBAAA,CAAAzF,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAA2F,mBAAA;IAAA;EAAA;IAAAhE,GAAA;IAAAM,KAAA;MAAA,IAAA2D,kBAAA,GAAA9G,iBAAA,CAED,WAAwB+G,UAAmB,EAAoB;QAC7D,IAAMC,SAAS,GAAG,IAAI7E,gBAAe,CAAA8E,eAAA,CAAC,SAAS,EAAExE,8BAA8B,EAAEsE,UAAU,CAAC;QAC5F,OAAOC,SAAS,CAACE,WAAW,CAAC,IAAI,CAAC;OACnC;MAAA,SAAAC,kBAAAC,GAAA;QAAA,OAAAN,kBAAA,CAAA3F,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAAiG,iBAAA;IAAA;EAAA;IAAAtE,GAAA;IAAAM,KAAA;MAAA,IAAAkE,qBAAA,GAAArH,iBAAA,CAnJD,WAAkCgD,IAAY,EAAiC;QAC7E,IAAMsE,OAAO,SAAS,IAAA/E,WAAe,EAAEgF,eAAF,EAAE;QACvC,IAAMC,OAAM,GAAGF,OAAO,CAACG,IAAI,CAAC,UAAC1E,MAAM;UAAA,OAAKA,MAAM,CAACC,IAAI,KAAKA,IAAI;QAAA,EAAC;QAE7D,IAAI,CAACwE,OAAM,EAAE;UACX,MAAM,IAAIxF,OAAY,CAAAyD,YAAA,CAAC,mCAAmC,GAAGzC,IAAI,CAAC;;QAEpE,OAAON,oBAAoB,CAACgF,YAAY,CAAC;UAAE3E,MAAM,EAANyE,OAAM;UAAEG,YAAY,EAAE;SAAO,CAAC;OAC1E;MAAA,SAAAC,qBAAAC,GAAA;QAAA,OAAAR,qBAAA,CAAAlG,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAA0G,oBAAA;IAAA;EAAA;IAAA/E,GAAA;IAAAM,KAAA;MAAA,IAAA2E,aAAA,GAAA9H,iBAAA,CAED,aAG0F;QAAA,IAAA+H,IAAA,GAAA7G,SAAA,CAAA8G,MAAA,QAAA9G,SAAA,QAAA+G,SAAA,GAAA/G,SAAA,MAAnC,EAAE;UAFvD6B,MAAM,GAAAgF,IAAA,CAANhF,MAAM;UACN4E,YAAY,GAAAI,IAAA,CAAZJ,YAAY;QAEZ,IAAI5E,MAAM,EAAE;UACV,IAAMmF,OAAO,GAAG,IAAIxF,oBAAoB,CAACK,MAAM,CAAC;UAChD,IAAI,QAAQmF,OAAO,CAAC9D,mBAAmB,EAAE,GAAG;YAC1C,MAAM,IAAIpC,OAAiB,CAAAmG,iBAAA,EAAE;;UAE/B,OAAOD,OAAO;;QAGhB,IAAMZ,OAAO,SAAS,IAAA/E,WAAe,EAAEgF,eAAF,EAAE;QACvC,IAAMa,OAAO,GAAGT,YAAY,SAAS,IAAAnF,oBAAoB,EAAS6F,oBAAT,CAACf,OAAO,CAAC,GAAGA,OAAO,CAAC,CAAC,CAAC;QAC/E,OAAO5E,oBAAoB,CAACgF,YAAY,CAAC;UAAE3E,MAAM,EAAEqF,OAAO;UAAET,YAAY,EAAE;SAAO,CAAC;OACnF;MAAA,SAAAD,aAAA;QAAA,OAAAI,aAAA,CAAA3G,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAAwG,YAAA;IAAA;EAAA;EAAA,OAAAhF,oBAAA;AAAA,EA1BuCR,cAAa,CAAAoG,aAAA;QAA1C5F,oBAAoB,GAApBA,oBAAoB"},"metadata":{},"sourceType":"script","externalDependencies":[]}