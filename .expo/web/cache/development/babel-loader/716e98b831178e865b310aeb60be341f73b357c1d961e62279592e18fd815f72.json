{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nvar _defineProperty2 = require(\"@babel/runtime/helpers/defineProperty\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, 'string');\n  return typeof key === 'symbol' ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== 'object' || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || 'default');\n    if (typeof res !== 'object') return res;\n    throw new TypeError('@@toPrimitive must return a primitive value.');\n  }\n  return (hint === 'string' ? String : Number)(input);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError('Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.');\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === 'string') return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === 'Object' && o.constructor) n = o.constructor.name;\n  if (n === 'Map' || n === 'Set') return Array.from(o);\n  if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : 'undefined' != typeof Symbol && arr[Symbol.iterator] || arr['@@iterator'];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nvar _require = require(\"./utils\"),\n  getConfigType = _require.getConfigType,\n  extractNativeModuleName = _require.extractNativeModuleName,\n  createParserErrorCapturer = _require.createParserErrorCapturer,\n  visit = _require.visit,\n  isModuleRegistryCall = _require.isModuleRegistryCall,\n  verifyPlatforms = _require.verifyPlatforms;\nvar _require2 = require(\"./error-utils\"),\n  throwIfPropertyValueTypeIsUnsupported = _require2.throwIfPropertyValueTypeIsUnsupported,\n  throwIfUnsupportedFunctionParamTypeAnnotationParserError = _require2.throwIfUnsupportedFunctionParamTypeAnnotationParserError,\n  throwIfUnsupportedFunctionReturnTypeAnnotationParserError = _require2.throwIfUnsupportedFunctionReturnTypeAnnotationParserError,\n  throwIfModuleTypeIsUnsupported = _require2.throwIfModuleTypeIsUnsupported,\n  throwIfUnusedModuleInterfaceParserError = _require2.throwIfUnusedModuleInterfaceParserError,\n  throwIfMoreThanOneModuleRegistryCalls = _require2.throwIfMoreThanOneModuleRegistryCalls,\n  throwIfWrongNumberOfCallExpressionArgs = _require2.throwIfWrongNumberOfCallExpressionArgs,\n  throwIfUntypedModule = _require2.throwIfUntypedModule,\n  throwIfIncorrectModuleRegistryCallTypeParameterParserError = _require2.throwIfIncorrectModuleRegistryCallTypeParameterParserError,\n  throwIfIncorrectModuleRegistryCallArgument = _require2.throwIfIncorrectModuleRegistryCallArgument,\n  throwIfModuleInterfaceNotFound = _require2.throwIfModuleInterfaceNotFound,\n  throwIfMoreThanOneModuleInterfaceParserError = _require2.throwIfMoreThanOneModuleInterfaceParserError,\n  throwIfModuleInterfaceIsMisnamed = _require2.throwIfModuleInterfaceIsMisnamed;\nvar _require3 = require(\"./errors\"),\n  MissingTypeParameterGenericParserError = _require3.MissingTypeParameterGenericParserError,\n  MoreThanOneTypeParameterGenericParserError = _require3.MoreThanOneTypeParameterGenericParserError,\n  UnnamedFunctionParamParserError = _require3.UnnamedFunctionParamParserError;\nvar invariant = require('invariant');\nfunction wrapModuleSchema(nativeModuleSchema, hasteModuleName) {\n  return {\n    modules: _defineProperty2({}, hasteModuleName, nativeModuleSchema)\n  };\n}\nfunction unwrapNullable(x) {\n  if (x.type === 'NullableTypeAnnotation') {\n    return [x.typeAnnotation, true];\n  }\n  return [x, false];\n}\nfunction wrapNullable(nullable, typeAnnotation) {\n  if (!nullable) {\n    return typeAnnotation;\n  }\n  return {\n    type: 'NullableTypeAnnotation',\n    typeAnnotation: typeAnnotation\n  };\n}\nfunction assertGenericTypeAnnotationHasExactlyOneTypeParameter(moduleName, typeAnnotation, parser) {\n  if (typeAnnotation.typeParameters == null) {\n    throw new MissingTypeParameterGenericParserError(moduleName, typeAnnotation, parser);\n  }\n  var typeAnnotationType = parser.typeParameterInstantiation;\n  invariant(typeAnnotation.typeParameters.type === typeAnnotationType, `assertGenericTypeAnnotationHasExactlyOneTypeParameter: Type parameters must be an AST node of type '${typeAnnotationType}'`);\n  if (typeAnnotation.typeParameters.params.length !== 1) {\n    throw new MoreThanOneTypeParameterGenericParserError(moduleName, typeAnnotation, parser);\n  }\n}\nfunction isObjectProperty(property, language) {\n  switch (language) {\n    case 'Flow':\n      return property.type === 'ObjectTypeProperty';\n    case 'TypeScript':\n      return property.type === 'TSPropertySignature';\n    default:\n      return false;\n  }\n}\nfunction parseObjectProperty(property, hasteModuleName, types, aliasMap, enumMap, tryParse, cxxOnly, nullable, translateTypeAnnotation, parser) {\n  var language = parser.language();\n  var name = parser.getKeyName(property, hasteModuleName);\n  var _property$optional = property.optional,\n    optional = _property$optional === void 0 ? false : _property$optional;\n  var languageTypeAnnotation = language === 'TypeScript' ? property.typeAnnotation.typeAnnotation : property.value;\n  var _unwrapNullable = unwrapNullable(translateTypeAnnotation(hasteModuleName, languageTypeAnnotation, types, aliasMap, enumMap, tryParse, cxxOnly, parser)),\n    _unwrapNullable2 = _slicedToArray(_unwrapNullable, 2),\n    propertyTypeAnnotation = _unwrapNullable2[0],\n    isPropertyNullable = _unwrapNullable2[1];\n  if (propertyTypeAnnotation.type === 'FunctionTypeAnnotation' || propertyTypeAnnotation.type === 'PromiseTypeAnnotation' || propertyTypeAnnotation.type === 'VoidTypeAnnotation') {\n    throwIfPropertyValueTypeIsUnsupported(hasteModuleName, languageTypeAnnotation, property.key, propertyTypeAnnotation.type);\n  }\n  return {\n    name: name,\n    optional: optional,\n    typeAnnotation: wrapNullable(isPropertyNullable, propertyTypeAnnotation)\n  };\n}\nfunction translateFunctionTypeAnnotation(hasteModuleName, functionTypeAnnotation, types, aliasMap, enumMap, tryParse, cxxOnly, translateTypeAnnotation, parser) {\n  var params = [];\n  var _loop = function _loop(param) {\n    var parsedParam = tryParse(function () {\n      if (parser.getFunctionNameFromParameter(param) == null) {\n        throw new UnnamedFunctionParamParserError(param, hasteModuleName);\n      }\n      var paramName = parser.getParameterName(param);\n      var _unwrapNullable3 = unwrapNullable(translateTypeAnnotation(hasteModuleName, parser.getParameterTypeAnnotation(param), types, aliasMap, enumMap, tryParse, cxxOnly, parser)),\n        _unwrapNullable4 = _slicedToArray(_unwrapNullable3, 2),\n        paramTypeAnnotation = _unwrapNullable4[0],\n        isParamTypeAnnotationNullable = _unwrapNullable4[1];\n      if (paramTypeAnnotation.type === 'VoidTypeAnnotation' || paramTypeAnnotation.type === 'PromiseTypeAnnotation') {\n        return throwIfUnsupportedFunctionParamTypeAnnotationParserError(hasteModuleName, param.typeAnnotation, paramName, paramTypeAnnotation.type);\n      }\n      return {\n        name: paramName,\n        optional: Boolean(param.optional),\n        typeAnnotation: wrapNullable(isParamTypeAnnotationNullable, paramTypeAnnotation)\n      };\n    });\n    if (parsedParam != null) {\n      params.push(parsedParam);\n    }\n  };\n  for (var param of parser.getFunctionTypeAnnotationParameters(functionTypeAnnotation)) {\n    _loop(param);\n  }\n  var _unwrapNullable5 = unwrapNullable(translateTypeAnnotation(hasteModuleName, parser.getFunctionTypeAnnotationReturnType(functionTypeAnnotation), types, aliasMap, enumMap, tryParse, cxxOnly, parser)),\n    _unwrapNullable6 = _slicedToArray(_unwrapNullable5, 2),\n    returnTypeAnnotation = _unwrapNullable6[0],\n    isReturnTypeAnnotationNullable = _unwrapNullable6[1];\n  throwIfUnsupportedFunctionReturnTypeAnnotationParserError(hasteModuleName, functionTypeAnnotation, 'FunctionTypeAnnotation', cxxOnly, returnTypeAnnotation.type);\n  return {\n    type: 'FunctionTypeAnnotation',\n    returnTypeAnnotation: wrapNullable(isReturnTypeAnnotationNullable, returnTypeAnnotation),\n    params: params\n  };\n}\nfunction buildPropertySchema(hasteModuleName, property, types, aliasMap, enumMap, tryParse, cxxOnly, resolveTypeAnnotation, translateTypeAnnotation, parser) {\n  var nullable = false;\n  var key = property.key,\n    value = property.value;\n  var methodName = key.name;\n  if (parser.language() === 'TypeScript') {\n    value = property.type === 'TSMethodSignature' ? property : property.typeAnnotation;\n  }\n  var _resolveTypeAnnotatio = resolveTypeAnnotation(value, types);\n  nullable = _resolveTypeAnnotatio.nullable;\n  value = _resolveTypeAnnotatio.typeAnnotation;\n  throwIfModuleTypeIsUnsupported(hasteModuleName, property.value, key.name, value.type, parser);\n  return {\n    name: methodName,\n    optional: Boolean(property.optional),\n    typeAnnotation: wrapNullable(nullable, translateFunctionTypeAnnotation(hasteModuleName, value, types, aliasMap, enumMap, tryParse, cxxOnly, translateTypeAnnotation, parser))\n  };\n}\nfunction buildSchemaFromConfigType(configType, filename, ast, wrapComponentSchema, buildComponentSchema, buildModuleSchema, parser, resolveTypeAnnotation, translateTypeAnnotation) {\n  switch (configType) {\n    case 'component':\n      {\n        return wrapComponentSchema(buildComponentSchema(ast, parser));\n      }\n    case 'module':\n      {\n        if (filename === undefined || filename === null) {\n          throw new Error('Filepath expected while parasing a module');\n        }\n        var nativeModuleName = extractNativeModuleName(filename);\n        var _createParserErrorCap = createParserErrorCapturer(),\n          _createParserErrorCap2 = _slicedToArray(_createParserErrorCap, 2),\n          parsingErrors = _createParserErrorCap2[0],\n          tryParse = _createParserErrorCap2[1];\n        var schema = tryParse(function () {\n          return buildModuleSchema(nativeModuleName, ast, tryParse, parser, resolveTypeAnnotation, translateTypeAnnotation);\n        });\n        if (parsingErrors.length > 0) {\n          throw parsingErrors[0];\n        }\n        invariant(schema != null, 'When there are no parsing errors, the schema should not be null');\n        return wrapModuleSchema(schema, nativeModuleName);\n      }\n    default:\n      return {\n        modules: {}\n      };\n  }\n}\nfunction buildSchema(contents, filename, wrapComponentSchema, buildComponentSchema, buildModuleSchema, Visitor, parser, resolveTypeAnnotation, translateTypeAnnotation) {\n  if (!contents.includes('codegenNativeComponent') && !contents.includes('TurboModule')) {\n    return {\n      modules: {}\n    };\n  }\n  var ast = parser.getAst(contents);\n  var configType = getConfigType(ast, Visitor);\n  return buildSchemaFromConfigType(configType, filename, ast, wrapComponentSchema, buildComponentSchema, buildModuleSchema, parser, resolveTypeAnnotation, translateTypeAnnotation);\n}\nfunction createComponentConfig(foundConfig, commandsTypeNames) {\n  return _objectSpread(_objectSpread({}, foundConfig), {}, {\n    commandTypeName: commandsTypeNames[0] == null ? null : commandsTypeNames[0].commandTypeName,\n    commandOptionsExpression: commandsTypeNames[0] == null ? null : commandsTypeNames[0].commandOptionsExpression\n  });\n}\nvar parseModuleName = function parseModuleName(hasteModuleName, moduleSpec, ast, parser) {\n  var callExpressions = [];\n  visit(ast, {\n    CallExpression: function CallExpression(node) {\n      if (isModuleRegistryCall(node)) {\n        callExpressions.push(node);\n      }\n    }\n  });\n  throwIfUnusedModuleInterfaceParserError(hasteModuleName, moduleSpec, callExpressions);\n  throwIfMoreThanOneModuleRegistryCalls(hasteModuleName, callExpressions, callExpressions.length);\n  var callExpression = callExpressions[0];\n  var typeParameters = parser.callExpressionTypeParameters(callExpression);\n  var methodName = callExpression.callee.property.name;\n  throwIfWrongNumberOfCallExpressionArgs(hasteModuleName, callExpression, methodName, callExpression.arguments.length);\n  throwIfIncorrectModuleRegistryCallArgument(hasteModuleName, callExpression.arguments[0], methodName);\n  var $moduleName = callExpression.arguments[0].value;\n  throwIfUntypedModule(typeParameters, hasteModuleName, callExpression, methodName, $moduleName);\n  throwIfIncorrectModuleRegistryCallTypeParameterParserError(hasteModuleName, typeParameters, methodName, $moduleName, parser);\n  return $moduleName;\n};\nvar buildModuleSchema = function buildModuleSchema(hasteModuleName, ast, tryParse, parser, resolveTypeAnnotation, translateTypeAnnotation) {\n  var language = parser.language();\n  var types = parser.getTypes(ast);\n  var moduleSpecs = Object.values(types).filter(function (t) {\n    return parser.isModuleInterface(t);\n  });\n  throwIfModuleInterfaceNotFound(moduleSpecs.length, hasteModuleName, ast, language);\n  throwIfMoreThanOneModuleInterfaceParserError(hasteModuleName, moduleSpecs, language);\n  var _moduleSpecs = _slicedToArray(moduleSpecs, 1),\n    moduleSpec = _moduleSpecs[0];\n  throwIfModuleInterfaceIsMisnamed(hasteModuleName, moduleSpec.id, language);\n  var moduleName = parseModuleName(hasteModuleName, moduleSpec, ast, parser);\n  var _verifyPlatforms = verifyPlatforms(hasteModuleName, moduleName),\n    cxxOnly = _verifyPlatforms.cxxOnly,\n    excludedPlatforms = _verifyPlatforms.excludedPlatforms;\n  var properties = language === 'Flow' ? moduleSpec.body.properties : moduleSpec.body.body;\n  return properties.filter(function (property) {\n    return property.type === 'ObjectTypeProperty' || property.type === 'TSPropertySignature' || property.type === 'TSMethodSignature';\n  }).map(function (property) {\n    var aliasMap = {};\n    var enumMap = {};\n    return tryParse(function () {\n      return {\n        aliasMap: aliasMap,\n        enumMap: enumMap,\n        propertyShape: buildPropertySchema(hasteModuleName, property, types, aliasMap, enumMap, tryParse, cxxOnly, resolveTypeAnnotation, translateTypeAnnotation, parser)\n      };\n    });\n  }).filter(Boolean).reduce(function (moduleSchema, _ref) {\n    var aliasMap = _ref.aliasMap,\n      enumMap = _ref.enumMap,\n      propertyShape = _ref.propertyShape;\n    return {\n      type: 'NativeModule',\n      aliasMap: _objectSpread(_objectSpread({}, moduleSchema.aliasMap), aliasMap),\n      enumMap: _objectSpread(_objectSpread({}, moduleSchema.enumMap), enumMap),\n      spec: {\n        properties: [].concat(_toConsumableArray(moduleSchema.spec.properties), [propertyShape])\n      },\n      moduleName: moduleSchema.moduleName,\n      excludedPlatforms: moduleSchema.excludedPlatforms\n    };\n  }, {\n    type: 'NativeModule',\n    aliasMap: {},\n    enumMap: {},\n    spec: {\n      properties: []\n    },\n    moduleName: moduleName,\n    excludedPlatforms: excludedPlatforms.length !== 0 ? _toConsumableArray(excludedPlatforms) : undefined\n  });\n};\nfunction findNativeComponentType(statement, foundConfigs, parser) {\n  var declaration = statement.declaration;\n  if (declaration.type === 'TSAsExpression' || declaration.type === 'TypeCastExpression') {\n    declaration = declaration.expression;\n  }\n  try {\n    if (declaration.callee.name === 'codegenNativeComponent') {\n      var typeArgumentParams = parser.getTypeArgumentParamsFromDeclaration(declaration);\n      var funcArgumentParams = declaration.arguments;\n      var nativeComponentType = parser.getNativeComponentType(typeArgumentParams, funcArgumentParams);\n      if (funcArgumentParams.length > 1) {\n        nativeComponentType.optionsExpression = funcArgumentParams[1];\n      }\n      foundConfigs.push(nativeComponentType);\n    }\n  } catch (e) {}\n}\nfunction getCommandOptions(commandOptionsExpression) {\n  if (commandOptionsExpression == null) {\n    return null;\n  }\n  var foundOptions;\n  try {\n    foundOptions = commandOptionsExpression.properties.reduce(function (options, prop) {\n      options[prop.key.name] = (prop && prop.value && prop.value.elements || []).map(function (element) {\n        return element && element.value;\n      });\n      return options;\n    }, {});\n  } catch (e) {\n    throw new Error('Failed to parse command options, please check that they are defined correctly');\n  }\n  return foundOptions;\n}\nfunction getOptions(optionsExpression) {\n  if (!optionsExpression) {\n    return null;\n  }\n  var foundOptions;\n  try {\n    foundOptions = optionsExpression.properties.reduce(function (options, prop) {\n      if (prop.value.type === 'ArrayExpression') {\n        options[prop.key.name] = prop.value.elements.map(function (element) {\n          return element.value;\n        });\n      } else {\n        options[prop.key.name] = prop.value.value;\n      }\n      return options;\n    }, {});\n  } catch (e) {\n    throw new Error('Failed to parse codegen options, please check that they are defined correctly');\n  }\n  if (foundOptions.paperComponentName && foundOptions.paperComponentNameDeprecated) {\n    throw new Error('Failed to parse codegen options, cannot use both paperComponentName and paperComponentNameDeprecated');\n  }\n  return foundOptions;\n}\nmodule.exports = {\n  wrapModuleSchema: wrapModuleSchema,\n  unwrapNullable: unwrapNullable,\n  wrapNullable: wrapNullable,\n  assertGenericTypeAnnotationHasExactlyOneTypeParameter: assertGenericTypeAnnotationHasExactlyOneTypeParameter,\n  isObjectProperty: isObjectProperty,\n  parseObjectProperty: parseObjectProperty,\n  translateFunctionTypeAnnotation: translateFunctionTypeAnnotation,\n  buildPropertySchema: buildPropertySchema,\n  buildSchemaFromConfigType: buildSchemaFromConfigType,\n  buildSchema: buildSchema,\n  createComponentConfig: createComponentConfig,\n  parseModuleName: parseModuleName,\n  buildModuleSchema: buildModuleSchema,\n  findNativeComponentType: findNativeComponentType,\n  getCommandOptions: getCommandOptions,\n  getOptions: getOptions\n};","map":{"version":3,"names":["_toConsumableArray","require","_defineProperty2","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","_toPropertyKey","configurable","writable","arg","_toPrimitive","String","input","hint","prim","Symbol","toPrimitive","undefined","res","call","TypeError","Number","_slicedToArray","arr","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","o","minLen","_arrayLikeToArray","n","prototype","toString","slice","constructor","name","Array","from","test","len","arr2","_i","iterator","_s","_e","_x","_r","_arr","_n","_d","next","done","err","return","isArray","_require","getConfigType","extractNativeModuleName","createParserErrorCapturer","visit","isModuleRegistryCall","verifyPlatforms","_require2","throwIfPropertyValueTypeIsUnsupported","throwIfUnsupportedFunctionParamTypeAnnotationParserError","throwIfUnsupportedFunctionReturnTypeAnnotationParserError","throwIfModuleTypeIsUnsupported","throwIfUnusedModuleInterfaceParserError","throwIfMoreThanOneModuleRegistryCalls","throwIfWrongNumberOfCallExpressionArgs","throwIfUntypedModule","throwIfIncorrectModuleRegistryCallTypeParameterParserError","throwIfIncorrectModuleRegistryCallArgument","throwIfModuleInterfaceNotFound","throwIfMoreThanOneModuleInterfaceParserError","throwIfModuleInterfaceIsMisnamed","_require3","MissingTypeParameterGenericParserError","MoreThanOneTypeParameterGenericParserError","UnnamedFunctionParamParserError","invariant","wrapModuleSchema","nativeModuleSchema","hasteModuleName","modules","unwrapNullable","x","type","typeAnnotation","wrapNullable","nullable","assertGenericTypeAnnotationHasExactlyOneTypeParameter","moduleName","parser","typeParameters","typeAnnotationType","typeParameterInstantiation","params","isObjectProperty","property","language","parseObjectProperty","types","aliasMap","enumMap","tryParse","cxxOnly","translateTypeAnnotation","getKeyName","_property$optional","optional","languageTypeAnnotation","_unwrapNullable","_unwrapNullable2","propertyTypeAnnotation","isPropertyNullable","translateFunctionTypeAnnotation","functionTypeAnnotation","_loop","param","parsedParam","getFunctionNameFromParameter","paramName","getParameterName","_unwrapNullable3","getParameterTypeAnnotation","_unwrapNullable4","paramTypeAnnotation","isParamTypeAnnotationNullable","Boolean","getFunctionTypeAnnotationParameters","_unwrapNullable5","getFunctionTypeAnnotationReturnType","_unwrapNullable6","returnTypeAnnotation","isReturnTypeAnnotationNullable","buildPropertySchema","resolveTypeAnnotation","methodName","_resolveTypeAnnotatio","buildSchemaFromConfigType","configType","filename","ast","wrapComponentSchema","buildComponentSchema","buildModuleSchema","Error","nativeModuleName","_createParserErrorCap","_createParserErrorCap2","parsingErrors","schema","buildSchema","contents","Visitor","includes","getAst","createComponentConfig","foundConfig","commandsTypeNames","commandTypeName","commandOptionsExpression","parseModuleName","moduleSpec","callExpressions","CallExpression","node","callExpression","callExpressionTypeParameters","callee","$moduleName","getTypes","moduleSpecs","values","t","isModuleInterface","_moduleSpecs","id","_verifyPlatforms","excludedPlatforms","properties","body","map","propertyShape","reduce","moduleSchema","_ref","spec","concat","findNativeComponentType","statement","foundConfigs","declaration","expression","typeArgumentParams","getTypeArgumentParamsFromDeclaration","funcArgumentParams","nativeComponentType","getNativeComponentType","optionsExpression","e","getCommandOptions","foundOptions","options","prop","elements","element","getOptions","paperComponentName","paperComponentNameDeprecated","module","exports"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native/codegen/lib/parsers/parsers-commons.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\n'use strict';\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly &&\n      (symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      })),\n      keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2\n      ? ownKeys(Object(source), !0).forEach(function (key) {\n          _defineProperty(target, key, source[key]);\n        })\n      : Object.getOwnPropertyDescriptors\n      ? Object.defineProperties(\n          target,\n          Object.getOwnPropertyDescriptors(source),\n        )\n      : ownKeys(Object(source)).forEach(function (key) {\n          Object.defineProperty(\n            target,\n            key,\n            Object.getOwnPropertyDescriptor(source, key),\n          );\n        });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true,\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, 'string');\n  return typeof key === 'symbol' ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== 'object' || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || 'default');\n    if (typeof res !== 'object') return res;\n    throw new TypeError('@@toPrimitive must return a primitive value.');\n  }\n  return (hint === 'string' ? String : Number)(input);\n}\nfunction _slicedToArray(arr, i) {\n  return (\n    _arrayWithHoles(arr) ||\n    _iterableToArrayLimit(arr, i) ||\n    _unsupportedIterableToArray(arr, i) ||\n    _nonIterableRest()\n  );\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\n    'Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',\n  );\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === 'string') return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === 'Object' && o.constructor) n = o.constructor.name;\n  if (n === 'Map' || n === 'Set') return Array.from(o);\n  if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n    return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i =\n    null == arr\n      ? null\n      : ('undefined' != typeof Symbol && arr[Symbol.iterator]) ||\n        arr['@@iterator'];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (((_x = (_i = _i.call(arr)).next), 0 === i)) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else\n        for (\n          ;\n          !(_n = (_s = _x.call(_i)).done) &&\n          (_arr.push(_s.value), _arr.length !== i);\n          _n = !0\n        );\n    } catch (err) {\n      (_d = !0), (_e = err);\n    } finally {\n      try {\n        if (!_n && null != _i.return && ((_r = _i.return()), Object(_r) !== _r))\n          return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nconst _require = require('./utils'),\n  getConfigType = _require.getConfigType,\n  extractNativeModuleName = _require.extractNativeModuleName,\n  createParserErrorCapturer = _require.createParserErrorCapturer,\n  visit = _require.visit,\n  isModuleRegistryCall = _require.isModuleRegistryCall,\n  verifyPlatforms = _require.verifyPlatforms;\nconst _require2 = require('./error-utils'),\n  throwIfPropertyValueTypeIsUnsupported =\n    _require2.throwIfPropertyValueTypeIsUnsupported,\n  throwIfUnsupportedFunctionParamTypeAnnotationParserError =\n    _require2.throwIfUnsupportedFunctionParamTypeAnnotationParserError,\n  throwIfUnsupportedFunctionReturnTypeAnnotationParserError =\n    _require2.throwIfUnsupportedFunctionReturnTypeAnnotationParserError,\n  throwIfModuleTypeIsUnsupported = _require2.throwIfModuleTypeIsUnsupported,\n  throwIfUnusedModuleInterfaceParserError =\n    _require2.throwIfUnusedModuleInterfaceParserError,\n  throwIfMoreThanOneModuleRegistryCalls =\n    _require2.throwIfMoreThanOneModuleRegistryCalls,\n  throwIfWrongNumberOfCallExpressionArgs =\n    _require2.throwIfWrongNumberOfCallExpressionArgs,\n  throwIfUntypedModule = _require2.throwIfUntypedModule,\n  throwIfIncorrectModuleRegistryCallTypeParameterParserError =\n    _require2.throwIfIncorrectModuleRegistryCallTypeParameterParserError,\n  throwIfIncorrectModuleRegistryCallArgument =\n    _require2.throwIfIncorrectModuleRegistryCallArgument,\n  throwIfModuleInterfaceNotFound = _require2.throwIfModuleInterfaceNotFound,\n  throwIfMoreThanOneModuleInterfaceParserError =\n    _require2.throwIfMoreThanOneModuleInterfaceParserError,\n  throwIfModuleInterfaceIsMisnamed = _require2.throwIfModuleInterfaceIsMisnamed;\nconst _require3 = require('./errors'),\n  MissingTypeParameterGenericParserError =\n    _require3.MissingTypeParameterGenericParserError,\n  MoreThanOneTypeParameterGenericParserError =\n    _require3.MoreThanOneTypeParameterGenericParserError,\n  UnnamedFunctionParamParserError = _require3.UnnamedFunctionParamParserError;\nconst invariant = require('invariant');\nfunction wrapModuleSchema(nativeModuleSchema, hasteModuleName) {\n  return {\n    modules: {\n      [hasteModuleName]: nativeModuleSchema,\n    },\n  };\n}\nfunction unwrapNullable(x) {\n  if (x.type === 'NullableTypeAnnotation') {\n    return [x.typeAnnotation, true];\n  }\n  return [x, false];\n}\nfunction wrapNullable(nullable, typeAnnotation) {\n  if (!nullable) {\n    return typeAnnotation;\n  }\n  return {\n    type: 'NullableTypeAnnotation',\n    typeAnnotation,\n  };\n}\nfunction assertGenericTypeAnnotationHasExactlyOneTypeParameter(\n  moduleName,\n  /**\n   * TODO(T108222691): Use flow-types for @babel/parser\n   */\n  typeAnnotation,\n  parser,\n) {\n  if (typeAnnotation.typeParameters == null) {\n    throw new MissingTypeParameterGenericParserError(\n      moduleName,\n      typeAnnotation,\n      parser,\n    );\n  }\n  const typeAnnotationType = parser.typeParameterInstantiation;\n  invariant(\n    typeAnnotation.typeParameters.type === typeAnnotationType,\n    `assertGenericTypeAnnotationHasExactlyOneTypeParameter: Type parameters must be an AST node of type '${typeAnnotationType}'`,\n  );\n  if (typeAnnotation.typeParameters.params.length !== 1) {\n    throw new MoreThanOneTypeParameterGenericParserError(\n      moduleName,\n      typeAnnotation,\n      parser,\n    );\n  }\n}\nfunction isObjectProperty(property, language) {\n  switch (language) {\n    case 'Flow':\n      return property.type === 'ObjectTypeProperty';\n    case 'TypeScript':\n      return property.type === 'TSPropertySignature';\n    default:\n      return false;\n  }\n}\nfunction parseObjectProperty(\n  property,\n  hasteModuleName,\n  types,\n  aliasMap,\n  enumMap,\n  tryParse,\n  cxxOnly,\n  nullable,\n  translateTypeAnnotation,\n  parser,\n) {\n  const language = parser.language();\n  const name = parser.getKeyName(property, hasteModuleName);\n  const _property$optional = property.optional,\n    optional = _property$optional === void 0 ? false : _property$optional;\n  const languageTypeAnnotation =\n    language === 'TypeScript'\n      ? property.typeAnnotation.typeAnnotation\n      : property.value;\n  const _unwrapNullable = unwrapNullable(\n      translateTypeAnnotation(\n        hasteModuleName,\n        languageTypeAnnotation,\n        types,\n        aliasMap,\n        enumMap,\n        tryParse,\n        cxxOnly,\n        parser,\n      ),\n    ),\n    _unwrapNullable2 = _slicedToArray(_unwrapNullable, 2),\n    propertyTypeAnnotation = _unwrapNullable2[0],\n    isPropertyNullable = _unwrapNullable2[1];\n  if (\n    propertyTypeAnnotation.type === 'FunctionTypeAnnotation' ||\n    propertyTypeAnnotation.type === 'PromiseTypeAnnotation' ||\n    propertyTypeAnnotation.type === 'VoidTypeAnnotation'\n  ) {\n    throwIfPropertyValueTypeIsUnsupported(\n      hasteModuleName,\n      languageTypeAnnotation,\n      property.key,\n      propertyTypeAnnotation.type,\n    );\n  }\n  return {\n    name,\n    optional,\n    typeAnnotation: wrapNullable(isPropertyNullable, propertyTypeAnnotation),\n  };\n}\nfunction translateFunctionTypeAnnotation(\n  hasteModuleName,\n  // TODO(T108222691): Use flow-types for @babel/parser\n  // TODO(T71778680): This is a FunctionTypeAnnotation. Type this.\n  functionTypeAnnotation,\n  types,\n  aliasMap,\n  enumMap,\n  tryParse,\n  cxxOnly,\n  translateTypeAnnotation,\n  parser,\n) {\n  const params = [];\n  for (const param of parser.getFunctionTypeAnnotationParameters(\n    functionTypeAnnotation,\n  )) {\n    const parsedParam = tryParse(() => {\n      if (parser.getFunctionNameFromParameter(param) == null) {\n        throw new UnnamedFunctionParamParserError(param, hasteModuleName);\n      }\n      const paramName = parser.getParameterName(param);\n      const _unwrapNullable3 = unwrapNullable(\n          translateTypeAnnotation(\n            hasteModuleName,\n            parser.getParameterTypeAnnotation(param),\n            types,\n            aliasMap,\n            enumMap,\n            tryParse,\n            cxxOnly,\n            parser,\n          ),\n        ),\n        _unwrapNullable4 = _slicedToArray(_unwrapNullable3, 2),\n        paramTypeAnnotation = _unwrapNullable4[0],\n        isParamTypeAnnotationNullable = _unwrapNullable4[1];\n      if (\n        paramTypeAnnotation.type === 'VoidTypeAnnotation' ||\n        paramTypeAnnotation.type === 'PromiseTypeAnnotation'\n      ) {\n        return throwIfUnsupportedFunctionParamTypeAnnotationParserError(\n          hasteModuleName,\n          param.typeAnnotation,\n          paramName,\n          paramTypeAnnotation.type,\n        );\n      }\n      return {\n        name: paramName,\n        optional: Boolean(param.optional),\n        typeAnnotation: wrapNullable(\n          isParamTypeAnnotationNullable,\n          paramTypeAnnotation,\n        ),\n      };\n    });\n    if (parsedParam != null) {\n      params.push(parsedParam);\n    }\n  }\n  const _unwrapNullable5 = unwrapNullable(\n      translateTypeAnnotation(\n        hasteModuleName,\n        parser.getFunctionTypeAnnotationReturnType(functionTypeAnnotation),\n        types,\n        aliasMap,\n        enumMap,\n        tryParse,\n        cxxOnly,\n        parser,\n      ),\n    ),\n    _unwrapNullable6 = _slicedToArray(_unwrapNullable5, 2),\n    returnTypeAnnotation = _unwrapNullable6[0],\n    isReturnTypeAnnotationNullable = _unwrapNullable6[1];\n  throwIfUnsupportedFunctionReturnTypeAnnotationParserError(\n    hasteModuleName,\n    functionTypeAnnotation,\n    'FunctionTypeAnnotation',\n    cxxOnly,\n    returnTypeAnnotation.type,\n  );\n  return {\n    type: 'FunctionTypeAnnotation',\n    returnTypeAnnotation: wrapNullable(\n      isReturnTypeAnnotationNullable,\n      returnTypeAnnotation,\n    ),\n    params,\n  };\n}\nfunction buildPropertySchema(\n  hasteModuleName,\n  // TODO(T108222691): [TS] Use flow-types for @babel/parser\n  // TODO(T71778680): [Flow] This is an ObjectTypeProperty containing either:\n  // - a FunctionTypeAnnotation or GenericTypeAnnotation\n  // - a NullableTypeAnnoation containing a FunctionTypeAnnotation or GenericTypeAnnotation\n  // Flow type this node\n  property,\n  types,\n  aliasMap,\n  enumMap,\n  tryParse,\n  cxxOnly,\n  resolveTypeAnnotation,\n  translateTypeAnnotation,\n  parser,\n) {\n  let nullable = false;\n  let key = property.key,\n    value = property.value;\n  const methodName = key.name;\n  if (parser.language() === 'TypeScript') {\n    value =\n      property.type === 'TSMethodSignature'\n        ? property\n        : property.typeAnnotation;\n  }\n  var _resolveTypeAnnotatio = resolveTypeAnnotation(value, types);\n  nullable = _resolveTypeAnnotatio.nullable;\n  value = _resolveTypeAnnotatio.typeAnnotation;\n  throwIfModuleTypeIsUnsupported(\n    hasteModuleName,\n    property.value,\n    key.name,\n    value.type,\n    parser,\n  );\n  return {\n    name: methodName,\n    optional: Boolean(property.optional),\n    typeAnnotation: wrapNullable(\n      nullable,\n      translateFunctionTypeAnnotation(\n        hasteModuleName,\n        value,\n        types,\n        aliasMap,\n        enumMap,\n        tryParse,\n        cxxOnly,\n        translateTypeAnnotation,\n        parser,\n      ),\n    ),\n  };\n}\nfunction buildSchemaFromConfigType(\n  configType,\n  filename,\n  ast,\n  wrapComponentSchema,\n  buildComponentSchema,\n  buildModuleSchema,\n  parser,\n  resolveTypeAnnotation,\n  translateTypeAnnotation,\n) {\n  switch (configType) {\n    case 'component': {\n      return wrapComponentSchema(buildComponentSchema(ast, parser));\n    }\n    case 'module': {\n      if (filename === undefined || filename === null) {\n        throw new Error('Filepath expected while parasing a module');\n      }\n      const nativeModuleName = extractNativeModuleName(filename);\n      const _createParserErrorCap = createParserErrorCapturer(),\n        _createParserErrorCap2 = _slicedToArray(_createParserErrorCap, 2),\n        parsingErrors = _createParserErrorCap2[0],\n        tryParse = _createParserErrorCap2[1];\n      const schema = tryParse(() =>\n        buildModuleSchema(\n          nativeModuleName,\n          ast,\n          tryParse,\n          parser,\n          resolveTypeAnnotation,\n          translateTypeAnnotation,\n        ),\n      );\n      if (parsingErrors.length > 0) {\n        /**\n         * TODO(T77968131): We have two options:\n         *  - Throw the first error, but indicate there are more then one errors.\n         *  - Display all errors, nicely formatted.\n         *\n         * For the time being, we're just throw the first error.\n         **/\n\n        throw parsingErrors[0];\n      }\n      invariant(\n        schema != null,\n        'When there are no parsing errors, the schema should not be null',\n      );\n      return wrapModuleSchema(schema, nativeModuleName);\n    }\n    default:\n      return {\n        modules: {},\n      };\n  }\n}\nfunction buildSchema(\n  contents,\n  filename,\n  wrapComponentSchema,\n  buildComponentSchema,\n  buildModuleSchema,\n  Visitor,\n  parser,\n  resolveTypeAnnotation,\n  translateTypeAnnotation,\n) {\n  // Early return for non-Spec JavaScript files\n  if (\n    !contents.includes('codegenNativeComponent') &&\n    !contents.includes('TurboModule')\n  ) {\n    return {\n      modules: {},\n    };\n  }\n  const ast = parser.getAst(contents);\n  const configType = getConfigType(ast, Visitor);\n  return buildSchemaFromConfigType(\n    configType,\n    filename,\n    ast,\n    wrapComponentSchema,\n    buildComponentSchema,\n    buildModuleSchema,\n    parser,\n    resolveTypeAnnotation,\n    translateTypeAnnotation,\n  );\n}\nfunction createComponentConfig(foundConfig, commandsTypeNames) {\n  return _objectSpread(\n    _objectSpread({}, foundConfig),\n    {},\n    {\n      commandTypeName:\n        commandsTypeNames[0] == null\n          ? null\n          : commandsTypeNames[0].commandTypeName,\n      commandOptionsExpression:\n        commandsTypeNames[0] == null\n          ? null\n          : commandsTypeNames[0].commandOptionsExpression,\n    },\n  );\n}\nconst parseModuleName = (hasteModuleName, moduleSpec, ast, parser) => {\n  const callExpressions = [];\n  visit(ast, {\n    CallExpression(node) {\n      if (isModuleRegistryCall(node)) {\n        callExpressions.push(node);\n      }\n    },\n  });\n  throwIfUnusedModuleInterfaceParserError(\n    hasteModuleName,\n    moduleSpec,\n    callExpressions,\n  );\n  throwIfMoreThanOneModuleRegistryCalls(\n    hasteModuleName,\n    callExpressions,\n    callExpressions.length,\n  );\n  const callExpression = callExpressions[0];\n  const typeParameters = parser.callExpressionTypeParameters(callExpression);\n  const methodName = callExpression.callee.property.name;\n  throwIfWrongNumberOfCallExpressionArgs(\n    hasteModuleName,\n    callExpression,\n    methodName,\n    callExpression.arguments.length,\n  );\n  throwIfIncorrectModuleRegistryCallArgument(\n    hasteModuleName,\n    callExpression.arguments[0],\n    methodName,\n  );\n  const $moduleName = callExpression.arguments[0].value;\n  throwIfUntypedModule(\n    typeParameters,\n    hasteModuleName,\n    callExpression,\n    methodName,\n    $moduleName,\n  );\n  throwIfIncorrectModuleRegistryCallTypeParameterParserError(\n    hasteModuleName,\n    typeParameters,\n    methodName,\n    $moduleName,\n    parser,\n  );\n  return $moduleName;\n};\nconst buildModuleSchema = (\n  hasteModuleName,\n  ast,\n  tryParse,\n  parser,\n  resolveTypeAnnotation,\n  translateTypeAnnotation,\n) => {\n  const language = parser.language();\n  const types = parser.getTypes(ast);\n  const moduleSpecs = Object.values(types).filter(t =>\n    parser.isModuleInterface(t),\n  );\n  throwIfModuleInterfaceNotFound(\n    moduleSpecs.length,\n    hasteModuleName,\n    ast,\n    language,\n  );\n  throwIfMoreThanOneModuleInterfaceParserError(\n    hasteModuleName,\n    moduleSpecs,\n    language,\n  );\n  const _moduleSpecs = _slicedToArray(moduleSpecs, 1),\n    moduleSpec = _moduleSpecs[0];\n  throwIfModuleInterfaceIsMisnamed(hasteModuleName, moduleSpec.id, language);\n\n  // Parse Module Name\n  const moduleName = parseModuleName(hasteModuleName, moduleSpec, ast, parser);\n\n  // Some module names use platform suffix to indicate platform-exclusive modules.\n  // Eventually this should be made explicit in the Flow type itself.\n  // Also check the hasteModuleName for platform suffix.\n  // Note: this shape is consistent with ComponentSchema.\n  const _verifyPlatforms = verifyPlatforms(hasteModuleName, moduleName),\n    cxxOnly = _verifyPlatforms.cxxOnly,\n    excludedPlatforms = _verifyPlatforms.excludedPlatforms;\n  const properties =\n    language === 'Flow' ? moduleSpec.body.properties : moduleSpec.body.body;\n\n  // $FlowFixMe[missing-type-arg]\n  return properties\n    .filter(\n      property =>\n        property.type === 'ObjectTypeProperty' ||\n        property.type === 'TSPropertySignature' ||\n        property.type === 'TSMethodSignature',\n    )\n    .map(property => {\n      const aliasMap = {};\n      const enumMap = {};\n      return tryParse(() => ({\n        aliasMap,\n        enumMap,\n        propertyShape: buildPropertySchema(\n          hasteModuleName,\n          property,\n          types,\n          aliasMap,\n          enumMap,\n          tryParse,\n          cxxOnly,\n          resolveTypeAnnotation,\n          translateTypeAnnotation,\n          parser,\n        ),\n      }));\n    })\n    .filter(Boolean)\n    .reduce(\n      (moduleSchema, {aliasMap, enumMap, propertyShape}) => ({\n        type: 'NativeModule',\n        aliasMap: _objectSpread(\n          _objectSpread({}, moduleSchema.aliasMap),\n          aliasMap,\n        ),\n        enumMap: _objectSpread(\n          _objectSpread({}, moduleSchema.enumMap),\n          enumMap,\n        ),\n        spec: {\n          properties: [...moduleSchema.spec.properties, propertyShape],\n        },\n        moduleName: moduleSchema.moduleName,\n        excludedPlatforms: moduleSchema.excludedPlatforms,\n      }),\n      {\n        type: 'NativeModule',\n        aliasMap: {},\n        enumMap: {},\n        spec: {\n          properties: [],\n        },\n        moduleName,\n        excludedPlatforms:\n          excludedPlatforms.length !== 0 ? [...excludedPlatforms] : undefined,\n      },\n    );\n};\n\n/**\n * This function is used to find the type of a native component\n * provided the default exports statement from generated AST.\n * @param statement The statement to be parsed.\n * @param foundConfigs The 'mutable' array of configs that have been found.\n * @param parser The language parser to be used.\n * @returns void\n */\nfunction findNativeComponentType(statement, foundConfigs, parser) {\n  let declaration = statement.declaration;\n\n  // codegenNativeComponent can be nested inside a cast\n  // expression so we need to go one level deeper\n  if (\n    declaration.type === 'TSAsExpression' ||\n    declaration.type === 'TypeCastExpression'\n  ) {\n    declaration = declaration.expression;\n  }\n  try {\n    if (declaration.callee.name === 'codegenNativeComponent') {\n      const typeArgumentParams =\n        parser.getTypeArgumentParamsFromDeclaration(declaration);\n      const funcArgumentParams = declaration.arguments;\n      const nativeComponentType = parser.getNativeComponentType(\n        typeArgumentParams,\n        funcArgumentParams,\n      );\n      if (funcArgumentParams.length > 1) {\n        nativeComponentType.optionsExpression = funcArgumentParams[1];\n      }\n      foundConfigs.push(nativeComponentType);\n    }\n  } catch (e) {\n    // ignore\n  }\n}\nfunction getCommandOptions(commandOptionsExpression) {\n  if (commandOptionsExpression == null) {\n    return null;\n  }\n  let foundOptions;\n  try {\n    foundOptions = commandOptionsExpression.properties.reduce(\n      (options, prop) => {\n        options[prop.key.name] = (\n          (prop && prop.value && prop.value.elements) ||\n          []\n        ).map(element => element && element.value);\n        return options;\n      },\n      {},\n    );\n  } catch (e) {\n    throw new Error(\n      'Failed to parse command options, please check that they are defined correctly',\n    );\n  }\n  return foundOptions;\n}\nfunction getOptions(optionsExpression) {\n  if (!optionsExpression) {\n    return null;\n  }\n  let foundOptions;\n  try {\n    foundOptions = optionsExpression.properties.reduce((options, prop) => {\n      if (prop.value.type === 'ArrayExpression') {\n        options[prop.key.name] = prop.value.elements.map(\n          element => element.value,\n        );\n      } else {\n        options[prop.key.name] = prop.value.value;\n      }\n      return options;\n    }, {});\n  } catch (e) {\n    throw new Error(\n      'Failed to parse codegen options, please check that they are defined correctly',\n    );\n  }\n  if (\n    foundOptions.paperComponentName &&\n    foundOptions.paperComponentNameDeprecated\n  ) {\n    throw new Error(\n      'Failed to parse codegen options, cannot use both paperComponentName and paperComponentNameDeprecated',\n    );\n  }\n  return foundOptions;\n}\nmodule.exports = {\n  wrapModuleSchema,\n  unwrapNullable,\n  wrapNullable,\n  assertGenericTypeAnnotationHasExactlyOneTypeParameter,\n  isObjectProperty,\n  parseObjectProperty,\n  translateFunctionTypeAnnotation,\n  buildPropertySchema,\n  buildSchemaFromConfigType,\n  buildSchema,\n  createComponentConfig,\n  parseModuleName,\n  buildModuleSchema,\n  findNativeComponentType,\n  getCommandOptions,\n  getOptions,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}