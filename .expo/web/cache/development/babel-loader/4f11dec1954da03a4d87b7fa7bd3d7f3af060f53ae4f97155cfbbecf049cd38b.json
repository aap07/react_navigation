{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = tslib_1.__importDefault(require(\"debug\"));\nvar crypto_1 = tslib_1.__importDefault(require(\"crypto\"));\nvar fs_1 = require(\"fs\");\nvar rimraf_1 = require(\"rimraf\");\nvar shared_1 = require(\"./shared\");\nvar utils_1 = require(\"../utils\");\nvar user_interface_1 = tslib_1.__importDefault(require(\"../user-interface\"));\nvar debug = debug_1.default('devcert:platforms:windows');\nvar encryptionKey;\nvar WindowsPlatform = function () {\n  function WindowsPlatform() {\n    _classCallCheck(this, WindowsPlatform);\n    this.HOST_FILE_PATH = 'C:\\\\Windows\\\\System32\\\\Drivers\\\\etc\\\\hosts';\n  }\n  _createClass(WindowsPlatform, [{\n    key: \"addToTrustStores\",\n    value: function addToTrustStores(certificatePath) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        debug('adding devcert root to Windows OS trust store');\n        try {\n          utils_1.run('certutil', ['-addstore', '-user', 'root', certificatePath]);\n        } catch (e) {\n          e.output.map(function (buffer) {\n            if (buffer) {\n              console.log(buffer.toString());\n            }\n          });\n        }\n        debug('adding devcert root to Firefox trust store');\n        try {\n          yield shared_1.openCertificateInFirefox('start firefox', certificatePath);\n        } catch (_a) {\n          debug('Error opening Firefox, most likely Firefox is not installed');\n        }\n      });\n    }\n  }, {\n    key: \"removeFromTrustStores\",\n    value: function removeFromTrustStores(certificatePath) {\n      debug('removing devcert root from Windows OS trust store');\n      try {\n        console.warn('Removing old certificates from trust stores. You may be prompted to grant permission for this. It\\'s safe to delete old devcert certificates.');\n        utils_1.run('certutil', ['-delstore', '-user', 'root', 'devcert']);\n      } catch (e) {\n        debug(`failed to remove ${certificatePath} from Windows OS trust store, continuing. ${e.toString()}`);\n      }\n    }\n  }, {\n    key: \"addDomainToHostFileIfMissing\",\n    value: function addDomainToHostFileIfMissing(domain) {\n      return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        var hostsFileContents = fs_1.readFileSync(this.HOST_FILE_PATH, 'utf8');\n        if (!hostsFileContents.includes(domain)) {\n          yield utils_1.sudo(`echo 127.0.0.1  ${domain} >> ${this.HOST_FILE_PATH}`);\n        }\n      });\n    }\n  }, {\n    key: \"deleteProtectedFiles\",\n    value: function deleteProtectedFiles(filepath) {\n      shared_1.assertNotTouchingFiles(filepath, 'delete');\n      rimraf_1.sync(filepath);\n    }\n  }, {\n    key: \"readProtectedFile\",\n    value: function readProtectedFile(filepath) {\n      return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        shared_1.assertNotTouchingFiles(filepath, 'read');\n        if (!encryptionKey) {\n          encryptionKey = yield user_interface_1.default.getWindowsEncryptionPassword();\n        }\n        try {\n          return this.decrypt(fs_1.readFileSync(filepath, 'utf8'), encryptionKey);\n        } catch (e) {\n          if (e.message.indexOf('bad decrypt') >= -1) {\n            encryptionKey = null;\n            return yield this.readProtectedFile(filepath);\n          }\n          throw e;\n        }\n      });\n    }\n  }, {\n    key: \"writeProtectedFile\",\n    value: function writeProtectedFile(filepath, contents) {\n      return tslib_1.__awaiter(this, void 0, void 0, function* () {\n        shared_1.assertNotTouchingFiles(filepath, 'write');\n        if (!encryptionKey) {\n          encryptionKey = yield user_interface_1.default.getWindowsEncryptionPassword();\n        }\n        var encryptedContents = this.encrypt(contents, encryptionKey);\n        fs_1.writeFileSync(filepath, encryptedContents);\n      });\n    }\n  }, {\n    key: \"encrypt\",\n    value: function encrypt(text, key) {\n      var cipher = crypto_1.default.createCipher('aes256', new Buffer(key));\n      return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\n    }\n  }, {\n    key: \"decrypt\",\n    value: function decrypt(encrypted, key) {\n      var decipher = crypto_1.default.createDecipher('aes256', new Buffer(key));\n      return decipher.update(encrypted, 'hex', 'utf8') + decipher.final('utf8');\n    }\n  }]);\n  return WindowsPlatform;\n}();\nexports.default = WindowsPlatform;","map":{"version":3,"names":["debug_1","tslib_1","__importDefault","require","crypto_1","fs_1","rimraf_1","shared_1","utils_1","user_interface_1","debug","default","encryptionKey","WindowsPlatform","_classCallCheck","HOST_FILE_PATH","_createClass","key","value","addToTrustStores","certificatePath","options","arguments","length","undefined","run","e","output","map","buffer","console","log","toString","openCertificateInFirefox","_a","removeFromTrustStores","warn","addDomainToHostFileIfMissing","domain","hostsFileContents","readFileSync","includes","sudo","deleteProtectedFiles","filepath","assertNotTouchingFiles","sync","readProtectedFile","getWindowsEncryptionPassword","decrypt","message","indexOf","writeProtectedFile","contents","encryptedContents","encrypt","writeFileSync","text","cipher","createCipher","Buffer","update","final","encrypted","decipher","createDecipher","exports"],"sources":["\\Users\\evanbacon\\Documents\\GitHub\\devcert\\platforms\\win32.ts"],"sourcesContent":["import createDebug from 'debug';\nimport crypto from 'crypto';\nimport { writeFileSync as write, readFileSync as read } from 'fs';\nimport { sync as rimraf } from 'rimraf';\nimport { Options } from '../index';\nimport { assertNotTouchingFiles, openCertificateInFirefox } from './shared';\nimport { Platform } from '.';\nimport { run, sudo } from '../utils';\nimport UI from '../user-interface';\n\nconst debug = createDebug('devcert:platforms:windows');\n\nlet encryptionKey: string;\n\nexport default class WindowsPlatform implements Platform {\n\n  private HOST_FILE_PATH = 'C:\\\\Windows\\\\System32\\\\Drivers\\\\etc\\\\hosts';\n\n  /**\n   * Windows is at least simple. Like macOS, most applications will delegate to\n   * the system trust store, which is updated with the confusingly named\n   * `certutil` exe (not the same as the NSS/Mozilla certutil). Firefox does it's\n   * own thing as usual, and getting a copy of NSS certutil onto the Windows\n   * machine to try updating the Firefox store is basically a nightmare, so we\n   * don't even try it - we just bail out to the GUI.\n   */\n  async addToTrustStores(certificatePath: string, options: Options = {}): Promise<void> {\n    // IE, Chrome, system utils\n    debug('adding devcert root to Windows OS trust store')\n    try {\n      run('certutil', ['-addstore', '-user', 'root', certificatePath]);\n    } catch (e) {\n      e.output.map((buffer: Buffer) => {\n        if (buffer) {\n          console.log(buffer.toString());\n        }\n      });\n    }\n    debug('adding devcert root to Firefox trust store')\n    // Firefox (don't even try NSS certutil, no easy install for Windows)\n    try {\n      await openCertificateInFirefox('start firefox', certificatePath);\n    } catch {\n      debug('Error opening Firefox, most likely Firefox is not installed');\n    }\n  }\n  \n  removeFromTrustStores(certificatePath: string) {\n    debug('removing devcert root from Windows OS trust store');\n    try {\n      console.warn('Removing old certificates from trust stores. You may be prompted to grant permission for this. It\\'s safe to delete old devcert certificates.');\n      run('certutil', ['-delstore', '-user', 'root', 'devcert']);\n    } catch (e) {\n      debug(`failed to remove ${ certificatePath } from Windows OS trust store, continuing. ${ e.toString() }`)\n    }\n  }\n\n  async addDomainToHostFileIfMissing(domain: string) {\n    let hostsFileContents = read(this.HOST_FILE_PATH, 'utf8');\n    if (!hostsFileContents.includes(domain)) {\n      await sudo(`echo 127.0.0.1  ${ domain } >> ${ this.HOST_FILE_PATH }`);\n    }\n  }\n  \n  deleteProtectedFiles(filepath: string) {\n    assertNotTouchingFiles(filepath, 'delete');\n    rimraf(filepath);\n  }\n\n  async readProtectedFile(filepath: string): Promise<string> {\n    assertNotTouchingFiles(filepath, 'read');\n    if (!encryptionKey) {\n      encryptionKey = await UI.getWindowsEncryptionPassword();\n    }\n    // Try to decrypt the file\n    try {\n      return this.decrypt(read(filepath, 'utf8'), encryptionKey);\n    } catch (e) {\n      // If it's a bad password, clear the cached copy and retry\n      if (e.message.indexOf('bad decrypt') >= -1) {\n        encryptionKey = null;\n        return await this.readProtectedFile(filepath);\n      }\n      throw e;\n    }\n  }\n\n  async writeProtectedFile(filepath: string, contents: string) {\n    assertNotTouchingFiles(filepath, 'write');\n    if (!encryptionKey) {\n      encryptionKey = await UI.getWindowsEncryptionPassword();\n    }\n    let encryptedContents = this.encrypt(contents, encryptionKey);\n    write(filepath, encryptedContents);\n  }\n\n  private encrypt(text: string, key: string) {\n    let cipher = crypto.createCipher('aes256', new Buffer(key));\n    return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\n  }\n\n  private decrypt(encrypted: string, key: string) {\n    let decipher = crypto.createDecipher('aes256', new Buffer(key));\n    return decipher.update(encrypted, 'hex', 'utf8') + decipher.final('utf8');\n  }\n\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}