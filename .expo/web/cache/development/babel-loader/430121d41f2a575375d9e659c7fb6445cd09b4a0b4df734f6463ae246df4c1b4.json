{"ast":null,"code":"'use strict';\n\nfunction getPropertyType(name, optional, typeAnnotation) {\n  var type = typeAnnotation.type === 'GenericTypeAnnotation' ? typeAnnotation.id.name : typeAnnotation.type;\n  switch (type) {\n    case 'BooleanTypeAnnotation':\n      return {\n        name: name,\n        optional: optional,\n        typeAnnotation: {\n          type: 'BooleanTypeAnnotation'\n        }\n      };\n    case 'StringTypeAnnotation':\n      return {\n        name: name,\n        optional: optional,\n        typeAnnotation: {\n          type: 'StringTypeAnnotation'\n        }\n      };\n    case 'Int32':\n      return {\n        name: name,\n        optional: optional,\n        typeAnnotation: {\n          type: 'Int32TypeAnnotation'\n        }\n      };\n    case 'Double':\n      return {\n        name: name,\n        optional: optional,\n        typeAnnotation: {\n          type: 'DoubleTypeAnnotation'\n        }\n      };\n    case 'Float':\n      return {\n        name: name,\n        optional: optional,\n        typeAnnotation: {\n          type: 'FloatTypeAnnotation'\n        }\n      };\n    case '$ReadOnly':\n      return getPropertyType(name, optional, typeAnnotation.typeParameters.params[0]);\n    case 'ObjectTypeAnnotation':\n      return {\n        name: name,\n        optional: optional,\n        typeAnnotation: {\n          type: 'ObjectTypeAnnotation',\n          properties: typeAnnotation.properties.map(buildPropertiesForEvent)\n        }\n      };\n    case 'UnionTypeAnnotation':\n      return {\n        name: name,\n        optional: optional,\n        typeAnnotation: {\n          type: 'StringEnumTypeAnnotation',\n          options: typeAnnotation.types.map(function (option) {\n            return option.value;\n          })\n        }\n      };\n    default:\n      type;\n      throw new Error(`Unable to determine event type for \"${name}\": ${type}`);\n  }\n}\nfunction findEventArgumentsAndType(typeAnnotation, types, bubblingType, paperName) {\n  if (!typeAnnotation.id) {\n    throw new Error(\"typeAnnotation of event doesn't have a name\");\n  }\n  var name = typeAnnotation.id.name;\n  if (name === '$ReadOnly') {\n    return {\n      argumentProps: typeAnnotation.typeParameters.params[0].properties,\n      paperTopLevelNameDeprecated: paperName,\n      bubblingType: bubblingType\n    };\n  } else if (name === 'BubblingEventHandler' || name === 'DirectEventHandler') {\n    var eventType = name === 'BubblingEventHandler' ? 'bubble' : 'direct';\n    var paperTopLevelNameDeprecated = typeAnnotation.typeParameters.params.length > 1 ? typeAnnotation.typeParameters.params[1].value : null;\n    if (typeAnnotation.typeParameters.params[0].type === 'NullLiteralTypeAnnotation') {\n      return {\n        argumentProps: [],\n        bubblingType: eventType,\n        paperTopLevelNameDeprecated: paperTopLevelNameDeprecated\n      };\n    }\n    return findEventArgumentsAndType(typeAnnotation.typeParameters.params[0], types, eventType, paperTopLevelNameDeprecated);\n  } else if (types[name]) {\n    return findEventArgumentsAndType(types[name].right, types, bubblingType, paperName);\n  } else {\n    return {\n      argumentProps: null,\n      bubblingType: null,\n      paperTopLevelNameDeprecated: null\n    };\n  }\n}\nfunction buildPropertiesForEvent(property) {\n  var name = property.key.name;\n  var optional = property.value.type === 'NullableTypeAnnotation' || property.optional;\n  var typeAnnotation = property.value.type === 'NullableTypeAnnotation' ? property.value.typeAnnotation : property.value;\n  return getPropertyType(name, optional, typeAnnotation);\n}\nfunction getEventArgument(argumentProps, name) {\n  return {\n    type: 'ObjectTypeAnnotation',\n    properties: argumentProps.map(buildPropertiesForEvent)\n  };\n}\nfunction buildEventSchema(types, property) {\n  var name = property.key.name;\n  var optional = property.optional || property.value.type === 'NullableTypeAnnotation';\n  var typeAnnotation = property.value.type === 'NullableTypeAnnotation' ? property.value.typeAnnotation : property.value;\n  if (typeAnnotation.type !== 'GenericTypeAnnotation' || typeAnnotation.id.name !== 'BubblingEventHandler' && typeAnnotation.id.name !== 'DirectEventHandler') {\n    return null;\n  }\n  var _findEventArgumentsAn = findEventArgumentsAndType(typeAnnotation, types),\n    argumentProps = _findEventArgumentsAn.argumentProps,\n    bubblingType = _findEventArgumentsAn.bubblingType,\n    paperTopLevelNameDeprecated = _findEventArgumentsAn.paperTopLevelNameDeprecated;\n  if (bubblingType && argumentProps) {\n    if (paperTopLevelNameDeprecated != null) {\n      return {\n        name: name,\n        optional: optional,\n        bubblingType: bubblingType,\n        paperTopLevelNameDeprecated: paperTopLevelNameDeprecated,\n        typeAnnotation: {\n          type: 'EventTypeAnnotation',\n          argument: getEventArgument(argumentProps, name)\n        }\n      };\n    }\n    return {\n      name: name,\n      optional: optional,\n      bubblingType: bubblingType,\n      typeAnnotation: {\n        type: 'EventTypeAnnotation',\n        argument: getEventArgument(argumentProps, name)\n      }\n    };\n  }\n  if (argumentProps === null) {\n    throw new Error(`Unable to determine event arguments for \"${name}\"`);\n  }\n  if (bubblingType === null) {\n    throw new Error(`Unable to determine event arguments for \"${name}\"`);\n  }\n}\nfunction getEvents(eventTypeAST, types) {\n  return eventTypeAST.filter(function (property) {\n    return property.type === 'ObjectTypeProperty';\n  }).map(function (property) {\n    return buildEventSchema(types, property);\n  }).filter(Boolean);\n}\nmodule.exports = {\n  getEvents: getEvents\n};","map":{"version":3,"names":["getPropertyType","name","optional","typeAnnotation","type","id","typeParameters","params","properties","map","buildPropertiesForEvent","options","types","option","value","Error","findEventArgumentsAndType","bubblingType","paperName","argumentProps","paperTopLevelNameDeprecated","eventType","length","right","property","key","getEventArgument","buildEventSchema","_findEventArgumentsAn","argument","getEvents","eventTypeAST","filter","Boolean","module","exports"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native/codegen/lib/parsers/flow/components/events.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\n'use strict';\n\nfunction getPropertyType(\n  /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n   * LTI update could not be added via codemod */\n  name,\n  optional,\n  typeAnnotation,\n) {\n  const type =\n    typeAnnotation.type === 'GenericTypeAnnotation'\n      ? typeAnnotation.id.name\n      : typeAnnotation.type;\n  switch (type) {\n    case 'BooleanTypeAnnotation':\n      return {\n        name,\n        optional,\n        typeAnnotation: {\n          type: 'BooleanTypeAnnotation',\n        },\n      };\n    case 'StringTypeAnnotation':\n      return {\n        name,\n        optional,\n        typeAnnotation: {\n          type: 'StringTypeAnnotation',\n        },\n      };\n    case 'Int32':\n      return {\n        name,\n        optional,\n        typeAnnotation: {\n          type: 'Int32TypeAnnotation',\n        },\n      };\n    case 'Double':\n      return {\n        name,\n        optional,\n        typeAnnotation: {\n          type: 'DoubleTypeAnnotation',\n        },\n      };\n    case 'Float':\n      return {\n        name,\n        optional,\n        typeAnnotation: {\n          type: 'FloatTypeAnnotation',\n        },\n      };\n    case '$ReadOnly':\n      return getPropertyType(\n        name,\n        optional,\n        typeAnnotation.typeParameters.params[0],\n      );\n    case 'ObjectTypeAnnotation':\n      return {\n        name,\n        optional,\n        typeAnnotation: {\n          type: 'ObjectTypeAnnotation',\n          properties: typeAnnotation.properties.map(buildPropertiesForEvent),\n        },\n      };\n    case 'UnionTypeAnnotation':\n      return {\n        name,\n        optional,\n        typeAnnotation: {\n          type: 'StringEnumTypeAnnotation',\n          options: typeAnnotation.types.map(option => option.value),\n        },\n      };\n    default:\n      type;\n      throw new Error(`Unable to determine event type for \"${name}\": ${type}`);\n  }\n}\nfunction findEventArgumentsAndType(\n  typeAnnotation,\n  types,\n  bubblingType,\n  paperName,\n) {\n  if (!typeAnnotation.id) {\n    throw new Error(\"typeAnnotation of event doesn't have a name\");\n  }\n  const name = typeAnnotation.id.name;\n  if (name === '$ReadOnly') {\n    return {\n      argumentProps: typeAnnotation.typeParameters.params[0].properties,\n      paperTopLevelNameDeprecated: paperName,\n      bubblingType,\n    };\n  } else if (name === 'BubblingEventHandler' || name === 'DirectEventHandler') {\n    const eventType = name === 'BubblingEventHandler' ? 'bubble' : 'direct';\n    const paperTopLevelNameDeprecated =\n      typeAnnotation.typeParameters.params.length > 1\n        ? typeAnnotation.typeParameters.params[1].value\n        : null;\n    if (\n      typeAnnotation.typeParameters.params[0].type ===\n      'NullLiteralTypeAnnotation'\n    ) {\n      return {\n        argumentProps: [],\n        bubblingType: eventType,\n        paperTopLevelNameDeprecated,\n      };\n    }\n    return findEventArgumentsAndType(\n      typeAnnotation.typeParameters.params[0],\n      types,\n      eventType,\n      paperTopLevelNameDeprecated,\n    );\n  } else if (types[name]) {\n    return findEventArgumentsAndType(\n      types[name].right,\n      types,\n      bubblingType,\n      paperName,\n    );\n  } else {\n    return {\n      argumentProps: null,\n      bubblingType: null,\n      paperTopLevelNameDeprecated: null,\n    };\n  }\n}\n\n/* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n * LTI update could not be added via codemod */\nfunction buildPropertiesForEvent(property) {\n  const name = property.key.name;\n  const optional =\n    property.value.type === 'NullableTypeAnnotation' || property.optional;\n  let typeAnnotation =\n    property.value.type === 'NullableTypeAnnotation'\n      ? property.value.typeAnnotation\n      : property.value;\n  return getPropertyType(name, optional, typeAnnotation);\n}\n\n/* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n * LTI update could not be added via codemod */\nfunction getEventArgument(argumentProps, name) {\n  return {\n    type: 'ObjectTypeAnnotation',\n    properties: argumentProps.map(buildPropertiesForEvent),\n  };\n}\nfunction buildEventSchema(types, property) {\n  const name = property.key.name;\n  const optional =\n    property.optional || property.value.type === 'NullableTypeAnnotation';\n  let typeAnnotation =\n    property.value.type === 'NullableTypeAnnotation'\n      ? property.value.typeAnnotation\n      : property.value;\n  if (\n    typeAnnotation.type !== 'GenericTypeAnnotation' ||\n    (typeAnnotation.id.name !== 'BubblingEventHandler' &&\n      typeAnnotation.id.name !== 'DirectEventHandler')\n  ) {\n    return null;\n  }\n  const _findEventArgumentsAn = findEventArgumentsAndType(\n      typeAnnotation,\n      types,\n    ),\n    argumentProps = _findEventArgumentsAn.argumentProps,\n    bubblingType = _findEventArgumentsAn.bubblingType,\n    paperTopLevelNameDeprecated =\n      _findEventArgumentsAn.paperTopLevelNameDeprecated;\n  if (bubblingType && argumentProps) {\n    if (paperTopLevelNameDeprecated != null) {\n      return {\n        name,\n        optional,\n        bubblingType,\n        paperTopLevelNameDeprecated,\n        typeAnnotation: {\n          type: 'EventTypeAnnotation',\n          argument: getEventArgument(argumentProps, name),\n        },\n      };\n    }\n    return {\n      name,\n      optional,\n      bubblingType,\n      typeAnnotation: {\n        type: 'EventTypeAnnotation',\n        argument: getEventArgument(argumentProps, name),\n      },\n    };\n  }\n  if (argumentProps === null) {\n    throw new Error(`Unable to determine event arguments for \"${name}\"`);\n  }\n  if (bubblingType === null) {\n    throw new Error(`Unable to determine event arguments for \"${name}\"`);\n  }\n}\n\n// $FlowFixMe[unclear-type] there's no flowtype for ASTs\n\nfunction getEvents(eventTypeAST, types) {\n  return eventTypeAST\n    .filter(property => property.type === 'ObjectTypeProperty')\n    .map(property => buildEventSchema(types, property))\n    .filter(Boolean);\n}\nmodule.exports = {\n  getEvents,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}