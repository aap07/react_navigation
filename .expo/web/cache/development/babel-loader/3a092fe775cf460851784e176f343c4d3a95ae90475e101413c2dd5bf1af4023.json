{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nvar directives = require(\"../doc/directives.js\");\nvar Document = require(\"../doc/Document.js\");\nvar errors = require(\"../errors.js\");\nvar identity = require(\"../nodes/identity.js\");\nvar composeDoc = require(\"./compose-doc.js\");\nvar resolveEnd = require(\"./resolve-end.js\");\nfunction getErrorPos(src) {\n  if (typeof src === 'number') return [src, src + 1];\n  if (Array.isArray(src)) return src.length === 2 ? src : [src[0], src[1]];\n  var offset = src.offset,\n    source = src.source;\n  return [offset, offset + (typeof source === 'string' ? source.length : 1)];\n}\nfunction parsePrelude(prelude) {\n  var _prelude;\n  var comment = '';\n  var atComment = false;\n  var afterEmptyLine = false;\n  for (var i = 0; i < prelude.length; ++i) {\n    var source = prelude[i];\n    switch (source[0]) {\n      case '#':\n        comment += (comment === '' ? '' : afterEmptyLine ? '\\n\\n' : '\\n') + (source.substring(1) || ' ');\n        atComment = true;\n        afterEmptyLine = false;\n        break;\n      case '%':\n        if (((_prelude = prelude[i + 1]) == null ? void 0 : _prelude[0]) !== '#') i += 1;\n        atComment = false;\n        break;\n      default:\n        if (!atComment) afterEmptyLine = true;\n        atComment = false;\n    }\n  }\n  return {\n    comment: comment,\n    afterEmptyLine: afterEmptyLine\n  };\n}\nvar Composer = function () {\n  function Composer() {\n    var _this = this;\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, Composer);\n    this.doc = null;\n    this.atDirectives = false;\n    this.prelude = [];\n    this.errors = [];\n    this.warnings = [];\n    this.onError = function (source, code, message, warning) {\n      var pos = getErrorPos(source);\n      if (warning) _this.warnings.push(new errors.YAMLWarning(pos, code, message));else _this.errors.push(new errors.YAMLParseError(pos, code, message));\n    };\n    this.directives = new directives.Directives({\n      version: options.version || '1.2'\n    });\n    this.options = options;\n  }\n  _createClass(Composer, [{\n    key: \"decorate\",\n    value: function decorate(doc, afterDoc) {\n      var _parsePrelude = parsePrelude(this.prelude),\n        comment = _parsePrelude.comment,\n        afterEmptyLine = _parsePrelude.afterEmptyLine;\n      if (comment) {\n        var dc = doc.contents;\n        if (afterDoc) {\n          doc.comment = doc.comment ? `${doc.comment}\\n${comment}` : comment;\n        } else if (afterEmptyLine || doc.directives.docStart || !dc) {\n          doc.commentBefore = comment;\n        } else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {\n          var it = dc.items[0];\n          if (identity.isPair(it)) it = it.key;\n          var cb = it.commentBefore;\n          it.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n        } else {\n          var _cb = dc.commentBefore;\n          dc.commentBefore = _cb ? `${comment}\\n${_cb}` : comment;\n        }\n      }\n      if (afterDoc) {\n        Array.prototype.push.apply(doc.errors, this.errors);\n        Array.prototype.push.apply(doc.warnings, this.warnings);\n      } else {\n        doc.errors = this.errors;\n        doc.warnings = this.warnings;\n      }\n      this.prelude = [];\n      this.errors = [];\n      this.warnings = [];\n    }\n  }, {\n    key: \"streamInfo\",\n    value: function streamInfo() {\n      return {\n        comment: parsePrelude(this.prelude).comment,\n        directives: this.directives,\n        errors: this.errors,\n        warnings: this.warnings\n      };\n    }\n  }, {\n    key: \"compose\",\n    value: function compose(tokens) {\n      var _this2 = this;\n      var forceDoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var endOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      return function* () {\n        for (var token of tokens) yield* _this2.next(token);\n        yield* _this2.end(forceDoc, endOffset);\n      }();\n    }\n  }, {\n    key: \"next\",\n    value: function* next(token) {\n      var _this3 = this;\n      if (process.env.LOG_STREAM) console.dir(token, {\n        depth: null\n      });\n      switch (token.type) {\n        case 'directive':\n          this.directives.add(token.source, function (offset, message, warning) {\n            var pos = getErrorPos(token);\n            pos[0] += offset;\n            _this3.onError(pos, 'BAD_DIRECTIVE', message, warning);\n          });\n          this.prelude.push(token.source);\n          this.atDirectives = true;\n          break;\n        case 'document':\n          {\n            var doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);\n            if (this.atDirectives && !doc.directives.docStart) this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');\n            this.decorate(doc, false);\n            if (this.doc) yield this.doc;\n            this.doc = doc;\n            this.atDirectives = false;\n            break;\n          }\n        case 'byte-order-mark':\n        case 'space':\n          break;\n        case 'comment':\n        case 'newline':\n          this.prelude.push(token.source);\n          break;\n        case 'error':\n          {\n            var msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;\n            var error = new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);\n            if (this.atDirectives || !this.doc) this.errors.push(error);else this.doc.errors.push(error);\n            break;\n          }\n        case 'doc-end':\n          {\n            if (!this.doc) {\n              var _msg = 'Unexpected doc-end without preceding document';\n              this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', _msg));\n              break;\n            }\n            this.doc.directives.docEnd = true;\n            var end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);\n            this.decorate(this.doc, true);\n            if (end.comment) {\n              var dc = this.doc.comment;\n              this.doc.comment = dc ? `${dc}\\n${end.comment}` : end.comment;\n            }\n            this.doc.range[2] = end.offset;\n            break;\n          }\n        default:\n          this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));\n      }\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      var _this4 = this;\n      var forceDoc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var endOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n      return function* () {\n        if (_this4.doc) {\n          _this4.decorate(_this4.doc, true);\n          yield _this4.doc;\n          _this4.doc = null;\n        } else if (forceDoc) {\n          var opts = Object.assign({\n            _directives: _this4.directives\n          }, _this4.options);\n          var doc = new Document.Document(undefined, opts);\n          if (_this4.atDirectives) _this4.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');\n          doc.range = [0, endOffset, endOffset];\n          _this4.decorate(doc, false);\n          yield doc;\n        }\n      }();\n    }\n  }]);\n  return Composer;\n}();\nexports.Composer = Composer;","map":{"version":3,"names":["_classCallCheck","require","_createClass","directives","Document","errors","identity","composeDoc","resolveEnd","getErrorPos","src","Array","isArray","length","offset","source","parsePrelude","prelude","_prelude","comment","atComment","afterEmptyLine","i","substring","Composer","_this","options","arguments","undefined","doc","atDirectives","warnings","onError","code","message","warning","pos","push","YAMLWarning","YAMLParseError","Directives","version","key","value","decorate","afterDoc","_parsePrelude","dc","contents","docStart","commentBefore","isCollection","flow","items","it","isPair","cb","prototype","apply","streamInfo","compose","tokens","_this2","forceDoc","endOffset","token","next","end","_this3","process","env","LOG_STREAM","console","dir","depth","type","add","msg","JSON","stringify","error","docEnd","strict","range","_this4","opts","Object","assign","_directives","exports"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native-community/cli-doctor/node_modules/yaml/dist/compose/composer.js"],"sourcesContent":["'use strict';\n\nvar directives = require('../doc/directives.js');\nvar Document = require('../doc/Document.js');\nvar errors = require('../errors.js');\nvar identity = require('../nodes/identity.js');\nvar composeDoc = require('./compose-doc.js');\nvar resolveEnd = require('./resolve-end.js');\n\nfunction getErrorPos(src) {\n    if (typeof src === 'number')\n        return [src, src + 1];\n    if (Array.isArray(src))\n        return src.length === 2 ? src : [src[0], src[1]];\n    const { offset, source } = src;\n    return [offset, offset + (typeof source === 'string' ? source.length : 1)];\n}\nfunction parsePrelude(prelude) {\n    let comment = '';\n    let atComment = false;\n    let afterEmptyLine = false;\n    for (let i = 0; i < prelude.length; ++i) {\n        const source = prelude[i];\n        switch (source[0]) {\n            case '#':\n                comment +=\n                    (comment === '' ? '' : afterEmptyLine ? '\\n\\n' : '\\n') +\n                        (source.substring(1) || ' ');\n                atComment = true;\n                afterEmptyLine = false;\n                break;\n            case '%':\n                if (prelude[i + 1]?.[0] !== '#')\n                    i += 1;\n                atComment = false;\n                break;\n            default:\n                // This may be wrong after doc-end, but in that case it doesn't matter\n                if (!atComment)\n                    afterEmptyLine = true;\n                atComment = false;\n        }\n    }\n    return { comment, afterEmptyLine };\n}\n/**\n * Compose a stream of CST nodes into a stream of YAML Documents.\n *\n * ```ts\n * import { Composer, Parser } from 'yaml'\n *\n * const src: string = ...\n * const tokens = new Parser().parse(src)\n * const docs = new Composer().compose(tokens)\n * ```\n */\nclass Composer {\n    constructor(options = {}) {\n        this.doc = null;\n        this.atDirectives = false;\n        this.prelude = [];\n        this.errors = [];\n        this.warnings = [];\n        this.onError = (source, code, message, warning) => {\n            const pos = getErrorPos(source);\n            if (warning)\n                this.warnings.push(new errors.YAMLWarning(pos, code, message));\n            else\n                this.errors.push(new errors.YAMLParseError(pos, code, message));\n        };\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        this.directives = new directives.Directives({ version: options.version || '1.2' });\n        this.options = options;\n    }\n    decorate(doc, afterDoc) {\n        const { comment, afterEmptyLine } = parsePrelude(this.prelude);\n        //console.log({ dc: doc.comment, prelude, comment })\n        if (comment) {\n            const dc = doc.contents;\n            if (afterDoc) {\n                doc.comment = doc.comment ? `${doc.comment}\\n${comment}` : comment;\n            }\n            else if (afterEmptyLine || doc.directives.docStart || !dc) {\n                doc.commentBefore = comment;\n            }\n            else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {\n                let it = dc.items[0];\n                if (identity.isPair(it))\n                    it = it.key;\n                const cb = it.commentBefore;\n                it.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n            }\n            else {\n                const cb = dc.commentBefore;\n                dc.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n            }\n        }\n        if (afterDoc) {\n            Array.prototype.push.apply(doc.errors, this.errors);\n            Array.prototype.push.apply(doc.warnings, this.warnings);\n        }\n        else {\n            doc.errors = this.errors;\n            doc.warnings = this.warnings;\n        }\n        this.prelude = [];\n        this.errors = [];\n        this.warnings = [];\n    }\n    /**\n     * Current stream status information.\n     *\n     * Mostly useful at the end of input for an empty stream.\n     */\n    streamInfo() {\n        return {\n            comment: parsePrelude(this.prelude).comment,\n            directives: this.directives,\n            errors: this.errors,\n            warnings: this.warnings\n        };\n    }\n    /**\n     * Compose tokens into documents.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    *compose(tokens, forceDoc = false, endOffset = -1) {\n        for (const token of tokens)\n            yield* this.next(token);\n        yield* this.end(forceDoc, endOffset);\n    }\n    /** Advance the composer by one CST token. */\n    *next(token) {\n        if (process.env.LOG_STREAM)\n            console.dir(token, { depth: null });\n        switch (token.type) {\n            case 'directive':\n                this.directives.add(token.source, (offset, message, warning) => {\n                    const pos = getErrorPos(token);\n                    pos[0] += offset;\n                    this.onError(pos, 'BAD_DIRECTIVE', message, warning);\n                });\n                this.prelude.push(token.source);\n                this.atDirectives = true;\n                break;\n            case 'document': {\n                const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);\n                if (this.atDirectives && !doc.directives.docStart)\n                    this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');\n                this.decorate(doc, false);\n                if (this.doc)\n                    yield this.doc;\n                this.doc = doc;\n                this.atDirectives = false;\n                break;\n            }\n            case 'byte-order-mark':\n            case 'space':\n                break;\n            case 'comment':\n            case 'newline':\n                this.prelude.push(token.source);\n                break;\n            case 'error': {\n                const msg = token.source\n                    ? `${token.message}: ${JSON.stringify(token.source)}`\n                    : token.message;\n                const error = new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);\n                if (this.atDirectives || !this.doc)\n                    this.errors.push(error);\n                else\n                    this.doc.errors.push(error);\n                break;\n            }\n            case 'doc-end': {\n                if (!this.doc) {\n                    const msg = 'Unexpected doc-end without preceding document';\n                    this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));\n                    break;\n                }\n                this.doc.directives.docEnd = true;\n                const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);\n                this.decorate(this.doc, true);\n                if (end.comment) {\n                    const dc = this.doc.comment;\n                    this.doc.comment = dc ? `${dc}\\n${end.comment}` : end.comment;\n                }\n                this.doc.range[2] = end.offset;\n                break;\n            }\n            default:\n                this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));\n        }\n    }\n    /**\n     * Call at end of input to yield any remaining document.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    *end(forceDoc = false, endOffset = -1) {\n        if (this.doc) {\n            this.decorate(this.doc, true);\n            yield this.doc;\n            this.doc = null;\n        }\n        else if (forceDoc) {\n            const opts = Object.assign({ _directives: this.directives }, this.options);\n            const doc = new Document.Document(undefined, opts);\n            if (this.atDirectives)\n                this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');\n            doc.range = [0, endOffset, endOffset];\n            this.decorate(doc, false);\n            yield doc;\n        }\n    }\n}\n\nexports.Composer = Composer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}