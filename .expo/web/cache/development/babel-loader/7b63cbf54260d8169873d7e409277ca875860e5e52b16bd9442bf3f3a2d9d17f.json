{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nvar EventManager = function () {\n  function EventManager(view) {\n    _classCallCheck(this, EventManager);\n    this.pointersInBounds = [];\n    this.view = view;\n    this.activePointersCounter = 0;\n  }\n  _createClass(EventManager, [{\n    key: \"onPointerDown\",\n    value: function onPointerDown(_event) {}\n  }, {\n    key: \"onPointerAdd\",\n    value: function onPointerAdd(_event) {}\n  }, {\n    key: \"onPointerUp\",\n    value: function onPointerUp(_event) {}\n  }, {\n    key: \"onPointerRemove\",\n    value: function onPointerRemove(_event) {}\n  }, {\n    key: \"onPointerMove\",\n    value: function onPointerMove(_event) {}\n  }, {\n    key: \"onPointerOut\",\n    value: function onPointerOut(_event) {}\n  }, {\n    key: \"onPointerEnter\",\n    value: function onPointerEnter(_event) {}\n  }, {\n    key: \"onPointerCancel\",\n    value: function onPointerCancel(_event) {}\n  }, {\n    key: \"onPointerOutOfBounds\",\n    value: function onPointerOutOfBounds(_event) {}\n  }, {\n    key: \"setOnPointerDown\",\n    value: function setOnPointerDown(callback) {\n      this.onPointerDown = callback;\n    }\n  }, {\n    key: \"setOnPointerAdd\",\n    value: function setOnPointerAdd(callback) {\n      this.onPointerAdd = callback;\n    }\n  }, {\n    key: \"setOnPointerUp\",\n    value: function setOnPointerUp(callback) {\n      this.onPointerUp = callback;\n    }\n  }, {\n    key: \"setOnPointerRemove\",\n    value: function setOnPointerRemove(callback) {\n      this.onPointerRemove = callback;\n    }\n  }, {\n    key: \"setOnPointerMove\",\n    value: function setOnPointerMove(callback) {\n      this.onPointerMove = callback;\n    }\n  }, {\n    key: \"setOnPointerOut\",\n    value: function setOnPointerOut(callback) {\n      this.onPointerOut = callback;\n    }\n  }, {\n    key: \"setOnPointerEnter\",\n    value: function setOnPointerEnter(callback) {\n      this.onPointerEnter = callback;\n    }\n  }, {\n    key: \"setOnPointerCancel\",\n    value: function setOnPointerCancel(callback) {\n      this.onPointerCancel = callback;\n    }\n  }, {\n    key: \"setOnPointerOutOfBounds\",\n    value: function setOnPointerOutOfBounds(callback) {\n      this.onPointerOutOfBounds = callback;\n    }\n  }, {\n    key: \"markAsInBounds\",\n    value: function markAsInBounds(pointerId) {\n      if (this.pointersInBounds.indexOf(pointerId) >= 0) {\n        return;\n      }\n      this.pointersInBounds.push(pointerId);\n    }\n  }, {\n    key: \"markAsOutOfBounds\",\n    value: function markAsOutOfBounds(pointerId) {\n      var index = this.pointersInBounds.indexOf(pointerId);\n      if (index < 0) {\n        return;\n      }\n      this.pointersInBounds.splice(index, 1);\n    }\n  }, {\n    key: \"resetManager\",\n    value: function resetManager() {\n      this.activePointersCounter = 0;\n      this.pointersInBounds = [];\n    }\n  }]);\n  return EventManager;\n}();\nexport { EventManager as default };","map":{"version":3,"names":["EventManager","view","_classCallCheck","pointersInBounds","activePointersCounter","_createClass","key","value","onPointerDown","_event","onPointerAdd","onPointerUp","onPointerRemove","onPointerMove","onPointerOut","onPointerEnter","onPointerCancel","onPointerOutOfBounds","setOnPointerDown","callback","setOnPointerAdd","setOnPointerUp","setOnPointerRemove","setOnPointerMove","setOnPointerOut","setOnPointerEnter","setOnPointerCancel","setOnPointerOutOfBounds","markAsInBounds","pointerId","indexOf","push","markAsOutOfBounds","index","splice","resetManager","default"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/react-native-gesture-handler/src/web/tools/EventManager.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-empty-function */\nimport { AdaptedEvent, EventTypes, TouchEventType } from '../interfaces';\n\nexport default abstract class EventManager {\n  protected readonly view: HTMLElement;\n  protected pointersInBounds: number[] = [];\n  protected activePointersCounter: number;\n\n  constructor(view: HTMLElement) {\n    this.view = view;\n    this.activePointersCounter = 0;\n  }\n\n  public abstract setListeners(): void;\n  protected abstract mapEvent(\n    event: Event,\n    eventType: EventTypes,\n    index?: number,\n    touchEventType?: TouchEventType\n  ): AdaptedEvent;\n\n  protected onPointerDown(_event: AdaptedEvent): void {}\n  protected onPointerAdd(_event: AdaptedEvent): void {}\n  protected onPointerUp(_event: AdaptedEvent): void {}\n  protected onPointerRemove(_event: AdaptedEvent): void {}\n  protected onPointerMove(_event: AdaptedEvent): void {}\n  protected onPointerOut(_event: AdaptedEvent): void {}\n  protected onPointerEnter(_event: AdaptedEvent): void {}\n  protected onPointerCancel(_event: AdaptedEvent): void {\n    // When pointer cancel is triggered and there are more pointers on the view, only one pointer is cancelled\n    // Because we want all pointers to be cancelled by that event, we are doing it manually by reseting handler and changing activePointersCounter to 0\n    // Events that correspond to removing the pointer (pointerup, touchend) have condition, that they don't perform any action when activePointersCounter\n    // is equal to 0. This prevents counter from going to negative values, when pointers are removed from view after one of them has been cancelled\n  }\n  protected onPointerOutOfBounds(_event: AdaptedEvent): void {}\n\n  public setOnPointerDown(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerDown = callback;\n  }\n  public setOnPointerAdd(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerAdd = callback;\n  }\n  public setOnPointerUp(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerUp = callback;\n  }\n  public setOnPointerRemove(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerRemove = callback;\n  }\n  public setOnPointerMove(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerMove = callback;\n  }\n  public setOnPointerOut(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerOut = callback;\n  }\n  public setOnPointerEnter(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerEnter = callback;\n  }\n  public setOnPointerCancel(callback: (event: AdaptedEvent) => void): void {\n    this.onPointerCancel = callback;\n  }\n  public setOnPointerOutOfBounds(\n    callback: (event: AdaptedEvent) => void\n  ): void {\n    this.onPointerOutOfBounds = callback;\n  }\n\n  protected markAsInBounds(pointerId: number): void {\n    if (this.pointersInBounds.indexOf(pointerId) >= 0) {\n      return;\n    }\n\n    this.pointersInBounds.push(pointerId);\n  }\n\n  protected markAsOutOfBounds(pointerId: number): void {\n    const index: number = this.pointersInBounds.indexOf(pointerId);\n\n    if (index < 0) {\n      return;\n    }\n\n    this.pointersInBounds.splice(index, 1);\n  }\n\n  public resetManager(): void {\n    // Reseting activePointersCounter is necessary to make gestures such as pinch work properly\n    // There are gestures that end when there is still one active pointer (like pinch/rotation)\n    // When these gestures end, they are reset, but they still receive events from pointer that is active\n    // This causes trouble, since only onPointerDown registers gesture in orchestrator, and while gestures receive\n    // Events from active pointer after they finished, next pointerdown event will be registered as additional pointer, not the first one\n    // This casues trouble like gestures getting stuck in END state, even though they should have gone to UNDETERMINED\n\n    this.activePointersCounter = 0;\n    this.pointersInBounds = [];\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}