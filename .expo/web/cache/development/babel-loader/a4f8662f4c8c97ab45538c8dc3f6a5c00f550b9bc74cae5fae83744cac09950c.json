{"ast":null,"code":"export {};","map":{"version":3,"names":[],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native-community/cli-doctor/node_modules/yaml/dist/schema/types.d.ts"],"sourcesContent":["import type { CreateNodeContext } from '../doc/createNode.js';\nimport type { Node } from '../nodes/Node.js';\nimport type { Scalar } from '../nodes/Scalar.js';\nimport type { YAMLMap } from '../nodes/YAMLMap.js';\nimport type { YAMLSeq } from '../nodes/YAMLSeq.js';\nimport type { ParseOptions } from '../options.js';\nimport type { StringifyContext } from '../stringify/stringify.js';\nimport type { Schema } from './Schema.js';\ninterface TagBase {\n    /**\n     * An optional factory function, used e.g. by collections when wrapping JS objects as AST nodes.\n     */\n    createNode?: (schema: Schema, value: unknown, ctx: CreateNodeContext) => Node;\n    /**\n     * If `true`, together with `test` allows for values to be stringified without\n     * an explicit tag. For most cases, it's unlikely that you'll actually want to\n     * use this, even if you first think you do.\n     */\n    default?: boolean;\n    /**\n     * If a tag has multiple forms that should be parsed and/or stringified\n     * differently, use `format` to identify them.\n     */\n    format?: string;\n    /**\n     * Used by `YAML.createNode` to detect your data type, e.g. using `typeof` or\n     * `instanceof`.\n     */\n    identify?: (value: unknown) => boolean;\n    /**\n     * The identifier for your data type, with which its stringified form will be\n     * prefixed. Should either be a !-prefixed local `!tag`, or a fully qualified\n     * `tag:domain,date:foo`.\n     */\n    tag: string;\n}\nexport interface ScalarTag extends TagBase {\n    collection?: never;\n    nodeClass?: never;\n    /**\n     * Turns a value into an AST node.\n     * If returning a non-`Node` value, the output will be wrapped as a `Scalar`.\n     */\n    resolve(value: string, onError: (message: string) => void, options: ParseOptions): unknown;\n    /**\n     * Optional function stringifying a Scalar node. If your data includes a\n     * suitable `.toString()` method, you can probably leave this undefined and\n     * use the default stringifier.\n     *\n     * @param item The node being stringified.\n     * @param ctx Contains the stringifying context variables.\n     * @param onComment Callback to signal that the stringifier includes the\n     *   item's comment in its output.\n     * @param onChompKeep Callback to signal that the output uses a block scalar\n     *   type with the `+` chomping indicator.\n     */\n    stringify?: (item: Scalar, ctx: StringifyContext, onComment?: () => void, onChompKeep?: () => void) => string;\n    /**\n     * Together with `default` allows for values to be stringified without an\n     * explicit tag and detected using a regular expression. For most cases, it's\n     * unlikely that you'll actually want to use these, even if you first think\n     * you do.\n     */\n    test?: RegExp;\n}\nexport interface CollectionTag extends TagBase {\n    stringify?: never;\n    test?: never;\n    /** The source collection type supported by this tag. */\n    collection: 'map' | 'seq';\n    /**\n     * The `Node` child class that implements this tag.\n     * If set, used to select this tag when stringifying.\n     *\n     * If the class provides a static `from` method, then that\n     * will be used if the tag object doesn't have a `createNode` method.\n     */\n    nodeClass?: {\n        new (schema?: Schema): Node;\n        from?: (schema: Schema, obj: unknown, ctx: CreateNodeContext) => Node;\n    };\n    /**\n     * Turns a value into an AST node.\n     * If returning a non-`Node` value, the output will be wrapped as a `Scalar`.\n     *\n     * Note: this is required if nodeClass is not provided.\n     */\n    resolve?: (value: YAMLMap.Parsed | YAMLSeq.Parsed, onError: (message: string) => void, options: ParseOptions) => unknown;\n}\nexport {};\n"],"mappings":"AAyFA"},"metadata":{},"sourceType":"module","externalDependencies":[]}