{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nvar _objectWithoutProperties = require(\"@babel/runtime/helpers/objectWithoutProperties\");\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nvar _excluded = [\"config\", \"duplicates\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findModulesAsync = void 0;\nvar chalk_1 = __importDefault(require(\"chalk\"));\nvar fast_glob_1 = __importDefault(require(\"fast-glob\"));\nvar fs_extra_1 = __importDefault(require(\"fs-extra\"));\nvar module_1 = require(\"module\");\nvar path_1 = __importDefault(require(\"path\"));\nvar ExpoModuleConfig_1 = require(\"../ExpoModuleConfig\");\nvar mergeLinkingOptions_1 = require(\"./mergeLinkingOptions\");\nvar EXPO_MODULE_CONFIG_FILENAMES = ['unimodule.json', 'expo-module.config.json'];\nfunction findModulesAsync(_x) {\n  return _findModulesAsync.apply(this, arguments);\n}\nfunction _findModulesAsync() {\n  _findModulesAsync = _asyncToGenerator(function* (providedOptions) {\n    var options = yield (0, mergeLinkingOptions_1.mergeLinkingOptionsAsync)(providedOptions);\n    var results = new Map();\n    var nativeModuleNames = new Set();\n    var searchPaths = options.nativeModulesDir && fs_extra_1.default.existsSync(options.nativeModulesDir) ? [options.nativeModulesDir].concat(_toConsumableArray(options.searchPaths)) : options.searchPaths;\n    for (var searchPath of searchPaths) {\n      var isNativeModulesDir = searchPath === options.nativeModulesDir;\n      var packageConfigPaths = yield findPackagesConfigPathsAsync(searchPath);\n      for (var packageConfigPath of packageConfigPaths) {\n        var _options$exclude;\n        var packagePath = yield fs_extra_1.default.realpath(path_1.default.join(searchPath, path_1.default.dirname(packageConfigPath)));\n        var expoModuleConfig = (0, ExpoModuleConfig_1.requireAndResolveExpoModuleConfig)(path_1.default.join(packagePath, path_1.default.basename(packageConfigPath)));\n        var _resolvePackageNameAn = resolvePackageNameAndVersion(packagePath, {\n            fallbackToDirName: isNativeModulesDir\n          }),\n          name = _resolvePackageNameAn.name,\n          version = _resolvePackageNameAn.version;\n        if (!isNativeModulesDir && (_options$exclude = options.exclude) != null && _options$exclude.includes(name) || !expoModuleConfig.supportsPlatform(options.platform)) {\n          continue;\n        }\n        var currentRevision = {\n          path: packagePath,\n          version: version,\n          config: expoModuleConfig\n        };\n        addRevisionToResults(results, name, currentRevision);\n        if (isNativeModulesDir && !nativeModuleNames.has(name)) {\n          nativeModuleNames.add(name);\n        }\n      }\n    }\n    var searchResults = Object.fromEntries(results.entries());\n    if (options.searchPaths.length <= 1) {\n      return searchResults;\n    }\n    return filterToProjectDependencies(searchResults, _objectSpread(_objectSpread({}, providedOptions), {}, {\n      alwaysIncludedPackagesNames: nativeModuleNames\n    }));\n  });\n  return _findModulesAsync.apply(this, arguments);\n}\nexports.findModulesAsync = findModulesAsync;\nfunction configPriority(fullpath) {\n  return EXPO_MODULE_CONFIG_FILENAMES.indexOf(path_1.default.basename(fullpath));\n}\nfunction addRevisionToResults(results, name, revision) {\n  var _results$get, _results$get2, _results$get2$duplica;\n  if (!results.has(name)) {\n    results.set(name, _objectSpread(_objectSpread({}, revision), {}, {\n      duplicates: []\n    }));\n  } else if (((_results$get = results.get(name)) == null ? void 0 : _results$get.path) !== revision.path && (_results$get2 = results.get(name)) != null && (_results$get2$duplica = _results$get2.duplicates) != null && _results$get2$duplica.every(function (_ref) {\n    var path = _ref.path;\n    return path !== revision.path;\n  })) {\n    var _results$get3, _results$get3$duplica;\n    var config = revision.config,\n      duplicates = revision.duplicates,\n      duplicateEntry = _objectWithoutProperties(revision, _excluded);\n    (_results$get3 = results.get(name)) == null ? void 0 : (_results$get3$duplica = _results$get3.duplicates) == null ? void 0 : _results$get3$duplica.push(duplicateEntry);\n  }\n}\nfunction findPackagesConfigPathsAsync(_x2) {\n  return _findPackagesConfigPathsAsync.apply(this, arguments);\n}\nfunction _findPackagesConfigPathsAsync() {\n  _findPackagesConfigPathsAsync = _asyncToGenerator(function* (searchPath) {\n    var bracedFilenames = '{' + EXPO_MODULE_CONFIG_FILENAMES.join(',') + '}';\n    var paths = yield (0, fast_glob_1.default)([`*/${bracedFilenames}`, `@*/*/${bracedFilenames}`, `./${bracedFilenames}`], {\n      cwd: searchPath\n    });\n    return Object.values(paths.reduce(function (acc, configPath) {\n      var dirname = path_1.default.dirname(configPath);\n      if (!acc[dirname] || configPriority(configPath) > configPriority(acc[dirname])) {\n        acc[dirname] = configPath;\n      }\n      return acc;\n    }, {}));\n  });\n  return _findPackagesConfigPathsAsync.apply(this, arguments);\n}\nfunction resolvePackageNameAndVersion(packagePath) {\n  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    fallbackToDirName = _ref2.fallbackToDirName;\n  try {\n    var _require = require(path_1.default.join(packagePath, 'package.json')),\n      name = _require.name,\n      version = _require.version;\n    return {\n      name: name,\n      version: version || 'UNVERSIONED'\n    };\n  } catch (e) {\n    if (fallbackToDirName) {\n      return {\n        name: path_1.default.basename(packagePath),\n        version: 'UNVERSIONED'\n      };\n    } else {\n      throw e;\n    }\n  }\n}\nfunction filterToProjectDependencies(results) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var filteredResults = {};\n  var visitedPackages = new Set();\n  for (var name of (_options$alwaysInclud = options.alwaysIncludedPackagesNames) != null ? _options$alwaysInclud : []) {\n    var _options$alwaysInclud;\n    if (results[name] && !visitedPackages.has(name)) {\n      filteredResults[name] = results[name];\n      visitedPackages.add(name);\n    }\n  }\n  function visitPackage(packageJsonPath) {\n    var packageJson = require(packageJsonPath);\n    if (visitedPackages.has(packageJson.name)) {\n      return;\n    }\n    visitedPackages.add(packageJson.name);\n    for (var dependencyName in packageJson.dependencies) {\n      var dependencyResult = results[dependencyName];\n      if (!filteredResults[dependencyName]) {\n        var dependencyPackageJsonPath = void 0;\n        if (dependencyResult) {\n          filteredResults[dependencyName] = dependencyResult;\n          dependencyPackageJsonPath = path_1.default.join(dependencyResult.path, 'package.json');\n        } else {\n          try {\n            var projectRequire = (0, module_1.createRequire)(packageJsonPath);\n            dependencyPackageJsonPath = projectRequire.resolve(`${dependencyName}/package.json`);\n          } catch (error) {\n            if (!options.silent && error.code !== 'ERR_PACKAGE_PATH_NOT_EXPORTED') {\n              console.warn(chalk_1.default.yellow(`⚠️  Cannot resolve the path to \"${dependencyName}\" package.`));\n            }\n            continue;\n          }\n        }\n        visitPackage(dependencyPackageJsonPath);\n      }\n    }\n  }\n  visitPackage(mergeLinkingOptions_1.projectPackageJsonPath);\n  return filteredResults;\n}","map":{"version":3,"names":["chalk_1","__importDefault","require","fast_glob_1","fs_extra_1","module_1","path_1","ExpoModuleConfig_1","mergeLinkingOptions_1","EXPO_MODULE_CONFIG_FILENAMES","findModulesAsync","_x","_findModulesAsync","apply","arguments","_asyncToGenerator","providedOptions","options","mergeLinkingOptionsAsync","results","Map","nativeModuleNames","Set","searchPaths","nativeModulesDir","default","existsSync","concat","_toConsumableArray","searchPath","isNativeModulesDir","packageConfigPaths","findPackagesConfigPathsAsync","packageConfigPath","_options$exclude","packagePath","realpath","join","dirname","expoModuleConfig","requireAndResolveExpoModuleConfig","basename","_resolvePackageNameAn","resolvePackageNameAndVersion","fallbackToDirName","name","version","exclude","includes","supportsPlatform","platform","currentRevision","path","config","addRevisionToResults","has","add","searchResults","Object","fromEntries","entries","length","filterToProjectDependencies","_objectSpread","alwaysIncludedPackagesNames","exports","configPriority","fullpath","indexOf","revision","_results$get","_results$get2","_results$get2$duplica","set","duplicates","get","every","_ref","_results$get3","_results$get3$duplica","duplicateEntry","_objectWithoutProperties","_excluded","push","_x2","_findPackagesConfigPathsAsync","bracedFilenames","paths","cwd","values","reduce","acc","configPath","_ref2","undefined","_require","e","filteredResults","visitedPackages","_options$alwaysInclud","visitPackage","packageJsonPath","packageJson","dependencyName","dependencies","dependencyResult","dependencyPackageJsonPath","projectRequire","createRequire","resolve","error","silent","code","console","warn","yellow","projectPackageJsonPath"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\expo-modules-autolinking\\src\\autolinking\\findModules.ts"],"sourcesContent":["import chalk from 'chalk';\nimport glob from 'fast-glob';\nimport fs from 'fs-extra';\nimport { createRequire } from 'module';\nimport path from 'path';\n\nimport { requireAndResolveExpoModuleConfig } from '../ExpoModuleConfig';\nimport { PackageRevision, SearchOptions, SearchResults } from '../types';\nimport { mergeLinkingOptionsAsync, projectPackageJsonPath } from './mergeLinkingOptions';\n\n// Names of the config files. From lowest to highest priority.\nconst EXPO_MODULE_CONFIG_FILENAMES = ['unimodule.json', 'expo-module.config.json'];\n\n/**\n * Searches for modules to link based on given config.\n */\nexport async function findModulesAsync(providedOptions: SearchOptions): Promise<SearchResults> {\n  const options = await mergeLinkingOptionsAsync(providedOptions);\n  const results: Map<string, PackageRevision> = new Map();\n\n  const nativeModuleNames = new Set<string>();\n\n  // custom native modules should be resolved first so that they can override other modules\n  const searchPaths =\n    options.nativeModulesDir && fs.existsSync(options.nativeModulesDir)\n      ? [options.nativeModulesDir, ...options.searchPaths]\n      : options.searchPaths;\n\n  for (const searchPath of searchPaths) {\n    const isNativeModulesDir = searchPath === options.nativeModulesDir;\n\n    const packageConfigPaths = await findPackagesConfigPathsAsync(searchPath);\n\n    for (const packageConfigPath of packageConfigPaths) {\n      const packagePath = await fs.realpath(path.join(searchPath, path.dirname(packageConfigPath)));\n      const expoModuleConfig = requireAndResolveExpoModuleConfig(\n        path.join(packagePath, path.basename(packageConfigPath))\n      );\n\n      const { name, version } = resolvePackageNameAndVersion(packagePath, {\n        fallbackToDirName: isNativeModulesDir,\n      });\n\n      // we ignore the `exclude` option for custom native modules\n      if (\n        (!isNativeModulesDir && options.exclude?.includes(name)) ||\n        !expoModuleConfig.supportsPlatform(options.platform)\n      ) {\n        continue;\n      }\n\n      // add the current revision to the results\n      const currentRevision: PackageRevision = {\n        path: packagePath,\n        version,\n        config: expoModuleConfig,\n      };\n      addRevisionToResults(results, name, currentRevision);\n\n      // if the module is a native module, we need to add it to the nativeModuleNames set\n      if (isNativeModulesDir && !nativeModuleNames.has(name)) {\n        nativeModuleNames.add(name);\n      }\n    }\n  }\n\n  const searchResults: SearchResults = Object.fromEntries(results.entries());\n\n  // It doesn't make much sense to strip modules if there is only one search path.\n  // (excluding custom native modules path)\n  // Workspace root usually doesn't specify all its dependencies (see Expo Go),\n  // so in this case we should link everything.\n  if (options.searchPaths.length <= 1) {\n    return searchResults;\n  }\n\n  return filterToProjectDependencies(searchResults, {\n    ...providedOptions,\n    // Custom native modules are not filtered out\n    // when they're not specified in package.json dependencies.\n    alwaysIncludedPackagesNames: nativeModuleNames,\n  });\n}\n\n/**\n * Returns the priority of the config at given path. Higher number means higher priority.\n */\nfunction configPriority(fullpath: string): number {\n  return EXPO_MODULE_CONFIG_FILENAMES.indexOf(path.basename(fullpath));\n}\n\n/**\n * Adds {@link revision} to the {@link results} map\n * or to package duplicates if it already exists.\n * @param results [mutable] yet resolved packages map\n * @param name resolved package name\n * @param revision resolved package revision\n */\nfunction addRevisionToResults(\n  results: Map<string, PackageRevision>,\n  name: string,\n  revision: PackageRevision\n): void {\n  if (!results.has(name)) {\n    // The revision that was found first will be the main one.\n    // An array of duplicates and the config are needed only here.\n    results.set(name, {\n      ...revision,\n      duplicates: [],\n    });\n  } else if (\n    results.get(name)?.path !== revision.path &&\n    results.get(name)?.duplicates?.every(({ path }) => path !== revision.path)\n  ) {\n    const { config, duplicates, ...duplicateEntry } = revision;\n    results.get(name)?.duplicates?.push(duplicateEntry);\n  }\n}\n\n/**\n * Returns paths to the highest priority config files, relative to the {@link searchPath}.\n * @example\n * ```\n * // Given the following file exists: /foo/myapp/modules/mymodule/expo-module.config.json\n * await findPackagesConfigPathsAsync('/foo/myapp/modules');\n * // returns ['mymodule/expo-module.config.json']\n *\n * await findPackagesConfigPathsAsync('/foo/myapp/modules/mymodule');\n * // returns ['expo-module.config.json']\n * ```\n */\nasync function findPackagesConfigPathsAsync(searchPath: string): Promise<string[]> {\n  const bracedFilenames = '{' + EXPO_MODULE_CONFIG_FILENAMES.join(',') + '}';\n  const paths = await glob(\n    [`*/${bracedFilenames}`, `@*/*/${bracedFilenames}`, `./${bracedFilenames}`],\n    {\n      cwd: searchPath,\n    }\n  );\n\n  // If the package has multiple configs (e.g. `unimodule.json` and `expo-module.config.json` during the transition time)\n  // then we want to give `expo-module.config.json` the priority.\n  return Object.values(\n    paths.reduce<Record<string, string>>((acc, configPath) => {\n      const dirname = path.dirname(configPath);\n\n      if (!acc[dirname] || configPriority(configPath) > configPriority(acc[dirname])) {\n        acc[dirname] = configPath;\n      }\n      return acc;\n    }, {})\n  );\n}\n\n/**\n * Resolves package name and version for the given {@link packagePath} from its `package.json`.\n * if {@link fallbackToDirName} is true, it returns the dir name when `package.json` doesn't exist.\n * @returns object with `name` and `version` properties. `version` falls back to `UNVERSIONED` if cannot be resolved.\n */\nfunction resolvePackageNameAndVersion(\n  packagePath: string,\n  { fallbackToDirName }: { fallbackToDirName?: boolean } = {}\n): { name: string; version: string } {\n  try {\n    const { name, version } = require(path.join(packagePath, 'package.json'));\n    return { name, version: version || 'UNVERSIONED' };\n  } catch (e) {\n    if (fallbackToDirName) {\n      // we don't have the package.json name, so we'll use the directory name\n      return {\n        name: path.basename(packagePath),\n        version: 'UNVERSIONED',\n      };\n    } else {\n      throw e;\n    }\n  }\n}\n\n/**\n * Filters out packages that are not the dependencies of the project.\n */\nfunction filterToProjectDependencies(\n  results: SearchResults,\n  options: Pick<SearchOptions, 'silent'> & { alwaysIncludedPackagesNames?: Set<string> } = {}\n) {\n  const filteredResults: SearchResults = {};\n  const visitedPackages = new Set<string>();\n\n  // iterate through always included package names and add them to the visited packages\n  // if the results contains them\n  for (const name of options.alwaysIncludedPackagesNames ?? []) {\n    if (results[name] && !visitedPackages.has(name)) {\n      filteredResults[name] = results[name];\n      visitedPackages.add(name);\n    }\n  }\n\n  // Helper for traversing the dependency hierarchy.\n  function visitPackage(packageJsonPath: string) {\n    const packageJson = require(packageJsonPath);\n\n    // Prevent getting into the recursive loop.\n    if (visitedPackages.has(packageJson.name)) {\n      return;\n    }\n    visitedPackages.add(packageJson.name);\n\n    // Iterate over the dependencies to find transitive modules.\n    for (const dependencyName in packageJson.dependencies) {\n      const dependencyResult = results[dependencyName];\n\n      if (!filteredResults[dependencyName]) {\n        let dependencyPackageJsonPath: string;\n\n        if (dependencyResult) {\n          filteredResults[dependencyName] = dependencyResult;\n          dependencyPackageJsonPath = path.join(dependencyResult.path, 'package.json');\n        } else {\n          try {\n            /**\n             * Custom `require` that resolves from the current working dir instead of this script path.\n             * **Requires Node v12.2.0**\n             */\n            const projectRequire = createRequire(packageJsonPath);\n            dependencyPackageJsonPath = projectRequire.resolve(`${dependencyName}/package.json`);\n          } catch (error: any) {\n            // Some packages don't include package.json in its `exports` field,\n            // but none of our packages do that, so it seems fine to just ignore that type of error.\n            // Related issue: https://github.com/react-native-community/cli/issues/1168\n            if (!options.silent && error.code !== 'ERR_PACKAGE_PATH_NOT_EXPORTED') {\n              console.warn(\n                chalk.yellow(`⚠️  Cannot resolve the path to \"${dependencyName}\" package.`)\n              );\n            }\n            continue;\n          }\n        }\n\n        // Visit the dependency package.\n        visitPackage(dependencyPackageJsonPath);\n      }\n    }\n  }\n\n  // Visit project's package.\n  visitPackage(projectPackageJsonPath);\n\n  return filteredResults;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}