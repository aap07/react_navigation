{"ast":null,"code":"'use strict';\nvar _objectWithoutProperties = require(\"@babel/runtime/helpers/objectWithoutProperties\");\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nvar _excluded = [\"width\"],\n  _excluded2 = [\"width\"];\nvar wordsep_simple_re = /([\\t\\n\\x0b\\x0c\\r ]+)/;\nvar TextWrapper = function () {\n  function TextWrapper() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, TextWrapper);\n    var _options$width = options.width,\n      width = _options$width === void 0 ? 70 : _options$width,\n      _options$initial_inde = options.initial_indent,\n      initial_indent = _options$initial_inde === void 0 ? '' : _options$initial_inde,\n      _options$subsequent_i = options.subsequent_indent,\n      subsequent_indent = _options$subsequent_i === void 0 ? '' : _options$subsequent_i,\n      _options$expand_tabs = options.expand_tabs,\n      expand_tabs = _options$expand_tabs === void 0 ? true : _options$expand_tabs,\n      _options$replace_whit = options.replace_whitespace,\n      replace_whitespace = _options$replace_whit === void 0 ? true : _options$replace_whit,\n      _options$fix_sentence = options.fix_sentence_endings,\n      fix_sentence_endings = _options$fix_sentence === void 0 ? false : _options$fix_sentence,\n      _options$break_long_w = options.break_long_words,\n      break_long_words = _options$break_long_w === void 0 ? true : _options$break_long_w,\n      _options$drop_whitesp = options.drop_whitespace,\n      drop_whitespace = _options$drop_whitesp === void 0 ? true : _options$drop_whitesp,\n      _options$break_on_hyp = options.break_on_hyphens,\n      break_on_hyphens = _options$break_on_hyp === void 0 ? true : _options$break_on_hyp,\n      _options$tabsize = options.tabsize,\n      tabsize = _options$tabsize === void 0 ? 8 : _options$tabsize,\n      _options$max_lines = options.max_lines,\n      max_lines = _options$max_lines === void 0 ? undefined : _options$max_lines,\n      _options$placeholder = options.placeholder,\n      placeholder = _options$placeholder === void 0 ? ' [...]' : _options$placeholder;\n    this.width = width;\n    this.initial_indent = initial_indent;\n    this.subsequent_indent = subsequent_indent;\n    this.expand_tabs = expand_tabs;\n    this.replace_whitespace = replace_whitespace;\n    this.fix_sentence_endings = fix_sentence_endings;\n    this.break_long_words = break_long_words;\n    this.drop_whitespace = drop_whitespace;\n    this.break_on_hyphens = break_on_hyphens;\n    this.tabsize = tabsize;\n    this.max_lines = max_lines;\n    this.placeholder = placeholder;\n  }\n  _createClass(TextWrapper, [{\n    key: \"_munge_whitespace\",\n    value: function _munge_whitespace(text) {\n      if (this.expand_tabs) {\n        text = text.replace(/\\t/g, ' '.repeat(this.tabsize));\n      }\n      if (this.replace_whitespace) {\n        text = text.replace(/[\\t\\n\\x0b\\x0c\\r]/g, ' ');\n      }\n      return text;\n    }\n  }, {\n    key: \"_split\",\n    value: function _split(text) {\n      var chunks = text.split(wordsep_simple_re);\n      chunks = chunks.filter(Boolean);\n      return chunks;\n    }\n  }, {\n    key: \"_handle_long_word\",\n    value: function _handle_long_word(reversed_chunks, cur_line, cur_len, width) {\n      var space_left;\n      if (width < 1) {\n        space_left = 1;\n      } else {\n        space_left = width - cur_len;\n      }\n      if (this.break_long_words) {\n        cur_line.push(reversed_chunks[reversed_chunks.length - 1].slice(0, space_left));\n        reversed_chunks[reversed_chunks.length - 1] = reversed_chunks[reversed_chunks.length - 1].slice(space_left);\n      } else if (!cur_line) {\n        cur_line.push.apply(cur_line, _toConsumableArray(reversed_chunks.pop()));\n      }\n    }\n  }, {\n    key: \"_wrap_chunks\",\n    value: function _wrap_chunks(chunks) {\n      var lines = [];\n      var indent;\n      if (this.width <= 0) {\n        throw Error(`invalid width ${this.width} (must be > 0)`);\n      }\n      if (this.max_lines !== undefined) {\n        if (this.max_lines > 1) {\n          indent = this.subsequent_indent;\n        } else {\n          indent = this.initial_indent;\n        }\n        if (indent.length + this.placeholder.trimStart().length > this.width) {\n          throw Error('placeholder too large for max width');\n        }\n      }\n      chunks = chunks.reverse();\n      while (chunks.length > 0) {\n        var cur_line = [];\n        var cur_len = 0;\n        var _indent = void 0;\n        if (lines) {\n          _indent = this.subsequent_indent;\n        } else {\n          _indent = this.initial_indent;\n        }\n        var width = this.width - _indent.length;\n        if (this.drop_whitespace && chunks[chunks.length - 1].trim() === '' && lines.length > 0) {\n          chunks.pop();\n        }\n        while (chunks.length > 0) {\n          var l = chunks[chunks.length - 1].length;\n          if (cur_len + l <= width) {\n            cur_line.push(chunks.pop());\n            cur_len += l;\n          } else {\n            break;\n          }\n        }\n        if (chunks.length && chunks[chunks.length - 1].length > width) {\n          this._handle_long_word(chunks, cur_line, cur_len, width);\n          cur_len = cur_line.map(function (l) {\n            return l.length;\n          }).reduce(function (a, b) {\n            return a + b;\n          }, 0);\n        }\n        if (this.drop_whitespace && cur_line.length > 0 && cur_line[cur_line.length - 1].trim() === '') {\n          cur_len -= cur_line[cur_line.length - 1].length;\n          cur_line.pop();\n        }\n        if (cur_line) {\n          if (this.max_lines === undefined || lines.length + 1 < this.max_lines || (chunks.length === 0 || this.drop_whitespace && chunks.length === 1 && !chunks[0].trim()) && cur_len <= width) {\n            lines.push(_indent + cur_line.join(''));\n          } else {\n            var had_break = false;\n            while (cur_line) {\n              if (cur_line[cur_line.length - 1].trim() && cur_len + this.placeholder.length <= width) {\n                cur_line.push(this.placeholder);\n                lines.push(_indent + cur_line.join(''));\n                had_break = true;\n                break;\n              }\n              cur_len -= cur_line[-1].length;\n              cur_line.pop();\n            }\n            if (!had_break) {\n              if (lines) {\n                var prev_line = lines[lines.length - 1].trimEnd();\n                if (prev_line.length + this.placeholder.length <= this.width) {\n                  lines[lines.length - 1] = prev_line + this.placeholder;\n                  break;\n                }\n              }\n              lines.push(_indent + this.placeholder.lstrip());\n            }\n            break;\n          }\n        }\n      }\n      return lines;\n    }\n  }, {\n    key: \"_split_chunks\",\n    value: function _split_chunks(text) {\n      text = this._munge_whitespace(text);\n      return this._split(text);\n    }\n  }, {\n    key: \"wrap\",\n    value: function wrap(text) {\n      var chunks = this._split_chunks(text);\n      return this._wrap_chunks(chunks);\n    }\n  }, {\n    key: \"fill\",\n    value: function fill(text) {\n      return this.wrap(text).join('\\n');\n    }\n  }]);\n  return TextWrapper;\n}();\nfunction wrap(text) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$width2 = options.width,\n    width = _options$width2 === void 0 ? 70 : _options$width2,\n    kwargs = _objectWithoutProperties(options, _excluded);\n  var w = new TextWrapper(Object.assign({\n    width: width\n  }, kwargs));\n  return w.wrap(text);\n}\nfunction fill(text) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$width3 = options.width,\n    width = _options$width3 === void 0 ? 70 : _options$width3,\n    kwargs = _objectWithoutProperties(options, _excluded2);\n  var w = new TextWrapper(Object.assign({\n    width: width\n  }, kwargs));\n  return w.fill(text);\n}\nvar _whitespace_only_re = /^[ \\t]+$/mg;\nvar _leading_whitespace_re = /(^[ \\t]*)(?:[^ \\t\\n])/mg;\nfunction dedent(text) {\n  var margin = undefined;\n  text = text.replace(_whitespace_only_re, '');\n  var indents = text.match(_leading_whitespace_re) || [];\n  for (var indent of indents) {\n    indent = indent.slice(0, -1);\n    if (margin === undefined) {\n      margin = indent;\n    } else if (indent.startsWith(margin)) {} else if (margin.startsWith(indent)) {\n      margin = indent;\n    } else {\n      for (var i = 0; i < margin.length && i < indent.length; i++) {\n        if (margin[i] !== indent[i]) {\n          margin = margin.slice(0, i);\n          break;\n        }\n      }\n    }\n  }\n  if (margin) {\n    text = text.replace(new RegExp('^' + margin, 'mg'), '');\n  }\n  return text;\n}\nmodule.exports = {\n  wrap: wrap,\n  fill: fill,\n  dedent: dedent\n};","map":{"version":3,"names":["_objectWithoutProperties","require","_toConsumableArray","_classCallCheck","_createClass","_excluded","_excluded2","wordsep_simple_re","TextWrapper","options","arguments","length","undefined","_options$width","width","_options$initial_inde","initial_indent","_options$subsequent_i","subsequent_indent","_options$expand_tabs","expand_tabs","_options$replace_whit","replace_whitespace","_options$fix_sentence","fix_sentence_endings","_options$break_long_w","break_long_words","_options$drop_whitesp","drop_whitespace","_options$break_on_hyp","break_on_hyphens","_options$tabsize","tabsize","_options$max_lines","max_lines","_options$placeholder","placeholder","key","value","_munge_whitespace","text","replace","repeat","_split","chunks","split","filter","Boolean","_handle_long_word","reversed_chunks","cur_line","cur_len","space_left","push","slice","apply","pop","_wrap_chunks","lines","indent","Error","trimStart","reverse","trim","l","map","reduce","a","b","join","had_break","prev_line","trimEnd","lstrip","_split_chunks","wrap","fill","_options$width2","kwargs","w","Object","assign","_options$width3","_whitespace_only_re","_leading_whitespace_re","dedent","margin","indents","match","startsWith","i","RegExp","module","exports"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@expo/xcpretty/node_modules/argparse/lib/textwrap.js"],"sourcesContent":["// Partial port of python's argparse module, version 3.9.0 (only wrap and fill functions):\n// https://github.com/python/cpython/blob/v3.9.0b4/Lib/textwrap.py\n\n'use strict'\n\n/*\n * Text wrapping and filling.\n */\n\n// Copyright (C) 1999-2001 Gregory P. Ward.\n// Copyright (C) 2002, 2003 Python Software Foundation.\n// Copyright (C) 2020 argparse.js authors\n// Originally written by Greg Ward <gward@python.net>\n\n// Hardcode the recognized whitespace characters to the US-ASCII\n// whitespace characters.  The main reason for doing this is that\n// some Unicode spaces (like \\u00a0) are non-breaking whitespaces.\n//\n// This less funky little regex just split on recognized spaces. E.g.\n//   \"Hello there -- you goof-ball, use the -b option!\"\n// splits into\n//   Hello/ /there/ /--/ /you/ /goof-ball,/ /use/ /the/ /-b/ /option!/\nconst wordsep_simple_re = /([\\t\\n\\x0b\\x0c\\r ]+)/\n\nclass TextWrapper {\n    /*\n     *  Object for wrapping/filling text.  The public interface consists of\n     *  the wrap() and fill() methods; the other methods are just there for\n     *  subclasses to override in order to tweak the default behaviour.\n     *  If you want to completely replace the main wrapping algorithm,\n     *  you'll probably have to override _wrap_chunks().\n     *\n     *  Several instance attributes control various aspects of wrapping:\n     *    width (default: 70)\n     *      the maximum width of wrapped lines (unless break_long_words\n     *      is false)\n     *    initial_indent (default: \"\")\n     *      string that will be prepended to the first line of wrapped\n     *      output.  Counts towards the line's width.\n     *    subsequent_indent (default: \"\")\n     *      string that will be prepended to all lines save the first\n     *      of wrapped output; also counts towards each line's width.\n     *    expand_tabs (default: true)\n     *      Expand tabs in input text to spaces before further processing.\n     *      Each tab will become 0 .. 'tabsize' spaces, depending on its position\n     *      in its line.  If false, each tab is treated as a single character.\n     *    tabsize (default: 8)\n     *      Expand tabs in input text to 0 .. 'tabsize' spaces, unless\n     *      'expand_tabs' is false.\n     *    replace_whitespace (default: true)\n     *      Replace all whitespace characters in the input text by spaces\n     *      after tab expansion.  Note that if expand_tabs is false and\n     *      replace_whitespace is true, every tab will be converted to a\n     *      single space!\n     *    fix_sentence_endings (default: false)\n     *      Ensure that sentence-ending punctuation is always followed\n     *      by two spaces.  Off by default because the algorithm is\n     *      (unavoidably) imperfect.\n     *    break_long_words (default: true)\n     *      Break words longer than 'width'.  If false, those words will not\n     *      be broken, and some lines might be longer than 'width'.\n     *    break_on_hyphens (default: true)\n     *      Allow breaking hyphenated words. If true, wrapping will occur\n     *      preferably on whitespaces and right after hyphens part of\n     *      compound words.\n     *    drop_whitespace (default: true)\n     *      Drop leading and trailing whitespace from lines.\n     *    max_lines (default: None)\n     *      Truncate wrapped lines.\n     *    placeholder (default: ' [...]')\n     *      Append to the last line of truncated text.\n     */\n\n    constructor(options = {}) {\n        let {\n            width = 70,\n            initial_indent = '',\n            subsequent_indent = '',\n            expand_tabs = true,\n            replace_whitespace = true,\n            fix_sentence_endings = false,\n            break_long_words = true,\n            drop_whitespace = true,\n            break_on_hyphens = true,\n            tabsize = 8,\n            max_lines = undefined,\n            placeholder=' [...]'\n        } = options\n\n        this.width = width\n        this.initial_indent = initial_indent\n        this.subsequent_indent = subsequent_indent\n        this.expand_tabs = expand_tabs\n        this.replace_whitespace = replace_whitespace\n        this.fix_sentence_endings = fix_sentence_endings\n        this.break_long_words = break_long_words\n        this.drop_whitespace = drop_whitespace\n        this.break_on_hyphens = break_on_hyphens\n        this.tabsize = tabsize\n        this.max_lines = max_lines\n        this.placeholder = placeholder\n    }\n\n\n    // -- Private methods -----------------------------------------------\n    // (possibly useful for subclasses to override)\n\n    _munge_whitespace(text) {\n        /*\n         *  _munge_whitespace(text : string) -> string\n         *\n         *  Munge whitespace in text: expand tabs and convert all other\n         *  whitespace characters to spaces.  Eg. \" foo\\\\tbar\\\\n\\\\nbaz\"\n         *  becomes \" foo    bar  baz\".\n         */\n        if (this.expand_tabs) {\n            text = text.replace(/\\t/g, ' '.repeat(this.tabsize)) // not strictly correct in js\n        }\n        if (this.replace_whitespace) {\n            text = text.replace(/[\\t\\n\\x0b\\x0c\\r]/g, ' ')\n        }\n        return text\n    }\n\n    _split(text) {\n        /*\n         *  _split(text : string) -> [string]\n         *\n         *  Split the text to wrap into indivisible chunks.  Chunks are\n         *  not quite the same as words; see _wrap_chunks() for full\n         *  details.  As an example, the text\n         *    Look, goof-ball -- use the -b option!\n         *  breaks into the following chunks:\n         *    'Look,', ' ', 'goof-', 'ball', ' ', '--', ' ',\n         *    'use', ' ', 'the', ' ', '-b', ' ', 'option!'\n         *  if break_on_hyphens is True, or in:\n         *    'Look,', ' ', 'goof-ball', ' ', '--', ' ',\n         *    'use', ' ', 'the', ' ', '-b', ' ', option!'\n         *  otherwise.\n         */\n        let chunks = text.split(wordsep_simple_re)\n        chunks = chunks.filter(Boolean)\n        return chunks\n    }\n\n    _handle_long_word(reversed_chunks, cur_line, cur_len, width) {\n        /*\n         *  _handle_long_word(chunks : [string],\n         *                    cur_line : [string],\n         *                    cur_len : int, width : int)\n         *\n         *  Handle a chunk of text (most likely a word, not whitespace) that\n         *  is too long to fit in any line.\n         */\n        // Figure out when indent is larger than the specified width, and make\n        // sure at least one character is stripped off on every pass\n        let space_left\n        if (width < 1) {\n            space_left = 1\n        } else {\n            space_left = width - cur_len\n        }\n\n        // If we're allowed to break long words, then do so: put as much\n        // of the next chunk onto the current line as will fit.\n        if (this.break_long_words) {\n            cur_line.push(reversed_chunks[reversed_chunks.length - 1].slice(0, space_left))\n            reversed_chunks[reversed_chunks.length - 1] = reversed_chunks[reversed_chunks.length - 1].slice(space_left)\n\n        // Otherwise, we have to preserve the long word intact.  Only add\n        // it to the current line if there's nothing already there --\n        // that minimizes how much we violate the width constraint.\n        } else if (!cur_line) {\n            cur_line.push(...reversed_chunks.pop())\n        }\n\n        // If we're not allowed to break long words, and there's already\n        // text on the current line, do nothing.  Next time through the\n        // main loop of _wrap_chunks(), we'll wind up here again, but\n        // cur_len will be zero, so the next line will be entirely\n        // devoted to the long word that we can't handle right now.\n    }\n\n    _wrap_chunks(chunks) {\n        /*\n         *  _wrap_chunks(chunks : [string]) -> [string]\n         *\n         *  Wrap a sequence of text chunks and return a list of lines of\n         *  length 'self.width' or less.  (If 'break_long_words' is false,\n         *  some lines may be longer than this.)  Chunks correspond roughly\n         *  to words and the whitespace between them: each chunk is\n         *  indivisible (modulo 'break_long_words'), but a line break can\n         *  come between any two chunks.  Chunks should not have internal\n         *  whitespace; ie. a chunk is either all whitespace or a \"word\".\n         *  Whitespace chunks will be removed from the beginning and end of\n         *  lines, but apart from that whitespace is preserved.\n         */\n        let lines = []\n        let indent\n        if (this.width <= 0) {\n            throw Error(`invalid width ${this.width} (must be > 0)`)\n        }\n        if (this.max_lines !== undefined) {\n            if (this.max_lines > 1) {\n                indent = this.subsequent_indent\n            } else {\n                indent = this.initial_indent\n            }\n            if (indent.length + this.placeholder.trimStart().length > this.width) {\n                throw Error('placeholder too large for max width')\n            }\n        }\n\n        // Arrange in reverse order so items can be efficiently popped\n        // from a stack of chucks.\n        chunks = chunks.reverse()\n\n        while (chunks.length > 0) {\n\n            // Start the list of chunks that will make up the current line.\n            // cur_len is just the length of all the chunks in cur_line.\n            let cur_line = []\n            let cur_len = 0\n\n            // Figure out which static string will prefix this line.\n            let indent\n            if (lines) {\n                indent = this.subsequent_indent\n            } else {\n                indent = this.initial_indent\n            }\n\n            // Maximum width for this line.\n            let width = this.width - indent.length\n\n            // First chunk on line is whitespace -- drop it, unless this\n            // is the very beginning of the text (ie. no lines started yet).\n            if (this.drop_whitespace && chunks[chunks.length - 1].trim() === '' && lines.length > 0) {\n                chunks.pop()\n            }\n\n            while (chunks.length > 0) {\n                let l = chunks[chunks.length - 1].length\n\n                // Can at least squeeze this chunk onto the current line.\n                if (cur_len + l <= width) {\n                    cur_line.push(chunks.pop())\n                    cur_len += l\n\n                // Nope, this line is full.\n                } else {\n                    break\n                }\n            }\n\n            // The current line is full, and the next chunk is too big to\n            // fit on *any* line (not just this one).\n            if (chunks.length && chunks[chunks.length - 1].length > width) {\n                this._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = cur_line.map(l => l.length).reduce((a, b) => a + b, 0)\n            }\n\n            // If the last chunk on this line is all whitespace, drop it.\n            if (this.drop_whitespace && cur_line.length > 0 && cur_line[cur_line.length - 1].trim() === '') {\n                cur_len -= cur_line[cur_line.length - 1].length\n                cur_line.pop()\n            }\n\n            if (cur_line) {\n                if (this.max_lines === undefined ||\n                    lines.length + 1 < this.max_lines ||\n                    (chunks.length === 0 ||\n                     this.drop_whitespace &&\n                     chunks.length === 1 &&\n                     !chunks[0].trim()) && cur_len <= width) {\n                    // Convert current line back to a string and store it in\n                    // list of all lines (return value).\n                    lines.push(indent + cur_line.join(''))\n                } else {\n                    let had_break = false\n                    while (cur_line) {\n                        if (cur_line[cur_line.length - 1].trim() &&\n                            cur_len + this.placeholder.length <= width) {\n                            cur_line.push(this.placeholder)\n                            lines.push(indent + cur_line.join(''))\n                            had_break = true\n                            break\n                        }\n                        cur_len -= cur_line[-1].length\n                        cur_line.pop()\n                    }\n                    if (!had_break) {\n                        if (lines) {\n                            let prev_line = lines[lines.length - 1].trimEnd()\n                            if (prev_line.length + this.placeholder.length <=\n                                    this.width) {\n                                lines[lines.length - 1] = prev_line + this.placeholder\n                                break\n                            }\n                        }\n                        lines.push(indent + this.placeholder.lstrip())\n                    }\n                    break\n                }\n            }\n        }\n\n        return lines\n    }\n\n    _split_chunks(text) {\n        text = this._munge_whitespace(text)\n        return this._split(text)\n    }\n\n    // -- Public interface ----------------------------------------------\n\n    wrap(text) {\n        /*\n         *  wrap(text : string) -> [string]\n         *\n         *  Reformat the single paragraph in 'text' so it fits in lines of\n         *  no more than 'self.width' columns, and return a list of wrapped\n         *  lines.  Tabs in 'text' are expanded with string.expandtabs(),\n         *  and all other whitespace characters (including newline) are\n         *  converted to space.\n         */\n        let chunks = this._split_chunks(text)\n        // not implemented in js\n        //if (this.fix_sentence_endings) {\n        //    this._fix_sentence_endings(chunks)\n        //}\n        return this._wrap_chunks(chunks)\n    }\n\n    fill(text) {\n        /*\n         *  fill(text : string) -> string\n         *\n         *  Reformat the single paragraph in 'text' to fit in lines of no\n         *  more than 'self.width' columns, and return a new string\n         *  containing the entire wrapped paragraph.\n         */\n        return this.wrap(text).join('\\n')\n    }\n}\n\n\n// -- Convenience interface ---------------------------------------------\n\nfunction wrap(text, options = {}) {\n    /*\n     *  Wrap a single paragraph of text, returning a list of wrapped lines.\n     *\n     *  Reformat the single paragraph in 'text' so it fits in lines of no\n     *  more than 'width' columns, and return a list of wrapped lines.  By\n     *  default, tabs in 'text' are expanded with string.expandtabs(), and\n     *  all other whitespace characters (including newline) are converted to\n     *  space.  See TextWrapper class for available keyword args to customize\n     *  wrapping behaviour.\n     */\n    let { width = 70, ...kwargs } = options\n    let w = new TextWrapper(Object.assign({ width }, kwargs))\n    return w.wrap(text)\n}\n\nfunction fill(text, options = {}) {\n    /*\n     *  Fill a single paragraph of text, returning a new string.\n     *\n     *  Reformat the single paragraph in 'text' to fit in lines of no more\n     *  than 'width' columns, and return a new string containing the entire\n     *  wrapped paragraph.  As with wrap(), tabs are expanded and other\n     *  whitespace characters converted to space.  See TextWrapper class for\n     *  available keyword args to customize wrapping behaviour.\n     */\n    let { width = 70, ...kwargs } = options\n    let w = new TextWrapper(Object.assign({ width }, kwargs))\n    return w.fill(text)\n}\n\n// -- Loosely related functionality -------------------------------------\n\nlet _whitespace_only_re = /^[ \\t]+$/mg\nlet _leading_whitespace_re = /(^[ \\t]*)(?:[^ \\t\\n])/mg\n\nfunction dedent(text) {\n    /*\n     *  Remove any common leading whitespace from every line in `text`.\n     *\n     *  This can be used to make triple-quoted strings line up with the left\n     *  edge of the display, while still presenting them in the source code\n     *  in indented form.\n     *\n     *  Note that tabs and spaces are both treated as whitespace, but they\n     *  are not equal: the lines \"  hello\" and \"\\\\thello\" are\n     *  considered to have no common leading whitespace.\n     *\n     *  Entirely blank lines are normalized to a newline character.\n     */\n    // Look for the longest leading string of spaces and tabs common to\n    // all lines.\n    let margin = undefined\n    text = text.replace(_whitespace_only_re, '')\n    let indents = text.match(_leading_whitespace_re) || []\n    for (let indent of indents) {\n        indent = indent.slice(0, -1)\n\n        if (margin === undefined) {\n            margin = indent\n\n        // Current line more deeply indented than previous winner:\n        // no change (previous winner is still on top).\n        } else if (indent.startsWith(margin)) {\n            // pass\n\n        // Current line consistent with and no deeper than previous winner:\n        // it's the new winner.\n        } else if (margin.startsWith(indent)) {\n            margin = indent\n\n        // Find the largest common whitespace between current line and previous\n        // winner.\n        } else {\n            for (let i = 0; i < margin.length && i < indent.length; i++) {\n                if (margin[i] !== indent[i]) {\n                    margin = margin.slice(0, i)\n                    break\n                }\n            }\n        }\n    }\n\n    if (margin) {\n        text = text.replace(new RegExp('^' + margin, 'mg'), '')\n    }\n    return text\n}\n\nmodule.exports = { wrap, fill, dedent }\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}