{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setupTypedRoutes = setupTypedRoutes;\nexports.getTemplateString = getTemplateString;\nexports.getTypedRoutesUtils = getTypedRoutesUtils;\nexports.extrapolateGroupRoutes = extrapolateGroupRoutes;\nexports.setToUnionType = exports.CAPTURE_GROUP_REGEX = exports.ARRAY_GROUP_REGEX = exports.SLUG = exports.CATCH_ALL = exports.CAPTURE_DYNAMIC_PARAMS = void 0;\nvar _promises = _interopRequireDefault(require(\"fs/promises\"));\nvar _lodash = require(\"lodash\");\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _dir = require(\"../../../utils/dir\");\nvar _template = require(\"../../../utils/template\");\nvar _metroWatchTypeScriptFiles = require(\"../metro/metroWatchTypeScriptFiles\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar CAPTURE_DYNAMIC_PARAMS = /\\[(?:\\.{3})?(\\w*?)[\\]$]/g;\nexports.CAPTURE_DYNAMIC_PARAMS = CAPTURE_DYNAMIC_PARAMS;\nvar CATCH_ALL = /\\[\\.\\.\\..+?\\]/g;\nexports.CATCH_ALL = CATCH_ALL;\nvar SLUG = /\\[.+?\\]/g;\nexports.SLUG = SLUG;\nvar ARRAY_GROUP_REGEX = /\\(\\s*\\w[\\w\\s]*?,.*?\\)/g;\nexports.ARRAY_GROUP_REGEX = ARRAY_GROUP_REGEX;\nvar CAPTURE_GROUP_REGEX = /[\\\\(,]\\s*(\\w[\\w\\s]*?)\\s*(?=[,\\\\)])/g;\nexports.CAPTURE_GROUP_REGEX = CAPTURE_GROUP_REGEX;\nfunction setupTypedRoutes(_x) {\n  return _setupTypedRoutes.apply(this, arguments);\n}\nfunction _setupTypedRoutes() {\n  _setupTypedRoutes = _asyncToGenerator(function* (_ref) {\n    var server = _ref.server,\n      metro = _ref.metro,\n      typesDirectory = _ref.typesDirectory,\n      projectRoot = _ref.projectRoot,\n      routerDirectory = _ref.routerDirectory;\n    var absoluteRouterDirectory = _path.default.join(projectRoot, routerDirectory);\n    var _getTypedRoutesUtils = getTypedRoutesUtils(absoluteRouterDirectory),\n      filePathToRoute = _getTypedRoutesUtils.filePathToRoute,\n      staticRoutes = _getTypedRoutesUtils.staticRoutes,\n      dynamicRoutes = _getTypedRoutesUtils.dynamicRoutes,\n      addFilePath = _getTypedRoutesUtils.addFilePath,\n      isRouteFile = _getTypedRoutesUtils.isRouteFile;\n    if (metro) {\n      (0, _metroWatchTypeScriptFiles).metroWatchTypeScriptFiles({\n        projectRoot: projectRoot,\n        server: server,\n        metro: metro,\n        eventTypes: [\"add\", \"delete\", \"change\"],\n        callback: function () {\n          var _callback = _asyncToGenerator(function* (_ref3) {\n            var filePath = _ref3.filePath,\n              type = _ref3.type;\n            if (!isRouteFile(filePath)) {\n              return;\n            }\n            var shouldRegenerate = false;\n            if (type === \"delete\") {\n              var route = filePathToRoute(filePath);\n              staticRoutes.delete(route);\n              dynamicRoutes.delete(route);\n              shouldRegenerate = true;\n            } else {\n              shouldRegenerate = addFilePath(filePath);\n            }\n            if (shouldRegenerate) {\n              regenerateRouterDotTS(typesDirectory, new Set(_toConsumableArray(staticRoutes.values()).flatMap(function (v) {\n                return Array.from(v);\n              })), new Set(_toConsumableArray(dynamicRoutes.values()).flatMap(function (v) {\n                return Array.from(v);\n              })), new Set(dynamicRoutes.keys()));\n            }\n          });\n          function callback(_x8) {\n            return _callback.apply(this, arguments);\n          }\n          return callback;\n        }()\n      });\n    }\n    if (yield (0, _dir).directoryExistsAsync(absoluteRouterDirectory)) {\n      yield walk(absoluteRouterDirectory, addFilePath);\n    }\n    regenerateRouterDotTS(typesDirectory, new Set(_toConsumableArray(staticRoutes.values()).flatMap(function (v) {\n      return Array.from(v);\n    })), new Set(_toConsumableArray(dynamicRoutes.values()).flatMap(function (v) {\n      return Array.from(v);\n    })), new Set(dynamicRoutes.keys()));\n  });\n  return _setupTypedRoutes.apply(this, arguments);\n}\nvar regenerateRouterDotTS = (0, _lodash).debounce(function () {\n  var _ref2 = _asyncToGenerator(function* (typesDir, staticRoutes, dynamicRoutes, dynamicRouteTemplates) {\n    yield _promises.default.mkdir(typesDir, {\n      recursive: true\n    });\n    yield _promises.default.writeFile(_path.default.resolve(typesDir, \"./router.d.ts\"), getTemplateString(staticRoutes, dynamicRoutes, dynamicRouteTemplates));\n  });\n  return function (_x2, _x3, _x4, _x5) {\n    return _ref2.apply(this, arguments);\n  };\n}(), 100);\nfunction getTemplateString(staticRoutes, dynamicRoutes, dynamicRouteTemplates) {\n  return routerDotTSTemplate({\n    staticRoutes: setToUnionType(staticRoutes),\n    dynamicRoutes: setToUnionType(dynamicRoutes),\n    dynamicRouteParams: setToUnionType(dynamicRouteTemplates)\n  });\n}\nfunction getTypedRoutesUtils(appRoot) {\n  var filePathSeperator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _path.default.sep;\n  var staticRoutes = new Map([[\"/\", new Set(\"/\")]]);\n  var dynamicRoutes = new Map();\n  function normalizedFilePath(filePath) {\n    return filePath.replaceAll(filePathSeperator, \"/\");\n  }\n  var normalizedAppRoot = normalizedFilePath(appRoot);\n  var filePathToRoute = function filePathToRoute(filePath) {\n    return normalizedFilePath(filePath).replace(normalizedAppRoot, \"\").replace(/index\\.[jt]sx?/, \"\").replace(/\\.[jt]sx?$/, \"\");\n  };\n  var isRouteFile = function isRouteFile(filePath) {\n    if (filePath.match(/_layout\\.[tj]sx?$/) || filePath.match(/\\/\\+/)) {\n      return false;\n    }\n    var relative = _path.default.relative(appRoot, filePath);\n    return relative && !relative.startsWith(\"..\") && !_path.default.isAbsolute(relative);\n  };\n  var addFilePath = function addFilePath(filePath) {\n    var route1 = filePathToRoute(filePath);\n    if (staticRoutes.has(route1) || dynamicRoutes.has(route1)) {\n      return false;\n    }\n    var dynamicParams = new Set(_toConsumableArray(route1.matchAll(CAPTURE_DYNAMIC_PARAMS)).map(function (match) {\n      return match[1];\n    }));\n    var isDynamic = dynamicParams.size > 0;\n    var addRoute = function addRoute(originalRoute, route) {\n      if (isDynamic) {\n        var set = dynamicRoutes.get(originalRoute);\n        if (!set) {\n          set = new Set();\n          dynamicRoutes.set(originalRoute, set);\n        }\n        set.add(route.replaceAll(CATCH_ALL, \"${CatchAllRoutePart<T>}\").replaceAll(SLUG, \"${SingleRoutePart<T>}\"));\n      } else {\n        var _set = staticRoutes.get(originalRoute);\n        if (!_set) {\n          _set = new Set();\n          staticRoutes.set(originalRoute, _set);\n        }\n        _set.add(route);\n      }\n    };\n    if (!route1.match(ARRAY_GROUP_REGEX)) {\n      addRoute(route1, route1);\n    }\n    if (route1.includes(\"/(\")) {\n      var routeWithoutGroups = route1.replace(/\\/\\(.+?\\)/g, \"\");\n      addRoute(route1, routeWithoutGroups);\n      for (var routeWithSingleGroup of extrapolateGroupRoutes(route1)) {\n        addRoute(route1, routeWithSingleGroup);\n      }\n    }\n    return true;\n  };\n  return {\n    staticRoutes: staticRoutes,\n    dynamicRoutes: dynamicRoutes,\n    filePathToRoute: filePathToRoute,\n    addFilePath: addFilePath,\n    isRouteFile: isRouteFile\n  };\n}\nvar setToUnionType = function setToUnionType(set) {\n  return set.size > 0 ? _toConsumableArray(set).map(function (s) {\n    return `\\`${s}\\``;\n  }).join(\" | \") : \"never\";\n};\nexports.setToUnionType = setToUnionType;\nfunction walk(_x6, _x7) {\n  return _walk.apply(this, arguments);\n}\nfunction _walk() {\n  _walk = _asyncToGenerator(function* (directory, callback) {\n    var files = yield _promises.default.readdir(directory);\n    for (var file of files) {\n      var p = _path.default.join(directory, file);\n      if ((yield _promises.default.stat(p)).isDirectory()) {\n        yield walk(p, callback);\n      } else {\n        var normalizedPath = p.replaceAll(_path.default.sep, \"/\");\n        callback(normalizedPath);\n      }\n    }\n  });\n  return _walk.apply(this, arguments);\n}\nfunction extrapolateGroupRoutes(route) {\n  var routes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n  routes.add(route.replaceAll(ARRAY_GROUP_REGEX, \"\").replaceAll(/\\/+/g, \"/\").replace(/\\/$/, \"\"));\n  var match = route.match(ARRAY_GROUP_REGEX);\n  if (!match) {\n    routes.add(route);\n    return routes;\n  }\n  var groupsMatch = match[0];\n  for (var group of groupsMatch.matchAll(CAPTURE_GROUP_REGEX)) {\n    extrapolateGroupRoutes(route.replace(groupsMatch, `(${group[1].trim()})`), routes);\n  }\n  return routes;\n}\nvar routerDotTSTemplate = _template.unsafeTemplate`/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable import/export */\n/* eslint-disable @typescript-eslint/ban-types */\ndeclare module \"expo-router\" {\n  import type { LinkProps as OriginalLinkProps } from 'expo-router/build/link/Link';\n  import type { Router as OriginalRouter } from 'expo-router/src/types';\n  export * from 'expo-router/build';\n\n  // prettier-ignore\n  type StaticRoutes = ${\"staticRoutes\"};\n  // prettier-ignore\n  type DynamicRoutes<T extends string> = ${\"dynamicRoutes\"};\n  // prettier-ignore\n  type DynamicRouteTemplate = ${\"dynamicRouteParams\"};\n\n  type RelativePathString = \\`./\\${string}\\` | \\`../\\${string}\\` | '..';\n  type AbsoluteRoute = DynamicRouteTemplate | StaticRoutes;\n  type ExternalPathString = \\`http\\${string}\\`;\n  type ExpoRouterRoutes = DynamicRouteTemplate | StaticRoutes | RelativePathString;\n  type AllRoutes = ExpoRouterRoutes | ExternalPathString;\n\n  /****************\n   * Route Utils  *\n   ****************/\n\n  type SearchOrHash = \\`?\\${string}\\` | \\`#\\${string}\\`;\n  type UnknownInputParams = Record<string, string | number | (string | number)[]>;\n  type UnknownOutputParams = Record<string, string | string[]>;\n\n  /**\n   * Return only the RoutePart of a string. If the string has multiple parts return never\n   *\n   * string   | type\n   * ---------|------\n   * 123      | 123\n   * /123/abc | never\n   * 123?abc  | never\n   * ./123    | never\n   * /123     | never\n   * 123/../  | never\n   */\n  type SingleRoutePart<S extends string> = S extends \\`\\${string}/\\${string}\\`\n    ? never\n    : S extends \\`\\${string}\\${SearchOrHash}\\`\n    ? never\n    : S extends ''\n    ? never\n    : S extends \\`(\\${string})\\`\n    ? never\n    : S extends \\`[\\${string}]\\`\n    ? never\n    : S;\n\n  /**\n   * Return only the CatchAll router part. If the string has search parameters or a hash return never\n   */\n  type CatchAllRoutePart<S extends string> = S extends \\`\\${string}\\${SearchOrHash}\\`\n    ? never\n    : S extends ''\n    ? never\n    : S extends \\`\\${string}(\\${string})\\${string}\\`\n    ? never\n    : S extends \\`\\${string}[\\${string}]\\${string}\\`\n    ? never\n    : S;\n\n  // type OptionalCatchAllRoutePart<S extends string> = S extends \\`\\${string}\\${SearchOrHash}\\` ? never : S\n\n  /**\n   * Return the name of a route parameter\n   * '[test]'    -> 'test'\n   * 'test'      -> never\n   * '[...test]' -> '...test'\n   */\n  type IsParameter<Part> = Part extends \\`[\\${infer ParamName}]\\` ? ParamName : never;\n\n  /**\n   * Return a union of all parameter names. If there are no names return never\n   *\n   * /[test]         -> 'test'\n   * /[abc]/[...def] -> 'abc'|'...def'\n   */\n  type ParameterNames<Path> = Path extends \\`\\${infer PartA}/\\${infer PartB}\\`\n    ? IsParameter<PartA> | ParameterNames<PartB>\n    : IsParameter<Path>;\n\n  /**\n   * Returns all segements of a route.\n   *\n   * /(group)/123/abc/[id]/[...rest] -> ['(group)', '123', 'abc', '[id]', '[...rest]'\n   */\n  type RouteSegments<Path> = Path extends \\`\\${infer PartA}/\\${infer PartB}\\`\n    ? PartA extends '' | '.'\n      ? [...RouteSegments<PartB>]\n      : [PartA, ...RouteSegments<PartB>]\n    : Path extends ''\n    ? []\n    : [Path];\n\n  /**\n   * Returns a Record of the routes parameters as strings and CatchAll parameters\n   *\n   * There are two versions, input and output, as you can input 'string | number' but\n   *  the output will always be 'string'\n   *\n   * /[id]/[...rest] -> { id: string, rest: string[] }\n   * /no-params      -> {}\n   */\n  type InputRouteParams<Path> = {\n    [Key in ParameterNames<Path> as Key extends \\`...\\${infer Name}\\`\n      ? Name\n      : Key]: Key extends \\`...\\${string}\\` ? (string | number)[] : string | number;\n  } & UnknownInputParams;\n\n  type OutputRouteParams<Path> = {\n    [Key in ParameterNames<Path> as Key extends \\`...\\${infer Name}\\`\n      ? Name\n      : Key]: Key extends \\`...\\${string}\\` ? string[] : string;\n  } & UnknownOutputParams;\n\n  /**\n   * Returns the search parameters for a route.\n   */\n  export type SearchParams<T extends AllRoutes> = T extends DynamicRouteTemplate\n    ? OutputRouteParams<T>\n    : T extends StaticRoutes\n    ? never\n    : UnknownOutputParams;\n\n  /**\n   * Route is mostly used as part of Href to ensure that a valid route is provided\n   *\n   * Given a dynamic route, this will return never. This is helpful for conditional logic\n   *\n   * /test         -> /test, /test2, etc\n   * /test/[abc]   -> never\n   * /test/resolve -> /test, /test2, etc\n   *\n   * Note that if we provide a value for [abc] then the route is allowed\n   *\n   * This is named Route to prevent confusion, as users they will often see it in tooltips\n   */\n  export type Route<T> = T extends string\n    ? T extends DynamicRouteTemplate\n      ? never\n      :\n          | StaticRoutes\n          | RelativePathString\n          | ExternalPathString\n          | (T extends \\`\\${infer P}\\${SearchOrHash}\\`\n              ? P extends DynamicRoutes<infer _>\n                ? T\n                : never\n              : T extends DynamicRoutes<infer _>\n              ? T\n              : never)\n    : never;\n\n  /*********\n   * Href  *\n   *********/\n\n  export type Href<T> = T extends Record<'pathname', string> ? HrefObject<T> : Route<T>;\n\n  export type HrefObject<\n    R extends Record<'pathname', string>,\n    P = R['pathname']\n  > = P extends DynamicRouteTemplate\n    ? { pathname: P; params: InputRouteParams<P> }\n    : P extends Route<P>\n    ? { pathname: Route<P> | DynamicRouteTemplate; params?: never | InputRouteParams<never> }\n    : never;\n\n  /***********************\n   * Expo Router Exports *\n   ***********************/\n\n  export type Router = Omit<OriginalRouter, 'push' | 'replace' | 'setParams'> & {\n    /** Navigate to the provided href. */\n    push: <T>(href: Href<T>) => void;\n    /** Navigate to route without appending to the history. */\n    replace: <T>(href: Href<T>) => void;\n    /** Update the current route query params. */\n    setParams: <T = ''>(params?: T extends '' ? Record<string, string> : InputRouteParams<T>) => void;\n  };\n\n  /** The imperative router. */\n  export const router: Router;\n\n  /************\n   * <Link /> *\n   ************/\n  export interface LinkProps<T> extends OriginalLinkProps {\n    href: Href<T>;\n  }\n\n  export interface LinkComponent {\n    <T>(props: React.PropsWithChildren<LinkProps<T>>): JSX.Element;\n    /** Helper method to resolve an Href object into a string. */\n    resolveHref: <T>(href: Href<T>) => string;\n  }\n\n  /**\n   * Component to render link to another route using a path.\n   * Uses an anchor tag on the web.\n   *\n   * @param props.href Absolute path to route (e.g. \\`/feeds/hot\\`).\n   * @param props.replace Should replace the current route without adding to the history.\n   * @param props.asChild Forward props to child component. Useful for custom buttons.\n   * @param props.children Child elements to render the content.\n   */\n  export const Link: LinkComponent;\n  \n  /** Redirects to the href as soon as the component is mounted. */\n  export const Redirect: <T>(\n    props: React.PropsWithChildren<{ href: Href<T> }>\n  ) => JSX.Element;\n\n  /************\n   * Hooks *\n   ************/\n  export function useRouter(): Router;\n\n  export function useLocalSearchParams<\n    T extends AllRoutes | UnknownOutputParams = UnknownOutputParams\n  >(): T extends AllRoutes ? SearchParams<T> : T;\n\n  /** @deprecated renamed to \\`useGlobalSearchParams\\` */\n  export function useSearchParams<\n    T extends AllRoutes | UnknownOutputParams = UnknownOutputParams\n  >(): T extends AllRoutes ? SearchParams<T> : T;\n\n  export function useGlobalSearchParams<\n    T extends AllRoutes | UnknownOutputParams = UnknownOutputParams\n  >(): T extends AllRoutes ? SearchParams<T> : T;\n\n  export function useSegments<\n    T extends AbsoluteRoute | RouteSegments<AbsoluteRoute> | RelativePathString\n  >(): T extends AbsoluteRoute ? RouteSegments<T> : T extends string ? string[] : T;\n}\n`;","map":{"version":3,"names":["_toConsumableArray","require","_asyncToGenerator","setupTypedRoutes","getTemplateString","getTypedRoutesUtils","extrapolateGroupRoutes","_promises","_interopRequireDefault","_lodash","_path","_dir","_template","_metroWatchTypeScriptFiles","CAPTURE_DYNAMIC_PARAMS","CATCH_ALL","SLUG","ARRAY_GROUP_REGEX","CAPTURE_GROUP_REGEX","_x","_setupTypedRoutes","apply","arguments","_ref","server","metro","typesDirectory","projectRoot","routerDirectory","absoluteRouterDirectory","default","join","_getTypedRoutesUtils","filePathToRoute","staticRoutes","dynamicRoutes","addFilePath","isRouteFile","metroWatchTypeScriptFiles","eventTypes","callback","_callback","_ref3","filePath","type","shouldRegenerate","route","delete","regenerateRouterDotTS","Set","values","flatMap","v","Array","from","keys","_x8","directoryExistsAsync","walk","debounce","_ref2","typesDir","dynamicRouteTemplates","mkdir","recursive","writeFile","resolve","_x2","_x3","_x4","_x5","routerDotTSTemplate","setToUnionType","dynamicRouteParams","appRoot","filePathSeperator","length","undefined","sep","Map","normalizedFilePath","replaceAll","normalizedAppRoot","replace","match","relative","startsWith","isAbsolute","route1","has","dynamicParams","matchAll","map","isDynamic","size","addRoute","originalRoute","set","get","add","includes","routeWithoutGroups","routeWithSingleGroup","s","_x6","_x7","_walk","directory","files","readdir","file","p","stat","isDirectory","normalizedPath","routes","groupsMatch","group","trim","unsafeTemplate"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\cli\\src\\start\\server\\type-generation\\routes.ts"],"sourcesContent":["import fs from 'fs/promises';\nimport { debounce } from 'lodash';\nimport { Server } from 'metro';\nimport path from 'path';\n\nimport { directoryExistsAsync } from '../../../utils/dir';\nimport { unsafeTemplate } from '../../../utils/template';\nimport { ServerLike } from '../BundlerDevServer';\nimport { metroWatchTypeScriptFiles } from '../metro/metroWatchTypeScriptFiles';\n\n// /test/[...param1]/[param2]/[param3] - captures [\"param1\", \"param2\", \"param3\"]\nexport const CAPTURE_DYNAMIC_PARAMS = /\\[(?:\\.{3})?(\\w*?)[\\]$]/g;\n// /[...param1]/ - Match [...param1]\nexport const CATCH_ALL = /\\[\\.\\.\\..+?\\]/g;\n// /[param1] - Match [param1]\nexport const SLUG = /\\[.+?\\]/g;\n// /(group1,group2,group3)/test - match (group1,group2,group3)\nexport const ARRAY_GROUP_REGEX = /\\(\\s*\\w[\\w\\s]*?,.*?\\)/g;\n// /(group1,group2,group3)/test - captures [\"group1\", \"group2\", \"group3\"]\nexport const CAPTURE_GROUP_REGEX = /[\\\\(,]\\s*(\\w[\\w\\s]*?)\\s*(?=[,\\\\)])/g;\n\nexport interface SetupTypedRoutesOptions {\n  server: ServerLike;\n  metro?: Server | null;\n  typesDirectory: string;\n  projectRoot: string;\n  routerDirectory: string;\n}\n\nexport async function setupTypedRoutes({\n  server,\n  metro,\n  typesDirectory,\n  projectRoot,\n  routerDirectory,\n}: SetupTypedRoutesOptions) {\n  const absoluteRouterDirectory = path.join(projectRoot, routerDirectory);\n\n  const { filePathToRoute, staticRoutes, dynamicRoutes, addFilePath, isRouteFile } =\n    getTypedRoutesUtils(absoluteRouterDirectory);\n\n  if (metro) {\n    // Setup out watcher first\n    metroWatchTypeScriptFiles({\n      projectRoot,\n      server,\n      metro,\n      eventTypes: ['add', 'delete', 'change'],\n      async callback({ filePath, type }) {\n        if (!isRouteFile(filePath)) {\n          return;\n        }\n\n        let shouldRegenerate = false;\n\n        if (type === 'delete') {\n          const route = filePathToRoute(filePath);\n          staticRoutes.delete(route);\n          dynamicRoutes.delete(route);\n          shouldRegenerate = true;\n        } else {\n          shouldRegenerate = addFilePath(filePath);\n        }\n\n        if (shouldRegenerate) {\n          regenerateRouterDotTS(\n            typesDirectory,\n            new Set([...staticRoutes.values()].flatMap((v) => Array.from(v))),\n            new Set([...dynamicRoutes.values()].flatMap((v) => Array.from(v))),\n            new Set(dynamicRoutes.keys())\n          );\n        }\n      },\n    });\n  }\n\n  if (await directoryExistsAsync(absoluteRouterDirectory)) {\n    // Do we need to walk the entire tree on startup?\n    // Idea: Store the list of files in the last write, then simply check Git for what files have changed\n    await walk(absoluteRouterDirectory, addFilePath);\n  }\n\n  regenerateRouterDotTS(\n    typesDirectory,\n    new Set([...staticRoutes.values()].flatMap((v) => Array.from(v))),\n    new Set([...dynamicRoutes.values()].flatMap((v) => Array.from(v))),\n    new Set(dynamicRoutes.keys())\n  );\n}\n\n/**\n * Generate a router.d.ts file that contains all of the routes in the project.\n * Should be debounced as its very common for developers to make changes to multiple files at once (eg Save All)\n */\nconst regenerateRouterDotTS = debounce(\n  async (\n    typesDir: string,\n    staticRoutes: Set<string>,\n    dynamicRoutes: Set<string>,\n    dynamicRouteTemplates: Set<string>\n  ) => {\n    await fs.mkdir(typesDir, { recursive: true });\n    await fs.writeFile(\n      path.resolve(typesDir, './router.d.ts'),\n      getTemplateString(staticRoutes, dynamicRoutes, dynamicRouteTemplates)\n    );\n  },\n  100\n);\n\n/*\n * This is exported for testing purposes\n */\nexport function getTemplateString(\n  staticRoutes: Set<string>,\n  dynamicRoutes: Set<string>,\n  dynamicRouteTemplates: Set<string>\n) {\n  return routerDotTSTemplate({\n    staticRoutes: setToUnionType(staticRoutes),\n    dynamicRoutes: setToUnionType(dynamicRoutes),\n    dynamicRouteParams: setToUnionType(dynamicRouteTemplates),\n  });\n}\n\n/**\n * Utility functions for typed routes\n *\n * These are extracted for easier testing\n */\nexport function getTypedRoutesUtils(appRoot: string, filePathSeperator = path.sep) {\n  /*\n   * staticRoutes are a map where the key if the route without groups and the value\n   *   is another set of all group versions of the route. e.g,\n   *    Map([\n   *      [\"/\", [\"/(app)/(notes)\", \"/(app)/(profile)\"]\n   *    ])\n   */\n  const staticRoutes = new Map<string, Set<string>>([['/', new Set('/')]]);\n  /*\n   * dynamicRoutes are the same as staticRoutes (key if the resolved route,\n   *   and the value is a set of possible routes). e.g:\n   *\n   * /[...fruits] -> /${CatchAllRoutePart<T>}\n   * /color/[color] -> /color/${SingleRoutePart<T>}\n   *\n   * The keys of this map are also important, as they can be used as \"static\" types\n   * <Link href={{ pathname: \"/[...fruits]\",params: { fruits: [\"apple\"] } }} />\n   */\n  const dynamicRoutes = new Map<string, Set<string>>();\n\n  function normalizedFilePath(filePath: string) {\n    return filePath.replaceAll(filePathSeperator, '/');\n  }\n\n  const normalizedAppRoot = normalizedFilePath(appRoot);\n\n  const filePathToRoute = (filePath: string) => {\n    return normalizedFilePath(filePath)\n      .replace(normalizedAppRoot, '')\n      .replace(/index\\.[jt]sx?/, '')\n      .replace(/\\.[jt]sx?$/, '');\n  };\n\n  const isRouteFile = (filePath: string) => {\n    // Layout and filenames starting with `+` are not routes\n    if (filePath.match(/_layout\\.[tj]sx?$/) || filePath.match(/\\/\\+/)) {\n      return false;\n    }\n\n    // Route files must be nested with in the appRoot\n    const relative = path.relative(appRoot, filePath);\n    return relative && !relative.startsWith('..') && !path.isAbsolute(relative);\n  };\n\n  const addFilePath = (filePath: string): boolean => {\n    const route = filePathToRoute(filePath);\n\n    // We have already processed this file\n    if (staticRoutes.has(route) || dynamicRoutes.has(route)) {\n      return false;\n    }\n\n    const dynamicParams = new Set(\n      [...route.matchAll(CAPTURE_DYNAMIC_PARAMS)].map((match) => match[1])\n    );\n    const isDynamic = dynamicParams.size > 0;\n\n    const addRoute = (originalRoute: string, route: string) => {\n      if (isDynamic) {\n        let set = dynamicRoutes.get(originalRoute);\n\n        if (!set) {\n          set = new Set();\n          dynamicRoutes.set(originalRoute, set);\n        }\n\n        set.add(\n          route\n            .replaceAll(CATCH_ALL, '${CatchAllRoutePart<T>}')\n            .replaceAll(SLUG, '${SingleRoutePart<T>}')\n        );\n      } else {\n        let set = staticRoutes.get(originalRoute);\n\n        if (!set) {\n          set = new Set();\n          staticRoutes.set(originalRoute, set);\n        }\n\n        set.add(route);\n      }\n    };\n\n    if (!route.match(ARRAY_GROUP_REGEX)) {\n      addRoute(route, route);\n    }\n\n    // Does this route have a group? eg /(group)\n    if (route.includes('/(')) {\n      const routeWithoutGroups = route.replace(/\\/\\(.+?\\)/g, '');\n      addRoute(route, routeWithoutGroups);\n\n      // If there are multiple groups, we need to expand them\n      // eg /(test1,test2)/page => /test1/page & /test2/page\n      for (const routeWithSingleGroup of extrapolateGroupRoutes(route)) {\n        addRoute(route, routeWithSingleGroup);\n      }\n    }\n\n    return true;\n  };\n\n  return {\n    staticRoutes,\n    dynamicRoutes,\n    filePathToRoute,\n    addFilePath,\n    isRouteFile,\n  };\n}\n\nexport const setToUnionType = <T>(set: Set<T>) => {\n  return set.size > 0 ? [...set].map((s) => `\\`${s}\\``).join(' | ') : 'never';\n};\n\n/**\n * Recursively walk a directory and call the callback with the file path.\n */\nasync function walk(directory: string, callback: (filePath: string) => void) {\n  const files = await fs.readdir(directory);\n  for (const file of files) {\n    const p = path.join(directory, file);\n    if ((await fs.stat(p)).isDirectory()) {\n      await walk(p, callback);\n    } else {\n      // Normalise the paths so they are easier to convert to URLs\n      const normalizedPath = p.replaceAll(path.sep, '/');\n      callback(normalizedPath);\n    }\n  }\n}\n\n/**\n * Given a route, return all possible routes that could be generated from it.\n */\nexport function extrapolateGroupRoutes(\n  route: string,\n  routes: Set<string> = new Set()\n): Set<string> {\n  // Create a version with no groups. We will then need to cleanup double and/or trailing slashes\n  routes.add(route.replaceAll(ARRAY_GROUP_REGEX, '').replaceAll(/\\/+/g, '/').replace(/\\/$/, ''));\n\n  const match = route.match(ARRAY_GROUP_REGEX);\n\n  if (!match) {\n    routes.add(route);\n    return routes;\n  }\n\n  const groupsMatch = match[0];\n\n  for (const group of groupsMatch.matchAll(CAPTURE_GROUP_REGEX)) {\n    extrapolateGroupRoutes(route.replace(groupsMatch, `(${group[1].trim()})`), routes);\n  }\n\n  return routes;\n}\n\n/**\n * NOTE: This code refers to a specific version of `expo-router` and is therefore unsafe to\n * mix with arbitrary versions.\n * TODO: Version this code with `expo-router` or version expo-router with `@expo/cli`.\n */\nconst routerDotTSTemplate = unsafeTemplate`/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable import/export */\n/* eslint-disable @typescript-eslint/ban-types */\ndeclare module \"expo-router\" {\n  import type { LinkProps as OriginalLinkProps } from 'expo-router/build/link/Link';\n  import type { Router as OriginalRouter } from 'expo-router/src/types';\n  export * from 'expo-router/build';\n\n  // prettier-ignore\n  type StaticRoutes = ${'staticRoutes'};\n  // prettier-ignore\n  type DynamicRoutes<T extends string> = ${'dynamicRoutes'};\n  // prettier-ignore\n  type DynamicRouteTemplate = ${'dynamicRouteParams'};\n\n  type RelativePathString = \\`./\\${string}\\` | \\`../\\${string}\\` | '..';\n  type AbsoluteRoute = DynamicRouteTemplate | StaticRoutes;\n  type ExternalPathString = \\`http\\${string}\\`;\n  type ExpoRouterRoutes = DynamicRouteTemplate | StaticRoutes | RelativePathString;\n  type AllRoutes = ExpoRouterRoutes | ExternalPathString;\n\n  /****************\n   * Route Utils  *\n   ****************/\n\n  type SearchOrHash = \\`?\\${string}\\` | \\`#\\${string}\\`;\n  type UnknownInputParams = Record<string, string | number | (string | number)[]>;\n  type UnknownOutputParams = Record<string, string | string[]>;\n\n  /**\n   * Return only the RoutePart of a string. If the string has multiple parts return never\n   *\n   * string   | type\n   * ---------|------\n   * 123      | 123\n   * /123/abc | never\n   * 123?abc  | never\n   * ./123    | never\n   * /123     | never\n   * 123/../  | never\n   */\n  type SingleRoutePart<S extends string> = S extends \\`\\${string}/\\${string}\\`\n    ? never\n    : S extends \\`\\${string}\\${SearchOrHash}\\`\n    ? never\n    : S extends ''\n    ? never\n    : S extends \\`(\\${string})\\`\n    ? never\n    : S extends \\`[\\${string}]\\`\n    ? never\n    : S;\n\n  /**\n   * Return only the CatchAll router part. If the string has search parameters or a hash return never\n   */\n  type CatchAllRoutePart<S extends string> = S extends \\`\\${string}\\${SearchOrHash}\\`\n    ? never\n    : S extends ''\n    ? never\n    : S extends \\`\\${string}(\\${string})\\${string}\\`\n    ? never\n    : S extends \\`\\${string}[\\${string}]\\${string}\\`\n    ? never\n    : S;\n\n  // type OptionalCatchAllRoutePart<S extends string> = S extends \\`\\${string}\\${SearchOrHash}\\` ? never : S\n\n  /**\n   * Return the name of a route parameter\n   * '[test]'    -> 'test'\n   * 'test'      -> never\n   * '[...test]' -> '...test'\n   */\n  type IsParameter<Part> = Part extends \\`[\\${infer ParamName}]\\` ? ParamName : never;\n\n  /**\n   * Return a union of all parameter names. If there are no names return never\n   *\n   * /[test]         -> 'test'\n   * /[abc]/[...def] -> 'abc'|'...def'\n   */\n  type ParameterNames<Path> = Path extends \\`\\${infer PartA}/\\${infer PartB}\\`\n    ? IsParameter<PartA> | ParameterNames<PartB>\n    : IsParameter<Path>;\n\n  /**\n   * Returns all segements of a route.\n   *\n   * /(group)/123/abc/[id]/[...rest] -> ['(group)', '123', 'abc', '[id]', '[...rest]'\n   */\n  type RouteSegments<Path> = Path extends \\`\\${infer PartA}/\\${infer PartB}\\`\n    ? PartA extends '' | '.'\n      ? [...RouteSegments<PartB>]\n      : [PartA, ...RouteSegments<PartB>]\n    : Path extends ''\n    ? []\n    : [Path];\n\n  /**\n   * Returns a Record of the routes parameters as strings and CatchAll parameters\n   *\n   * There are two versions, input and output, as you can input 'string | number' but\n   *  the output will always be 'string'\n   *\n   * /[id]/[...rest] -> { id: string, rest: string[] }\n   * /no-params      -> {}\n   */\n  type InputRouteParams<Path> = {\n    [Key in ParameterNames<Path> as Key extends \\`...\\${infer Name}\\`\n      ? Name\n      : Key]: Key extends \\`...\\${string}\\` ? (string | number)[] : string | number;\n  } & UnknownInputParams;\n\n  type OutputRouteParams<Path> = {\n    [Key in ParameterNames<Path> as Key extends \\`...\\${infer Name}\\`\n      ? Name\n      : Key]: Key extends \\`...\\${string}\\` ? string[] : string;\n  } & UnknownOutputParams;\n\n  /**\n   * Returns the search parameters for a route.\n   */\n  export type SearchParams<T extends AllRoutes> = T extends DynamicRouteTemplate\n    ? OutputRouteParams<T>\n    : T extends StaticRoutes\n    ? never\n    : UnknownOutputParams;\n\n  /**\n   * Route is mostly used as part of Href to ensure that a valid route is provided\n   *\n   * Given a dynamic route, this will return never. This is helpful for conditional logic\n   *\n   * /test         -> /test, /test2, etc\n   * /test/[abc]   -> never\n   * /test/resolve -> /test, /test2, etc\n   *\n   * Note that if we provide a value for [abc] then the route is allowed\n   *\n   * This is named Route to prevent confusion, as users they will often see it in tooltips\n   */\n  export type Route<T> = T extends string\n    ? T extends DynamicRouteTemplate\n      ? never\n      :\n          | StaticRoutes\n          | RelativePathString\n          | ExternalPathString\n          | (T extends \\`\\${infer P}\\${SearchOrHash}\\`\n              ? P extends DynamicRoutes<infer _>\n                ? T\n                : never\n              : T extends DynamicRoutes<infer _>\n              ? T\n              : never)\n    : never;\n\n  /*********\n   * Href  *\n   *********/\n\n  export type Href<T> = T extends Record<'pathname', string> ? HrefObject<T> : Route<T>;\n\n  export type HrefObject<\n    R extends Record<'pathname', string>,\n    P = R['pathname']\n  > = P extends DynamicRouteTemplate\n    ? { pathname: P; params: InputRouteParams<P> }\n    : P extends Route<P>\n    ? { pathname: Route<P> | DynamicRouteTemplate; params?: never | InputRouteParams<never> }\n    : never;\n\n  /***********************\n   * Expo Router Exports *\n   ***********************/\n\n  export type Router = Omit<OriginalRouter, 'push' | 'replace' | 'setParams'> & {\n    /** Navigate to the provided href. */\n    push: <T>(href: Href<T>) => void;\n    /** Navigate to route without appending to the history. */\n    replace: <T>(href: Href<T>) => void;\n    /** Update the current route query params. */\n    setParams: <T = ''>(params?: T extends '' ? Record<string, string> : InputRouteParams<T>) => void;\n  };\n\n  /** The imperative router. */\n  export const router: Router;\n\n  /************\n   * <Link /> *\n   ************/\n  export interface LinkProps<T> extends OriginalLinkProps {\n    href: Href<T>;\n  }\n\n  export interface LinkComponent {\n    <T>(props: React.PropsWithChildren<LinkProps<T>>): JSX.Element;\n    /** Helper method to resolve an Href object into a string. */\n    resolveHref: <T>(href: Href<T>) => string;\n  }\n\n  /**\n   * Component to render link to another route using a path.\n   * Uses an anchor tag on the web.\n   *\n   * @param props.href Absolute path to route (e.g. \\`/feeds/hot\\`).\n   * @param props.replace Should replace the current route without adding to the history.\n   * @param props.asChild Forward props to child component. Useful for custom buttons.\n   * @param props.children Child elements to render the content.\n   */\n  export const Link: LinkComponent;\n  \n  /** Redirects to the href as soon as the component is mounted. */\n  export const Redirect: <T>(\n    props: React.PropsWithChildren<{ href: Href<T> }>\n  ) => JSX.Element;\n\n  /************\n   * Hooks *\n   ************/\n  export function useRouter(): Router;\n\n  export function useLocalSearchParams<\n    T extends AllRoutes | UnknownOutputParams = UnknownOutputParams\n  >(): T extends AllRoutes ? SearchParams<T> : T;\n\n  /** @deprecated renamed to \\`useGlobalSearchParams\\` */\n  export function useSearchParams<\n    T extends AllRoutes | UnknownOutputParams = UnknownOutputParams\n  >(): T extends AllRoutes ? SearchParams<T> : T;\n\n  export function useGlobalSearchParams<\n    T extends AllRoutes | UnknownOutputParams = UnknownOutputParams\n  >(): T extends AllRoutes ? SearchParams<T> : T;\n\n  export function useSegments<\n    T extends AbsoluteRoute | RouteSegments<AbsoluteRoute> | RelativePathString\n  >(): T extends AbsoluteRoute ? RouteSegments<T> : T extends string ? string[] : T;\n}\n`;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}