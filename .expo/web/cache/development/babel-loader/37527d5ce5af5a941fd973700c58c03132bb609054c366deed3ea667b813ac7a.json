{"ast":null,"code":"","map":{"version":3,"names":[],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@expo/cli/node_modules/type-fest/source/conditional-keys.d.ts"],"sourcesContent":["/**\nExtract the keys from a type where the value type of the key extends the given `Condition`.\n\nInternally this is used for the `ConditionalPick` and `ConditionalExcept` types.\n\n@example\n```\nimport {ConditionalKeys} from 'type-fest';\n\ninterface Example {\n\ta: string;\n\tb: string | number;\n\tc?: string;\n\td: {};\n}\n\ntype StringKeysOnly = ConditionalKeys<Example, string>;\n//=> 'a'\n```\n\nTo support partial types, make sure your `Condition` is a union of undefined (for example, `string | undefined`) as demonstrated below.\n\n@example\n```\ntype StringKeysAndUndefined = ConditionalKeys<Example, string | undefined>;\n//=> 'a' | 'c'\n```\n*/\nexport type ConditionalKeys<Base, Condition> = NonNullable<\n\t// Wrap in `NonNullable` to strip away the `undefined` type from the produced union.\n\t{\n\t\t// Map through all the keys of the given base type.\n\t\t[Key in keyof Base]:\n\t\t\t// Pick only keys with types extending the given `Condition` type.\n\t\t\tBase[Key] extends Condition\n\t\t\t\t// Retain this key since the condition passes.\n\t\t\t\t? Key\n\t\t\t\t// Discard this key since the condition fails.\n\t\t\t\t: never;\n\n\t// Convert the produced object into a union type of the keys which passed the conditional test.\n\t}[keyof Base]\n>;\n"],"mappings":""},"metadata":{},"sourceType":"script","externalDependencies":[]}