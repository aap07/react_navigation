{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar tslib_1 = require(\"tslib\");\nvar fs_1 = require(\"fs\");\nvar debug_1 = tslib_1.__importDefault(require(\"debug\"));\nvar command_exists_1 = require(\"command-exists\");\nvar rimraf_1 = tslib_1.__importDefault(require(\"rimraf\"));\nvar constants_1 = require(\"./constants\");\nvar platforms_1 = tslib_1.__importDefault(require(\"./platforms\"));\nvar certificate_authority_1 = tslib_1.__importStar(require(\"./certificate-authority\"));\nexports.uninstall = certificate_authority_1.uninstall;\nvar certificates_1 = tslib_1.__importDefault(require(\"./certificates\"));\nvar user_interface_1 = tslib_1.__importDefault(require(\"./user-interface\"));\nvar debug = debug_1.default('devcert');\nfunction certificateFor(domain) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return tslib_1.__awaiter(this, void 0, void 0, function* () {\n    if (constants_1.VALID_IP.test(domain)) {\n      throw new Error('IP addresses are not supported currently');\n    }\n    if (!constants_1.VALID_DOMAIN.test(domain)) {\n      throw new Error(`\"${domain}\" is not a valid domain name.`);\n    }\n    debug(`Certificate requested for ${domain}. Skipping certutil install: ${Boolean(options.skipCertutilInstall)}. Skipping hosts file: ${Boolean(options.skipHostsFile)}`);\n    if (options.ui) {\n      Object.assign(user_interface_1.default, options.ui);\n    }\n    if (!constants_1.isMac && !constants_1.isLinux && !constants_1.isWindows) {\n      throw new Error(`Platform not supported: \"${process.platform}\"`);\n    }\n    if (!command_exists_1.sync('openssl')) {\n      throw new Error('OpenSSL not found: OpenSSL is required to generate SSL certificates - make sure it is installed and available in your PATH');\n    }\n    var domainKeyPath = constants_1.pathForDomain(domain, `private-key.key`);\n    var domainCertPath = constants_1.pathForDomain(domain, `certificate.crt`);\n    if (!fs_1.existsSync(constants_1.rootCAKeyPath)) {\n      debug('Root CA is not installed yet, so it must be our first run. Installing root CA ...');\n      yield certificate_authority_1.default(options);\n    } else if (options.getCaBuffer || options.getCaPath) {\n      debug('Root CA is not readable, but it probably is because an earlier version of devcert locked it. Trying to fix...');\n      yield certificate_authority_1.ensureCACertReadable(options);\n    }\n    if (!fs_1.existsSync(constants_1.pathForDomain(domain, `certificate.crt`))) {\n      debug(`Can't find certificate file for ${domain}, so it must be the first request for ${domain}. Generating and caching ...`);\n      yield certificates_1.default(domain);\n    }\n    if (!options.skipHostsFile) {\n      yield platforms_1.default.addDomainToHostFileIfMissing(domain);\n    }\n    debug(`Returning domain certificate`);\n    var ret = {\n      key: fs_1.readFileSync(domainKeyPath),\n      cert: fs_1.readFileSync(domainCertPath)\n    };\n    if (options.getCaBuffer) ret.ca = fs_1.readFileSync(constants_1.rootCACertPath);\n    if (options.getCaPath) ret.caPath = constants_1.rootCACertPath;\n    return ret;\n  });\n}\nexports.certificateFor = certificateFor;\nfunction hasCertificateFor(domain) {\n  return fs_1.existsSync(constants_1.pathForDomain(domain, `certificate.crt`));\n}\nexports.hasCertificateFor = hasCertificateFor;\nfunction configuredDomains() {\n  return fs_1.readdirSync(constants_1.domainsDir);\n}\nexports.configuredDomains = configuredDomains;\nfunction removeDomain(domain) {\n  return rimraf_1.default.sync(constants_1.pathForDomain(domain));\n}\nexports.removeDomain = removeDomain;","map":{"version":3,"names":["fs_1","require","debug_1","tslib_1","__importDefault","command_exists_1","rimraf_1","constants_1","platforms_1","certificate_authority_1","__importStar","exports","uninstall","certificates_1","user_interface_1","debug","default","certificateFor","domain","options","arguments","length","undefined","VALID_IP","test","Error","VALID_DOMAIN","Boolean","skipCertutilInstall","skipHostsFile","ui","Object","assign","isMac","isLinux","isWindows","process","platform","sync","domainKeyPath","pathForDomain","domainCertPath","existsSync","rootCAKeyPath","getCaBuffer","getCaPath","ensureCACertReadable","addDomainToHostFileIfMissing","ret","key","readFileSync","cert","ca","rootCACertPath","caPath","hasCertificateFor","configuredDomains","readdirSync","domainsDir","removeDomain"],"sources":["\\Users\\evanbacon\\Documents\\GitHub\\devcert\\index.ts"],"sourcesContent":["import { readFileSync as readFile, readdirSync as readdir, existsSync as exists } from 'fs';\nimport createDebug from 'debug';\nimport { sync as commandExists } from 'command-exists';\nimport rimraf from 'rimraf';\nimport {\n  isMac,\n  isLinux,\n  isWindows,\n  pathForDomain,\n  domainsDir,\n  rootCAKeyPath,\n  rootCACertPath,\n  VALID_DOMAIN,\n  VALID_IP\n} from './constants';\nimport currentPlatform from './platforms';\nimport installCertificateAuthority, { ensureCACertReadable, uninstall } from './certificate-authority';\nimport generateDomainCertificate from './certificates';\nimport UI, { UserInterface } from './user-interface';\nexport { uninstall };\n\nconst debug = createDebug('devcert');\n\nexport interface Options /* extends Partial<ICaBufferOpts & ICaPathOpts>  */{\n  /** Return the CA certificate data? */\n  getCaBuffer?: boolean;\n  /** Return the path to the CA certificate? */\n  getCaPath?: boolean;\n  /** If `certutil` is not installed already (for updating nss databases; e.g. firefox), do not attempt to install it */\n  skipCertutilInstall?: boolean,\n  /** Do not update your systems host file with the domain name of the certificate */\n  skipHostsFile?: boolean,\n  /** User interface hooks */\n  ui?: UserInterface\n}\n\ninterface ICaBuffer {\n  ca: Buffer;\n}\ninterface ICaPath {\n  caPath: string;\n}\ninterface IDomainData {\n  key: Buffer;\n  cert: Buffer;\n}\ntype IReturnCa<O extends Options> = O['getCaBuffer'] extends true ? ICaBuffer : false;\ntype IReturnCaPath<O extends Options> = O['getCaPath'] extends true ? ICaPath : false;\ntype IReturnData<O extends Options = {}> = (IDomainData) & (IReturnCa<O>) & (IReturnCaPath<O>);\n\n/**\n * Request an SSL certificate for the given app name signed by the devcert root\n * certificate authority. If devcert has previously generated a certificate for\n * that app name on this machine, it will reuse that certificate.\n *\n * If this is the first time devcert is being run on this machine, it will\n * generate and attempt to install a root certificate authority.\n *\n * Returns a promise that resolves with { key, cert }, where `key` and `cert`\n * are Buffers with the contents of the certificate private key and certificate\n * file, respectively\n * \n * If `options.getCaBuffer` is true, return value will include the ca certificate data\n * as { ca: Buffer }\n * \n * If `options.getCaPath` is true, return value will include the ca certificate path\n * as { caPath: string }\n */\nexport async function certificateFor<O extends Options>(domain: string, options: O = {} as O): Promise<IReturnData<O>> {\n  if (VALID_IP.test(domain)) {\n    throw new Error('IP addresses are not supported currently');\n  }\n  if (!VALID_DOMAIN.test(domain)) {\n    throw new Error(`\"${domain}\" is not a valid domain name.`);\n  }\n  debug(`Certificate requested for ${ domain }. Skipping certutil install: ${ Boolean(options.skipCertutilInstall) }. Skipping hosts file: ${ Boolean(options.skipHostsFile) }`);\n\n  if (options.ui) {\n    Object.assign(UI, options.ui);\n  }\n\n  if (!isMac && !isLinux && !isWindows) {\n    throw new Error(`Platform not supported: \"${ process.platform }\"`);\n  }\n\n  if (!commandExists('openssl')) {\n    throw new Error('OpenSSL not found: OpenSSL is required to generate SSL certificates - make sure it is installed and available in your PATH');\n  }\n\n  let domainKeyPath = pathForDomain(domain, `private-key.key`);\n  let domainCertPath = pathForDomain(domain, `certificate.crt`);\n\n  if (!exists(rootCAKeyPath)) {\n    debug('Root CA is not installed yet, so it must be our first run. Installing root CA ...');\n    await installCertificateAuthority(options);\n  } else if (options.getCaBuffer || options.getCaPath) {\n    debug('Root CA is not readable, but it probably is because an earlier version of devcert locked it. Trying to fix...');\n    await ensureCACertReadable(options);\n  }\n\n  if (!exists(pathForDomain(domain, `certificate.crt`))) {\n    debug(`Can't find certificate file for ${ domain }, so it must be the first request for ${ domain }. Generating and caching ...`);\n    await generateDomainCertificate(domain);\n  }\n\n  if (!options.skipHostsFile) {\n    await currentPlatform.addDomainToHostFileIfMissing(domain);\n  }\n\n  debug(`Returning domain certificate`);\n\n  const ret = {\n    key: readFile(domainKeyPath),\n    cert: readFile(domainCertPath)\n  } as IReturnData<O>;\n  if (options.getCaBuffer) (ret as ICaBuffer).ca = readFile(rootCACertPath);\n  if (options.getCaPath) (ret as ICaPath).caPath = rootCACertPath;\n\n  return ret;\n}\n\nexport function hasCertificateFor(domain: string) {\n  return exists(pathForDomain(domain, `certificate.crt`));\n}\n\nexport function configuredDomains() {\n  return readdir(domainsDir);\n}\n\nexport function removeDomain(domain: string) {\n  return rimraf.sync(pathForDomain(domain));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}