{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.promptForDeviceAsync = promptForDeviceAsync;\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\nvar _errors = require(\"../../../utils/errors\");\nvar _prompts = require(\"../../../utils/prompts\");\nvar _adb = require(\"./adb\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction nameStyleForDevice(device) {\n  var isActive = device.isBooted;\n  if (!isActive) {\n    return function (text) {\n      return text;\n    };\n  }\n  if (device.isAuthorized) {\n    return _chalk.default.bold;\n  }\n  return function (text) {\n    return _chalk.default.bold(_chalk.default.gray(text));\n  };\n}\nfunction promptForDeviceAsync(_x) {\n  return _promptForDeviceAsync.apply(this, arguments);\n}\nfunction _promptForDeviceAsync() {\n  _promptForDeviceAsync = _asyncToGenerator(function* (devices) {\n    var _yield$promptAsync = yield (0, _prompts).promptAsync({\n        type: \"autocomplete\",\n        name: \"value\",\n        limit: 11,\n        message: \"Select a device/emulator\",\n        choices: devices.map(function (item) {\n          var format = nameStyleForDevice(item);\n          var type = item.isAuthorized ? item.type : \"unauthorized\";\n          return {\n            title: `${format(item.name)} ${_chalk.default.dim(`(${type})`)}`,\n            value: item.name\n          };\n        }),\n        suggest: (0, _prompts).createSelectionFilter()\n      }),\n      value = _yield$promptAsync.value;\n    var device = devices.find(function (_ref) {\n      var name = _ref.name;\n      return name === value;\n    });\n    if ((device == null ? void 0 : device.isAuthorized) === false) {\n      (0, _adb).logUnauthorized(device);\n      throw new _errors.AbortCommandError();\n    }\n    return device;\n  });\n  return _promptForDeviceAsync.apply(this, arguments);\n}","map":{"version":3,"names":["_asyncToGenerator","require","promptForDeviceAsync","_chalk","_interopRequireDefault","_errors","_prompts","_adb","nameStyleForDevice","device","isActive","isBooted","text","isAuthorized","default","bold","gray","_x","_promptForDeviceAsync","apply","arguments","devices","_yield$promptAsync","promptAsync","type","name","limit","message","choices","map","item","format","title","dim","value","suggest","createSelectionFilter","find","_ref","logUnauthorized","AbortCommandError"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\cli\\src\\start\\platforms\\android\\promptAndroidDevice.ts"],"sourcesContent":["import chalk from 'chalk';\n\nimport { AbortCommandError } from '../../../utils/errors';\nimport { createSelectionFilter, promptAsync } from '../../../utils/prompts';\nimport { Device, logUnauthorized } from './adb';\n\nfunction nameStyleForDevice(device: Device): (name: string) => string {\n  const isActive = device.isBooted;\n  if (!isActive) {\n    // Use no style changes for a disconnected device that is available to be opened.\n    return (text: string) => text;\n  }\n  // A device that is connected and ready to be used should be bolded to match iOS.\n  if (device.isAuthorized) {\n    return chalk.bold;\n  }\n  // Devices that are unauthorized and connected cannot be used, but they are connected so gray them out.\n  return (text: string) => chalk.bold(chalk.gray(text));\n}\n\nexport async function promptForDeviceAsync(devices: Device[]): Promise<Device> {\n  // TODO: provide an option to add or download more simulators\n\n  const { value } = await promptAsync({\n    type: 'autocomplete',\n    name: 'value',\n    limit: 11,\n    message: 'Select a device/emulator',\n    choices: devices.map((item) => {\n      const format = nameStyleForDevice(item);\n      const type = item.isAuthorized ? item.type : 'unauthorized';\n      return {\n        title: `${format(item.name)} ${chalk.dim(`(${type})`)}`,\n        value: item.name,\n      };\n    }),\n    suggest: createSelectionFilter(),\n  });\n\n  const device = devices.find(({ name }) => name === value);\n\n  if (device?.isAuthorized === false) {\n    logUnauthorized(device);\n    throw new AbortCommandError();\n  }\n\n  return device!;\n}\n"],"mappings":"AAAA;;AAAA,IAAAA,iBAAA,GAAAC,OAAA;;;;QAoBsBC,oBAAoB,GAApBA,oBAAoB;AApBxB,IAAAC,MAAO,GAAAC,sBAAA,CAAAH,OAAA,CAAP,OAAO;AAES,IAAAI,OAAuB,GAAAJ,OAAA;AACN,IAAAK,QAAwB,GAAAL,OAAA;AACnC,IAAAM,IAAO,GAAAN,OAAA;;;;;;AAE/C,SAASO,kBAAkBA,CAACC,MAAc,EAA4B;EACpE,IAAMC,QAAQ,GAAGD,MAAM,CAACE,QAAQ;EAChC,IAAI,CAACD,QAAQ,EAAE;IAEb,OAAO,UAACE,IAAY;MAAA,OAAKA,IAAI;IAAA;;EAG/B,IAAIH,MAAM,CAACI,YAAY,EAAE;IACvB,OAAOV,MAAK,CAAAW,OAAA,CAACC,IAAI;;EAGnB,OAAO,UAACH,IAAY;IAAA,OAAKT,MAAK,CAAAW,OAAA,CAACC,IAAI,CAACZ,MAAK,CAAAW,OAAA,CAACE,IAAI,CAACJ,IAAI,CAAC,CAAC;EAAA;;AACtD,SAEqBV,oBAAoBA,CAAAe,EAAA;EAAA,OAAAC,qBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAF,sBAAA;EAAAA,qBAAA,GAAAlB,iBAAA,CAAnC,WAAoCqB,OAAiB,EAAmB;IAG7E,IAAAC,kBAAA,SAAwB,IAAAhB,QAAW,EAcjCiB,WAdiC,CAAC;QAClCC,IAAI,EAAE,cAAc;QACpBC,IAAI,EAAE,OAAO;QACbC,KAAK,EAAE,EAAE;QACTC,OAAO,EAAE,0BAA0B;QACnCC,OAAO,EAAEP,OAAO,CAACQ,GAAG,CAAC,UAACC,IAAI,EAAK;UAC7B,IAAMC,MAAM,GAAGvB,kBAAkB,CAACsB,IAAI,CAAC;UACvC,IAAMN,IAAI,GAAGM,IAAI,CAACjB,YAAY,GAAGiB,IAAI,CAACN,IAAI,GAAG,cAAc;UAC3D,OAAO;YACLQ,KAAK,EAAG,GAAED,MAAM,CAACD,IAAI,CAACL,IAAI,CAAE,IAAGtB,MAAK,CAAAW,OAAA,CAACmB,GAAG,CAAE,IAAGT,IAAK,GAAE,CAAE,EAAC;YACvDU,KAAK,EAAEJ,IAAI,CAACL;WACb;SACF,CAAC;QACFU,OAAO,EAAE,IAAA7B,QAAqB,EAAE8B,qBAAF;OAC/B,CAAC;MAdMF,KAAK,GAAAZ,kBAAA,CAALY,KAAK;IAgBb,IAAMzB,MAAM,GAAGY,OAAO,CAACgB,IAAI,CAAC,UAAAC,IAAA;MAAA,IAAGb,IAAI,GAAAa,IAAA,CAAJb,IAAI;MAAA,OAAOA,IAAI,KAAKS,KAAK;IAAA,EAAC;IAEzD,IAAI,CAAAzB,MAAM,QAAc,GAApB,MAAoB,GAApBA,MAAM,CAAEI,YAAY,MAAK,KAAK,EAAE;MAClC,IAAAN,IAAe,EAAQgC,eAAR,CAAC9B,MAAM,CAAC;MACvB,MAAM,IAAIJ,OAAiB,CAAAmC,iBAAA,EAAE;;IAG/B,OAAO/B,MAAM;GACd;EAAA,OAAAS,qBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}