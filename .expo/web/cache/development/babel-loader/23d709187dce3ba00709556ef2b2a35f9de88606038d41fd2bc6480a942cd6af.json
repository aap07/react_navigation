{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addObjcImports = addObjcImports;\nexports.findObjcFunctionCodeBlock = findObjcFunctionCodeBlock;\nexports.findObjcInterfaceCodeBlock = findObjcInterfaceCodeBlock;\nexports.findSwiftFunctionCodeBlock = findSwiftFunctionCodeBlock;\nexports.insertContentsInsideObjcFunctionBlock = insertContentsInsideObjcFunctionBlock;\nexports.insertContentsInsideObjcInterfaceBlock = insertContentsInsideObjcInterfaceBlock;\nexports.insertContentsInsideSwiftClassBlock = insertContentsInsideSwiftClassBlock;\nexports.insertContentsInsideSwiftFunctionBlock = insertContentsInsideSwiftFunctionBlock;\nfunction _commonCodeMod() {\n  var data = require(\"../utils/commonCodeMod\");\n  _commonCodeMod = function _commonCodeMod() {\n    return data;\n  };\n  return data;\n}\nfunction _matchBrackets() {\n  var data = require(\"../utils/matchBrackets\");\n  _matchBrackets = function _matchBrackets() {\n    return data;\n  };\n  return data;\n}\nfunction addObjcImports(source, imports) {\n  var lines = source.split('\\n');\n  var lineIndexWithFirstImport = lines.findIndex(function (line) {\n    return line.match(/^#import .*$/);\n  });\n  for (var importElement of imports) {\n    if (!source.includes(importElement)) {\n      var importStatement = `#import ${importElement}`;\n      lines.splice(lineIndexWithFirstImport + 1, 0, importStatement);\n    }\n  }\n  return lines.join('\\n');\n}\nfunction findObjcInterfaceCodeBlock(contents, declaration) {\n  var start = contents.search(new RegExp(`^${declaration}\\\\W`, 'm'));\n  if (start < 0) {\n    return null;\n  }\n  var end = contents.indexOf('\\n@end', start);\n  end += 5;\n  return {\n    start: start,\n    end: end,\n    code: contents.substring(start, end)\n  };\n}\nfunction findObjcFunctionCodeBlock(contents, selector) {\n  var symbols = selector.split(':');\n  var argsCount = symbols.length - 1;\n  var pattern = '^[\\\\-+]\\\\s*\\\\(.+?\\\\)';\n  if (argsCount === 0) {\n    pattern += `${symbols[0]}\\\\s+`;\n  } else {\n    for (var i = 0; i < argsCount; ++i) {\n      var argSymbol = `${symbols[i]}:\\\\(.+\\\\)\\\\w+`;\n      pattern += `${argSymbol}\\\\s+`;\n    }\n  }\n  pattern += '{';\n  var start = contents.search(new RegExp(pattern, 'm'));\n  if (start < 0) {\n    return null;\n  }\n  start = contents.indexOf('{', start);\n  var end = (0, _matchBrackets().findMatchingBracketPosition)(contents, '{', start);\n  return {\n    start: start,\n    end: end,\n    code: contents.substring(start, end + 1)\n  };\n}\nfunction insertContentsInsideObjcFunctionBlock(srcContents, selector, insertion, options) {\n  return insertContentsInsideFunctionBlock(srcContents, selector, insertion, options, 'objc');\n}\nfunction insertContentsInsideObjcInterfaceBlock(srcContents, declaration, insertion, options) {\n  var codeBlock = findObjcInterfaceCodeBlock(srcContents, declaration);\n  if (!codeBlock) {\n    return srcContents;\n  }\n  var position = options.position;\n  if (position === 'head') {\n    var firstNewLineIndex = srcContents.indexOf('\\n', codeBlock.start);\n    srcContents = (0, _commonCodeMod().insertContentsAtOffset)(srcContents, insertion, firstNewLineIndex);\n  } else if (position === 'tail') {\n    var endLen = '@end'.length;\n    srcContents = (0, _commonCodeMod().insertContentsAtOffset)(srcContents, insertion, codeBlock.end - endLen);\n  }\n  return srcContents;\n}\nfunction findSwiftFunctionCodeBlock(contents, selector) {\n  var parenthesesIndex = selector.indexOf('(');\n  var funcName = selector.substring(0, parenthesesIndex);\n  var argLabels = selector.substring(parenthesesIndex + 1, selector.length - 2).split(':');\n  var searchOffset = 0;\n  var funcCandidateRegExp = new RegExp(`\\\\sfunc\\\\s+${funcName}\\\\(`, 'm');\n  var funcCandidateOffset = (0, _commonCodeMod().searchFromOffset)(contents, funcCandidateRegExp, searchOffset);\n  while (funcCandidateOffset >= 0) {\n    var paramsStartOffset = contents.indexOf('(', funcCandidateOffset);\n    var paramsEndOffset = (0, _matchBrackets().findMatchingBracketPosition)(contents, '(', paramsStartOffset);\n    var paramsString = contents.substring(paramsStartOffset + 1, paramsEndOffset);\n    var params = paramsString.split(',').map(parseSwiftFunctionParam);\n    searchOffset = paramsEndOffset + 1;\n    funcCandidateOffset = (0, _commonCodeMod().searchFromOffset)(contents, funcCandidateRegExp, searchOffset);\n    if (argLabels.length !== params.length) {\n      continue;\n    }\n    for (var i = 0; i < argLabels.length; ++i) {\n      if (argLabels[i] !== params[i].argumentLabel) {\n        continue;\n      }\n    }\n    var codeBlockStart = contents.indexOf('{', paramsEndOffset);\n    var codeBlockEnd = (0, _matchBrackets().findMatchingBracketPosition)(contents, '{', paramsEndOffset);\n    var codeBlock = contents.substring(codeBlockStart, codeBlockEnd + 1);\n    return {\n      start: codeBlockStart,\n      end: codeBlockEnd,\n      code: codeBlock\n    };\n  }\n  return null;\n}\nfunction parseSwiftFunctionParam(paramTuple) {\n  var semiIndex = paramTuple.indexOf(':');\n  var _paramTuple$substring = paramTuple.substring(0, semiIndex).split(/\\s+/),\n    _paramTuple$substring2 = _slicedToArray(_paramTuple$substring, 2),\n    argumentLabel = _paramTuple$substring2[0],\n    parameterName = _paramTuple$substring2[1];\n  var typeString = paramTuple.substring(semiIndex + 1).trim();\n  return {\n    argumentLabel: argumentLabel,\n    parameterName: parameterName,\n    typeString: typeString\n  };\n}\nfunction insertContentsInsideSwiftClassBlock(srcContents, declaration, insertion, options) {\n  var start = srcContents.search(new RegExp(`\\\\s*${declaration}.*?[\\\\(\\\\{]`));\n  if (start < 0) {\n    throw new Error(`Unable to find class code block - declaration[${declaration}]`);\n  }\n  var position = options.position;\n  if (position === 'head') {\n    var firstBracketIndex = srcContents.indexOf('{', start);\n    srcContents = (0, _commonCodeMod().insertContentsAtOffset)(srcContents, insertion, firstBracketIndex + 1);\n  } else if (position === 'tail') {\n    var endBracketIndex = (0, _matchBrackets().findMatchingBracketPosition)(srcContents, '{', start);\n    srcContents = (0, _commonCodeMod().insertContentsAtOffset)(srcContents, insertion, endBracketIndex);\n  }\n  return srcContents;\n}\nfunction insertContentsInsideSwiftFunctionBlock(srcContents, selector, insertion, options) {\n  return insertContentsInsideFunctionBlock(srcContents, selector, insertion, options, 'swift');\n}\nfunction insertContentsInsideFunctionBlock(srcContents, selector, insertion, options, language) {\n  var _options$indent;\n  var codeBlock = language === 'objc' ? findObjcFunctionCodeBlock(srcContents, selector) : findSwiftFunctionCodeBlock(srcContents, selector);\n  if (!codeBlock) {\n    return srcContents;\n  }\n  var position = options.position;\n  var indent = ' '.repeat((_options$indent = options.indent) !== null && _options$indent !== void 0 ? _options$indent : 2);\n  if (position === 'head') {\n    srcContents = (0, _commonCodeMod().insertContentsAtOffset)(srcContents, `\\n${indent}${insertion}`, codeBlock.start + 1);\n  } else if (position === 'tail') {\n    srcContents = (0, _commonCodeMod().insertContentsAtOffset)(srcContents, `\\n${indent}${insertion}`, codeBlock.end - 1);\n  } else if (position === 'tailBeforeLastReturn') {\n    var lastReturnIndex = srcContents.lastIndexOf(' return ', codeBlock.end);\n    if (lastReturnIndex < 0) {\n      throw new Error(`Cannot find last return statement:\\n${srcContents}`);\n    }\n    lastReturnIndex += 1;\n    srcContents = (0, _commonCodeMod().insertContentsAtOffset)(srcContents, `${insertion}\\n${indent}`, lastReturnIndex);\n  }\n  return srcContents;\n}","map":{"version":3,"names":["_commonCodeMod","data","require","_matchBrackets","addObjcImports","source","imports","lines","split","lineIndexWithFirstImport","findIndex","line","match","importElement","includes","importStatement","splice","join","findObjcInterfaceCodeBlock","contents","declaration","start","search","RegExp","end","indexOf","code","substring","findObjcFunctionCodeBlock","selector","symbols","argsCount","length","pattern","i","argSymbol","findMatchingBracketPosition","insertContentsInsideObjcFunctionBlock","srcContents","insertion","options","insertContentsInsideFunctionBlock","insertContentsInsideObjcInterfaceBlock","codeBlock","position","firstNewLineIndex","insertContentsAtOffset","endLen","findSwiftFunctionCodeBlock","parenthesesIndex","funcName","argLabels","searchOffset","funcCandidateRegExp","funcCandidateOffset","searchFromOffset","paramsStartOffset","paramsEndOffset","paramsString","params","map","parseSwiftFunctionParam","argumentLabel","codeBlockStart","codeBlockEnd","paramTuple","semiIndex","_paramTuple$substring","_paramTuple$substring2","_slicedToArray","parameterName","typeString","trim","insertContentsInsideSwiftClassBlock","Error","firstBracketIndex","endBracketIndex","insertContentsInsideSwiftFunctionBlock","language","_options$indent","indent","repeat","lastReturnIndex","lastIndexOf"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\config-plugins\\src\\ios\\codeMod.ts"],"sourcesContent":["import { CodeBlock, insertContentsAtOffset, searchFromOffset } from '../utils/commonCodeMod';\nimport { findMatchingBracketPosition } from '../utils/matchBrackets';\n\ninterface SwiftFunctionParam {\n  argumentLabel: string;\n  parameterName: string;\n  typeString: string;\n}\n\ninterface InsertContentFunctionOptions {\n  position: 'head' | 'tail' | 'tailBeforeLastReturn';\n  indent?: number;\n}\n\n/**\n * Add Objective-C import\n * @param source source contents\n * @param imports array of imports, e.g. ['<Foundation/Foundation.h>']\n * @returns updated contents\n */\nexport function addObjcImports(source: string, imports: string[]): string {\n  const lines = source.split('\\n');\n  // Try to insert statements after first #import where would probably not in #if block\n  const lineIndexWithFirstImport = lines.findIndex((line) => line.match(/^#import .*$/));\n  for (const importElement of imports) {\n    if (!source.includes(importElement)) {\n      const importStatement = `#import ${importElement}`;\n      lines.splice(lineIndexWithFirstImport + 1, 0, importStatement);\n    }\n  }\n  return lines.join('\\n');\n}\n\n/**\n * Find code block of Objective-C interface or implementation\n *\n * @param contents source contents\n * @param declaration interface/implementation, e.g. '@interface Foo'\n * @returns found CodeBlock, or null if not found\n */\nexport function findObjcInterfaceCodeBlock(\n  contents: string,\n  declaration: string\n): CodeBlock | null {\n  const start = contents.search(new RegExp(`^${declaration}\\\\W`, 'm'));\n  if (start < 0) {\n    return null;\n  }\n\n  let end = contents.indexOf('\\n@end', start);\n  end += 5; // '\\n@end'.length === 5\n\n  return {\n    start,\n    end,\n    code: contents.substring(start, end),\n  };\n}\n\n/**\n * Find code block of Objective-C function without declaration, will return only {} block\n *\n * @param contents source contents\n * @param selector function selector, e.g. 'doSomething:withSomeValue:'\n * @returns found CodeBlock, or null if not found.\n */\nexport function findObjcFunctionCodeBlock(contents: string, selector: string): CodeBlock | null {\n  const symbols = selector.split(':');\n  const argsCount = symbols.length - 1;\n  let pattern = '^[\\\\-+]\\\\s*\\\\(.+?\\\\)';\n  if (argsCount === 0) {\n    pattern += `${symbols[0]}\\\\s+`;\n  } else {\n    for (let i = 0; i < argsCount; ++i) {\n      const argSymbol = `${symbols[i]}:\\\\(.+\\\\)\\\\w+`;\n      pattern += `${argSymbol}\\\\s+`;\n    }\n  }\n  pattern += '{';\n  let start = contents.search(new RegExp(pattern, 'm'));\n  if (start < 0) {\n    return null;\n  }\n  start = contents.indexOf('{', start);\n\n  const end = findMatchingBracketPosition(contents, '{', start);\n  return {\n    start,\n    end,\n    code: contents.substring(start, end + 1),\n  };\n}\n\n/**\n * Insert contents to the Objective-C function block\n *\n * @param srcContents source contents\n * @param selector function selector, e.g. 'doSomething:withSomeValue:'\n * @param insertion code to insert\n * @param options insertion options\n * @returns updated contents\n */\nexport function insertContentsInsideObjcFunctionBlock(\n  srcContents: string,\n  selector: string,\n  insertion: string,\n  options: InsertContentFunctionOptions\n): string {\n  return insertContentsInsideFunctionBlock(srcContents, selector, insertion, options, 'objc');\n}\n\n/**\n * Insert contents to the Objective-C interface/implementation block\n *\n * @param srcContents source contents\n * @param declaration interface/implementation, e.g. '@interface Foo'\n * @param insertion code to insert\n * @param options insertion options\n * @returns updated contents\n */\nexport function insertContentsInsideObjcInterfaceBlock(\n  srcContents: string,\n  declaration: string,\n  insertion: string,\n  options: {\n    position: 'head' | 'tail';\n  }\n): string {\n  const codeBlock = findObjcInterfaceCodeBlock(srcContents, declaration);\n  if (!codeBlock) {\n    return srcContents;\n  }\n\n  const { position } = options;\n  if (position === 'head') {\n    const firstNewLineIndex = srcContents.indexOf('\\n', codeBlock.start);\n    srcContents = insertContentsAtOffset(srcContents, insertion, firstNewLineIndex);\n  } else if (position === 'tail') {\n    const endLen = '@end'.length;\n    srcContents = insertContentsAtOffset(srcContents, insertion, codeBlock.end - endLen);\n  }\n  return srcContents;\n}\n\n/**\n * Find code block of Swift function without declaration, will return only {} block\n *\n * @param contents source contents\n * @param selector function selector, e.g. 'doSomething(_:withSomeValue:)'\n * @returns found CodeBlock, or null if not found.\n */\nexport function findSwiftFunctionCodeBlock(contents: string, selector: string): CodeBlock | null {\n  const parenthesesIndex = selector.indexOf('(');\n  // `functName` === 'doSomething' of 'doSomething(_:withSomeValue:)'\n  const funcName = selector.substring(0, parenthesesIndex);\n  // `argLabels` === ['_', 'withSomeValue'] 'doSomething(_:withSomeValue:)'\n  const argLabels = selector.substring(parenthesesIndex + 1, selector.length - 2).split(':');\n\n  let searchOffset = 0;\n  const funcCandidateRegExp = new RegExp(`\\\\sfunc\\\\s+${funcName}\\\\(`, 'm');\n  let funcCandidateOffset = searchFromOffset(contents, funcCandidateRegExp, searchOffset);\n  while (funcCandidateOffset >= 0) {\n    // Parse function parameters\n    const paramsStartOffset = contents.indexOf('(', funcCandidateOffset);\n    const paramsEndOffset = findMatchingBracketPosition(contents, '(', paramsStartOffset);\n    const paramsString = contents.substring(paramsStartOffset + 1, paramsEndOffset);\n    const params = paramsString.split(',').map(parseSwiftFunctionParam);\n\n    // Prepare offset for next round\n    searchOffset = paramsEndOffset + 1;\n    funcCandidateOffset = searchFromOffset(contents, funcCandidateRegExp, searchOffset);\n\n    // Try to match function parameters\n    if (argLabels.length !== params.length) {\n      continue;\n    }\n    for (let i = 0; i < argLabels.length; ++i) {\n      if (argLabels[i] !== params[i].argumentLabel) {\n        continue;\n      }\n    }\n\n    // This function is matched one, get the code block.\n    const codeBlockStart = contents.indexOf('{', paramsEndOffset);\n    const codeBlockEnd = findMatchingBracketPosition(contents, '{', paramsEndOffset);\n    const codeBlock = contents.substring(codeBlockStart, codeBlockEnd + 1);\n    return {\n      start: codeBlockStart,\n      end: codeBlockEnd,\n      code: codeBlock,\n    };\n  }\n\n  return null;\n}\n\nfunction parseSwiftFunctionParam(paramTuple: string): SwiftFunctionParam {\n  const semiIndex = paramTuple.indexOf(':');\n  const [argumentLabel, parameterName] = paramTuple.substring(0, semiIndex).split(/\\s+/);\n  const typeString = paramTuple.substring(semiIndex + 1).trim();\n  return {\n    argumentLabel,\n    parameterName,\n    typeString,\n  };\n}\n\n/**\n * Insert contents to the swift class block\n *\n * @param srcContents source contents\n * @param declaration class/extension declaration, e.g. 'class AppDelegate'\n * @param insertion code to append\n * @param options insertion options\n * @returns updated contents\n */\nexport function insertContentsInsideSwiftClassBlock(\n  srcContents: string,\n  declaration: string,\n  insertion: string,\n  options: {\n    position: 'head' | 'tail';\n  }\n): string {\n  const start = srcContents.search(new RegExp(`\\\\s*${declaration}.*?[\\\\(\\\\{]`));\n  if (start < 0) {\n    throw new Error(`Unable to find class code block - declaration[${declaration}]`);\n  }\n\n  const { position } = options;\n  if (position === 'head') {\n    const firstBracketIndex = srcContents.indexOf('{', start);\n    srcContents = insertContentsAtOffset(srcContents, insertion, firstBracketIndex + 1);\n  } else if (position === 'tail') {\n    const endBracketIndex = findMatchingBracketPosition(srcContents, '{', start);\n    srcContents = insertContentsAtOffset(srcContents, insertion, endBracketIndex);\n  }\n  return srcContents;\n}\n\n/**\n * Insert contents to the Swift function block\n *\n * @param srcContents source contents\n * @param selector function selector, e.g. 'doSomething:withSomeValue:'\n * @param insertion code to insert\n * @param options insertion options\n * @returns updated contents\n */\nexport function insertContentsInsideSwiftFunctionBlock(\n  srcContents: string,\n  selector: string,\n  insertion: string,\n  options: InsertContentFunctionOptions\n): string {\n  return insertContentsInsideFunctionBlock(srcContents, selector, insertion, options, 'swift');\n}\n\nfunction insertContentsInsideFunctionBlock(\n  srcContents: string,\n  selector: string,\n  insertion: string,\n  options: InsertContentFunctionOptions,\n  language: 'objc' | 'swift'\n): string {\n  const codeBlock =\n    language === 'objc'\n      ? findObjcFunctionCodeBlock(srcContents, selector)\n      : findSwiftFunctionCodeBlock(srcContents, selector);\n  if (!codeBlock) {\n    return srcContents;\n  }\n\n  const { position } = options;\n  const indent = ' '.repeat(options.indent ?? 2);\n\n  if (position === 'head') {\n    srcContents = insertContentsAtOffset(\n      srcContents,\n      `\\n${indent}${insertion}`,\n      codeBlock.start + 1\n    );\n  } else if (position === 'tail') {\n    srcContents = insertContentsAtOffset(srcContents, `\\n${indent}${insertion}`, codeBlock.end - 1);\n  } else if (position === 'tailBeforeLastReturn') {\n    let lastReturnIndex = srcContents.lastIndexOf(' return ', codeBlock.end);\n    if (lastReturnIndex < 0) {\n      throw new Error(`Cannot find last return statement:\\n${srcContents}`);\n    }\n    lastReturnIndex += 1; // +1 for the prefix space\n    srcContents = insertContentsAtOffset(srcContents, `${insertion}\\n${indent}`, lastReturnIndex);\n  }\n\n  return srcContents;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}