{"ast":null,"code":"'use strict';\n\nvar _require = require(\"../parseTopLevelType\"),\n  parseTopLevelType = _require.parseTopLevelType;\nfunction buildCommandSchemaInternal(name, optional, parameters, types) {\n  var _firstParam$typeAnnot, _firstParam$typeAnnot2;\n  var firstParam = parameters[0].typeAnnotation;\n  if (!(firstParam.typeAnnotation != null && firstParam.typeAnnotation.type === 'TSTypeReference' && ((_firstParam$typeAnnot = firstParam.typeAnnotation.typeName.left) === null || _firstParam$typeAnnot === void 0 ? void 0 : _firstParam$typeAnnot.name) === 'React' && ((_firstParam$typeAnnot2 = firstParam.typeAnnotation.typeName.right) === null || _firstParam$typeAnnot2 === void 0 ? void 0 : _firstParam$typeAnnot2.name) === 'ElementRef')) {\n    throw new Error(`The first argument of method ${name} must be of type React.ElementRef<>`);\n  }\n  var params = parameters.slice(1).map(function (param) {\n    var paramName = param.name;\n    var paramValue = parseTopLevelType(param.typeAnnotation.typeAnnotation, types).type;\n    var type = paramValue.type === 'TSTypeReference' ? paramValue.typeName.name : paramValue.type;\n    var returnType;\n    switch (type) {\n      case 'RootTag':\n        returnType = {\n          type: 'ReservedTypeAnnotation',\n          name: 'RootTag'\n        };\n        break;\n      case 'TSBooleanKeyword':\n        returnType = {\n          type: 'BooleanTypeAnnotation'\n        };\n        break;\n      case 'Int32':\n        returnType = {\n          type: 'Int32TypeAnnotation'\n        };\n        break;\n      case 'Double':\n        returnType = {\n          type: 'DoubleTypeAnnotation'\n        };\n        break;\n      case 'Float':\n        returnType = {\n          type: 'FloatTypeAnnotation'\n        };\n        break;\n      case 'TSStringKeyword':\n        returnType = {\n          type: 'StringTypeAnnotation'\n        };\n        break;\n      default:\n        type;\n        throw new Error(`Unsupported param type for method \"${name}\", param \"${paramName}\". Found ${type}`);\n    }\n    return {\n      name: paramName,\n      optional: false,\n      typeAnnotation: returnType\n    };\n  });\n  return {\n    name: name,\n    optional: optional,\n    typeAnnotation: {\n      type: 'FunctionTypeAnnotation',\n      params: params,\n      returnTypeAnnotation: {\n        type: 'VoidTypeAnnotation'\n      }\n    }\n  };\n}\nfunction buildCommandSchema(property, types) {\n  if (property.type === 'TSPropertySignature') {\n    var topLevelType = parseTopLevelType(property.typeAnnotation.typeAnnotation, types);\n    var name = property.key.name;\n    var optional = property.optional || topLevelType.optional;\n    var parameters = topLevelType.type.parameters || topLevelType.type.params;\n    return buildCommandSchemaInternal(name, optional, parameters, types);\n  } else {\n    var _name = property.key.name;\n    var _optional = property.optional || false;\n    var _parameters = property.parameters || property.params;\n    return buildCommandSchemaInternal(_name, _optional, _parameters, types);\n  }\n}\nfunction getCommands(commandTypeAST, types) {\n  return commandTypeAST.filter(function (property) {\n    return property.type === 'TSPropertySignature' || property.type === 'TSMethodSignature';\n  }).map(function (property) {\n    return buildCommandSchema(property, types);\n  }).filter(Boolean);\n}\nmodule.exports = {\n  getCommands: getCommands\n};","map":{"version":3,"names":["_require","require","parseTopLevelType","buildCommandSchemaInternal","name","optional","parameters","types","_firstParam$typeAnnot","_firstParam$typeAnnot2","firstParam","typeAnnotation","type","typeName","left","right","Error","params","slice","map","param","paramName","paramValue","returnType","returnTypeAnnotation","buildCommandSchema","property","topLevelType","key","getCommands","commandTypeAST","filter","Boolean","module","exports"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native/codegen/lib/parsers/typescript/components/commands.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\n'use strict';\n\nconst _require = require('../parseTopLevelType'),\n  parseTopLevelType = _require.parseTopLevelType;\n\n// $FlowFixMe[unclear-type] there's no flowtype for ASTs\n\nfunction buildCommandSchemaInternal(name, optional, parameters, types) {\n  var _firstParam$typeAnnot, _firstParam$typeAnnot2;\n  const firstParam = parameters[0].typeAnnotation;\n  if (\n    !(\n      firstParam.typeAnnotation != null &&\n      firstParam.typeAnnotation.type === 'TSTypeReference' &&\n      ((_firstParam$typeAnnot = firstParam.typeAnnotation.typeName.left) ===\n        null || _firstParam$typeAnnot === void 0\n        ? void 0\n        : _firstParam$typeAnnot.name) === 'React' &&\n      ((_firstParam$typeAnnot2 = firstParam.typeAnnotation.typeName.right) ===\n        null || _firstParam$typeAnnot2 === void 0\n        ? void 0\n        : _firstParam$typeAnnot2.name) === 'ElementRef'\n    )\n  ) {\n    throw new Error(\n      `The first argument of method ${name} must be of type React.ElementRef<>`,\n    );\n  }\n  const params = parameters.slice(1).map(param => {\n    const paramName = param.name;\n    const paramValue = parseTopLevelType(\n      param.typeAnnotation.typeAnnotation,\n      types,\n    ).type;\n    const type =\n      paramValue.type === 'TSTypeReference'\n        ? paramValue.typeName.name\n        : paramValue.type;\n    let returnType;\n    switch (type) {\n      case 'RootTag':\n        returnType = {\n          type: 'ReservedTypeAnnotation',\n          name: 'RootTag',\n        };\n        break;\n      case 'TSBooleanKeyword':\n        returnType = {\n          type: 'BooleanTypeAnnotation',\n        };\n        break;\n      case 'Int32':\n        returnType = {\n          type: 'Int32TypeAnnotation',\n        };\n        break;\n      case 'Double':\n        returnType = {\n          type: 'DoubleTypeAnnotation',\n        };\n        break;\n      case 'Float':\n        returnType = {\n          type: 'FloatTypeAnnotation',\n        };\n        break;\n      case 'TSStringKeyword':\n        returnType = {\n          type: 'StringTypeAnnotation',\n        };\n        break;\n      default:\n        type;\n        throw new Error(\n          `Unsupported param type for method \"${name}\", param \"${paramName}\". Found ${type}`,\n        );\n    }\n    return {\n      name: paramName,\n      optional: false,\n      typeAnnotation: returnType,\n    };\n  });\n  return {\n    name,\n    optional,\n    typeAnnotation: {\n      type: 'FunctionTypeAnnotation',\n      params,\n      returnTypeAnnotation: {\n        type: 'VoidTypeAnnotation',\n      },\n    },\n  };\n}\nfunction buildCommandSchema(property, types) {\n  if (property.type === 'TSPropertySignature') {\n    const topLevelType = parseTopLevelType(\n      property.typeAnnotation.typeAnnotation,\n      types,\n    );\n    const name = property.key.name;\n    const optional = property.optional || topLevelType.optional;\n    const parameters = topLevelType.type.parameters || topLevelType.type.params;\n    return buildCommandSchemaInternal(name, optional, parameters, types);\n  } else {\n    const name = property.key.name;\n    const optional = property.optional || false;\n    const parameters = property.parameters || property.params;\n    return buildCommandSchemaInternal(name, optional, parameters, types);\n  }\n}\nfunction getCommands(commandTypeAST, types) {\n  return commandTypeAST\n    .filter(\n      property =>\n        property.type === 'TSPropertySignature' ||\n        property.type === 'TSMethodSignature',\n    )\n    .map(property => buildCommandSchema(property, types))\n    .filter(Boolean);\n}\nmodule.exports = {\n  getCommands,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}