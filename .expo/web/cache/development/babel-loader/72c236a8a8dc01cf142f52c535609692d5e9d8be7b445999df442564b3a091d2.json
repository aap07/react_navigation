{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BinaryXmlParser = void 0;\nvar assert = __importStar(require(\"assert\"));\nvar NodeType = {\n  ELEMENT_NODE: 1,\n  ATTRIBUTE_NODE: 2,\n  CDATA_SECTION_NODE: 4\n};\nvar ChunkType = {\n  NULL: 0x0000,\n  STRING_POOL: 0x0001,\n  TABLE: 0x0002,\n  XML: 0x0003,\n  XML_FIRST_CHUNK: 0x0100,\n  XML_START_NAMESPACE: 0x0100,\n  XML_END_NAMESPACE: 0x0101,\n  XML_START_ELEMENT: 0x0102,\n  XML_END_ELEMENT: 0x0103,\n  XML_CDATA: 0x0104,\n  XML_LAST_CHUNK: 0x017f,\n  XML_RESOURCE_MAP: 0x0180,\n  TABLE_PACKAGE: 0x0200,\n  TABLE_TYPE: 0x0201,\n  TABLE_TYPE_SPEC: 0x0202\n};\nvar StringFlags = {\n  SORTED: 1 << 0,\n  UTF8: 1 << 8\n};\nvar TypedValue = {\n  COMPLEX_MANTISSA_MASK: 0x00ffffff,\n  COMPLEX_MANTISSA_SHIFT: 0x00000008,\n  COMPLEX_RADIX_0p23: 0x00000003,\n  COMPLEX_RADIX_16p7: 0x00000001,\n  COMPLEX_RADIX_23p0: 0x00000000,\n  COMPLEX_RADIX_8p15: 0x00000002,\n  COMPLEX_RADIX_MASK: 0x00000003,\n  COMPLEX_RADIX_SHIFT: 0x00000004,\n  COMPLEX_UNIT_DIP: 0x00000001,\n  COMPLEX_UNIT_FRACTION: 0x00000000,\n  COMPLEX_UNIT_FRACTION_PARENT: 0x00000001,\n  COMPLEX_UNIT_IN: 0x00000004,\n  COMPLEX_UNIT_MASK: 0x0000000f,\n  COMPLEX_UNIT_MM: 0x00000005,\n  COMPLEX_UNIT_PT: 0x00000003,\n  COMPLEX_UNIT_PX: 0x00000000,\n  COMPLEX_UNIT_SHIFT: 0x00000000,\n  COMPLEX_UNIT_SP: 0x00000002,\n  DENSITY_DEFAULT: 0x00000000,\n  DENSITY_NONE: 0x0000ffff,\n  TYPE_ATTRIBUTE: 0x00000002,\n  TYPE_DIMENSION: 0x00000005,\n  TYPE_FIRST_COLOR_INT: 0x0000001c,\n  TYPE_FIRST_INT: 0x00000010,\n  TYPE_FLOAT: 0x00000004,\n  TYPE_FRACTION: 0x00000006,\n  TYPE_INT_BOOLEAN: 0x00000012,\n  TYPE_INT_COLOR_ARGB4: 0x0000001e,\n  TYPE_INT_COLOR_ARGB8: 0x0000001c,\n  TYPE_INT_COLOR_RGB4: 0x0000001f,\n  TYPE_INT_COLOR_RGB8: 0x0000001d,\n  TYPE_INT_DEC: 0x00000010,\n  TYPE_INT_HEX: 0x00000011,\n  TYPE_LAST_COLOR_INT: 0x0000001f,\n  TYPE_LAST_INT: 0x0000001f,\n  TYPE_NULL: 0x00000000,\n  TYPE_REFERENCE: 0x00000001,\n  TYPE_STRING: 0x00000003\n};\nvar BinaryXmlParser = function () {\n  function BinaryXmlParser(buffer) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, BinaryXmlParser);\n    this.buffer = buffer;\n    this.cursor = 0;\n    this.strings = [];\n    this.resources = [];\n    this.stack = [];\n    this.debug = false;\n    this.debug = options.debug || false;\n  }\n  _createClass(BinaryXmlParser, [{\n    key: \"readU8\",\n    value: function readU8() {\n      var val = this.buffer[this.cursor];\n      this.cursor += 1;\n      return val;\n    }\n  }, {\n    key: \"readU16\",\n    value: function readU16() {\n      var val = this.buffer.readUInt16LE(this.cursor);\n      this.cursor += 2;\n      return val;\n    }\n  }, {\n    key: \"readS32\",\n    value: function readS32() {\n      var val = this.buffer.readInt32LE(this.cursor);\n      this.cursor += 4;\n      return val;\n    }\n  }, {\n    key: \"readU32\",\n    value: function readU32() {\n      var val = this.buffer.readUInt32LE(this.cursor);\n      this.cursor += 4;\n      return val;\n    }\n  }, {\n    key: \"readLength8\",\n    value: function readLength8() {\n      var len = this.readU8();\n      if (len & 0x80) {\n        len = (len & 0x7f) << 8;\n        len += this.readU8();\n      }\n      return len;\n    }\n  }, {\n    key: \"readLength16\",\n    value: function readLength16() {\n      var len = this.readU16();\n      if (len & 0x8000) {\n        len = (len & 0x7fff) << 16;\n        len += this.readU16();\n      }\n      return len;\n    }\n  }, {\n    key: \"readDimension\",\n    value: function readDimension() {\n      var dimension = {\n        value: null,\n        unit: null,\n        rawUnit: null\n      };\n      var value = this.readU32();\n      var unit = dimension.value & 0xff;\n      dimension.value = value >> 8;\n      dimension.rawUnit = unit;\n      switch (unit) {\n        case TypedValue.COMPLEX_UNIT_MM:\n          dimension.unit = 'mm';\n          break;\n        case TypedValue.COMPLEX_UNIT_PX:\n          dimension.unit = 'px';\n          break;\n        case TypedValue.COMPLEX_UNIT_DIP:\n          dimension.unit = 'dp';\n          break;\n        case TypedValue.COMPLEX_UNIT_SP:\n          dimension.unit = 'sp';\n          break;\n        case TypedValue.COMPLEX_UNIT_PT:\n          dimension.unit = 'pt';\n          break;\n        case TypedValue.COMPLEX_UNIT_IN:\n          dimension.unit = 'in';\n          break;\n      }\n      return dimension;\n    }\n  }, {\n    key: \"readFraction\",\n    value: function readFraction() {\n      var fraction = {\n        value: null,\n        type: null,\n        rawType: null\n      };\n      var value = this.readU32();\n      var type = value & 0xf;\n      fraction.value = this.convertIntToFloat(value >> 4);\n      fraction.rawType = type;\n      switch (type) {\n        case TypedValue.COMPLEX_UNIT_FRACTION:\n          fraction.type = '%';\n          break;\n        case TypedValue.COMPLEX_UNIT_FRACTION_PARENT:\n          fraction.type = '%p';\n          break;\n      }\n      return fraction;\n    }\n  }, {\n    key: \"readHex24\",\n    value: function readHex24() {\n      var val = (this.readU32() & 0xffffff).toString(16);\n      return val;\n    }\n  }, {\n    key: \"readHex32\",\n    value: function readHex32() {\n      var val = this.readU32().toString(16);\n      return val;\n    }\n  }, {\n    key: \"readTypedValue\",\n    value: function readTypedValue() {\n      var typedValue = {\n        value: null,\n        type: null,\n        rawType: null\n      };\n      var start = this.cursor;\n      var size = this.readU16();\n      this.readU8();\n      var dataType = this.readU8();\n      if (size === 0) {\n        size = 8;\n      }\n      typedValue.rawType = dataType;\n      switch (dataType) {\n        case TypedValue.TYPE_INT_DEC:\n          typedValue.value = this.readS32();\n          typedValue.type = 'int_dec';\n          break;\n        case TypedValue.TYPE_INT_HEX:\n          typedValue.value = this.readS32();\n          typedValue.type = 'int_hex';\n          break;\n        case TypedValue.TYPE_STRING:\n          {\n            var ref = this.readS32();\n            typedValue.value = ref > 0 ? this.strings[ref] : '';\n            typedValue.type = 'string';\n            break;\n          }\n        case TypedValue.TYPE_REFERENCE:\n          {\n            var id = this.readU32();\n            typedValue.value = `resourceId:0x${id.toString(16)}`;\n            typedValue.type = 'reference';\n            break;\n          }\n        case TypedValue.TYPE_INT_BOOLEAN:\n          typedValue.value = this.readS32() !== 0;\n          typedValue.type = 'boolean';\n          break;\n        case TypedValue.TYPE_NULL:\n          this.readU32();\n          typedValue.value = null;\n          typedValue.type = 'null';\n          break;\n        case TypedValue.TYPE_INT_COLOR_RGB8:\n          typedValue.value = this.readHex24();\n          typedValue.type = 'rgb8';\n          break;\n        case TypedValue.TYPE_INT_COLOR_RGB4:\n          typedValue.value = this.readHex24();\n          typedValue.type = 'rgb4';\n          break;\n        case TypedValue.TYPE_INT_COLOR_ARGB8:\n          typedValue.value = this.readHex32();\n          typedValue.type = 'argb8';\n          break;\n        case TypedValue.TYPE_INT_COLOR_ARGB4:\n          typedValue.value = this.readHex32();\n          typedValue.type = 'argb4';\n          break;\n        case TypedValue.TYPE_DIMENSION:\n          typedValue.value = this.readDimension();\n          typedValue.type = 'dimension';\n          break;\n        case TypedValue.TYPE_FRACTION:\n          typedValue.value = this.readFraction();\n          typedValue.type = 'fraction';\n          break;\n        default:\n          {\n            typedValue.value = this.readU32();\n            typedValue.type = 'unknown';\n          }\n      }\n      var end = start + size;\n      if (this.cursor !== end) {\n        this.cursor = end;\n      }\n      return typedValue;\n    }\n  }, {\n    key: \"convertIntToFloat\",\n    value: function convertIntToFloat(int) {\n      var buf = new ArrayBuffer(4);\n      new Int32Array(buf)[0] = int;\n      return new Float32Array(buf)[0];\n    }\n  }, {\n    key: \"readString\",\n    value: function readString(encoding) {\n      var stringLength;\n      var byteLength;\n      var value;\n      switch (encoding) {\n        case 'utf-8':\n          stringLength = this.readLength8();\n          byteLength = this.readLength8();\n          value = this.buffer.toString(encoding, this.cursor, this.cursor += byteLength);\n          assert.equal(this.readU8(), 0, 'String must end with trailing zero');\n          return value;\n        case 'ucs2':\n          stringLength = this.readLength16();\n          byteLength = stringLength * 2;\n          value = this.buffer.toString(encoding, this.cursor, this.cursor += byteLength);\n          assert.equal(this.readU16(), 0, 'String must end with trailing zero');\n          return value;\n        default:\n          throw new assert.AssertionError({\n            message: `Unsupported encoding '${encoding}'`\n          });\n      }\n    }\n  }, {\n    key: \"readChunkHeader\",\n    value: function readChunkHeader() {\n      return {\n        startOffset: this.cursor,\n        chunkType: this.readU16(),\n        headerSize: this.readU16(),\n        chunkSize: this.readU32()\n      };\n    }\n  }, {\n    key: \"readStringPool\",\n    value: function readStringPool(header) {\n      header.stringCount = this.readU32();\n      header.styleCount = this.readU32();\n      header.flags = this.readU32();\n      header.stringsStart = this.readU32();\n      header.stylesStart = this.readU32();\n      if (header.chunkType !== ChunkType.STRING_POOL) {\n        throw new assert.AssertionError({\n          message: 'Invalid string pool header'\n        });\n      }\n      var offsets = [];\n      for (var i = 0, l = header.stringCount; i < l; ++i) {\n        offsets.push(this.readU32());\n      }\n      var encoding = (header.flags & StringFlags.UTF8) === StringFlags.UTF8 ? 'utf-8' : 'ucs2';\n      var stringsStart = header.startOffset + header.stringsStart;\n      this.cursor = stringsStart;\n      for (var _i = 0, _l = header.stringCount; _i < _l; ++_i) {\n        this.cursor = stringsStart + offsets[_i];\n        this.strings.push(this.readString(encoding));\n      }\n      this.cursor = header.startOffset + header.chunkSize;\n      return null;\n    }\n  }, {\n    key: \"readResourceMap\",\n    value: function readResourceMap(header) {\n      var count = Math.floor((header.chunkSize - header.headerSize) / 4);\n      for (var i = 0; i < count; ++i) {\n        this.resources.push(this.readU32());\n      }\n      return null;\n    }\n  }, {\n    key: \"readXmlNamespaceStart\",\n    value: function readXmlNamespaceStart() {\n      this.readU32();\n      this.readU32();\n      this.readU32();\n      this.readU32();\n      return null;\n    }\n  }, {\n    key: \"readXmlNamespaceEnd\",\n    value: function readXmlNamespaceEnd() {\n      this.readU32();\n      this.readU32();\n      this.readU32();\n      this.readU32();\n      return null;\n    }\n  }, {\n    key: \"readXmlElementStart\",\n    value: function readXmlElementStart() {\n      var node = {\n        namespaceURI: null,\n        nodeType: NodeType.ELEMENT_NODE,\n        nodeName: null,\n        attributes: [],\n        childNodes: []\n      };\n      this.readU32();\n      this.readU32();\n      var nsRef = this.readS32();\n      var nameRef = this.readS32();\n      if (nsRef > 0) {\n        node.namespaceURI = this.strings[nsRef];\n      }\n      node.nodeName = this.strings[nameRef];\n      this.readU16();\n      this.readU16();\n      var attrCount = this.readU16();\n      this.readU16();\n      this.readU16();\n      this.readU16();\n      for (var i = 0; i < attrCount; ++i) {\n        node.attributes.push(this.readXmlAttribute());\n      }\n      if (this.document) {\n        this.parent.childNodes.push(node);\n        this.parent = node;\n      } else {\n        this.document = this.parent = node;\n      }\n      this.stack.push(node);\n      return node;\n    }\n  }, {\n    key: \"readXmlAttribute\",\n    value: function readXmlAttribute() {\n      var attr = {\n        namespaceURI: null,\n        nodeType: NodeType.ATTRIBUTE_NODE,\n        nodeName: null,\n        name: null,\n        value: null,\n        typedValue: null\n      };\n      var nsRef = this.readS32();\n      var nameRef = this.readS32();\n      var valueRef = this.readS32();\n      if (nsRef > 0) {\n        attr.namespaceURI = this.strings[nsRef];\n      }\n      attr.nodeName = attr.name = this.strings[nameRef];\n      if (valueRef > 0) {\n        attr.value = this.strings[valueRef];\n      }\n      attr.typedValue = this.readTypedValue();\n      return attr;\n    }\n  }, {\n    key: \"readXmlElementEnd\",\n    value: function readXmlElementEnd() {\n      this.readU32();\n      this.readU32();\n      this.readU32();\n      this.readU32();\n      this.stack.pop();\n      this.parent = this.stack[this.stack.length - 1];\n      return null;\n    }\n  }, {\n    key: \"readXmlCData\",\n    value: function readXmlCData() {\n      var cdata = {\n        namespaceURI: null,\n        nodeType: NodeType.CDATA_SECTION_NODE,\n        nodeName: '#cdata',\n        data: null,\n        typedValue: null\n      };\n      this.readU32();\n      this.readU32();\n      var dataRef = this.readS32();\n      if (dataRef > 0) {\n        cdata.data = this.strings[dataRef];\n      }\n      cdata.typedValue = this.readTypedValue();\n      this.parent.childNodes.push(cdata);\n      return cdata;\n    }\n  }, {\n    key: \"readNull\",\n    value: function readNull(header) {\n      this.cursor += header.chunkSize - header.headerSize;\n      return null;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse() {\n      var xmlHeader = this.readChunkHeader();\n      if (xmlHeader.chunkType !== ChunkType.XML) {\n        throw new assert.AssertionError({\n          message: 'Invalid XML header'\n        });\n      }\n      while (this.cursor < this.buffer.length) {\n        var start = this.cursor;\n        var header = this.readChunkHeader();\n        switch (header.chunkType) {\n          case ChunkType.STRING_POOL:\n            this.readStringPool(header);\n            break;\n          case ChunkType.XML_RESOURCE_MAP:\n            this.readResourceMap(header);\n            break;\n          case ChunkType.XML_START_NAMESPACE:\n            this.readXmlNamespaceStart();\n            break;\n          case ChunkType.XML_END_NAMESPACE:\n            this.readXmlNamespaceEnd();\n            break;\n          case ChunkType.XML_START_ELEMENT:\n            this.readXmlElementStart();\n            break;\n          case ChunkType.XML_END_ELEMENT:\n            this.readXmlElementEnd();\n            break;\n          case ChunkType.XML_CDATA:\n            this.readXmlCData();\n            break;\n          case ChunkType.NULL:\n            this.readNull(header);\n            break;\n          default:\n            throw new assert.AssertionError({\n              message: `Unsupported chunk type '${header.chunkType}'`\n            });\n        }\n        var end = start + header.chunkSize;\n        if (this.cursor !== end) {}\n      }\n      return this.document;\n    }\n  }]);\n  return BinaryXmlParser;\n}();\nexports.BinaryXmlParser = BinaryXmlParser;","map":{"version":3,"names":["assert","__importStar","require","NodeType","ELEMENT_NODE","ATTRIBUTE_NODE","CDATA_SECTION_NODE","ChunkType","NULL","STRING_POOL","TABLE","XML","XML_FIRST_CHUNK","XML_START_NAMESPACE","XML_END_NAMESPACE","XML_START_ELEMENT","XML_END_ELEMENT","XML_CDATA","XML_LAST_CHUNK","XML_RESOURCE_MAP","TABLE_PACKAGE","TABLE_TYPE","TABLE_TYPE_SPEC","StringFlags","SORTED","UTF8","TypedValue","COMPLEX_MANTISSA_MASK","COMPLEX_MANTISSA_SHIFT","COMPLEX_RADIX_0p23","COMPLEX_RADIX_16p7","COMPLEX_RADIX_23p0","COMPLEX_RADIX_8p15","COMPLEX_RADIX_MASK","COMPLEX_RADIX_SHIFT","COMPLEX_UNIT_DIP","COMPLEX_UNIT_FRACTION","COMPLEX_UNIT_FRACTION_PARENT","COMPLEX_UNIT_IN","COMPLEX_UNIT_MASK","COMPLEX_UNIT_MM","COMPLEX_UNIT_PT","COMPLEX_UNIT_PX","COMPLEX_UNIT_SHIFT","COMPLEX_UNIT_SP","DENSITY_DEFAULT","DENSITY_NONE","TYPE_ATTRIBUTE","TYPE_DIMENSION","TYPE_FIRST_COLOR_INT","TYPE_FIRST_INT","TYPE_FLOAT","TYPE_FRACTION","TYPE_INT_BOOLEAN","TYPE_INT_COLOR_ARGB4","TYPE_INT_COLOR_ARGB8","TYPE_INT_COLOR_RGB4","TYPE_INT_COLOR_RGB8","TYPE_INT_DEC","TYPE_INT_HEX","TYPE_LAST_COLOR_INT","TYPE_LAST_INT","TYPE_NULL","TYPE_REFERENCE","TYPE_STRING","BinaryXmlParser","buffer","options","arguments","length","undefined","_classCallCheck","cursor","strings","resources","stack","debug","_createClass","key","value","readU8","val","readU16","readUInt16LE","readS32","readInt32LE","readU32","readUInt32LE","readLength8","len","readLength16","readDimension","dimension","unit","rawUnit","readFraction","fraction","type","rawType","convertIntToFloat","readHex24","toString","readHex32","readTypedValue","typedValue","start","size","dataType","ref","id","end","int","buf","ArrayBuffer","Int32Array","Float32Array","readString","encoding","stringLength","byteLength","equal","AssertionError","message","readChunkHeader","startOffset","chunkType","headerSize","chunkSize","readStringPool","header","stringCount","styleCount","flags","stringsStart","stylesStart","offsets","i","l","push","readResourceMap","count","Math","floor","readXmlNamespaceStart","readXmlNamespaceEnd","readXmlElementStart","node","namespaceURI","nodeType","nodeName","attributes","childNodes","nsRef","nameRef","attrCount","readXmlAttribute","document","parent","attr","name","valueRef","readXmlElementEnd","pop","readXmlCData","cdata","data","dataRef","readNull","parse","xmlHeader","exports"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\plist\\src\\binary.ts"],"sourcesContent":["/**\n * https://github.com/openstf/adbkit-apkreader/blob/368f6b207c57e82fa7373c1608920ca7f4a8904c/lib/apkreader/parser/binaryxml.js\n */\nimport * as assert from 'assert';\n\n// import * as Debug from 'debug';\n// const debug = Debug('native-run:android:util:binary-xml-parser');\n\nconst NodeType = {\n  ELEMENT_NODE: 1,\n  ATTRIBUTE_NODE: 2,\n  CDATA_SECTION_NODE: 4,\n};\n\nconst ChunkType = {\n  NULL: 0x0000,\n  STRING_POOL: 0x0001,\n  TABLE: 0x0002,\n  XML: 0x0003,\n  XML_FIRST_CHUNK: 0x0100,\n  XML_START_NAMESPACE: 0x0100,\n  XML_END_NAMESPACE: 0x0101,\n  XML_START_ELEMENT: 0x0102,\n  XML_END_ELEMENT: 0x0103,\n  XML_CDATA: 0x0104,\n  XML_LAST_CHUNK: 0x017f,\n  XML_RESOURCE_MAP: 0x0180,\n  TABLE_PACKAGE: 0x0200,\n  TABLE_TYPE: 0x0201,\n  TABLE_TYPE_SPEC: 0x0202,\n};\n\nconst StringFlags = {\n  SORTED: 1 << 0,\n  UTF8: 1 << 8,\n};\n\n// Taken from android.util.TypedValue\nconst TypedValue = {\n  COMPLEX_MANTISSA_MASK: 0x00ffffff,\n  COMPLEX_MANTISSA_SHIFT: 0x00000008,\n  COMPLEX_RADIX_0p23: 0x00000003,\n  COMPLEX_RADIX_16p7: 0x00000001,\n  COMPLEX_RADIX_23p0: 0x00000000,\n  COMPLEX_RADIX_8p15: 0x00000002,\n  COMPLEX_RADIX_MASK: 0x00000003,\n  COMPLEX_RADIX_SHIFT: 0x00000004,\n  COMPLEX_UNIT_DIP: 0x00000001,\n  COMPLEX_UNIT_FRACTION: 0x00000000,\n  COMPLEX_UNIT_FRACTION_PARENT: 0x00000001,\n  COMPLEX_UNIT_IN: 0x00000004,\n  COMPLEX_UNIT_MASK: 0x0000000f,\n  COMPLEX_UNIT_MM: 0x00000005,\n  COMPLEX_UNIT_PT: 0x00000003,\n  COMPLEX_UNIT_PX: 0x00000000,\n  COMPLEX_UNIT_SHIFT: 0x00000000,\n  COMPLEX_UNIT_SP: 0x00000002,\n  DENSITY_DEFAULT: 0x00000000,\n  DENSITY_NONE: 0x0000ffff,\n  TYPE_ATTRIBUTE: 0x00000002,\n  TYPE_DIMENSION: 0x00000005,\n  TYPE_FIRST_COLOR_INT: 0x0000001c,\n  TYPE_FIRST_INT: 0x00000010,\n  TYPE_FLOAT: 0x00000004,\n  TYPE_FRACTION: 0x00000006,\n  TYPE_INT_BOOLEAN: 0x00000012,\n  TYPE_INT_COLOR_ARGB4: 0x0000001e,\n  TYPE_INT_COLOR_ARGB8: 0x0000001c,\n  TYPE_INT_COLOR_RGB4: 0x0000001f,\n  TYPE_INT_COLOR_RGB8: 0x0000001d,\n  TYPE_INT_DEC: 0x00000010,\n  TYPE_INT_HEX: 0x00000011,\n  TYPE_LAST_COLOR_INT: 0x0000001f,\n  TYPE_LAST_INT: 0x0000001f,\n  TYPE_NULL: 0x00000000,\n  TYPE_REFERENCE: 0x00000001,\n  TYPE_STRING: 0x00000003,\n};\n\nexport class BinaryXmlParser {\n  cursor = 0;\n  strings: string[] = [];\n  resources: any[] = [];\n  document: any;\n  parent: any;\n  stack: any[] = [];\n  debug = false;\n  constructor(public buffer: Buffer, options: any = {}) {\n    this.debug = options.debug || false;\n  }\n\n  readU8(): number {\n    const val = this.buffer[this.cursor];\n    this.cursor += 1;\n    return val;\n  }\n\n  readU16(): number {\n    const val = this.buffer.readUInt16LE(this.cursor);\n    this.cursor += 2;\n    return val;\n  }\n\n  readS32(): number {\n    const val = this.buffer.readInt32LE(this.cursor);\n    this.cursor += 4;\n    return val;\n  }\n\n  readU32(): number {\n    // debug('readU32');\n    // debug('cursor:', this.cursor);\n    const val = this.buffer.readUInt32LE(this.cursor);\n    // debug('value:', val);\n    this.cursor += 4;\n    return val;\n  }\n\n  readLength8(): number {\n    // debug('readLength8');\n    let len = this.readU8();\n    if (len & 0x80) {\n      len = (len & 0x7f) << 8;\n      len += this.readU8();\n    }\n    // debug('length:', len);\n    return len;\n  }\n\n  readLength16(): number {\n    // debug('readLength16');\n    let len = this.readU16();\n    if (len & 0x8000) {\n      len = (len & 0x7fff) << 16;\n      len += this.readU16();\n    }\n    // debug('length:', len);\n    return len;\n  }\n\n  readDimension(): any {\n    // debug('readDimension');\n\n    const dimension: any = {\n      value: null,\n      unit: null,\n      rawUnit: null,\n    };\n\n    const value = this.readU32();\n    const unit = dimension.value & 0xff;\n\n    dimension.value = value >> 8;\n    dimension.rawUnit = unit;\n\n    switch (unit) {\n      case TypedValue.COMPLEX_UNIT_MM:\n        dimension.unit = 'mm';\n        break;\n      case TypedValue.COMPLEX_UNIT_PX:\n        dimension.unit = 'px';\n        break;\n      case TypedValue.COMPLEX_UNIT_DIP:\n        dimension.unit = 'dp';\n        break;\n      case TypedValue.COMPLEX_UNIT_SP:\n        dimension.unit = 'sp';\n        break;\n      case TypedValue.COMPLEX_UNIT_PT:\n        dimension.unit = 'pt';\n        break;\n      case TypedValue.COMPLEX_UNIT_IN:\n        dimension.unit = 'in';\n        break;\n    }\n\n    return dimension;\n  }\n\n  readFraction(): any {\n    const fraction: any = {\n      value: null,\n      type: null,\n      rawType: null,\n    };\n\n    const value = this.readU32();\n    const type = value & 0xf;\n\n    fraction.value = this.convertIntToFloat(value >> 4);\n    fraction.rawType = type;\n\n    switch (type) {\n      case TypedValue.COMPLEX_UNIT_FRACTION:\n        fraction.type = '%';\n        break;\n      case TypedValue.COMPLEX_UNIT_FRACTION_PARENT:\n        fraction.type = '%p';\n        break;\n    }\n\n    return fraction;\n  }\n\n  readHex24(): string {\n    const val = (this.readU32() & 0xffffff).toString(16);\n    return val;\n  }\n\n  readHex32(): string {\n    const val = this.readU32().toString(16);\n    return val;\n  }\n\n  readTypedValue(): any {\n    const typedValue: any = {\n      value: null,\n      type: null,\n      rawType: null,\n    };\n\n    const start = this.cursor;\n\n    let size = this.readU16();\n    /* const zero = */ this.readU8();\n    const dataType = this.readU8();\n\n    // Yes, there has been a real world APK where the size is malformed.\n    if (size === 0) {\n      size = 8;\n    }\n\n    typedValue.rawType = dataType;\n\n    switch (dataType) {\n      case TypedValue.TYPE_INT_DEC:\n        typedValue.value = this.readS32();\n        typedValue.type = 'int_dec';\n        break;\n      case TypedValue.TYPE_INT_HEX:\n        typedValue.value = this.readS32();\n        typedValue.type = 'int_hex';\n        break;\n      case TypedValue.TYPE_STRING: {\n        const ref = this.readS32();\n        typedValue.value = ref > 0 ? this.strings[ref] : '';\n        typedValue.type = 'string';\n        break;\n      }\n      case TypedValue.TYPE_REFERENCE: {\n        const id = this.readU32();\n        typedValue.value = `resourceId:0x${id.toString(16)}`;\n        typedValue.type = 'reference';\n        break;\n      }\n      case TypedValue.TYPE_INT_BOOLEAN:\n        typedValue.value = this.readS32() !== 0;\n        typedValue.type = 'boolean';\n        break;\n      case TypedValue.TYPE_NULL:\n        this.readU32();\n        typedValue.value = null;\n        typedValue.type = 'null';\n        break;\n      case TypedValue.TYPE_INT_COLOR_RGB8:\n        typedValue.value = this.readHex24();\n        typedValue.type = 'rgb8';\n        break;\n      case TypedValue.TYPE_INT_COLOR_RGB4:\n        typedValue.value = this.readHex24();\n        typedValue.type = 'rgb4';\n        break;\n      case TypedValue.TYPE_INT_COLOR_ARGB8:\n        typedValue.value = this.readHex32();\n        typedValue.type = 'argb8';\n        break;\n      case TypedValue.TYPE_INT_COLOR_ARGB4:\n        typedValue.value = this.readHex32();\n        typedValue.type = 'argb4';\n        break;\n      case TypedValue.TYPE_DIMENSION:\n        typedValue.value = this.readDimension();\n        typedValue.type = 'dimension';\n        break;\n      case TypedValue.TYPE_FRACTION:\n        typedValue.value = this.readFraction();\n        typedValue.type = 'fraction';\n        break;\n      default: {\n        // const type = dataType.toString(16);\n        typedValue.value = this.readU32();\n        typedValue.type = 'unknown';\n      }\n    }\n\n    // Ensure we consume the whole value\n    const end = start + size;\n    if (this.cursor !== end) {\n      // const type = dataType.toString(16);\n      // const diff = end - this.cursor;\n      //       debug(`Cursor is off by ${diff} bytes at ${this.cursor} at supposed end \\\n      // of typed value of type 0x${type}. The typed value started at offset ${start} \\\n      // and is supposed to end at offset ${end}. Ignoring the rest of the value.`);\n      this.cursor = end;\n    }\n\n    return typedValue;\n  }\n\n  // https://twitter.com/kawasima/status/427730289201139712\n  convertIntToFloat(int: number): number {\n    const buf = new ArrayBuffer(4);\n    new Int32Array(buf)[0] = int;\n    return new Float32Array(buf)[0];\n  }\n\n  readString(encoding: string): string {\n    let stringLength;\n    let byteLength;\n    let value;\n    switch (encoding) {\n      case 'utf-8':\n        stringLength = this.readLength8();\n        byteLength = this.readLength8();\n        value = this.buffer.toString(encoding, this.cursor, (this.cursor += byteLength));\n        assert.equal(this.readU8(), 0, 'String must end with trailing zero');\n        return value;\n      case 'ucs2':\n        stringLength = this.readLength16();\n        byteLength = stringLength * 2;\n        value = this.buffer.toString(encoding, this.cursor, (this.cursor += byteLength));\n        assert.equal(this.readU16(), 0, 'String must end with trailing zero');\n        return value;\n      default:\n        throw new assert.AssertionError({ message: `Unsupported encoding '${encoding}'` });\n    }\n  }\n\n  readChunkHeader(): {\n    startOffset: number;\n    chunkType: number;\n    headerSize: number;\n    chunkSize: number;\n  } {\n    return {\n      startOffset: this.cursor,\n      chunkType: this.readU16(),\n      headerSize: this.readU16(),\n      chunkSize: this.readU32(),\n    };\n  }\n\n  readStringPool(header: any): null {\n    header.stringCount = this.readU32();\n    header.styleCount = this.readU32();\n    header.flags = this.readU32();\n    header.stringsStart = this.readU32();\n    header.stylesStart = this.readU32();\n\n    if (header.chunkType !== ChunkType.STRING_POOL) {\n      throw new assert.AssertionError({ message: 'Invalid string pool header' });\n    }\n\n    const offsets = [];\n    for (let i = 0, l = header.stringCount; i < l; ++i) {\n      offsets.push(this.readU32());\n    }\n\n    const encoding = (header.flags & StringFlags.UTF8) === StringFlags.UTF8 ? 'utf-8' : 'ucs2';\n\n    const stringsStart = header.startOffset + header.stringsStart;\n    this.cursor = stringsStart;\n    for (let i = 0, l = header.stringCount; i < l; ++i) {\n      this.cursor = stringsStart + offsets[i];\n      this.strings.push(this.readString(encoding));\n    }\n\n    // Skip styles\n    this.cursor = header.startOffset + header.chunkSize;\n\n    return null;\n  }\n\n  readResourceMap(header: any): null {\n    const count = Math.floor((header.chunkSize - header.headerSize) / 4);\n    for (let i = 0; i < count; ++i) {\n      this.resources.push(this.readU32());\n    }\n    return null;\n  }\n\n  readXmlNamespaceStart(/* header */): null {\n    this.readU32();\n    this.readU32();\n    this.readU32();\n    this.readU32();\n\n    // const line = this.readU32();\n    // const commentRef = this.readU32();\n    // const prefixRef = this.readS32();\n    // const uriRef = this.readS32();\n\n    // We don't currently care about the values, but they could\n    // be accessed like so:\n    //\n    // namespaceURI.prefix = this.strings[prefixRef] // if prefixRef > 0\n    // namespaceURI.uri = this.strings[uriRef] // if uriRef > 0\n\n    return null;\n  }\n\n  readXmlNamespaceEnd(/* header */): null {\n    // debug('readXmlNamespaceEnd');\n\n    this.readU32();\n    this.readU32();\n    this.readU32();\n    this.readU32();\n\n    // const line = this.readU32();\n    // const commentRef = this.readU32();\n    // const prefixRef = this.readS32();\n    // const uriRef = this.readS32();\n\n    // We don't currently care about the values, but they could\n    // be accessed like so:\n    //\n    // namespaceURI.prefix = this.strings[prefixRef] // if prefixRef > 0\n    // namespaceURI.uri = this.strings[uriRef] // if uriRef > 0\n\n    return null;\n  }\n\n  readXmlElementStart(/* header */): any {\n    // debug('readXmlElementStart');\n\n    const node: any = {\n      namespaceURI: null,\n      nodeType: NodeType.ELEMENT_NODE,\n      nodeName: null,\n      attributes: [],\n      childNodes: [],\n    };\n\n    this.readU32();\n    this.readU32();\n    // const line = this.readU32();\n    // const commentRef = this.readU32();\n    const nsRef = this.readS32();\n    const nameRef = this.readS32();\n\n    if (nsRef > 0) {\n      node.namespaceURI = this.strings[nsRef];\n    }\n\n    node.nodeName = this.strings[nameRef];\n\n    this.readU16();\n    this.readU16();\n    // const attrStart = this.readU16();\n    // const attrSize = this.readU16();\n    const attrCount = this.readU16();\n    // const idIndex = this.readU16();\n    // const classIndex = this.readU16();\n    // const styleIndex = this.readU16();\n    this.readU16();\n    this.readU16();\n    this.readU16();\n\n    for (let i = 0; i < attrCount; ++i) {\n      node.attributes.push(this.readXmlAttribute());\n    }\n\n    if (this.document) {\n      this.parent.childNodes.push(node);\n      this.parent = node;\n    } else {\n      this.document = this.parent = node;\n    }\n\n    this.stack.push(node);\n\n    return node;\n  }\n\n  readXmlAttribute(): any {\n    // debug('readXmlAttribute');\n\n    const attr: any = {\n      namespaceURI: null,\n      nodeType: NodeType.ATTRIBUTE_NODE,\n      nodeName: null,\n      name: null,\n      value: null,\n      typedValue: null,\n    };\n\n    const nsRef = this.readS32();\n    const nameRef = this.readS32();\n    const valueRef = this.readS32();\n\n    if (nsRef > 0) {\n      attr.namespaceURI = this.strings[nsRef];\n    }\n\n    attr.nodeName = attr.name = this.strings[nameRef];\n\n    if (valueRef > 0) {\n      attr.value = this.strings[valueRef];\n    }\n\n    attr.typedValue = this.readTypedValue();\n\n    return attr;\n  }\n\n  readXmlElementEnd(/* header */): null {\n    // debug('readXmlCData');\n\n    this.readU32();\n    this.readU32();\n    this.readU32();\n    this.readU32();\n    // const line = this.readU32();\n    // const commentRef = this.readU32();\n    // const nsRef = this.readS32();\n    // const nameRef = this.readS32();\n\n    this.stack.pop();\n    this.parent = this.stack[this.stack.length - 1];\n\n    return null;\n  }\n\n  readXmlCData(/* header */): any {\n    // debug('readXmlCData');\n\n    const cdata: any = {\n      namespaceURI: null,\n      nodeType: NodeType.CDATA_SECTION_NODE,\n      nodeName: '#cdata',\n      data: null,\n      typedValue: null,\n    };\n\n    this.readU32();\n    this.readU32();\n    // const line = this.readU32();\n    // const commentRef = this.readU32();\n    const dataRef = this.readS32();\n\n    if (dataRef > 0) {\n      cdata.data = this.strings[dataRef];\n    }\n\n    cdata.typedValue = this.readTypedValue();\n\n    this.parent.childNodes.push(cdata);\n\n    return cdata;\n  }\n\n  readNull(header: any): null {\n    // debug('readNull');\n    this.cursor += header.chunkSize - header.headerSize;\n    return null;\n  }\n\n  parse(): any {\n    // debug('parse');\n\n    const xmlHeader = this.readChunkHeader();\n    if (xmlHeader.chunkType !== ChunkType.XML) {\n      throw new assert.AssertionError({ message: 'Invalid XML header' });\n    }\n\n    while (this.cursor < this.buffer.length) {\n      // debug('chunk');\n      const start = this.cursor;\n      const header = this.readChunkHeader();\n      switch (header.chunkType) {\n        case ChunkType.STRING_POOL:\n          this.readStringPool(header);\n          break;\n        case ChunkType.XML_RESOURCE_MAP:\n          this.readResourceMap(header);\n          break;\n        case ChunkType.XML_START_NAMESPACE:\n          this.readXmlNamespaceStart();\n          break;\n        case ChunkType.XML_END_NAMESPACE:\n          this.readXmlNamespaceEnd();\n          break;\n        case ChunkType.XML_START_ELEMENT:\n          this.readXmlElementStart();\n          break;\n        case ChunkType.XML_END_ELEMENT:\n          this.readXmlElementEnd();\n          break;\n        case ChunkType.XML_CDATA:\n          this.readXmlCData();\n          break;\n        case ChunkType.NULL:\n          this.readNull(header);\n          break;\n        default:\n          throw new assert.AssertionError({\n            message: `Unsupported chunk type '${header.chunkType}'`,\n          });\n      }\n\n      // Ensure we consume the whole chunk\n      const end = start + header.chunkSize;\n      if (this.cursor !== end) {\n        // const diff = end - this.cursor;\n        // const type = header.chunkType.toString(16);\n        // debug(`Cursor is off by ${diff} bytes at ${this.cursor} at supposed \\\n        // end of chunk of type 0x${type}. The chunk started at offset ${start} and is \\\n        // supposed to end at offset ${end}. Ignoring the rest of the chunk.`);\n        //         this.cursor = end;\n      }\n    }\n\n    return this.document;\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA,IAAAA,MAAA,GAAAC,YAAA,CAAAC,OAAA;AAKA,IAAMC,QAAQ,GAAG;EACfC,YAAY,EAAE,CAAC;EACfC,cAAc,EAAE,CAAC;EACjBC,kBAAkB,EAAE;CACrB;AAED,IAAMC,SAAS,GAAG;EAChBC,IAAI,EAAE,MAAM;EACZC,WAAW,EAAE,MAAM;EACnBC,KAAK,EAAE,MAAM;EACbC,GAAG,EAAE,MAAM;EACXC,eAAe,EAAE,MAAM;EACvBC,mBAAmB,EAAE,MAAM;EAC3BC,iBAAiB,EAAE,MAAM;EACzBC,iBAAiB,EAAE,MAAM;EACzBC,eAAe,EAAE,MAAM;EACvBC,SAAS,EAAE,MAAM;EACjBC,cAAc,EAAE,MAAM;EACtBC,gBAAgB,EAAE,MAAM;EACxBC,aAAa,EAAE,MAAM;EACrBC,UAAU,EAAE,MAAM;EAClBC,eAAe,EAAE;CAClB;AAED,IAAMC,WAAW,GAAG;EAClBC,MAAM,EAAE,CAAC,IAAI,CAAC;EACdC,IAAI,EAAE,CAAC,IAAI;CACZ;AAGD,IAAMC,UAAU,GAAG;EACjBC,qBAAqB,EAAE,UAAU;EACjCC,sBAAsB,EAAE,UAAU;EAClCC,kBAAkB,EAAE,UAAU;EAC9BC,kBAAkB,EAAE,UAAU;EAC9BC,kBAAkB,EAAE,UAAU;EAC9BC,kBAAkB,EAAE,UAAU;EAC9BC,kBAAkB,EAAE,UAAU;EAC9BC,mBAAmB,EAAE,UAAU;EAC/BC,gBAAgB,EAAE,UAAU;EAC5BC,qBAAqB,EAAE,UAAU;EACjCC,4BAA4B,EAAE,UAAU;EACxCC,eAAe,EAAE,UAAU;EAC3BC,iBAAiB,EAAE,UAAU;EAC7BC,eAAe,EAAE,UAAU;EAC3BC,eAAe,EAAE,UAAU;EAC3BC,eAAe,EAAE,UAAU;EAC3BC,kBAAkB,EAAE,UAAU;EAC9BC,eAAe,EAAE,UAAU;EAC3BC,eAAe,EAAE,UAAU;EAC3BC,YAAY,EAAE,UAAU;EACxBC,cAAc,EAAE,UAAU;EAC1BC,cAAc,EAAE,UAAU;EAC1BC,oBAAoB,EAAE,UAAU;EAChCC,cAAc,EAAE,UAAU;EAC1BC,UAAU,EAAE,UAAU;EACtBC,aAAa,EAAE,UAAU;EACzBC,gBAAgB,EAAE,UAAU;EAC5BC,oBAAoB,EAAE,UAAU;EAChCC,oBAAoB,EAAE,UAAU;EAChCC,mBAAmB,EAAE,UAAU;EAC/BC,mBAAmB,EAAE,UAAU;EAC/BC,YAAY,EAAE,UAAU;EACxBC,YAAY,EAAE,UAAU;EACxBC,mBAAmB,EAAE,UAAU;EAC/BC,aAAa,EAAE,UAAU;EACzBC,SAAS,EAAE,UAAU;EACrBC,cAAc,EAAE,UAAU;EAC1BC,WAAW,EAAE;CACd;AAAC,IAEWC,eAAe;EAQ1B,SAAAA,gBAAmBC,MAAc,EAAmB;IAAA,IAAjBC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAe,EAAE;IAAAG,eAAA,OAAAN,eAAA;IAAjC,KAAAC,MAAM,GAANA,MAAM;IAPzB,KAAAM,MAAM,GAAG,CAAC;IACV,KAAAC,OAAO,GAAa,EAAE;IACtB,KAAAC,SAAS,GAAU,EAAE;IAGrB,KAAAC,KAAK,GAAU,EAAE;IACjB,KAAAC,KAAK,GAAG,KAAK;IAEX,IAAI,CAACA,KAAK,GAAGT,OAAO,CAACS,KAAK,IAAI,KAAK;EACrC;EAACC,YAAA,CAAAZ,eAAA;IAAAa,GAAA;IAAAC,KAAA,EAED,SAAAC,OAAA,EAAM;MACJ,IAAMC,GAAG,GAAG,IAAI,CAACf,MAAM,CAAC,IAAI,CAACM,MAAM,CAAC;MACpC,IAAI,CAACA,MAAM,IAAI,CAAC;MAChB,OAAOS,GAAG;IACZ;EAAC;IAAAH,GAAA;IAAAC,KAAA,EAED,SAAAG,QAAA,EAAO;MACL,IAAMD,GAAG,GAAG,IAAI,CAACf,MAAM,CAACiB,YAAY,CAAC,IAAI,CAACX,MAAM,CAAC;MACjD,IAAI,CAACA,MAAM,IAAI,CAAC;MAChB,OAAOS,GAAG;IACZ;EAAC;IAAAH,GAAA;IAAAC,KAAA,EAED,SAAAK,QAAA,EAAO;MACL,IAAMH,GAAG,GAAG,IAAI,CAACf,MAAM,CAACmB,WAAW,CAAC,IAAI,CAACb,MAAM,CAAC;MAChD,IAAI,CAACA,MAAM,IAAI,CAAC;MAChB,OAAOS,GAAG;IACZ;EAAC;IAAAH,GAAA;IAAAC,KAAA,EAED,SAAAO,QAAA,EAAO;MAGL,IAAML,GAAG,GAAG,IAAI,CAACf,MAAM,CAACqB,YAAY,CAAC,IAAI,CAACf,MAAM,CAAC;MAEjD,IAAI,CAACA,MAAM,IAAI,CAAC;MAChB,OAAOS,GAAG;IACZ;EAAC;IAAAH,GAAA;IAAAC,KAAA,EAED,SAAAS,YAAA,EAAW;MAET,IAAIC,GAAG,GAAG,IAAI,CAACT,MAAM,EAAE;MACvB,IAAIS,GAAG,GAAG,IAAI,EAAE;QACdA,GAAG,GAAG,CAACA,GAAG,GAAG,IAAI,KAAK,CAAC;QACvBA,GAAG,IAAI,IAAI,CAACT,MAAM,EAAE;;MAGtB,OAAOS,GAAG;IACZ;EAAC;IAAAX,GAAA;IAAAC,KAAA,EAED,SAAAW,aAAA,EAAY;MAEV,IAAID,GAAG,GAAG,IAAI,CAACP,OAAO,EAAE;MACxB,IAAIO,GAAG,GAAG,MAAM,EAAE;QAChBA,GAAG,GAAG,CAACA,GAAG,GAAG,MAAM,KAAK,EAAE;QAC1BA,GAAG,IAAI,IAAI,CAACP,OAAO,EAAE;;MAGvB,OAAOO,GAAG;IACZ;EAAC;IAAAX,GAAA;IAAAC,KAAA,EAED,SAAAY,cAAA,EAAa;MAGX,IAAMC,SAAS,GAAQ;QACrBb,KAAK,EAAE,IAAI;QACXc,IAAI,EAAE,IAAI;QACVC,OAAO,EAAE;OACV;MAED,IAAMf,KAAK,GAAG,IAAI,CAACO,OAAO,EAAE;MAC5B,IAAMO,IAAI,GAAGD,SAAS,CAACb,KAAK,GAAG,IAAI;MAEnCa,SAAS,CAACb,KAAK,GAAGA,KAAK,IAAI,CAAC;MAC5Ba,SAAS,CAACE,OAAO,GAAGD,IAAI;MAExB,QAAQA,IAAI;QACV,KAAKnE,UAAU,CAACc,eAAe;UAC7BoD,SAAS,CAACC,IAAI,GAAG,IAAI;UACrB;QACF,KAAKnE,UAAU,CAACgB,eAAe;UAC7BkD,SAAS,CAACC,IAAI,GAAG,IAAI;UACrB;QACF,KAAKnE,UAAU,CAACS,gBAAgB;UAC9ByD,SAAS,CAACC,IAAI,GAAG,IAAI;UACrB;QACF,KAAKnE,UAAU,CAACkB,eAAe;UAC7BgD,SAAS,CAACC,IAAI,GAAG,IAAI;UACrB;QACF,KAAKnE,UAAU,CAACe,eAAe;UAC7BmD,SAAS,CAACC,IAAI,GAAG,IAAI;UACrB;QACF,KAAKnE,UAAU,CAACY,eAAe;UAC7BsD,SAAS,CAACC,IAAI,GAAG,IAAI;UACrB;;MAGJ,OAAOD,SAAS;IAClB;EAAC;IAAAd,GAAA;IAAAC,KAAA,EAED,SAAAgB,aAAA,EAAY;MACV,IAAMC,QAAQ,GAAQ;QACpBjB,KAAK,EAAE,IAAI;QACXkB,IAAI,EAAE,IAAI;QACVC,OAAO,EAAE;OACV;MAED,IAAMnB,KAAK,GAAG,IAAI,CAACO,OAAO,EAAE;MAC5B,IAAMW,IAAI,GAAGlB,KAAK,GAAG,GAAG;MAExBiB,QAAQ,CAACjB,KAAK,GAAG,IAAI,CAACoB,iBAAiB,CAACpB,KAAK,IAAI,CAAC,CAAC;MACnDiB,QAAQ,CAACE,OAAO,GAAGD,IAAI;MAEvB,QAAQA,IAAI;QACV,KAAKvE,UAAU,CAACU,qBAAqB;UACnC4D,QAAQ,CAACC,IAAI,GAAG,GAAG;UACnB;QACF,KAAKvE,UAAU,CAACW,4BAA4B;UAC1C2D,QAAQ,CAACC,IAAI,GAAG,IAAI;UACpB;;MAGJ,OAAOD,QAAQ;IACjB;EAAC;IAAAlB,GAAA;IAAAC,KAAA,EAED,SAAAqB,UAAA,EAAS;MACP,IAAMnB,GAAG,GAAG,CAAC,IAAI,CAACK,OAAO,EAAE,GAAG,QAAQ,EAAEe,QAAQ,CAAC,EAAE,CAAC;MACpD,OAAOpB,GAAG;IACZ;EAAC;IAAAH,GAAA;IAAAC,KAAA,EAED,SAAAuB,UAAA,EAAS;MACP,IAAMrB,GAAG,GAAG,IAAI,CAACK,OAAO,EAAE,CAACe,QAAQ,CAAC,EAAE,CAAC;MACvC,OAAOpB,GAAG;IACZ;EAAC;IAAAH,GAAA;IAAAC,KAAA,EAED,SAAAwB,eAAA,EAAc;MACZ,IAAMC,UAAU,GAAQ;QACtBzB,KAAK,EAAE,IAAI;QACXkB,IAAI,EAAE,IAAI;QACVC,OAAO,EAAE;OACV;MAED,IAAMO,KAAK,GAAG,IAAI,CAACjC,MAAM;MAEzB,IAAIkC,IAAI,GAAG,IAAI,CAACxB,OAAO,EAAE;MACN,IAAI,CAACF,MAAM,EAAE;MAChC,IAAM2B,QAAQ,GAAG,IAAI,CAAC3B,MAAM,EAAE;MAG9B,IAAI0B,IAAI,KAAK,CAAC,EAAE;QACdA,IAAI,GAAG,CAAC;;MAGVF,UAAU,CAACN,OAAO,GAAGS,QAAQ;MAE7B,QAAQA,QAAQ;QACd,KAAKjF,UAAU,CAACgC,YAAY;UAC1B8C,UAAU,CAACzB,KAAK,GAAG,IAAI,CAACK,OAAO,EAAE;UACjCoB,UAAU,CAACP,IAAI,GAAG,SAAS;UAC3B;QACF,KAAKvE,UAAU,CAACiC,YAAY;UAC1B6C,UAAU,CAACzB,KAAK,GAAG,IAAI,CAACK,OAAO,EAAE;UACjCoB,UAAU,CAACP,IAAI,GAAG,SAAS;UAC3B;QACF,KAAKvE,UAAU,CAACsC,WAAW;UAAE;YAC3B,IAAM4C,GAAG,GAAG,IAAI,CAACxB,OAAO,EAAE;YAC1BoB,UAAU,CAACzB,KAAK,GAAG6B,GAAG,GAAG,CAAC,GAAG,IAAI,CAACnC,OAAO,CAACmC,GAAG,CAAC,GAAG,EAAE;YACnDJ,UAAU,CAACP,IAAI,GAAG,QAAQ;YAC1B;;QAEF,KAAKvE,UAAU,CAACqC,cAAc;UAAE;YAC9B,IAAM8C,EAAE,GAAG,IAAI,CAACvB,OAAO,EAAE;YACzBkB,UAAU,CAACzB,KAAK,GAAG,gBAAgB8B,EAAE,CAACR,QAAQ,CAAC,EAAE,CAAC,EAAE;YACpDG,UAAU,CAACP,IAAI,GAAG,WAAW;YAC7B;;QAEF,KAAKvE,UAAU,CAAC2B,gBAAgB;UAC9BmD,UAAU,CAACzB,KAAK,GAAG,IAAI,CAACK,OAAO,EAAE,KAAK,CAAC;UACvCoB,UAAU,CAACP,IAAI,GAAG,SAAS;UAC3B;QACF,KAAKvE,UAAU,CAACoC,SAAS;UACvB,IAAI,CAACwB,OAAO,EAAE;UACdkB,UAAU,CAACzB,KAAK,GAAG,IAAI;UACvByB,UAAU,CAACP,IAAI,GAAG,MAAM;UACxB;QACF,KAAKvE,UAAU,CAAC+B,mBAAmB;UACjC+C,UAAU,CAACzB,KAAK,GAAG,IAAI,CAACqB,SAAS,EAAE;UACnCI,UAAU,CAACP,IAAI,GAAG,MAAM;UACxB;QACF,KAAKvE,UAAU,CAAC8B,mBAAmB;UACjCgD,UAAU,CAACzB,KAAK,GAAG,IAAI,CAACqB,SAAS,EAAE;UACnCI,UAAU,CAACP,IAAI,GAAG,MAAM;UACxB;QACF,KAAKvE,UAAU,CAAC6B,oBAAoB;UAClCiD,UAAU,CAACzB,KAAK,GAAG,IAAI,CAACuB,SAAS,EAAE;UACnCE,UAAU,CAACP,IAAI,GAAG,OAAO;UACzB;QACF,KAAKvE,UAAU,CAAC4B,oBAAoB;UAClCkD,UAAU,CAACzB,KAAK,GAAG,IAAI,CAACuB,SAAS,EAAE;UACnCE,UAAU,CAACP,IAAI,GAAG,OAAO;UACzB;QACF,KAAKvE,UAAU,CAACsB,cAAc;UAC5BwD,UAAU,CAACzB,KAAK,GAAG,IAAI,CAACY,aAAa,EAAE;UACvCa,UAAU,CAACP,IAAI,GAAG,WAAW;UAC7B;QACF,KAAKvE,UAAU,CAAC0B,aAAa;UAC3BoD,UAAU,CAACzB,KAAK,GAAG,IAAI,CAACgB,YAAY,EAAE;UACtCS,UAAU,CAACP,IAAI,GAAG,UAAU;UAC5B;QACF;UAAS;YAEPO,UAAU,CAACzB,KAAK,GAAG,IAAI,CAACO,OAAO,EAAE;YACjCkB,UAAU,CAACP,IAAI,GAAG,SAAS;;;MAK/B,IAAMa,GAAG,GAAGL,KAAK,GAAGC,IAAI;MACxB,IAAI,IAAI,CAAClC,MAAM,KAAKsC,GAAG,EAAE;QAMvB,IAAI,CAACtC,MAAM,GAAGsC,GAAG;;MAGnB,OAAON,UAAU;IACnB;EAAC;IAAA1B,GAAA;IAAAC,KAAA,EAGD,SAAAoB,kBAAkBY,GAAW;MAC3B,IAAMC,GAAG,GAAG,IAAIC,WAAW,CAAC,CAAC,CAAC;MAC9B,IAAIC,UAAU,CAACF,GAAG,CAAC,CAAC,CAAC,CAAC,GAAGD,GAAG;MAC5B,OAAO,IAAII,YAAY,CAACH,GAAG,CAAC,CAAC,CAAC,CAAC;IACjC;EAAC;IAAAlC,GAAA;IAAAC,KAAA,EAED,SAAAqC,WAAWC,QAAgB;MACzB,IAAIC,YAAY;MAChB,IAAIC,UAAU;MACd,IAAIxC,KAAK;MACT,QAAQsC,QAAQ;QACd,KAAK,OAAO;UACVC,YAAY,GAAG,IAAI,CAAC9B,WAAW,EAAE;UACjC+B,UAAU,GAAG,IAAI,CAAC/B,WAAW,EAAE;UAC/BT,KAAK,GAAG,IAAI,CAACb,MAAM,CAACmC,QAAQ,CAACgB,QAAQ,EAAE,IAAI,CAAC7C,MAAM,EAAG,IAAI,CAACA,MAAM,IAAI+C,UAAW,CAAC;UAChFvH,MAAM,CAACwH,KAAK,CAAC,IAAI,CAACxC,MAAM,EAAE,EAAE,CAAC,EAAE,oCAAoC,CAAC;UACpE,OAAOD,KAAK;QACd,KAAK,MAAM;UACTuC,YAAY,GAAG,IAAI,CAAC5B,YAAY,EAAE;UAClC6B,UAAU,GAAGD,YAAY,GAAG,CAAC;UAC7BvC,KAAK,GAAG,IAAI,CAACb,MAAM,CAACmC,QAAQ,CAACgB,QAAQ,EAAE,IAAI,CAAC7C,MAAM,EAAG,IAAI,CAACA,MAAM,IAAI+C,UAAW,CAAC;UAChFvH,MAAM,CAACwH,KAAK,CAAC,IAAI,CAACtC,OAAO,EAAE,EAAE,CAAC,EAAE,oCAAoC,CAAC;UACrE,OAAOH,KAAK;QACd;UACE,MAAM,IAAI/E,MAAM,CAACyH,cAAc,CAAC;YAAEC,OAAO,EAAE,yBAAyBL,QAAQ;UAAG,CAAE,CAAC;;IAExF;EAAC;IAAAvC,GAAA;IAAAC,KAAA,EAED,SAAA4C,gBAAA,EAAe;MAMb,OAAO;QACLC,WAAW,EAAE,IAAI,CAACpD,MAAM;QACxBqD,SAAS,EAAE,IAAI,CAAC3C,OAAO,EAAE;QACzB4C,UAAU,EAAE,IAAI,CAAC5C,OAAO,EAAE;QAC1B6C,SAAS,EAAE,IAAI,CAACzC,OAAO;OACxB;IACH;EAAC;IAAAR,GAAA;IAAAC,KAAA,EAED,SAAAiD,eAAeC,MAAW;MACxBA,MAAM,CAACC,WAAW,GAAG,IAAI,CAAC5C,OAAO,EAAE;MACnC2C,MAAM,CAACE,UAAU,GAAG,IAAI,CAAC7C,OAAO,EAAE;MAClC2C,MAAM,CAACG,KAAK,GAAG,IAAI,CAAC9C,OAAO,EAAE;MAC7B2C,MAAM,CAACI,YAAY,GAAG,IAAI,CAAC/C,OAAO,EAAE;MACpC2C,MAAM,CAACK,WAAW,GAAG,IAAI,CAAChD,OAAO,EAAE;MAEnC,IAAI2C,MAAM,CAACJ,SAAS,KAAKtH,SAAS,CAACE,WAAW,EAAE;QAC9C,MAAM,IAAIT,MAAM,CAACyH,cAAc,CAAC;UAAEC,OAAO,EAAE;QAA4B,CAAE,CAAC;;MAG5E,IAAMa,OAAO,GAAG,EAAE;MAClB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGR,MAAM,CAACC,WAAW,EAAEM,CAAC,GAAGC,CAAC,EAAE,EAAED,CAAC,EAAE;QAClDD,OAAO,CAACG,IAAI,CAAC,IAAI,CAACpD,OAAO,EAAE,CAAC;;MAG9B,IAAM+B,QAAQ,GAAG,CAACY,MAAM,CAACG,KAAK,GAAG7G,WAAW,CAACE,IAAI,MAAMF,WAAW,CAACE,IAAI,GAAG,OAAO,GAAG,MAAM;MAE1F,IAAM4G,YAAY,GAAGJ,MAAM,CAACL,WAAW,GAAGK,MAAM,CAACI,YAAY;MAC7D,IAAI,CAAC7D,MAAM,GAAG6D,YAAY;MAC1B,KAAK,IAAIG,EAAC,GAAG,CAAC,EAAEC,EAAC,GAAGR,MAAM,CAACC,WAAW,EAAEM,EAAC,GAAGC,EAAC,EAAE,EAAED,EAAC,EAAE;QAClD,IAAI,CAAChE,MAAM,GAAG6D,YAAY,GAAGE,OAAO,CAACC,EAAC,CAAC;QACvC,IAAI,CAAC/D,OAAO,CAACiE,IAAI,CAAC,IAAI,CAACtB,UAAU,CAACC,QAAQ,CAAC,CAAC;;MAI9C,IAAI,CAAC7C,MAAM,GAAGyD,MAAM,CAACL,WAAW,GAAGK,MAAM,CAACF,SAAS;MAEnD,OAAO,IAAI;IACb;EAAC;IAAAjD,GAAA;IAAAC,KAAA,EAED,SAAA4D,gBAAgBV,MAAW;MACzB,IAAMW,KAAK,GAAGC,IAAI,CAACC,KAAK,CAAC,CAACb,MAAM,CAACF,SAAS,GAAGE,MAAM,CAACH,UAAU,IAAI,CAAC,CAAC;MACpE,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGI,KAAK,EAAE,EAAEJ,CAAC,EAAE;QAC9B,IAAI,CAAC9D,SAAS,CAACgE,IAAI,CAAC,IAAI,CAACpD,OAAO,EAAE,CAAC;;MAErC,OAAO,IAAI;IACb;EAAC;IAAAR,GAAA;IAAAC,KAAA,EAED,SAAAgE,sBAAA,EAAkC;MAChC,IAAI,CAACzD,OAAO,EAAE;MACd,IAAI,CAACA,OAAO,EAAE;MACd,IAAI,CAACA,OAAO,EAAE;MACd,IAAI,CAACA,OAAO,EAAE;MAad,OAAO,IAAI;IACb;EAAC;IAAAR,GAAA;IAAAC,KAAA,EAED,SAAAiE,oBAAA,EAAgC;MAG9B,IAAI,CAAC1D,OAAO,EAAE;MACd,IAAI,CAACA,OAAO,EAAE;MACd,IAAI,CAACA,OAAO,EAAE;MACd,IAAI,CAACA,OAAO,EAAE;MAad,OAAO,IAAI;IACb;EAAC;IAAAR,GAAA;IAAAC,KAAA,EAED,SAAAkE,oBAAA,EAAgC;MAG9B,IAAMC,IAAI,GAAQ;QAChBC,YAAY,EAAE,IAAI;QAClBC,QAAQ,EAAEjJ,QAAQ,CAACC,YAAY;QAC/BiJ,QAAQ,EAAE,IAAI;QACdC,UAAU,EAAE,EAAE;QACdC,UAAU,EAAE;OACb;MAED,IAAI,CAACjE,OAAO,EAAE;MACd,IAAI,CAACA,OAAO,EAAE;MAGd,IAAMkE,KAAK,GAAG,IAAI,CAACpE,OAAO,EAAE;MAC5B,IAAMqE,OAAO,GAAG,IAAI,CAACrE,OAAO,EAAE;MAE9B,IAAIoE,KAAK,GAAG,CAAC,EAAE;QACbN,IAAI,CAACC,YAAY,GAAG,IAAI,CAAC1E,OAAO,CAAC+E,KAAK,CAAC;;MAGzCN,IAAI,CAACG,QAAQ,GAAG,IAAI,CAAC5E,OAAO,CAACgF,OAAO,CAAC;MAErC,IAAI,CAACvE,OAAO,EAAE;MACd,IAAI,CAACA,OAAO,EAAE;MAGd,IAAMwE,SAAS,GAAG,IAAI,CAACxE,OAAO,EAAE;MAIhC,IAAI,CAACA,OAAO,EAAE;MACd,IAAI,CAACA,OAAO,EAAE;MACd,IAAI,CAACA,OAAO,EAAE;MAEd,KAAK,IAAIsD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkB,SAAS,EAAE,EAAElB,CAAC,EAAE;QAClCU,IAAI,CAACI,UAAU,CAACZ,IAAI,CAAC,IAAI,CAACiB,gBAAgB,EAAE,CAAC;;MAG/C,IAAI,IAAI,CAACC,QAAQ,EAAE;QACjB,IAAI,CAACC,MAAM,CAACN,UAAU,CAACb,IAAI,CAACQ,IAAI,CAAC;QACjC,IAAI,CAACW,MAAM,GAAGX,IAAI;OACnB,MAAM;QACL,IAAI,CAACU,QAAQ,GAAG,IAAI,CAACC,MAAM,GAAGX,IAAI;;MAGpC,IAAI,CAACvE,KAAK,CAAC+D,IAAI,CAACQ,IAAI,CAAC;MAErB,OAAOA,IAAI;IACb;EAAC;IAAApE,GAAA;IAAAC,KAAA,EAED,SAAA4E,iBAAA,EAAgB;MAGd,IAAMG,IAAI,GAAQ;QAChBX,YAAY,EAAE,IAAI;QAClBC,QAAQ,EAAEjJ,QAAQ,CAACE,cAAc;QACjCgJ,QAAQ,EAAE,IAAI;QACdU,IAAI,EAAE,IAAI;QACVhF,KAAK,EAAE,IAAI;QACXyB,UAAU,EAAE;OACb;MAED,IAAMgD,KAAK,GAAG,IAAI,CAACpE,OAAO,EAAE;MAC5B,IAAMqE,OAAO,GAAG,IAAI,CAACrE,OAAO,EAAE;MAC9B,IAAM4E,QAAQ,GAAG,IAAI,CAAC5E,OAAO,EAAE;MAE/B,IAAIoE,KAAK,GAAG,CAAC,EAAE;QACbM,IAAI,CAACX,YAAY,GAAG,IAAI,CAAC1E,OAAO,CAAC+E,KAAK,CAAC;;MAGzCM,IAAI,CAACT,QAAQ,GAAGS,IAAI,CAACC,IAAI,GAAG,IAAI,CAACtF,OAAO,CAACgF,OAAO,CAAC;MAEjD,IAAIO,QAAQ,GAAG,CAAC,EAAE;QAChBF,IAAI,CAAC/E,KAAK,GAAG,IAAI,CAACN,OAAO,CAACuF,QAAQ,CAAC;;MAGrCF,IAAI,CAACtD,UAAU,GAAG,IAAI,CAACD,cAAc,EAAE;MAEvC,OAAOuD,IAAI;IACb;EAAC;IAAAhF,GAAA;IAAAC,KAAA,EAED,SAAAkF,kBAAA,EAA8B;MAG5B,IAAI,CAAC3E,OAAO,EAAE;MACd,IAAI,CAACA,OAAO,EAAE;MACd,IAAI,CAACA,OAAO,EAAE;MACd,IAAI,CAACA,OAAO,EAAE;MAMd,IAAI,CAACX,KAAK,CAACuF,GAAG,EAAE;MAChB,IAAI,CAACL,MAAM,GAAG,IAAI,CAAClF,KAAK,CAAC,IAAI,CAACA,KAAK,CAACN,MAAM,GAAG,CAAC,CAAC;MAE/C,OAAO,IAAI;IACb;EAAC;IAAAS,GAAA;IAAAC,KAAA,EAED,SAAAoF,aAAA,EAAyB;MAGvB,IAAMC,KAAK,GAAQ;QACjBjB,YAAY,EAAE,IAAI;QAClBC,QAAQ,EAAEjJ,QAAQ,CAACG,kBAAkB;QACrC+I,QAAQ,EAAE,QAAQ;QAClBgB,IAAI,EAAE,IAAI;QACV7D,UAAU,EAAE;OACb;MAED,IAAI,CAAClB,OAAO,EAAE;MACd,IAAI,CAACA,OAAO,EAAE;MAGd,IAAMgF,OAAO,GAAG,IAAI,CAAClF,OAAO,EAAE;MAE9B,IAAIkF,OAAO,GAAG,CAAC,EAAE;QACfF,KAAK,CAACC,IAAI,GAAG,IAAI,CAAC5F,OAAO,CAAC6F,OAAO,CAAC;;MAGpCF,KAAK,CAAC5D,UAAU,GAAG,IAAI,CAACD,cAAc,EAAE;MAExC,IAAI,CAACsD,MAAM,CAACN,UAAU,CAACb,IAAI,CAAC0B,KAAK,CAAC;MAElC,OAAOA,KAAK;IACd;EAAC;IAAAtF,GAAA;IAAAC,KAAA,EAED,SAAAwF,SAAStC,MAAW;MAElB,IAAI,CAACzD,MAAM,IAAIyD,MAAM,CAACF,SAAS,GAAGE,MAAM,CAACH,UAAU;MACnD,OAAO,IAAI;IACb;EAAC;IAAAhD,GAAA;IAAAC,KAAA,EAED,SAAAyF,MAAA,EAAK;MAGH,IAAMC,SAAS,GAAG,IAAI,CAAC9C,eAAe,EAAE;MACxC,IAAI8C,SAAS,CAAC5C,SAAS,KAAKtH,SAAS,CAACI,GAAG,EAAE;QACzC,MAAM,IAAIX,MAAM,CAACyH,cAAc,CAAC;UAAEC,OAAO,EAAE;QAAoB,CAAE,CAAC;;MAGpE,OAAO,IAAI,CAAClD,MAAM,GAAG,IAAI,CAACN,MAAM,CAACG,MAAM,EAAE;QAEvC,IAAMoC,KAAK,GAAG,IAAI,CAACjC,MAAM;QACzB,IAAMyD,MAAM,GAAG,IAAI,CAACN,eAAe,EAAE;QACrC,QAAQM,MAAM,CAACJ,SAAS;UACtB,KAAKtH,SAAS,CAACE,WAAW;YACxB,IAAI,CAACuH,cAAc,CAACC,MAAM,CAAC;YAC3B;UACF,KAAK1H,SAAS,CAACY,gBAAgB;YAC7B,IAAI,CAACwH,eAAe,CAACV,MAAM,CAAC;YAC5B;UACF,KAAK1H,SAAS,CAACM,mBAAmB;YAChC,IAAI,CAACkI,qBAAqB,EAAE;YAC5B;UACF,KAAKxI,SAAS,CAACO,iBAAiB;YAC9B,IAAI,CAACkI,mBAAmB,EAAE;YAC1B;UACF,KAAKzI,SAAS,CAACQ,iBAAiB;YAC9B,IAAI,CAACkI,mBAAmB,EAAE;YAC1B;UACF,KAAK1I,SAAS,CAACS,eAAe;YAC5B,IAAI,CAACiJ,iBAAiB,EAAE;YACxB;UACF,KAAK1J,SAAS,CAACU,SAAS;YACtB,IAAI,CAACkJ,YAAY,EAAE;YACnB;UACF,KAAK5J,SAAS,CAACC,IAAI;YACjB,IAAI,CAAC+J,QAAQ,CAACtC,MAAM,CAAC;YACrB;UACF;YACE,MAAM,IAAIjI,MAAM,CAACyH,cAAc,CAAC;cAC9BC,OAAO,EAAE,2BAA2BO,MAAM,CAACJ,SAAS;aACrD,CAAC;;QAIN,IAAMf,GAAG,GAAGL,KAAK,GAAGwB,MAAM,CAACF,SAAS;QACpC,IAAI,IAAI,CAACvD,MAAM,KAAKsC,GAAG,EAAE,C;;MAU3B,OAAO,IAAI,CAAC8C,QAAQ;IACtB;EAAC;EAAA,OAAA3F,eAAA;AAAA;AAjiBHyG,OAAA,CAAAzG,eAAA,GAAAA,eAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}