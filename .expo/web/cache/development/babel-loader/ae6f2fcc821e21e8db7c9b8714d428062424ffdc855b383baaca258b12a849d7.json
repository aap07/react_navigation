{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasAdbReverseAsync = hasAdbReverseAsync;\nexports.startAdbReverseAsync = startAdbReverseAsync;\nexports.stopAdbReverseAsync = stopAdbReverseAsync;\nvar Log = _interopRequireWildcard(require(\"../../../log\"));\nvar _exit = require(\"../../../utils/exit\");\nvar _androidSdk = require(\"./AndroidSdk\");\nvar _adb = require(\"./adb\");\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nvar debug = require(\"debug\")(\"expo:start:platforms:android:adbReverse\");\nvar removeExitHook = null;\nfunction hasAdbReverseAsync() {\n  try {\n    return !!(0, _androidSdk).assertSdkRoot();\n  } catch (error) {\n    debug(\"Failed to resolve the Android SDK path, skipping ADB: %s\", error.message);\n    return false;\n  }\n}\nfunction startAdbReverseAsync(_x) {\n  return _startAdbReverseAsync.apply(this, arguments);\n}\nfunction _startAdbReverseAsync() {\n  _startAdbReverseAsync = _asyncToGenerator(function* (ports) {\n    removeExitHook = (0, _exit).installExitHooks(function () {\n      stopAdbReverseAsync(ports);\n    });\n    var devices = yield (0, _adb).getAttachedDevicesAsync();\n    for (var device of devices) {\n      for (var port of ports) {\n        if (!(yield adbReverseAsync(device, port))) {\n          debug(`Failed to start reverse port ${port} on device \"${device.name}\"`);\n          return false;\n        }\n      }\n    }\n    return true;\n  });\n  return _startAdbReverseAsync.apply(this, arguments);\n}\nfunction stopAdbReverseAsync(_x2) {\n  return _stopAdbReverseAsync.apply(this, arguments);\n}\nfunction _stopAdbReverseAsync() {\n  _stopAdbReverseAsync = _asyncToGenerator(function* (ports) {\n    removeExitHook == null ? void 0 : removeExitHook();\n    var devices = yield (0, _adb).getAttachedDevicesAsync();\n    for (var device of devices) {\n      for (var port of ports) {\n        yield adbReverseRemoveAsync(device, port);\n      }\n    }\n  });\n  return _stopAdbReverseAsync.apply(this, arguments);\n}\nfunction adbReverseAsync(_x3, _x4) {\n  return _adbReverseAsync.apply(this, arguments);\n}\nfunction _adbReverseAsync() {\n  _adbReverseAsync = _asyncToGenerator(function* (device, port) {\n    if (!device.isAuthorized) {\n      (0, _adb).logUnauthorized(device);\n      return false;\n    }\n    try {\n      yield (0, _adb).getServer().runAsync((0, _adb).adbArgs(device.pid, \"reverse\", `tcp:${port}`, `tcp:${port}`));\n      return true;\n    } catch (error) {\n      Log.warn(`[ADB] Couldn't reverse port ${port}: ${error.message}`);\n      return false;\n    }\n  });\n  return _adbReverseAsync.apply(this, arguments);\n}\nfunction adbReverseRemoveAsync(_x5, _x6) {\n  return _adbReverseRemoveAsync.apply(this, arguments);\n}\nfunction _adbReverseRemoveAsync() {\n  _adbReverseRemoveAsync = _asyncToGenerator(function* (device, port) {\n    if (!device.isAuthorized) {\n      return false;\n    }\n    try {\n      yield (0, _adb).getServer().runAsync((0, _adb).adbArgs(device.pid, \"reverse\", \"--remove\", `tcp:${port}`));\n      return true;\n    } catch (error) {\n      debug(`Could not unforward port ${port}: ${error.message}`);\n      return false;\n    }\n  });\n  return _adbReverseRemoveAsync.apply(this, arguments);\n}","map":{"version":3,"names":["_asyncToGenerator","require","hasAdbReverseAsync","startAdbReverseAsync","stopAdbReverseAsync","Log","_interopRequireWildcard","_exit","_androidSdk","_adb","debug","removeExitHook","assertSdkRoot","error","message","_x","_startAdbReverseAsync","apply","arguments","ports","installExitHooks","devices","getAttachedDevicesAsync","device","port","adbReverseAsync","name","_x2","_stopAdbReverseAsync","adbReverseRemoveAsync","_x3","_x4","_adbReverseAsync","isAuthorized","logUnauthorized","getServer","runAsync","adbArgs","pid","warn","_x5","_x6","_adbReverseRemoveAsync"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\cli\\src\\start\\platforms\\android\\adbReverse.ts"],"sourcesContent":["import * as Log from '../../../log';\nimport { installExitHooks } from '../../../utils/exit';\nimport { assertSdkRoot } from './AndroidSdk';\nimport { adbArgs, Device, getAttachedDevicesAsync, getServer, logUnauthorized } from './adb';\n\nconst debug = require('debug')('expo:start:platforms:android:adbReverse') as typeof console.log;\n\nlet removeExitHook: (() => void) | null = null;\n\nexport function hasAdbReverseAsync(): boolean {\n  try {\n    return !!assertSdkRoot();\n  } catch (error: any) {\n    debug('Failed to resolve the Android SDK path, skipping ADB: %s', error.message);\n    return false;\n  }\n}\n\nexport async function startAdbReverseAsync(ports: number[]): Promise<boolean> {\n  // Install cleanup automatically...\n  removeExitHook = installExitHooks(() => {\n    stopAdbReverseAsync(ports);\n  });\n\n  const devices = await getAttachedDevicesAsync();\n  for (const device of devices) {\n    for (const port of ports) {\n      if (!(await adbReverseAsync(device, port))) {\n        debug(`Failed to start reverse port ${port} on device \"${device.name}\"`);\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nexport async function stopAdbReverseAsync(ports: number[]): Promise<void> {\n  removeExitHook?.();\n\n  const devices = await getAttachedDevicesAsync();\n  for (const device of devices) {\n    for (const port of ports) {\n      await adbReverseRemoveAsync(device, port);\n    }\n  }\n}\n\nasync function adbReverseAsync(device: Device, port: number): Promise<boolean> {\n  if (!device.isAuthorized) {\n    logUnauthorized(device);\n    return false;\n  }\n\n  try {\n    await getServer().runAsync(adbArgs(device.pid, 'reverse', `tcp:${port}`, `tcp:${port}`));\n    return true;\n  } catch (error: any) {\n    Log.warn(`[ADB] Couldn't reverse port ${port}: ${error.message}`);\n    return false;\n  }\n}\n\nasync function adbReverseRemoveAsync(device: Device, port: number): Promise<boolean> {\n  if (!device.isAuthorized) {\n    return false;\n  }\n\n  try {\n    await getServer().runAsync(adbArgs(device.pid, 'reverse', '--remove', `tcp:${port}`));\n    return true;\n  } catch (error: any) {\n    // Don't send this to warn because we call this preemptively sometimes\n    debug(`Could not unforward port ${port}: ${error.message}`);\n    return false;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}