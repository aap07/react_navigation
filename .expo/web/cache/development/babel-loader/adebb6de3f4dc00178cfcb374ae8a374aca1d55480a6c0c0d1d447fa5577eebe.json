{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ensureConfigExistsAsync = ensureConfigExistsAsync;\nexports.ensureConfigAsync = ensureConfigAsync;\nvar _config = require(\"@expo/config\");\nvar _jsonFile = _interopRequireDefault(require(\"@expo/json-file\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nvar Log = _interopRequireWildcard(require(\"../log\"));\nvar _errors = require(\"../utils/errors\");\nvar _getOrPromptApplicationId = require(\"../utils/getOrPromptApplicationId\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nfunction ensureConfigExistsAsync(_x) {\n  return _ensureConfigExistsAsync.apply(this, arguments);\n}\nfunction _ensureConfigExistsAsync() {\n  _ensureConfigExistsAsync = _asyncToGenerator(function* (projectRoot) {\n    try {\n      var config = (0, _config).getConfig(projectRoot, {\n        skipSDKVersionRequirement: false\n      });\n      if (!config.dynamicConfigPath && !config.staticConfigPath) {\n        delete config.exp._internal;\n        yield _jsonFile.default.writeAsync(_path.default.join(projectRoot, \"app.json\"), {\n          expo: config.exp\n        }, {\n          json5: false\n        });\n      }\n    } catch (error) {\n      Log.log();\n      throw new _errors.CommandError(`${error.message}\\n`);\n    }\n  });\n  return _ensureConfigExistsAsync.apply(this, arguments);\n}\nfunction ensureConfigAsync(_x2, _x3) {\n  return _ensureConfigAsync.apply(this, arguments);\n}\nfunction _ensureConfigAsync() {\n  _ensureConfigAsync = _asyncToGenerator(function* (projectRoot, _ref) {\n    var platforms = _ref.platforms;\n    yield ensureConfigExistsAsync(projectRoot);\n    if (platforms.includes(\"android\")) {\n      yield (0, _getOrPromptApplicationId).getOrPromptForPackage(projectRoot);\n    }\n    if (platforms.includes(\"ios\")) {\n      yield (0, _getOrPromptApplicationId).getOrPromptForBundleIdentifier(projectRoot);\n    }\n    return (0, _config).getConfig(projectRoot);\n  });\n  return _ensureConfigAsync.apply(this, arguments);\n}","map":{"version":3,"names":["_asyncToGenerator","require","ensureConfigExistsAsync","ensureConfigAsync","_config","_jsonFile","_interopRequireDefault","_path","Log","_interopRequireWildcard","_errors","_getOrPromptApplicationId","_x","_ensureConfigExistsAsync","apply","arguments","projectRoot","config","getConfig","skipSDKVersionRequirement","dynamicConfigPath","staticConfigPath","exp","_internal","default","writeAsync","join","expo","json5","error","log","CommandError","message","_x2","_x3","_ensureConfigAsync","_ref","platforms","includes","getOrPromptForPackage","getOrPromptForBundleIdentifier"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\cli\\src\\prebuild\\ensureConfigAsync.ts"],"sourcesContent":["import { ExpoConfig, getConfig, PackageJSONConfig } from '@expo/config';\nimport { ModPlatform } from '@expo/config-plugins';\nimport JsonFile, { JSONObject } from '@expo/json-file';\nimport path from 'path';\n\nimport * as Log from '../log';\nimport { CommandError } from '../utils/errors';\nimport {\n  getOrPromptForBundleIdentifier,\n  getOrPromptForPackage,\n} from '../utils/getOrPromptApplicationId';\n\n/**\n * If an Expo config file does not exist, write a new one using the in-memory config.\n *\n * @param projectRoot\n */\nexport async function ensureConfigExistsAsync(projectRoot: string) {\n  try {\n    const config = getConfig(projectRoot, { skipSDKVersionRequirement: false });\n    // If no config exists in the file system then we should generate one so the process doesn't fail.\n    if (!config.dynamicConfigPath && !config.staticConfigPath) {\n      // Remove the internal object before writing.\n      delete config.exp._internal;\n\n      // Write the generated config.\n      await JsonFile.writeAsync(\n        path.join(projectRoot, 'app.json'),\n        { expo: config.exp as unknown as JSONObject },\n        { json5: false }\n      );\n    }\n  } catch (error: any) {\n    // TODO(Bacon): Currently this is already handled in the command\n    Log.log();\n    throw new CommandError(`${error.message}\\n`);\n  }\n}\n\n/** Ensure config is written, and prompts for application identifiers. */\nexport async function ensureConfigAsync(\n  projectRoot: string,\n  {\n    platforms,\n  }: {\n    platforms: ModPlatform[];\n  }\n): Promise<{ exp: ExpoConfig; pkg: PackageJSONConfig }> {\n  await ensureConfigExistsAsync(projectRoot);\n\n  // Prompt for the Android package first because it's more strict than the bundle identifier\n  // this means you'll have a better chance at matching the bundle identifier with the package name.\n  if (platforms.includes('android')) {\n    await getOrPromptForPackage(projectRoot);\n  }\n\n  if (platforms.includes('ios')) {\n    await getOrPromptForBundleIdentifier(projectRoot);\n  }\n\n  // Read config again because prompting for bundle id or package name may have mutated the results.\n  return getConfig(projectRoot);\n}\n"],"mappings":"AAAA;;AAAA,IAAAA,iBAAA,GAAAC,OAAA;;;;QAiBsBC,uBAAuB,GAAvBA,uBAAuB;QAuBvBC,iBAAiB,GAAjBA,iBAAiB;AAxCkB,IAAAC,OAAc,GAAAH,OAAA,CAAd,cAAc;AAElC,IAAAI,SAAiB,GAAAC,sBAAA,CAAAL,OAAA,CAAjB,iBAAiB;AACrC,IAAAM,KAAM,GAAAD,sBAAA,CAAAL,OAAA,CAAN,MAAM;AAEX,IAAAO,GAAG,GAAAC,uBAAA,CAAAR,OAAA,SAAc,EAAd;AACc,IAAAS,OAAiB,GAAAT,OAAA;AAIvC,IAAAU,yBAAmC,GAAAV,OAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;SAOpBC,uBAAuBA,CAAAU,EAAA;EAAA,OAAAC,wBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAF,yBAAA;EAAAA,wBAAA,GAAAb,iBAAA,CAAtC,WAAuCgB,WAAmB,EAAE;IACjE,IAAI;MACF,IAAMC,MAAM,GAAG,IAAAb,OAAS,EAAmDc,SAAnD,CAACF,WAAW,EAAE;QAAEG,yBAAyB,EAAE;OAAO,CAAC;MAE3E,IAAI,CAACF,MAAM,CAACG,iBAAiB,IAAI,CAACH,MAAM,CAACI,gBAAgB,EAAE;QAEzD,OAAOJ,MAAM,CAACK,GAAG,CAACC,SAAS;QAG3B,MAAMlB,SAAQ,CAAAmB,OAAA,CAACC,UAAU,CACvBlB,KAAI,CAAAiB,OAAA,CAACE,IAAI,CAACV,WAAW,EAAE,UAAU,CAAC,EAClC;UAAEW,IAAI,EAAEV,MAAM,CAACK;SAA8B,EAC7C;UAAEM,KAAK,EAAE;SAAO,CACjB;;KAEJ,CAAC,OAAOC,KAAK,EAAO;MAEnBrB,GAAG,CAACsB,GAAG,EAAE;MACT,MAAM,IAAIpB,OAAY,CAAAqB,YAAA,CAAE,GAAEF,KAAK,CAACG,OAAQ,IAAG,CAAC;;GAE/C;EAAA,OAAAnB,wBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAGqBZ,iBAAiBA,CAAA8B,GAAA,EAAAC,GAAA;EAAA,OAAAC,kBAAA,CAAArB,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAoB,mBAAA;EAAAA,kBAAA,GAAAnC,iBAAA,CAAhC,WACLgB,WAAmB,EAAAoB,IAAA,EAMmC;IAAA,IAJpDC,SAAS,GAAAD,IAAA,CAATC,SAAS;IAKX,MAAMnC,uBAAuB,CAACc,WAAW,CAAC;IAI1C,IAAIqB,SAAS,CAACC,QAAQ,CAAC,SAAS,CAAC,EAAE;MACjC,MAAM,IAAA3B,yBAAqB,EAAa4B,qBAAb,CAACvB,WAAW,CAAC;;IAG1C,IAAIqB,SAAS,CAACC,QAAQ,CAAC,KAAK,CAAC,EAAE;MAC7B,MAAM,IAAA3B,yBAA8B,EAAa6B,8BAAb,CAACxB,WAAW,CAAC;;IAInD,OAAO,IAAAZ,OAAS,EAAac,SAAb,CAACF,WAAW,CAAC;GAC9B;EAAA,OAAAmB,kBAAA,CAAArB,KAAA,OAAAC,SAAA;AAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}