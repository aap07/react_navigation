{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { tokenType } from \"./cst.js\";\nimport { Lexer } from \"./lexer.js\";\nfunction includesToken(list, type) {\n  for (var i = 0; i < list.length; ++i) if (list[i].type === type) return true;\n  return false;\n}\nfunction findNonEmptyIndex(list) {\n  for (var i = 0; i < list.length; ++i) {\n    switch (list[i].type) {\n      case 'space':\n      case 'comment':\n      case 'newline':\n        break;\n      default:\n        return i;\n    }\n  }\n  return -1;\n}\nfunction isFlowToken(token) {\n  switch (token == null ? void 0 : token.type) {\n    case 'alias':\n    case 'scalar':\n    case 'single-quoted-scalar':\n    case 'double-quoted-scalar':\n    case 'flow-collection':\n      return true;\n    default:\n      return false;\n  }\n}\nfunction getPrevProps(parent) {\n  switch (parent.type) {\n    case 'document':\n      return parent.start;\n    case 'block-map':\n      {\n        var _it$sep;\n        var it = parent.items[parent.items.length - 1];\n        return (_it$sep = it.sep) != null ? _it$sep : it.start;\n      }\n    case 'block-seq':\n      return parent.items[parent.items.length - 1].start;\n    default:\n      return [];\n  }\n}\nfunction getFirstKeyStartProps(prev) {\n  if (prev.length === 0) return [];\n  var i = prev.length;\n  loop: while (--i >= 0) {\n    switch (prev[i].type) {\n      case 'doc-start':\n      case 'explicit-key-ind':\n      case 'map-value-ind':\n      case 'seq-item-ind':\n      case 'newline':\n        break loop;\n    }\n  }\n  while (((_prev$i = prev[++i]) == null ? void 0 : _prev$i.type) === 'space') {\n    var _prev$i;\n  }\n  return prev.splice(i, prev.length);\n}\nfunction fixFlowSeqItems(fc) {\n  if (fc.start.type === 'flow-seq-start') {\n    for (var it of fc.items) {\n      if (it.sep && !it.value && !includesToken(it.start, 'explicit-key-ind') && !includesToken(it.sep, 'map-value-ind')) {\n        if (it.key) it.value = it.key;\n        delete it.key;\n        if (isFlowToken(it.value)) {\n          if (it.value.end) Array.prototype.push.apply(it.value.end, it.sep);else it.value.end = it.sep;\n        } else Array.prototype.push.apply(it.start, it.sep);\n        delete it.sep;\n      }\n    }\n  }\n}\nvar Parser = function () {\n  function Parser(onNewLine) {\n    _classCallCheck(this, Parser);\n    this.atNewLine = true;\n    this.atScalar = false;\n    this.indent = 0;\n    this.offset = 0;\n    this.onKeyLine = false;\n    this.stack = [];\n    this.source = '';\n    this.type = '';\n    this.lexer = new Lexer();\n    this.onNewLine = onNewLine;\n  }\n  _createClass(Parser, [{\n    key: \"parse\",\n    value: function parse(source) {\n      var _this = this;\n      var incomplete = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return function* () {\n        if (_this.onNewLine && _this.offset === 0) _this.onNewLine(0);\n        for (var lexeme of _this.lexer.lex(source, incomplete)) yield* _this.next(lexeme);\n        if (!incomplete) yield* _this.end();\n      }();\n    }\n  }, {\n    key: \"next\",\n    value: function* next(source) {\n      this.source = source;\n      if (this.atScalar) {\n        this.atScalar = false;\n        yield* this.step();\n        this.offset += source.length;\n        return;\n      }\n      var type = tokenType(source);\n      if (!type) {\n        var message = `Not a YAML token: ${source}`;\n        yield* this.pop({\n          type: 'error',\n          offset: this.offset,\n          message: message,\n          source: source\n        });\n        this.offset += source.length;\n      } else if (type === 'scalar') {\n        this.atNewLine = false;\n        this.atScalar = true;\n        this.type = 'scalar';\n      } else {\n        this.type = type;\n        yield* this.step();\n        switch (type) {\n          case 'newline':\n            this.atNewLine = true;\n            this.indent = 0;\n            if (this.onNewLine) this.onNewLine(this.offset + source.length);\n            break;\n          case 'space':\n            if (this.atNewLine && source[0] === ' ') this.indent += source.length;\n            break;\n          case 'explicit-key-ind':\n          case 'map-value-ind':\n          case 'seq-item-ind':\n            if (this.atNewLine) this.indent += source.length;\n            break;\n          case 'doc-mode':\n          case 'flow-error-end':\n            return;\n          default:\n            this.atNewLine = false;\n        }\n        this.offset += source.length;\n      }\n    }\n  }, {\n    key: \"end\",\n    value: function* end() {\n      while (this.stack.length > 0) yield* this.pop();\n    }\n  }, {\n    key: \"sourceToken\",\n    get: function get() {\n      var st = {\n        type: this.type,\n        offset: this.offset,\n        indent: this.indent,\n        source: this.source\n      };\n      return st;\n    }\n  }, {\n    key: \"step\",\n    value: function* step() {\n      var top = this.peek(1);\n      if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {\n        while (this.stack.length > 0) yield* this.pop();\n        this.stack.push({\n          type: 'doc-end',\n          offset: this.offset,\n          source: this.source\n        });\n        return;\n      }\n      if (!top) return yield* this.stream();\n      switch (top.type) {\n        case 'document':\n          return yield* this.document(top);\n        case 'alias':\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n          return yield* this.scalar(top);\n        case 'block-scalar':\n          return yield* this.blockScalar(top);\n        case 'block-map':\n          return yield* this.blockMap(top);\n        case 'block-seq':\n          return yield* this.blockSequence(top);\n        case 'flow-collection':\n          return yield* this.flowCollection(top);\n        case 'doc-end':\n          return yield* this.documentEnd(top);\n      }\n      yield* this.pop();\n    }\n  }, {\n    key: \"peek\",\n    value: function peek(n) {\n      return this.stack[this.stack.length - n];\n    }\n  }, {\n    key: \"pop\",\n    value: function* pop(error) {\n      var token = error != null ? error : this.stack.pop();\n      if (!token) {\n        var message = 'Tried to pop an empty stack';\n        yield {\n          type: 'error',\n          offset: this.offset,\n          source: '',\n          message: message\n        };\n      } else if (this.stack.length === 0) {\n        yield token;\n      } else {\n        var top = this.peek(1);\n        if (token.type === 'block-scalar') {\n          token.indent = 'indent' in top ? top.indent : 0;\n        } else if (token.type === 'flow-collection' && top.type === 'document') {\n          token.indent = 0;\n        }\n        if (token.type === 'flow-collection') fixFlowSeqItems(token);\n        switch (top.type) {\n          case 'document':\n            top.value = token;\n            break;\n          case 'block-scalar':\n            top.props.push(token);\n            break;\n          case 'block-map':\n            {\n              var it = top.items[top.items.length - 1];\n              if (it.value) {\n                top.items.push({\n                  start: [],\n                  key: token,\n                  sep: []\n                });\n                this.onKeyLine = true;\n                return;\n              } else if (it.sep) {\n                it.value = token;\n              } else {\n                Object.assign(it, {\n                  key: token,\n                  sep: []\n                });\n                this.onKeyLine = !includesToken(it.start, 'explicit-key-ind');\n                return;\n              }\n              break;\n            }\n          case 'block-seq':\n            {\n              var _it = top.items[top.items.length - 1];\n              if (_it.value) top.items.push({\n                start: [],\n                value: token\n              });else _it.value = token;\n              break;\n            }\n          case 'flow-collection':\n            {\n              var _it2 = top.items[top.items.length - 1];\n              if (!_it2 || _it2.value) top.items.push({\n                start: [],\n                key: token,\n                sep: []\n              });else if (_it2.sep) _it2.value = token;else Object.assign(_it2, {\n                key: token,\n                sep: []\n              });\n              return;\n            }\n          default:\n            yield* this.pop();\n            yield* this.pop(token);\n        }\n        if ((top.type === 'document' || top.type === 'block-map' || top.type === 'block-seq') && (token.type === 'block-map' || token.type === 'block-seq')) {\n          var last = token.items[token.items.length - 1];\n          if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every(function (st) {\n            return st.type !== 'comment' || st.indent < token.indent;\n          }))) {\n            if (top.type === 'document') top.end = last.start;else top.items.push({\n              start: last.start\n            });\n            token.items.splice(-1, 1);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"stream\",\n    value: function* stream() {\n      switch (this.type) {\n        case 'directive-line':\n          yield {\n            type: 'directive',\n            offset: this.offset,\n            source: this.source\n          };\n          return;\n        case 'byte-order-mark':\n        case 'space':\n        case 'comment':\n        case 'newline':\n          yield this.sourceToken;\n          return;\n        case 'doc-mode':\n        case 'doc-start':\n          {\n            var doc = {\n              type: 'document',\n              offset: this.offset,\n              start: []\n            };\n            if (this.type === 'doc-start') doc.start.push(this.sourceToken);\n            this.stack.push(doc);\n            return;\n          }\n      }\n      yield {\n        type: 'error',\n        offset: this.offset,\n        message: `Unexpected ${this.type} token in YAML stream`,\n        source: this.source\n      };\n    }\n  }, {\n    key: \"document\",\n    value: function* document(doc) {\n      if (doc.value) return yield* this.lineEnd(doc);\n      switch (this.type) {\n        case 'doc-start':\n          {\n            if (findNonEmptyIndex(doc.start) !== -1) {\n              yield* this.pop();\n              yield* this.step();\n            } else doc.start.push(this.sourceToken);\n            return;\n          }\n        case 'anchor':\n        case 'tag':\n        case 'space':\n        case 'comment':\n        case 'newline':\n          doc.start.push(this.sourceToken);\n          return;\n      }\n      var bv = this.startBlockValue(doc);\n      if (bv) this.stack.push(bv);else {\n        yield {\n          type: 'error',\n          offset: this.offset,\n          message: `Unexpected ${this.type} token in YAML document`,\n          source: this.source\n        };\n      }\n    }\n  }, {\n    key: \"scalar\",\n    value: function* scalar(_scalar) {\n      if (this.type === 'map-value-ind') {\n        var prev = getPrevProps(this.peek(2));\n        var start = getFirstKeyStartProps(prev);\n        var sep;\n        if (_scalar.end) {\n          sep = _scalar.end;\n          sep.push(this.sourceToken);\n          delete _scalar.end;\n        } else sep = [this.sourceToken];\n        var map = {\n          type: 'block-map',\n          offset: _scalar.offset,\n          indent: _scalar.indent,\n          items: [{\n            start: start,\n            key: _scalar,\n            sep: sep\n          }]\n        };\n        this.onKeyLine = true;\n        this.stack[this.stack.length - 1] = map;\n      } else yield* this.lineEnd(_scalar);\n    }\n  }, {\n    key: \"blockScalar\",\n    value: function* blockScalar(scalar) {\n      switch (this.type) {\n        case 'space':\n        case 'comment':\n        case 'newline':\n          scalar.props.push(this.sourceToken);\n          return;\n        case 'scalar':\n          scalar.source = this.source;\n          this.atNewLine = true;\n          this.indent = 0;\n          if (this.onNewLine) {\n            var nl = this.source.indexOf('\\n') + 1;\n            while (nl !== 0) {\n              this.onNewLine(this.offset + nl);\n              nl = this.source.indexOf('\\n', nl) + 1;\n            }\n          }\n          yield* this.pop();\n          break;\n        default:\n          yield* this.pop();\n          yield* this.step();\n      }\n    }\n  }, {\n    key: \"blockMap\",\n    value: function* blockMap(map) {\n      var it = map.items[map.items.length - 1];\n      switch (this.type) {\n        case 'newline':\n          this.onKeyLine = false;\n          if (it.value) {\n            var end = 'end' in it.value ? it.value.end : undefined;\n            var last = Array.isArray(end) ? end[end.length - 1] : undefined;\n            if ((last == null ? void 0 : last.type) === 'comment') end == null ? void 0 : end.push(this.sourceToken);else map.items.push({\n              start: [this.sourceToken]\n            });\n          } else if (it.sep) {\n            it.sep.push(this.sourceToken);\n          } else {\n            it.start.push(this.sourceToken);\n          }\n          return;\n        case 'space':\n        case 'comment':\n          if (it.value) {\n            map.items.push({\n              start: [this.sourceToken]\n            });\n          } else if (it.sep) {\n            it.sep.push(this.sourceToken);\n          } else {\n            if (this.atIndentedComment(it.start, map.indent)) {\n              var _prev$value;\n              var prev = map.items[map.items.length - 2];\n              var _end = prev == null ? void 0 : (_prev$value = prev.value) == null ? void 0 : _prev$value.end;\n              if (Array.isArray(_end)) {\n                Array.prototype.push.apply(_end, it.start);\n                _end.push(this.sourceToken);\n                map.items.pop();\n                return;\n              }\n            }\n            it.start.push(this.sourceToken);\n          }\n          return;\n      }\n      if (this.indent >= map.indent) {\n        var atNextItem = !this.onKeyLine && this.indent === map.indent && it.sep;\n        var start = [];\n        if (atNextItem && it.sep && !it.value) {\n          var nl = [];\n          for (var i = 0; i < it.sep.length; ++i) {\n            var st = it.sep[i];\n            switch (st.type) {\n              case 'newline':\n                nl.push(i);\n                break;\n              case 'space':\n                break;\n              case 'comment':\n                if (st.indent > map.indent) nl.length = 0;\n                break;\n              default:\n                nl.length = 0;\n            }\n          }\n          if (nl.length >= 2) start = it.sep.splice(nl[1]);\n        }\n        switch (this.type) {\n          case 'anchor':\n          case 'tag':\n            if (atNextItem || it.value) {\n              start.push(this.sourceToken);\n              map.items.push({\n                start: start\n              });\n              this.onKeyLine = true;\n            } else if (it.sep) {\n              it.sep.push(this.sourceToken);\n            } else {\n              it.start.push(this.sourceToken);\n            }\n            return;\n          case 'explicit-key-ind':\n            if (!it.sep && !includesToken(it.start, 'explicit-key-ind')) {\n              it.start.push(this.sourceToken);\n            } else if (atNextItem || it.value) {\n              start.push(this.sourceToken);\n              map.items.push({\n                start: start\n              });\n            } else {\n              this.stack.push({\n                type: 'block-map',\n                offset: this.offset,\n                indent: this.indent,\n                items: [{\n                  start: [this.sourceToken]\n                }]\n              });\n            }\n            this.onKeyLine = true;\n            return;\n          case 'map-value-ind':\n            if (includesToken(it.start, 'explicit-key-ind')) {\n              if (!it.sep) {\n                if (includesToken(it.start, 'newline')) {\n                  Object.assign(it, {\n                    key: null,\n                    sep: [this.sourceToken]\n                  });\n                } else {\n                  var _start = getFirstKeyStartProps(it.start);\n                  this.stack.push({\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{\n                      start: _start,\n                      key: null,\n                      sep: [this.sourceToken]\n                    }]\n                  });\n                }\n              } else if (it.value) {\n                map.items.push({\n                  start: [],\n                  key: null,\n                  sep: [this.sourceToken]\n                });\n              } else if (includesToken(it.sep, 'map-value-ind')) {\n                this.stack.push({\n                  type: 'block-map',\n                  offset: this.offset,\n                  indent: this.indent,\n                  items: [{\n                    start: start,\n                    key: null,\n                    sep: [this.sourceToken]\n                  }]\n                });\n              } else if (isFlowToken(it.key) && !includesToken(it.sep, 'newline')) {\n                var _start2 = getFirstKeyStartProps(it.start);\n                var key = it.key;\n                var sep = it.sep;\n                sep.push(this.sourceToken);\n                delete it.key, delete it.sep;\n                this.stack.push({\n                  type: 'block-map',\n                  offset: this.offset,\n                  indent: this.indent,\n                  items: [{\n                    start: _start2,\n                    key: key,\n                    sep: sep\n                  }]\n                });\n              } else if (start.length > 0) {\n                it.sep = it.sep.concat(start, this.sourceToken);\n              } else {\n                it.sep.push(this.sourceToken);\n              }\n            } else {\n              if (!it.sep) {\n                Object.assign(it, {\n                  key: null,\n                  sep: [this.sourceToken]\n                });\n              } else if (it.value || atNextItem) {\n                map.items.push({\n                  start: start,\n                  key: null,\n                  sep: [this.sourceToken]\n                });\n              } else if (includesToken(it.sep, 'map-value-ind')) {\n                this.stack.push({\n                  type: 'block-map',\n                  offset: this.offset,\n                  indent: this.indent,\n                  items: [{\n                    start: [],\n                    key: null,\n                    sep: [this.sourceToken]\n                  }]\n                });\n              } else {\n                it.sep.push(this.sourceToken);\n              }\n            }\n            this.onKeyLine = true;\n            return;\n          case 'alias':\n          case 'scalar':\n          case 'single-quoted-scalar':\n          case 'double-quoted-scalar':\n            {\n              var fs = this.flowScalar(this.type);\n              if (atNextItem || it.value) {\n                map.items.push({\n                  start: start,\n                  key: fs,\n                  sep: []\n                });\n                this.onKeyLine = true;\n              } else if (it.sep) {\n                this.stack.push(fs);\n              } else {\n                Object.assign(it, {\n                  key: fs,\n                  sep: []\n                });\n                this.onKeyLine = true;\n              }\n              return;\n            }\n          default:\n            {\n              var bv = this.startBlockValue(map);\n              if (bv) {\n                if (atNextItem && bv.type !== 'block-seq' && includesToken(it.start, 'explicit-key-ind')) {\n                  map.items.push({\n                    start: start\n                  });\n                }\n                this.stack.push(bv);\n                return;\n              }\n            }\n        }\n      }\n      yield* this.pop();\n      yield* this.step();\n    }\n  }, {\n    key: \"blockSequence\",\n    value: function* blockSequence(seq) {\n      var it = seq.items[seq.items.length - 1];\n      switch (this.type) {\n        case 'newline':\n          if (it.value) {\n            var end = 'end' in it.value ? it.value.end : undefined;\n            var last = Array.isArray(end) ? end[end.length - 1] : undefined;\n            if ((last == null ? void 0 : last.type) === 'comment') end == null ? void 0 : end.push(this.sourceToken);else seq.items.push({\n              start: [this.sourceToken]\n            });\n          } else it.start.push(this.sourceToken);\n          return;\n        case 'space':\n        case 'comment':\n          if (it.value) seq.items.push({\n            start: [this.sourceToken]\n          });else {\n            if (this.atIndentedComment(it.start, seq.indent)) {\n              var _prev$value2;\n              var prev = seq.items[seq.items.length - 2];\n              var _end2 = prev == null ? void 0 : (_prev$value2 = prev.value) == null ? void 0 : _prev$value2.end;\n              if (Array.isArray(_end2)) {\n                Array.prototype.push.apply(_end2, it.start);\n                _end2.push(this.sourceToken);\n                seq.items.pop();\n                return;\n              }\n            }\n            it.start.push(this.sourceToken);\n          }\n          return;\n        case 'anchor':\n        case 'tag':\n          if (it.value || this.indent <= seq.indent) break;\n          it.start.push(this.sourceToken);\n          return;\n        case 'seq-item-ind':\n          if (this.indent !== seq.indent) break;\n          if (it.value || includesToken(it.start, 'seq-item-ind')) seq.items.push({\n            start: [this.sourceToken]\n          });else it.start.push(this.sourceToken);\n          return;\n      }\n      if (this.indent > seq.indent) {\n        var bv = this.startBlockValue(seq);\n        if (bv) {\n          this.stack.push(bv);\n          return;\n        }\n      }\n      yield* this.pop();\n      yield* this.step();\n    }\n  }, {\n    key: \"flowCollection\",\n    value: function* flowCollection(fc) {\n      var it = fc.items[fc.items.length - 1];\n      if (this.type === 'flow-error-end') {\n        var top;\n        do {\n          yield* this.pop();\n          top = this.peek(1);\n        } while (top && top.type === 'flow-collection');\n      } else if (fc.end.length === 0) {\n        switch (this.type) {\n          case 'comma':\n          case 'explicit-key-ind':\n            if (!it || it.sep) fc.items.push({\n              start: [this.sourceToken]\n            });else it.start.push(this.sourceToken);\n            return;\n          case 'map-value-ind':\n            if (!it || it.value) fc.items.push({\n              start: [],\n              key: null,\n              sep: [this.sourceToken]\n            });else if (it.sep) it.sep.push(this.sourceToken);else Object.assign(it, {\n              key: null,\n              sep: [this.sourceToken]\n            });\n            return;\n          case 'space':\n          case 'comment':\n          case 'newline':\n          case 'anchor':\n          case 'tag':\n            if (!it || it.value) fc.items.push({\n              start: [this.sourceToken]\n            });else if (it.sep) it.sep.push(this.sourceToken);else it.start.push(this.sourceToken);\n            return;\n          case 'alias':\n          case 'scalar':\n          case 'single-quoted-scalar':\n          case 'double-quoted-scalar':\n            {\n              var fs = this.flowScalar(this.type);\n              if (!it || it.value) fc.items.push({\n                start: [],\n                key: fs,\n                sep: []\n              });else if (it.sep) this.stack.push(fs);else Object.assign(it, {\n                key: fs,\n                sep: []\n              });\n              return;\n            }\n          case 'flow-map-end':\n          case 'flow-seq-end':\n            fc.end.push(this.sourceToken);\n            return;\n        }\n        var bv = this.startBlockValue(fc);\n        if (bv) this.stack.push(bv);else {\n          yield* this.pop();\n          yield* this.step();\n        }\n      } else {\n        var parent = this.peek(2);\n        if (parent.type === 'block-map' && (this.type === 'map-value-ind' && parent.indent === fc.indent || this.type === 'newline' && !parent.items[parent.items.length - 1].sep)) {\n          yield* this.pop();\n          yield* this.step();\n        } else if (this.type === 'map-value-ind' && parent.type !== 'flow-collection') {\n          var prev = getPrevProps(parent);\n          var start = getFirstKeyStartProps(prev);\n          fixFlowSeqItems(fc);\n          var sep = fc.end.splice(1, fc.end.length);\n          sep.push(this.sourceToken);\n          var map = {\n            type: 'block-map',\n            offset: fc.offset,\n            indent: fc.indent,\n            items: [{\n              start: start,\n              key: fc,\n              sep: sep\n            }]\n          };\n          this.onKeyLine = true;\n          this.stack[this.stack.length - 1] = map;\n        } else {\n          yield* this.lineEnd(fc);\n        }\n      }\n    }\n  }, {\n    key: \"flowScalar\",\n    value: function flowScalar(type) {\n      if (this.onNewLine) {\n        var nl = this.source.indexOf('\\n') + 1;\n        while (nl !== 0) {\n          this.onNewLine(this.offset + nl);\n          nl = this.source.indexOf('\\n', nl) + 1;\n        }\n      }\n      return {\n        type: type,\n        offset: this.offset,\n        indent: this.indent,\n        source: this.source\n      };\n    }\n  }, {\n    key: \"startBlockValue\",\n    value: function startBlockValue(parent) {\n      switch (this.type) {\n        case 'alias':\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n          return this.flowScalar(this.type);\n        case 'block-scalar-header':\n          return {\n            type: 'block-scalar',\n            offset: this.offset,\n            indent: this.indent,\n            props: [this.sourceToken],\n            source: ''\n          };\n        case 'flow-map-start':\n        case 'flow-seq-start':\n          return {\n            type: 'flow-collection',\n            offset: this.offset,\n            indent: this.indent,\n            start: this.sourceToken,\n            items: [],\n            end: []\n          };\n        case 'seq-item-ind':\n          return {\n            type: 'block-seq',\n            offset: this.offset,\n            indent: this.indent,\n            items: [{\n              start: [this.sourceToken]\n            }]\n          };\n        case 'explicit-key-ind':\n          {\n            this.onKeyLine = true;\n            var prev = getPrevProps(parent);\n            var start = getFirstKeyStartProps(prev);\n            start.push(this.sourceToken);\n            return {\n              type: 'block-map',\n              offset: this.offset,\n              indent: this.indent,\n              items: [{\n                start: start\n              }]\n            };\n          }\n        case 'map-value-ind':\n          {\n            this.onKeyLine = true;\n            var _prev = getPrevProps(parent);\n            var _start3 = getFirstKeyStartProps(_prev);\n            return {\n              type: 'block-map',\n              offset: this.offset,\n              indent: this.indent,\n              items: [{\n                start: _start3,\n                key: null,\n                sep: [this.sourceToken]\n              }]\n            };\n          }\n      }\n      return null;\n    }\n  }, {\n    key: \"atIndentedComment\",\n    value: function atIndentedComment(start, indent) {\n      if (this.type !== 'comment') return false;\n      if (this.indent <= indent) return false;\n      return start.every(function (st) {\n        return st.type === 'newline' || st.type === 'space';\n      });\n    }\n  }, {\n    key: \"documentEnd\",\n    value: function* documentEnd(docEnd) {\n      if (this.type !== 'doc-mode') {\n        if (docEnd.end) docEnd.end.push(this.sourceToken);else docEnd.end = [this.sourceToken];\n        if (this.type === 'newline') yield* this.pop();\n      }\n    }\n  }, {\n    key: \"lineEnd\",\n    value: function* lineEnd(token) {\n      switch (this.type) {\n        case 'comma':\n        case 'doc-start':\n        case 'doc-end':\n        case 'flow-seq-end':\n        case 'flow-map-end':\n        case 'map-value-ind':\n          yield* this.pop();\n          yield* this.step();\n          break;\n        case 'newline':\n          this.onKeyLine = false;\n        case 'space':\n        case 'comment':\n        default:\n          if (token.end) token.end.push(this.sourceToken);else token.end = [this.sourceToken];\n          if (this.type === 'newline') yield* this.pop();\n      }\n    }\n  }]);\n  return Parser;\n}();\nexport { Parser };","map":{"version":3,"names":["tokenType","Lexer","includesToken","list","type","i","length","findNonEmptyIndex","isFlowToken","token","getPrevProps","parent","start","_it$sep","it","items","sep","getFirstKeyStartProps","prev","loop","_prev$i","splice","fixFlowSeqItems","fc","value","key","end","Array","prototype","push","apply","Parser","onNewLine","_classCallCheck","atNewLine","atScalar","indent","offset","onKeyLine","stack","source","lexer","_createClass","parse","_this","incomplete","arguments","undefined","lexeme","lex","next","step","message","pop","get","st","top","peek","stream","document","scalar","blockScalar","blockMap","blockSequence","flowCollection","documentEnd","n","error","props","Object","assign","last","every","sourceToken","doc","lineEnd","bv","startBlockValue","map","nl","indexOf","isArray","atIndentedComment","_prev$value","atNextItem","concat","fs","flowScalar","seq","_prev$value2","docEnd"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native-community/cli-doctor/node_modules/yaml/browser/dist/parse/parser.js"],"sourcesContent":["import { tokenType } from './cst.js';\nimport { Lexer } from './lexer.js';\n\nfunction includesToken(list, type) {\n    for (let i = 0; i < list.length; ++i)\n        if (list[i].type === type)\n            return true;\n    return false;\n}\nfunction findNonEmptyIndex(list) {\n    for (let i = 0; i < list.length; ++i) {\n        switch (list[i].type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                break;\n            default:\n                return i;\n        }\n    }\n    return -1;\n}\nfunction isFlowToken(token) {\n    switch (token?.type) {\n        case 'alias':\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n        case 'flow-collection':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction getPrevProps(parent) {\n    switch (parent.type) {\n        case 'document':\n            return parent.start;\n        case 'block-map': {\n            const it = parent.items[parent.items.length - 1];\n            return it.sep ?? it.start;\n        }\n        case 'block-seq':\n            return parent.items[parent.items.length - 1].start;\n        /* istanbul ignore next should not happen */\n        default:\n            return [];\n    }\n}\n/** Note: May modify input array */\nfunction getFirstKeyStartProps(prev) {\n    if (prev.length === 0)\n        return [];\n    let i = prev.length;\n    loop: while (--i >= 0) {\n        switch (prev[i].type) {\n            case 'doc-start':\n            case 'explicit-key-ind':\n            case 'map-value-ind':\n            case 'seq-item-ind':\n            case 'newline':\n                break loop;\n        }\n    }\n    while (prev[++i]?.type === 'space') {\n        /* loop */\n    }\n    return prev.splice(i, prev.length);\n}\nfunction fixFlowSeqItems(fc) {\n    if (fc.start.type === 'flow-seq-start') {\n        for (const it of fc.items) {\n            if (it.sep &&\n                !it.value &&\n                !includesToken(it.start, 'explicit-key-ind') &&\n                !includesToken(it.sep, 'map-value-ind')) {\n                if (it.key)\n                    it.value = it.key;\n                delete it.key;\n                if (isFlowToken(it.value)) {\n                    if (it.value.end)\n                        Array.prototype.push.apply(it.value.end, it.sep);\n                    else\n                        it.value.end = it.sep;\n                }\n                else\n                    Array.prototype.push.apply(it.start, it.sep);\n                delete it.sep;\n            }\n        }\n    }\n}\n/**\n * A YAML concrete syntax tree (CST) parser\n *\n * ```ts\n * const src: string = ...\n * for (const token of new Parser().parse(src)) {\n *   // token: Token\n * }\n * ```\n *\n * To use the parser with a user-provided lexer:\n *\n * ```ts\n * function* parse(source: string, lexer: Lexer) {\n *   const parser = new Parser()\n *   for (const lexeme of lexer.lex(source))\n *     yield* parser.next(lexeme)\n *   yield* parser.end()\n * }\n *\n * const src: string = ...\n * const lexer = new Lexer()\n * for (const token of parse(src, lexer)) {\n *   // token: Token\n * }\n * ```\n */\nclass Parser {\n    /**\n     * @param onNewLine - If defined, called separately with the start position of\n     *   each new line (in `parse()`, including the start of input).\n     */\n    constructor(onNewLine) {\n        /** If true, space and sequence indicators count as indentation */\n        this.atNewLine = true;\n        /** If true, next token is a scalar value */\n        this.atScalar = false;\n        /** Current indentation level */\n        this.indent = 0;\n        /** Current offset since the start of parsing */\n        this.offset = 0;\n        /** On the same line with a block map key */\n        this.onKeyLine = false;\n        /** Top indicates the node that's currently being built */\n        this.stack = [];\n        /** The source of the current token, set in parse() */\n        this.source = '';\n        /** The type of the current token, set in parse() */\n        this.type = '';\n        // Must be defined after `next()`\n        this.lexer = new Lexer();\n        this.onNewLine = onNewLine;\n    }\n    /**\n     * Parse `source` as a YAML stream.\n     * If `incomplete`, a part of the last line may be left as a buffer for the next call.\n     *\n     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.\n     *\n     * @returns A generator of tokens representing each directive, document, and other structure.\n     */\n    *parse(source, incomplete = false) {\n        if (this.onNewLine && this.offset === 0)\n            this.onNewLine(0);\n        for (const lexeme of this.lexer.lex(source, incomplete))\n            yield* this.next(lexeme);\n        if (!incomplete)\n            yield* this.end();\n    }\n    /**\n     * Advance the parser by the `source` of one lexical token.\n     */\n    *next(source) {\n        this.source = source;\n        if (this.atScalar) {\n            this.atScalar = false;\n            yield* this.step();\n            this.offset += source.length;\n            return;\n        }\n        const type = tokenType(source);\n        if (!type) {\n            const message = `Not a YAML token: ${source}`;\n            yield* this.pop({ type: 'error', offset: this.offset, message, source });\n            this.offset += source.length;\n        }\n        else if (type === 'scalar') {\n            this.atNewLine = false;\n            this.atScalar = true;\n            this.type = 'scalar';\n        }\n        else {\n            this.type = type;\n            yield* this.step();\n            switch (type) {\n                case 'newline':\n                    this.atNewLine = true;\n                    this.indent = 0;\n                    if (this.onNewLine)\n                        this.onNewLine(this.offset + source.length);\n                    break;\n                case 'space':\n                    if (this.atNewLine && source[0] === ' ')\n                        this.indent += source.length;\n                    break;\n                case 'explicit-key-ind':\n                case 'map-value-ind':\n                case 'seq-item-ind':\n                    if (this.atNewLine)\n                        this.indent += source.length;\n                    break;\n                case 'doc-mode':\n                case 'flow-error-end':\n                    return;\n                default:\n                    this.atNewLine = false;\n            }\n            this.offset += source.length;\n        }\n    }\n    /** Call at end of input to push out any remaining constructions */\n    *end() {\n        while (this.stack.length > 0)\n            yield* this.pop();\n    }\n    get sourceToken() {\n        const st = {\n            type: this.type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n        return st;\n    }\n    *step() {\n        const top = this.peek(1);\n        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {\n            while (this.stack.length > 0)\n                yield* this.pop();\n            this.stack.push({\n                type: 'doc-end',\n                offset: this.offset,\n                source: this.source\n            });\n            return;\n        }\n        if (!top)\n            return yield* this.stream();\n        switch (top.type) {\n            case 'document':\n                return yield* this.document(top);\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return yield* this.scalar(top);\n            case 'block-scalar':\n                return yield* this.blockScalar(top);\n            case 'block-map':\n                return yield* this.blockMap(top);\n            case 'block-seq':\n                return yield* this.blockSequence(top);\n            case 'flow-collection':\n                return yield* this.flowCollection(top);\n            case 'doc-end':\n                return yield* this.documentEnd(top);\n        }\n        /* istanbul ignore next should not happen */\n        yield* this.pop();\n    }\n    peek(n) {\n        return this.stack[this.stack.length - n];\n    }\n    *pop(error) {\n        const token = error ?? this.stack.pop();\n        /* istanbul ignore if should not happen */\n        if (!token) {\n            const message = 'Tried to pop an empty stack';\n            yield { type: 'error', offset: this.offset, source: '', message };\n        }\n        else if (this.stack.length === 0) {\n            yield token;\n        }\n        else {\n            const top = this.peek(1);\n            if (token.type === 'block-scalar') {\n                // Block scalars use their parent rather than header indent\n                token.indent = 'indent' in top ? top.indent : 0;\n            }\n            else if (token.type === 'flow-collection' && top.type === 'document') {\n                // Ignore all indent for top-level flow collections\n                token.indent = 0;\n            }\n            if (token.type === 'flow-collection')\n                fixFlowSeqItems(token);\n            switch (top.type) {\n                case 'document':\n                    top.value = token;\n                    break;\n                case 'block-scalar':\n                    top.props.push(token); // error\n                    break;\n                case 'block-map': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value) {\n                        top.items.push({ start: [], key: token, sep: [] });\n                        this.onKeyLine = true;\n                        return;\n                    }\n                    else if (it.sep) {\n                        it.value = token;\n                    }\n                    else {\n                        Object.assign(it, { key: token, sep: [] });\n                        this.onKeyLine = !includesToken(it.start, 'explicit-key-ind');\n                        return;\n                    }\n                    break;\n                }\n                case 'block-seq': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value)\n                        top.items.push({ start: [], value: token });\n                    else\n                        it.value = token;\n                    break;\n                }\n                case 'flow-collection': {\n                    const it = top.items[top.items.length - 1];\n                    if (!it || it.value)\n                        top.items.push({ start: [], key: token, sep: [] });\n                    else if (it.sep)\n                        it.value = token;\n                    else\n                        Object.assign(it, { key: token, sep: [] });\n                    return;\n                }\n                /* istanbul ignore next should not happen */\n                default:\n                    yield* this.pop();\n                    yield* this.pop(token);\n            }\n            if ((top.type === 'document' ||\n                top.type === 'block-map' ||\n                top.type === 'block-seq') &&\n                (token.type === 'block-map' || token.type === 'block-seq')) {\n                const last = token.items[token.items.length - 1];\n                if (last &&\n                    !last.sep &&\n                    !last.value &&\n                    last.start.length > 0 &&\n                    findNonEmptyIndex(last.start) === -1 &&\n                    (token.indent === 0 ||\n                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {\n                    if (top.type === 'document')\n                        top.end = last.start;\n                    else\n                        top.items.push({ start: last.start });\n                    token.items.splice(-1, 1);\n                }\n            }\n        }\n    }\n    *stream() {\n        switch (this.type) {\n            case 'directive-line':\n                yield { type: 'directive', offset: this.offset, source: this.source };\n                return;\n            case 'byte-order-mark':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                yield this.sourceToken;\n                return;\n            case 'doc-mode':\n            case 'doc-start': {\n                const doc = {\n                    type: 'document',\n                    offset: this.offset,\n                    start: []\n                };\n                if (this.type === 'doc-start')\n                    doc.start.push(this.sourceToken);\n                this.stack.push(doc);\n                return;\n            }\n        }\n        yield {\n            type: 'error',\n            offset: this.offset,\n            message: `Unexpected ${this.type} token in YAML stream`,\n            source: this.source\n        };\n    }\n    *document(doc) {\n        if (doc.value)\n            return yield* this.lineEnd(doc);\n        switch (this.type) {\n            case 'doc-start': {\n                if (findNonEmptyIndex(doc.start) !== -1) {\n                    yield* this.pop();\n                    yield* this.step();\n                }\n                else\n                    doc.start.push(this.sourceToken);\n                return;\n            }\n            case 'anchor':\n            case 'tag':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                doc.start.push(this.sourceToken);\n                return;\n        }\n        const bv = this.startBlockValue(doc);\n        if (bv)\n            this.stack.push(bv);\n        else {\n            yield {\n                type: 'error',\n                offset: this.offset,\n                message: `Unexpected ${this.type} token in YAML document`,\n                source: this.source\n            };\n        }\n    }\n    *scalar(scalar) {\n        if (this.type === 'map-value-ind') {\n            const prev = getPrevProps(this.peek(2));\n            const start = getFirstKeyStartProps(prev);\n            let sep;\n            if (scalar.end) {\n                sep = scalar.end;\n                sep.push(this.sourceToken);\n                delete scalar.end;\n            }\n            else\n                sep = [this.sourceToken];\n            const map = {\n                type: 'block-map',\n                offset: scalar.offset,\n                indent: scalar.indent,\n                items: [{ start, key: scalar, sep }]\n            };\n            this.onKeyLine = true;\n            this.stack[this.stack.length - 1] = map;\n        }\n        else\n            yield* this.lineEnd(scalar);\n    }\n    *blockScalar(scalar) {\n        switch (this.type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                scalar.props.push(this.sourceToken);\n                return;\n            case 'scalar':\n                scalar.source = this.source;\n                // block-scalar source includes trailing newline\n                this.atNewLine = true;\n                this.indent = 0;\n                if (this.onNewLine) {\n                    let nl = this.source.indexOf('\\n') + 1;\n                    while (nl !== 0) {\n                        this.onNewLine(this.offset + nl);\n                        nl = this.source.indexOf('\\n', nl) + 1;\n                    }\n                }\n                yield* this.pop();\n                break;\n            /* istanbul ignore next should not happen */\n            default:\n                yield* this.pop();\n                yield* this.step();\n        }\n    }\n    *blockMap(map) {\n        const it = map.items[map.items.length - 1];\n        // it.sep is true-ish if pair already has key or : separator\n        switch (this.type) {\n            case 'newline':\n                this.onKeyLine = false;\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value) {\n                    map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    if (this.atIndentedComment(it.start, map.indent)) {\n                        const prev = map.items[map.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            map.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n        }\n        if (this.indent >= map.indent) {\n            const atNextItem = !this.onKeyLine && this.indent === map.indent && it.sep;\n            // For empty nodes, assign newline-separated not indented empty tokens to following node\n            let start = [];\n            if (atNextItem && it.sep && !it.value) {\n                const nl = [];\n                for (let i = 0; i < it.sep.length; ++i) {\n                    const st = it.sep[i];\n                    switch (st.type) {\n                        case 'newline':\n                            nl.push(i);\n                            break;\n                        case 'space':\n                            break;\n                        case 'comment':\n                            if (st.indent > map.indent)\n                                nl.length = 0;\n                            break;\n                        default:\n                            nl.length = 0;\n                    }\n                }\n                if (nl.length >= 2)\n                    start = it.sep.splice(nl[1]);\n            }\n            switch (this.type) {\n                case 'anchor':\n                case 'tag':\n                    if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        it.sep.push(this.sourceToken);\n                    }\n                    else {\n                        it.start.push(this.sourceToken);\n                    }\n                    return;\n                case 'explicit-key-ind':\n                    if (!it.sep && !includesToken(it.start, 'explicit-key-ind')) {\n                        it.start.push(this.sourceToken);\n                    }\n                    else if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start });\n                    }\n                    else {\n                        this.stack.push({\n                            type: 'block-map',\n                            offset: this.offset,\n                            indent: this.indent,\n                            items: [{ start: [this.sourceToken] }]\n                        });\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'map-value-ind':\n                    if (includesToken(it.start, 'explicit-key-ind')) {\n                        if (!it.sep) {\n                            if (includesToken(it.start, 'newline')) {\n                                Object.assign(it, { key: null, sep: [this.sourceToken] });\n                            }\n                            else {\n                                const start = getFirstKeyStartProps(it.start);\n                                this.stack.push({\n                                    type: 'block-map',\n                                    offset: this.offset,\n                                    indent: this.indent,\n                                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                                });\n                            }\n                        }\n                        else if (it.value) {\n                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else if (isFlowToken(it.key) &&\n                            !includesToken(it.sep, 'newline')) {\n                            const start = getFirstKeyStartProps(it.start);\n                            const key = it.key;\n                            const sep = it.sep;\n                            sep.push(this.sourceToken);\n                            // @ts-expect-error type guard is wrong here\n                            delete it.key, delete it.sep;\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key, sep }]\n                            });\n                        }\n                        else if (start.length > 0) {\n                            // Not actually at next item\n                            it.sep = it.sep.concat(start, this.sourceToken);\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    else {\n                        if (!it.sep) {\n                            Object.assign(it, { key: null, sep: [this.sourceToken] });\n                        }\n                        else if (it.value || atNextItem) {\n                            map.items.push({ start, key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start: [], key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (atNextItem || it.value) {\n                        map.items.push({ start, key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        this.stack.push(fs);\n                    }\n                    else {\n                        Object.assign(it, { key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    return;\n                }\n                default: {\n                    const bv = this.startBlockValue(map);\n                    if (bv) {\n                        if (atNextItem &&\n                            bv.type !== 'block-seq' &&\n                            includesToken(it.start, 'explicit-key-ind')) {\n                            map.items.push({ start });\n                        }\n                        this.stack.push(bv);\n                        return;\n                    }\n                }\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *blockSequence(seq) {\n        const it = seq.items[seq.items.length - 1];\n        switch (this.type) {\n            case 'newline':\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        seq.items.push({ start: [this.sourceToken] });\n                }\n                else\n                    it.start.push(this.sourceToken);\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value)\n                    seq.items.push({ start: [this.sourceToken] });\n                else {\n                    if (this.atIndentedComment(it.start, seq.indent)) {\n                        const prev = seq.items[seq.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            seq.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'anchor':\n            case 'tag':\n                if (it.value || this.indent <= seq.indent)\n                    break;\n                it.start.push(this.sourceToken);\n                return;\n            case 'seq-item-ind':\n                if (this.indent !== seq.indent)\n                    break;\n                if (it.value || includesToken(it.start, 'seq-item-ind'))\n                    seq.items.push({ start: [this.sourceToken] });\n                else\n                    it.start.push(this.sourceToken);\n                return;\n        }\n        if (this.indent > seq.indent) {\n            const bv = this.startBlockValue(seq);\n            if (bv) {\n                this.stack.push(bv);\n                return;\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *flowCollection(fc) {\n        const it = fc.items[fc.items.length - 1];\n        if (this.type === 'flow-error-end') {\n            let top;\n            do {\n                yield* this.pop();\n                top = this.peek(1);\n            } while (top && top.type === 'flow-collection');\n        }\n        else if (fc.end.length === 0) {\n            switch (this.type) {\n                case 'comma':\n                case 'explicit-key-ind':\n                    if (!it || it.sep)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'map-value-ind':\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        Object.assign(it, { key: null, sep: [this.sourceToken] });\n                    return;\n                case 'space':\n                case 'comment':\n                case 'newline':\n                case 'anchor':\n                case 'tag':\n                    if (!it || it.value)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: fs, sep: [] });\n                    else if (it.sep)\n                        this.stack.push(fs);\n                    else\n                        Object.assign(it, { key: fs, sep: [] });\n                    return;\n                }\n                case 'flow-map-end':\n                case 'flow-seq-end':\n                    fc.end.push(this.sourceToken);\n                    return;\n            }\n            const bv = this.startBlockValue(fc);\n            /* istanbul ignore else should not happen */\n            if (bv)\n                this.stack.push(bv);\n            else {\n                yield* this.pop();\n                yield* this.step();\n            }\n        }\n        else {\n            const parent = this.peek(2);\n            if (parent.type === 'block-map' &&\n                ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||\n                    (this.type === 'newline' &&\n                        !parent.items[parent.items.length - 1].sep))) {\n                yield* this.pop();\n                yield* this.step();\n            }\n            else if (this.type === 'map-value-ind' &&\n                parent.type !== 'flow-collection') {\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                fixFlowSeqItems(fc);\n                const sep = fc.end.splice(1, fc.end.length);\n                sep.push(this.sourceToken);\n                const map = {\n                    type: 'block-map',\n                    offset: fc.offset,\n                    indent: fc.indent,\n                    items: [{ start, key: fc, sep }]\n                };\n                this.onKeyLine = true;\n                this.stack[this.stack.length - 1] = map;\n            }\n            else {\n                yield* this.lineEnd(fc);\n            }\n        }\n    }\n    flowScalar(type) {\n        if (this.onNewLine) {\n            let nl = this.source.indexOf('\\n') + 1;\n            while (nl !== 0) {\n                this.onNewLine(this.offset + nl);\n                nl = this.source.indexOf('\\n', nl) + 1;\n            }\n        }\n        return {\n            type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n    }\n    startBlockValue(parent) {\n        switch (this.type) {\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return this.flowScalar(this.type);\n            case 'block-scalar-header':\n                return {\n                    type: 'block-scalar',\n                    offset: this.offset,\n                    indent: this.indent,\n                    props: [this.sourceToken],\n                    source: ''\n                };\n            case 'flow-map-start':\n            case 'flow-seq-start':\n                return {\n                    type: 'flow-collection',\n                    offset: this.offset,\n                    indent: this.indent,\n                    start: this.sourceToken,\n                    items: [],\n                    end: []\n                };\n            case 'seq-item-ind':\n                return {\n                    type: 'block-seq',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start: [this.sourceToken] }]\n                };\n            case 'explicit-key-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                start.push(this.sourceToken);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start }]\n                };\n            }\n            case 'map-value-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                };\n            }\n        }\n        return null;\n    }\n    atIndentedComment(start, indent) {\n        if (this.type !== 'comment')\n            return false;\n        if (this.indent <= indent)\n            return false;\n        return start.every(st => st.type === 'newline' || st.type === 'space');\n    }\n    *documentEnd(docEnd) {\n        if (this.type !== 'doc-mode') {\n            if (docEnd.end)\n                docEnd.end.push(this.sourceToken);\n            else\n                docEnd.end = [this.sourceToken];\n            if (this.type === 'newline')\n                yield* this.pop();\n        }\n    }\n    *lineEnd(token) {\n        switch (this.type) {\n            case 'comma':\n            case 'doc-start':\n            case 'doc-end':\n            case 'flow-seq-end':\n            case 'flow-map-end':\n            case 'map-value-ind':\n                yield* this.pop();\n                yield* this.step();\n                break;\n            case 'newline':\n                this.onKeyLine = false;\n            // fallthrough\n            case 'space':\n            case 'comment':\n            default:\n                // all other values are errors\n                if (token.end)\n                    token.end.push(this.sourceToken);\n                else\n                    token.end = [this.sourceToken];\n                if (this.type === 'newline')\n                    yield* this.pop();\n        }\n    }\n}\n\nexport { Parser };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}