{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport { unlinkSync as rm, readFileSync as readFile, writeFileSync as writeFile } from 'fs';\nimport createDebug from 'debug';\nimport { domainsDir, rootCADir, ensureConfigDirs, getLegacyConfigDir, rootCAKeyPath, rootCACertPath, caSelfSignConfig, opensslSerialFilePath, opensslDatabaseFilePath, caVersionFile } from \"./constants\";\nimport currentPlatform from \"./platforms\";\nimport { openssl, mktmp } from \"./utils\";\nimport { generateKey } from \"./certificates\";\nvar debug = createDebug('devcert:certificate-authority');\nexport default function installCertificateAuthority() {\n  return _installCertificateAuthority.apply(this, arguments);\n}\nfunction _installCertificateAuthority() {\n  _installCertificateAuthority = _asyncToGenerator(function* () {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    debug(`Uninstalling existing certificates, which will be void once any existing CA is gone`);\n    uninstall();\n    ensureConfigDirs();\n    debug(`Making a temp working directory for files to copied in`);\n    var rootKeyPath = mktmp();\n    debug(`Generating the OpenSSL configuration needed to setup the certificate authority`);\n    seedConfigFiles();\n    debug(`Generating a private key`);\n    generateKey(rootKeyPath);\n    debug(`Generating a CA certificate`);\n    openssl(['req', '-new', '-x509', '-config', caSelfSignConfig, '-key', rootKeyPath, '-out', rootCACertPath, '-days', '825']);\n    debug('Saving certificate authority credentials');\n    yield saveCertificateAuthorityCredentials(rootKeyPath);\n    debug(`Adding the root certificate authority to trust stores`);\n    yield currentPlatform.addToTrustStores(rootCACertPath, options);\n  });\n  return _installCertificateAuthority.apply(this, arguments);\n}\nfunction seedConfigFiles() {\n  writeFile(caVersionFile, '2');\n  writeFile(opensslDatabaseFilePath, '');\n  writeFile(opensslSerialFilePath, '01');\n}\nexport function withCertificateAuthorityCredentials(_x) {\n  return _withCertificateAuthorityCredentials.apply(this, arguments);\n}\nfunction _withCertificateAuthorityCredentials() {\n  _withCertificateAuthorityCredentials = _asyncToGenerator(function* (cb) {\n    debug(`Retrieving devcert's certificate authority credentials`);\n    var tmpCAKeyPath = mktmp();\n    var caKey = yield currentPlatform.readProtectedFile(rootCAKeyPath);\n    writeFile(tmpCAKeyPath, caKey);\n    yield cb({\n      caKeyPath: tmpCAKeyPath,\n      caCertPath: rootCACertPath\n    });\n    rm(tmpCAKeyPath);\n  });\n  return _withCertificateAuthorityCredentials.apply(this, arguments);\n}\nfunction saveCertificateAuthorityCredentials(_x2) {\n  return _saveCertificateAuthorityCredentials.apply(this, arguments);\n}\nfunction _saveCertificateAuthorityCredentials() {\n  _saveCertificateAuthorityCredentials = _asyncToGenerator(function* (keypath) {\n    debug(`Saving devcert's certificate authority credentials`);\n    var key = readFile(keypath, 'utf-8');\n    yield currentPlatform.writeProtectedFile(rootCAKeyPath, key);\n  });\n  return _saveCertificateAuthorityCredentials.apply(this, arguments);\n}\nfunction certErrors() {\n  try {\n    openssl(['x509', '-in', rootCACertPath, '-noout']);\n    return '';\n  } catch (e) {\n    return e.toString();\n  }\n}\nexport function ensureCACertReadable() {\n  return _ensureCACertReadable.apply(this, arguments);\n}\nfunction _ensureCACertReadable() {\n  _ensureCACertReadable = _asyncToGenerator(function* () {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!certErrors()) {\n      return;\n    }\n    try {\n      var caFileContents = yield currentPlatform.readProtectedFile(rootCACertPath);\n      currentPlatform.deleteProtectedFiles(rootCACertPath);\n      writeFile(rootCACertPath, caFileContents);\n    } catch (e) {\n      return installCertificateAuthority(options);\n    }\n    var remainingErrors = certErrors();\n    if (remainingErrors) {\n      return installCertificateAuthority(options);\n    }\n  });\n  return _ensureCACertReadable.apply(this, arguments);\n}\nexport function uninstall() {\n  currentPlatform.removeFromTrustStores(rootCACertPath);\n  currentPlatform.deleteProtectedFiles(domainsDir);\n  currentPlatform.deleteProtectedFiles(rootCADir);\n  currentPlatform.deleteProtectedFiles(getLegacyConfigDir());\n}","map":{"version":3,"names":["unlinkSync","rm","readFileSync","readFile","writeFileSync","writeFile","createDebug","domainsDir","rootCADir","ensureConfigDirs","getLegacyConfigDir","rootCAKeyPath","rootCACertPath","caSelfSignConfig","opensslSerialFilePath","opensslDatabaseFilePath","caVersionFile","currentPlatform","openssl","mktmp","generateKey","debug","installCertificateAuthority","_installCertificateAuthority","apply","arguments","_asyncToGenerator","options","length","undefined","uninstall","rootKeyPath","seedConfigFiles","saveCertificateAuthorityCredentials","addToTrustStores","withCertificateAuthorityCredentials","_x","_withCertificateAuthorityCredentials","cb","tmpCAKeyPath","caKey","readProtectedFile","caKeyPath","caCertPath","_x2","_saveCertificateAuthorityCredentials","keypath","key","writeProtectedFile","certErrors","e","toString","ensureCACertReadable","_ensureCACertReadable","caFileContents","deleteProtectedFiles","remainingErrors","removeFromTrustStores"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@expo/devcert/src/certificate-authority.ts"],"sourcesContent":["import {\n  unlinkSync as rm,\n  readFileSync as readFile,\n  writeFileSync as writeFile\n} from 'fs';\nimport createDebug from 'debug';\n\nimport {\n  domainsDir,\n  rootCADir,\n  ensureConfigDirs,\n  getLegacyConfigDir,\n  rootCAKeyPath,\n  rootCACertPath,\n  caSelfSignConfig,\n  opensslSerialFilePath,\n  opensslDatabaseFilePath,\n  caVersionFile\n} from './constants';\nimport currentPlatform from './platforms';\nimport { openssl, mktmp } from './utils';\nimport { generateKey } from './certificates';\nimport { Options } from './index';\n\nconst debug = createDebug('devcert:certificate-authority');\n\n/**\n * Install the once-per-machine trusted root CA. We'll use this CA to sign\n * per-app certs.\n */\nexport default async function installCertificateAuthority(options: Options = {}): Promise<void> {\n  debug(`Uninstalling existing certificates, which will be void once any existing CA is gone`);\n  uninstall();\n  ensureConfigDirs();\n\n  debug(`Making a temp working directory for files to copied in`);\n  let rootKeyPath = mktmp();\n\n  debug(`Generating the OpenSSL configuration needed to setup the certificate authority`);\n  seedConfigFiles();\n\n  debug(`Generating a private key`);\n  generateKey(rootKeyPath);\n\n  debug(`Generating a CA certificate`);\n  openssl(['req', '-new', '-x509', '-config', caSelfSignConfig, '-key', rootKeyPath, '-out', rootCACertPath, '-days', '825']);\n\n  debug('Saving certificate authority credentials');\n  await saveCertificateAuthorityCredentials(rootKeyPath);\n\n  debug(`Adding the root certificate authority to trust stores`);\n  await currentPlatform.addToTrustStores(rootCACertPath, options);\n}\n\n/**\n * Initializes the files OpenSSL needs to sign certificates as a certificate\n * authority, as well as our CA setup version\n */\nfunction seedConfigFiles() {\n  // This is v2 of the devcert certificate authority setup\n  writeFile(caVersionFile, '2');\n  // OpenSSL CA files\n  writeFile(opensslDatabaseFilePath, '');\n  writeFile(opensslSerialFilePath, '01');\n}\n\nexport async function withCertificateAuthorityCredentials(cb: ({ caKeyPath, caCertPath }: { caKeyPath: string, caCertPath: string }) => Promise<void> | void) {\n  debug(`Retrieving devcert's certificate authority credentials`);\n  let tmpCAKeyPath = mktmp();\n  let caKey = await currentPlatform.readProtectedFile(rootCAKeyPath);\n  writeFile(tmpCAKeyPath, caKey);\n  await cb({ caKeyPath: tmpCAKeyPath, caCertPath: rootCACertPath });\n  rm(tmpCAKeyPath);\n}\n\nasync function saveCertificateAuthorityCredentials(keypath: string) {\n  debug(`Saving devcert's certificate authority credentials`);\n  let key = readFile(keypath, 'utf-8');\n  await currentPlatform.writeProtectedFile(rootCAKeyPath, key);\n}\n\n\nfunction certErrors(): string {\n  try {\n    openssl(['x509', '-in', rootCACertPath, '-noout']);\n    return '';\n  } catch (e) {\n    return e.toString();\n  }\n}\n\n// This function helps to migrate from v1.0.x to >= v1.1.0.\n/**\n * Smoothly migrate the certificate storage from v1.0.x to >= v1.1.0.\n * In v1.1.0 there are new options for retrieving the CA cert directly,\n * to help third-party Node apps trust the root CA.\n * \n * If a v1.0.x cert already exists, then devcert has written it with\n * platform.writeProtectedFile(), so an unprivileged readFile cannot access it.\n * Pre-detect and remedy this; it should only happen once per installation.\n */\nexport async function ensureCACertReadable(options: Options = {}): Promise<void> {\n  if (!certErrors()) {\n    return;\n  }\n  /**\n   * on windows, writeProtectedFile left the cert encrypted on *nix, the cert\n   * has no read permissions either way, openssl will fail and that means we\n   * have to fix it\n   */\n  try {\n    const caFileContents = await currentPlatform.readProtectedFile(rootCACertPath);\n    currentPlatform.deleteProtectedFiles(rootCACertPath);\n    writeFile(rootCACertPath, caFileContents);\n  } catch (e) {\n    return installCertificateAuthority(options);\n  }\n  \n  // double check that we have a live one\n  const remainingErrors = certErrors();\n  if (remainingErrors) {\n    return installCertificateAuthority(options);\n  }\n}\n\n/**\n * Remove as much of the devcert files and state as we can. This is necessary\n * when generating a new root certificate, and should be available to API\n * consumers as well.\n * \n * Not all of it will be removable. If certutil is not installed, we'll leave\n * Firefox alone. We try to remove files with maximum permissions, and if that\n * fails, we'll silently fail.\n * \n * It's also possible that the command to untrust will not work, and we'll\n * silently fail that as well; with no existing certificates anymore, the\n * security exposure there is minimal.\n */\nexport function uninstall(): void {\n  currentPlatform.removeFromTrustStores(rootCACertPath);\n  currentPlatform.deleteProtectedFiles(domainsDir);\n  currentPlatform.deleteProtectedFiles(rootCADir);\n  currentPlatform.deleteProtectedFiles(getLegacyConfigDir());\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}