{"ast":null,"code":"'use strict';\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError('Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.');\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === 'string') return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === 'Object' && o.constructor) n = o.constructor.name;\n  if (n === 'Map' || n === 'Set') return Array.from(o);\n  if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : 'undefined' != typeof Symbol && arr[Symbol.iterator] || arr['@@iterator'];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nvar invariant = require('invariant');\nvar _require = require(\"./Utils\"),\n  getNamespacedStructName = _require.getNamespacedStructName;\nvar _require2 = require(\"../../Utils\"),\n  capitalize = _require2.capitalize;\nvar _require3 = require(\"../../../parsers/parsers-commons\"),\n  wrapNullable = _require3.wrapNullable,\n  unwrapNullable = _require3.unwrapNullable;\nvar ProtocolMethodTemplate = function ProtocolMethodTemplate(_ref) {\n  var returnObjCType = _ref.returnObjCType,\n    methodName = _ref.methodName,\n    params = _ref.params;\n  return `- (${returnObjCType})${methodName}${params};`;\n};\nfunction serializeMethod(hasteModuleName, property, structCollector, resolveAlias) {\n  var methodName = property.name,\n    nullableTypeAnnotation = property.typeAnnotation;\n  var _unwrapNullable = unwrapNullable(nullableTypeAnnotation),\n    _unwrapNullable2 = _slicedToArray(_unwrapNullable, 1),\n    propertyTypeAnnotation = _unwrapNullable2[0];\n  var params = propertyTypeAnnotation.params;\n  if (methodName === 'getConstants') {\n    return serializeConstantsProtocolMethods(hasteModuleName, property, structCollector, resolveAlias);\n  }\n  var methodParams = [];\n  var structParamRecords = [];\n  params.forEach(function (param, index) {\n    var structName = getParamStructName(methodName, param);\n    var _getParamObjCType = getParamObjCType(hasteModuleName, methodName, param, structName, structCollector, resolveAlias),\n      objCType = _getParamObjCType.objCType,\n      isStruct = _getParamObjCType.isStruct;\n    methodParams.push({\n      paramName: param.name,\n      objCType: objCType\n    });\n    if (isStruct) {\n      structParamRecords.push({\n        paramIndex: index,\n        structName: structName\n      });\n    }\n  });\n  var _unwrapNullable3 = unwrapNullable(propertyTypeAnnotation.returnTypeAnnotation),\n    _unwrapNullable4 = _slicedToArray(_unwrapNullable3, 1),\n    returnTypeAnnotation = _unwrapNullable4[0];\n  if (returnTypeAnnotation.type === 'PromiseTypeAnnotation') {\n    methodParams.push({\n      paramName: 'resolve',\n      objCType: 'RCTPromiseResolveBlock'\n    }, {\n      paramName: 'reject',\n      objCType: 'RCTPromiseRejectBlock'\n    });\n  }\n  var returnObjCType = getReturnObjCType(methodName, propertyTypeAnnotation.returnTypeAnnotation);\n  var paddingMax = `- (${returnObjCType})${methodName}`.length;\n  var objCParams = methodParams.reduce(function ($objCParams, _ref2, i) {\n    var objCType = _ref2.objCType,\n      paramName = _ref2.paramName;\n    var rhs = `(${objCType})${paramName}`;\n    var padding = ' '.repeat(Math.max(0, paddingMax - paramName.length));\n    return i === 0 ? `:${rhs}` : `${$objCParams}\\n${padding}${paramName}:${rhs}`;\n  }, '');\n  var protocolMethod = ProtocolMethodTemplate({\n    methodName: methodName,\n    returnObjCType: returnObjCType,\n    params: objCParams\n  });\n  var selector = methodParams.map(function (_ref3) {\n    var paramName = _ref3.paramName;\n    return paramName;\n  }).reduce(function ($selector, paramName, i) {\n    return i === 0 ? `${$selector}:` : `${$selector}${paramName}:`;\n  }, methodName);\n  var returnJSType = getReturnJSType(methodName, returnTypeAnnotation);\n  return [{\n    methodName: methodName,\n    protocolMethod: protocolMethod,\n    selector: `@selector(${selector})`,\n    structParamRecords: structParamRecords,\n    returnJSType: returnJSType,\n    argCount: params.length\n  }];\n}\nfunction getParamStructName(methodName, param) {\n  var _unwrapNullable5 = unwrapNullable(param.typeAnnotation),\n    _unwrapNullable6 = _slicedToArray(_unwrapNullable5, 1),\n    typeAnnotation = _unwrapNullable6[0];\n  if (typeAnnotation.type === 'TypeAliasTypeAnnotation') {\n    return typeAnnotation.name;\n  }\n  return `Spec${capitalize(methodName)}${capitalize(param.name)}`;\n}\nfunction getParamObjCType(hasteModuleName, methodName, param, structName, structCollector, resolveAlias) {\n  var paramName = param.name,\n    nullableTypeAnnotation = param.typeAnnotation;\n  var _unwrapNullable7 = unwrapNullable(nullableTypeAnnotation),\n    _unwrapNullable8 = _slicedToArray(_unwrapNullable7, 2),\n    typeAnnotation = _unwrapNullable8[0],\n    nullable = _unwrapNullable8[1];\n  var notRequired = param.optional || nullable;\n  function wrapIntoNullableIfNeeded(generatedType) {\n    return nullable ? `${generatedType} _Nullable` : generatedType;\n  }\n  var isStruct = function isStruct(objCType) {\n    return {\n      isStruct: true,\n      objCType: objCType\n    };\n  };\n  var notStruct = function notStruct(objCType) {\n    return {\n      isStruct: false,\n      objCType: objCType\n    };\n  };\n  switch (typeAnnotation.type) {\n    case 'FunctionTypeAnnotation':\n      {\n        return notStruct('RCTResponseSenderBlock');\n      }\n    case 'ArrayTypeAnnotation':\n      {\n        return notStruct(wrapIntoNullableIfNeeded('NSArray *'));\n      }\n  }\n  var _unwrapNullable9 = unwrapNullable(structCollector.process(structName, 'REGULAR', resolveAlias, wrapNullable(nullable, typeAnnotation))),\n    _unwrapNullable10 = _slicedToArray(_unwrapNullable9, 1),\n    structTypeAnnotation = _unwrapNullable10[0];\n  invariant(structTypeAnnotation.type !== 'ArrayTypeAnnotation', 'ArrayTypeAnnotations should have been processed earlier');\n  switch (structTypeAnnotation.type) {\n    case 'TypeAliasTypeAnnotation':\n      {\n        return isStruct(getNamespacedStructName(hasteModuleName, structTypeAnnotation.name) + ' &');\n      }\n    case 'ReservedTypeAnnotation':\n      switch (structTypeAnnotation.name) {\n        case 'RootTag':\n          return notStruct(notRequired ? 'NSNumber *' : 'double');\n        default:\n          structTypeAnnotation.name;\n          throw new Error(`Unsupported type for param \"${paramName}\" in ${methodName}. Found: ${structTypeAnnotation.type}`);\n      }\n    case 'StringTypeAnnotation':\n      return notStruct(wrapIntoNullableIfNeeded('NSString *'));\n    case 'NumberTypeAnnotation':\n      return notStruct(notRequired ? 'NSNumber *' : 'double');\n    case 'FloatTypeAnnotation':\n      return notStruct(notRequired ? 'NSNumber *' : 'double');\n    case 'DoubleTypeAnnotation':\n      return notStruct(notRequired ? 'NSNumber *' : 'double');\n    case 'Int32TypeAnnotation':\n      return notStruct(notRequired ? 'NSNumber *' : 'double');\n    case 'BooleanTypeAnnotation':\n      return notStruct(notRequired ? 'NSNumber *' : 'BOOL');\n    case 'EnumDeclaration':\n      switch (typeAnnotation.memberType) {\n        case 'NumberTypeAnnotation':\n          return notStruct(notRequired ? 'NSNumber *' : 'double');\n        case 'StringTypeAnnotation':\n          return notStruct(wrapIntoNullableIfNeeded('NSString *'));\n        default:\n          throw new Error(`Unsupported enum type for param \"${paramName}\" in ${methodName}. Found: ${typeAnnotation.type}`);\n      }\n    case 'GenericObjectTypeAnnotation':\n      return notStruct(wrapIntoNullableIfNeeded('NSDictionary *'));\n    default:\n      structTypeAnnotation.type;\n      throw new Error(`Unsupported type for param \"${paramName}\" in ${methodName}. Found: ${typeAnnotation.type}`);\n  }\n}\nfunction getReturnObjCType(methodName, nullableTypeAnnotation) {\n  var _unwrapNullable11 = unwrapNullable(nullableTypeAnnotation),\n    _unwrapNullable12 = _slicedToArray(_unwrapNullable11, 2),\n    typeAnnotation = _unwrapNullable12[0],\n    nullable = _unwrapNullable12[1];\n  function wrapIntoNullableIfNeeded(generatedType) {\n    return nullable ? `${generatedType} _Nullable` : generatedType;\n  }\n  switch (typeAnnotation.type) {\n    case 'VoidTypeAnnotation':\n      return 'void';\n    case 'PromiseTypeAnnotation':\n      return 'void';\n    case 'ObjectTypeAnnotation':\n      return wrapIntoNullableIfNeeded('NSDictionary *');\n    case 'TypeAliasTypeAnnotation':\n      return wrapIntoNullableIfNeeded('NSDictionary *');\n    case 'ArrayTypeAnnotation':\n      if (typeAnnotation.elementType == null) {\n        return wrapIntoNullableIfNeeded('NSArray<id<NSObject>> *');\n      }\n      return wrapIntoNullableIfNeeded(`NSArray<${getReturnObjCType(methodName, typeAnnotation.elementType)}> *`);\n    case 'ReservedTypeAnnotation':\n      switch (typeAnnotation.name) {\n        case 'RootTag':\n          return wrapIntoNullableIfNeeded('NSNumber *');\n        default:\n          typeAnnotation.name;\n          throw new Error(`Unsupported return type for ${methodName}. Found: ${typeAnnotation.name}`);\n      }\n    case 'StringTypeAnnotation':\n      return wrapIntoNullableIfNeeded('NSString *');\n    case 'NumberTypeAnnotation':\n      return wrapIntoNullableIfNeeded('NSNumber *');\n    case 'FloatTypeAnnotation':\n      return wrapIntoNullableIfNeeded('NSNumber *');\n    case 'DoubleTypeAnnotation':\n      return wrapIntoNullableIfNeeded('NSNumber *');\n    case 'Int32TypeAnnotation':\n      return wrapIntoNullableIfNeeded('NSNumber *');\n    case 'BooleanTypeAnnotation':\n      return wrapIntoNullableIfNeeded('NSNumber *');\n    case 'EnumDeclaration':\n      switch (typeAnnotation.memberType) {\n        case 'NumberTypeAnnotation':\n          return wrapIntoNullableIfNeeded('NSNumber *');\n        case 'StringTypeAnnotation':\n          return wrapIntoNullableIfNeeded('NSString *');\n        default:\n          throw new Error(`Unsupported enum return type for ${methodName}. Found: ${typeAnnotation.type}`);\n      }\n    case 'UnionTypeAnnotation':\n      switch (typeAnnotation.memberType) {\n        case 'NumberTypeAnnotation':\n          return wrapIntoNullableIfNeeded('NSNumber *');\n        case 'ObjectTypeAnnotation':\n          return wrapIntoNullableIfNeeded('NSDictionary *');\n        case 'StringTypeAnnotation':\n          return wrapIntoNullableIfNeeded('NSString *');\n        default:\n          throw new Error(`Unsupported union return type for ${methodName}, found: ${typeAnnotation.memberType}\"`);\n      }\n    case 'GenericObjectTypeAnnotation':\n      return wrapIntoNullableIfNeeded('NSDictionary *');\n    default:\n      typeAnnotation.type;\n      throw new Error(`Unsupported return type for ${methodName}. Found: ${typeAnnotation.type}`);\n  }\n}\nfunction getReturnJSType(methodName, nullableTypeAnnotation) {\n  var _unwrapNullable13 = unwrapNullable(nullableTypeAnnotation),\n    _unwrapNullable14 = _slicedToArray(_unwrapNullable13, 1),\n    typeAnnotation = _unwrapNullable14[0];\n  switch (typeAnnotation.type) {\n    case 'VoidTypeAnnotation':\n      return 'VoidKind';\n    case 'PromiseTypeAnnotation':\n      return 'PromiseKind';\n    case 'ObjectTypeAnnotation':\n      return 'ObjectKind';\n    case 'TypeAliasTypeAnnotation':\n      return 'ObjectKind';\n    case 'ArrayTypeAnnotation':\n      return 'ArrayKind';\n    case 'ReservedTypeAnnotation':\n      return 'NumberKind';\n    case 'StringTypeAnnotation':\n      return 'StringKind';\n    case 'NumberTypeAnnotation':\n      return 'NumberKind';\n    case 'FloatTypeAnnotation':\n      return 'NumberKind';\n    case 'DoubleTypeAnnotation':\n      return 'NumberKind';\n    case 'Int32TypeAnnotation':\n      return 'NumberKind';\n    case 'BooleanTypeAnnotation':\n      return 'BooleanKind';\n    case 'GenericObjectTypeAnnotation':\n      return 'ObjectKind';\n    case 'EnumDeclaration':\n      switch (typeAnnotation.memberType) {\n        case 'NumberTypeAnnotation':\n          return 'NumberKind';\n        case 'StringTypeAnnotation':\n          return 'StringKind';\n        default:\n          throw new Error(`Unsupported return type for ${methodName}. Found: ${typeAnnotation.type}`);\n      }\n    case 'UnionTypeAnnotation':\n      switch (typeAnnotation.memberType) {\n        case 'NumberTypeAnnotation':\n          return 'NumberKind';\n        case 'ObjectTypeAnnotation':\n          return 'ObjectKind';\n        case 'StringTypeAnnotation':\n          return 'StringKind';\n        default:\n          throw new Error(`Unsupported return type for ${methodName}. Found: ${typeAnnotation.type}`);\n      }\n    default:\n      typeAnnotation.type;\n      throw new Error(`Unsupported return type for ${methodName}. Found: ${typeAnnotation.type}`);\n  }\n}\nfunction serializeConstantsProtocolMethods(hasteModuleName, property, structCollector, resolveAlias) {\n  var _unwrapNullable15 = unwrapNullable(property.typeAnnotation),\n    _unwrapNullable16 = _slicedToArray(_unwrapNullable15, 1),\n    propertyTypeAnnotation = _unwrapNullable16[0];\n  if (propertyTypeAnnotation.params.length !== 0) {\n    throw new Error(`${hasteModuleName}.getConstants() may only accept 0 arguments.`);\n  }\n  var returnTypeAnnotation = propertyTypeAnnotation.returnTypeAnnotation;\n  if (returnTypeAnnotation.type !== 'ObjectTypeAnnotation') {\n    throw new Error(`${hasteModuleName}.getConstants() may only return an object literal: {...}.`);\n  }\n  if (returnTypeAnnotation.properties.length === 0) {\n    return [];\n  }\n  var realTypeAnnotation = structCollector.process('Constants', 'CONSTANTS', resolveAlias, returnTypeAnnotation);\n  invariant(realTypeAnnotation.type === 'TypeAliasTypeAnnotation', \"Unable to generate C++ struct from module's getConstants() method return type.\");\n  var returnObjCType = `facebook::react::ModuleConstants<JS::${hasteModuleName}::Constants::Builder>`;\n  return ['constantsToExport', 'getConstants'].map(function (methodName) {\n    var protocolMethod = ProtocolMethodTemplate({\n      methodName: methodName,\n      returnObjCType: returnObjCType,\n      params: ''\n    });\n    return {\n      methodName: methodName,\n      protocolMethod: protocolMethod,\n      returnJSType: 'ObjectKind',\n      selector: `@selector(${methodName})`,\n      structParamRecords: [],\n      argCount: 0\n    };\n  });\n}\nmodule.exports = {\n  serializeMethod: serializeMethod\n};","map":{"version":3,"names":["_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","len","length","arr2","_i","Symbol","iterator","_s","_e","_x","_r","_arr","_n","_d","next","done","push","value","err","return","isArray","invariant","require","_require","getNamespacedStructName","_require2","capitalize","_require3","wrapNullable","unwrapNullable","ProtocolMethodTemplate","_ref","returnObjCType","methodName","params","serializeMethod","hasteModuleName","property","structCollector","resolveAlias","nullableTypeAnnotation","typeAnnotation","_unwrapNullable","_unwrapNullable2","propertyTypeAnnotation","serializeConstantsProtocolMethods","methodParams","structParamRecords","forEach","param","index","structName","getParamStructName","_getParamObjCType","getParamObjCType","objCType","isStruct","paramName","paramIndex","_unwrapNullable3","returnTypeAnnotation","_unwrapNullable4","type","getReturnObjCType","paddingMax","objCParams","reduce","$objCParams","_ref2","rhs","padding","repeat","Math","max","protocolMethod","selector","map","_ref3","$selector","returnJSType","getReturnJSType","argCount","_unwrapNullable5","_unwrapNullable6","_unwrapNullable7","_unwrapNullable8","nullable","notRequired","optional","wrapIntoNullableIfNeeded","generatedType","notStruct","_unwrapNullable9","process","_unwrapNullable10","structTypeAnnotation","Error","memberType","_unwrapNullable11","_unwrapNullable12","elementType","_unwrapNullable13","_unwrapNullable14","_unwrapNullable15","_unwrapNullable16","properties","realTypeAnnotation","module","exports"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native/codegen/lib/generators/modules/GenerateModuleObjCpp/serializeMethod.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\n'use strict';\n\nfunction _slicedToArray(arr, i) {\n  return (\n    _arrayWithHoles(arr) ||\n    _iterableToArrayLimit(arr, i) ||\n    _unsupportedIterableToArray(arr, i) ||\n    _nonIterableRest()\n  );\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\n    'Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',\n  );\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === 'string') return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === 'Object' && o.constructor) n = o.constructor.name;\n  if (n === 'Map' || n === 'Set') return Array.from(o);\n  if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n    return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i =\n    null == arr\n      ? null\n      : ('undefined' != typeof Symbol && arr[Symbol.iterator]) ||\n        arr['@@iterator'];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (((_x = (_i = _i.call(arr)).next), 0 === i)) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else\n        for (\n          ;\n          !(_n = (_s = _x.call(_i)).done) &&\n          (_arr.push(_s.value), _arr.length !== i);\n          _n = !0\n        );\n    } catch (err) {\n      (_d = !0), (_e = err);\n    } finally {\n      try {\n        if (!_n && null != _i.return && ((_r = _i.return()), Object(_r) !== _r))\n          return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nconst invariant = require('invariant');\nconst _require = require('./Utils'),\n  getNamespacedStructName = _require.getNamespacedStructName;\nconst _require2 = require('../../Utils'),\n  capitalize = _require2.capitalize;\nconst _require3 = require('../../../parsers/parsers-commons'),\n  wrapNullable = _require3.wrapNullable,\n  unwrapNullable = _require3.unwrapNullable;\nconst ProtocolMethodTemplate = ({returnObjCType, methodName, params}) =>\n  `- (${returnObjCType})${methodName}${params};`;\nfunction serializeMethod(\n  hasteModuleName,\n  property,\n  structCollector,\n  resolveAlias,\n) {\n  const methodName = property.name,\n    nullableTypeAnnotation = property.typeAnnotation;\n  const _unwrapNullable = unwrapNullable(nullableTypeAnnotation),\n    _unwrapNullable2 = _slicedToArray(_unwrapNullable, 1),\n    propertyTypeAnnotation = _unwrapNullable2[0];\n  const params = propertyTypeAnnotation.params;\n  if (methodName === 'getConstants') {\n    return serializeConstantsProtocolMethods(\n      hasteModuleName,\n      property,\n      structCollector,\n      resolveAlias,\n    );\n  }\n  const methodParams = [];\n  const structParamRecords = [];\n  params.forEach((param, index) => {\n    const structName = getParamStructName(methodName, param);\n    const _getParamObjCType = getParamObjCType(\n        hasteModuleName,\n        methodName,\n        param,\n        structName,\n        structCollector,\n        resolveAlias,\n      ),\n      objCType = _getParamObjCType.objCType,\n      isStruct = _getParamObjCType.isStruct;\n    methodParams.push({\n      paramName: param.name,\n      objCType,\n    });\n    if (isStruct) {\n      structParamRecords.push({\n        paramIndex: index,\n        structName,\n      });\n    }\n  });\n\n  // Unwrap returnTypeAnnotation, so we check if the return type is Promise\n  // TODO(T76719514): Disallow nullable PromiseTypeAnnotations\n  const _unwrapNullable3 = unwrapNullable(\n      propertyTypeAnnotation.returnTypeAnnotation,\n    ),\n    _unwrapNullable4 = _slicedToArray(_unwrapNullable3, 1),\n    returnTypeAnnotation = _unwrapNullable4[0];\n  if (returnTypeAnnotation.type === 'PromiseTypeAnnotation') {\n    methodParams.push(\n      {\n        paramName: 'resolve',\n        objCType: 'RCTPromiseResolveBlock',\n      },\n      {\n        paramName: 'reject',\n        objCType: 'RCTPromiseRejectBlock',\n      },\n    );\n  }\n\n  /**\n   * Build Protocol Method\n   **/\n  const returnObjCType = getReturnObjCType(\n    methodName,\n    propertyTypeAnnotation.returnTypeAnnotation,\n  );\n  const paddingMax = `- (${returnObjCType})${methodName}`.length;\n  const objCParams = methodParams.reduce(\n    ($objCParams, {objCType, paramName}, i) => {\n      const rhs = `(${objCType})${paramName}`;\n      const padding = ' '.repeat(Math.max(0, paddingMax - paramName.length));\n      return i === 0\n        ? `:${rhs}`\n        : `${$objCParams}\\n${padding}${paramName}:${rhs}`;\n    },\n    '',\n  );\n  const protocolMethod = ProtocolMethodTemplate({\n    methodName,\n    returnObjCType,\n    params: objCParams,\n  });\n\n  /**\n   * Build ObjC Selector\n   */\n  // $FlowFixMe[missing-type-arg]\n  const selector = methodParams\n    .map(({paramName}) => paramName)\n    .reduce(($selector, paramName, i) => {\n      return i === 0 ? `${$selector}:` : `${$selector}${paramName}:`;\n    }, methodName);\n\n  /**\n   * Build JS Return type\n   */\n  const returnJSType = getReturnJSType(methodName, returnTypeAnnotation);\n  return [\n    {\n      methodName,\n      protocolMethod,\n      selector: `@selector(${selector})`,\n      structParamRecords,\n      returnJSType,\n      argCount: params.length,\n    },\n  ];\n}\nfunction getParamStructName(methodName, param) {\n  const _unwrapNullable5 = unwrapNullable(param.typeAnnotation),\n    _unwrapNullable6 = _slicedToArray(_unwrapNullable5, 1),\n    typeAnnotation = _unwrapNullable6[0];\n  if (typeAnnotation.type === 'TypeAliasTypeAnnotation') {\n    return typeAnnotation.name;\n  }\n  return `Spec${capitalize(methodName)}${capitalize(param.name)}`;\n}\nfunction getParamObjCType(\n  hasteModuleName,\n  methodName,\n  param,\n  structName,\n  structCollector,\n  resolveAlias,\n) {\n  const paramName = param.name,\n    nullableTypeAnnotation = param.typeAnnotation;\n  const _unwrapNullable7 = unwrapNullable(nullableTypeAnnotation),\n    _unwrapNullable8 = _slicedToArray(_unwrapNullable7, 2),\n    typeAnnotation = _unwrapNullable8[0],\n    nullable = _unwrapNullable8[1];\n  const notRequired = param.optional || nullable;\n  function wrapIntoNullableIfNeeded(generatedType) {\n    return nullable ? `${generatedType} _Nullable` : generatedType;\n  }\n  const isStruct = objCType => ({\n    isStruct: true,\n    objCType,\n  });\n  const notStruct = objCType => ({\n    isStruct: false,\n    objCType,\n  });\n\n  // Handle types that can only be in parameters\n  switch (typeAnnotation.type) {\n    case 'FunctionTypeAnnotation': {\n      return notStruct('RCTResponseSenderBlock');\n    }\n    case 'ArrayTypeAnnotation': {\n      /**\n       * Array in params always codegen NSArray *\n       *\n       * TODO(T73933406): Support codegen for Arrays of structs and primitives\n       *\n       * For example:\n       *   Array<number> => NSArray<NSNumber *>\n       *   type Animal = {};\n       *   Array<Animal> => NSArray<JS::NativeSampleTurboModule::Animal *>, etc.\n       */\n      return notStruct(wrapIntoNullableIfNeeded('NSArray *'));\n    }\n  }\n  const _unwrapNullable9 = unwrapNullable(\n      structCollector.process(\n        structName,\n        'REGULAR',\n        resolveAlias,\n        wrapNullable(nullable, typeAnnotation),\n      ),\n    ),\n    _unwrapNullable10 = _slicedToArray(_unwrapNullable9, 1),\n    structTypeAnnotation = _unwrapNullable10[0];\n  invariant(\n    structTypeAnnotation.type !== 'ArrayTypeAnnotation',\n    'ArrayTypeAnnotations should have been processed earlier',\n  );\n  switch (structTypeAnnotation.type) {\n    case 'TypeAliasTypeAnnotation': {\n      /**\n       * TODO(T73943261): Support nullable object literals and aliases?\n       */\n      return isStruct(\n        getNamespacedStructName(hasteModuleName, structTypeAnnotation.name) +\n          ' &',\n      );\n    }\n    case 'ReservedTypeAnnotation':\n      switch (structTypeAnnotation.name) {\n        case 'RootTag':\n          return notStruct(notRequired ? 'NSNumber *' : 'double');\n        default:\n          structTypeAnnotation.name;\n          throw new Error(\n            `Unsupported type for param \"${paramName}\" in ${methodName}. Found: ${structTypeAnnotation.type}`,\n          );\n      }\n    case 'StringTypeAnnotation':\n      return notStruct(wrapIntoNullableIfNeeded('NSString *'));\n    case 'NumberTypeAnnotation':\n      return notStruct(notRequired ? 'NSNumber *' : 'double');\n    case 'FloatTypeAnnotation':\n      return notStruct(notRequired ? 'NSNumber *' : 'double');\n    case 'DoubleTypeAnnotation':\n      return notStruct(notRequired ? 'NSNumber *' : 'double');\n    case 'Int32TypeAnnotation':\n      return notStruct(notRequired ? 'NSNumber *' : 'double');\n    case 'BooleanTypeAnnotation':\n      return notStruct(notRequired ? 'NSNumber *' : 'BOOL');\n    case 'EnumDeclaration':\n      switch (typeAnnotation.memberType) {\n        case 'NumberTypeAnnotation':\n          return notStruct(notRequired ? 'NSNumber *' : 'double');\n        case 'StringTypeAnnotation':\n          return notStruct(wrapIntoNullableIfNeeded('NSString *'));\n        default:\n          throw new Error(\n            `Unsupported enum type for param \"${paramName}\" in ${methodName}. Found: ${typeAnnotation.type}`,\n          );\n      }\n    case 'GenericObjectTypeAnnotation':\n      return notStruct(wrapIntoNullableIfNeeded('NSDictionary *'));\n    default:\n      structTypeAnnotation.type;\n      throw new Error(\n        `Unsupported type for param \"${paramName}\" in ${methodName}. Found: ${typeAnnotation.type}`,\n      );\n  }\n}\nfunction getReturnObjCType(methodName, nullableTypeAnnotation) {\n  const _unwrapNullable11 = unwrapNullable(nullableTypeAnnotation),\n    _unwrapNullable12 = _slicedToArray(_unwrapNullable11, 2),\n    typeAnnotation = _unwrapNullable12[0],\n    nullable = _unwrapNullable12[1];\n  function wrapIntoNullableIfNeeded(generatedType) {\n    return nullable ? `${generatedType} _Nullable` : generatedType;\n  }\n  switch (typeAnnotation.type) {\n    case 'VoidTypeAnnotation':\n      return 'void';\n    case 'PromiseTypeAnnotation':\n      return 'void';\n    case 'ObjectTypeAnnotation':\n      return wrapIntoNullableIfNeeded('NSDictionary *');\n    case 'TypeAliasTypeAnnotation':\n      return wrapIntoNullableIfNeeded('NSDictionary *');\n    case 'ArrayTypeAnnotation':\n      if (typeAnnotation.elementType == null) {\n        return wrapIntoNullableIfNeeded('NSArray<id<NSObject>> *');\n      }\n      return wrapIntoNullableIfNeeded(\n        `NSArray<${getReturnObjCType(\n          methodName,\n          typeAnnotation.elementType,\n        )}> *`,\n      );\n    case 'ReservedTypeAnnotation':\n      switch (typeAnnotation.name) {\n        case 'RootTag':\n          return wrapIntoNullableIfNeeded('NSNumber *');\n        default:\n          typeAnnotation.name;\n          throw new Error(\n            `Unsupported return type for ${methodName}. Found: ${typeAnnotation.name}`,\n          );\n      }\n    case 'StringTypeAnnotation':\n      // TODO: Can NSString * returns not be _Nullable?\n      // In the legacy codegen, we don't surround NSSTring * with _Nullable\n      return wrapIntoNullableIfNeeded('NSString *');\n    case 'NumberTypeAnnotation':\n      return wrapIntoNullableIfNeeded('NSNumber *');\n    case 'FloatTypeAnnotation':\n      return wrapIntoNullableIfNeeded('NSNumber *');\n    case 'DoubleTypeAnnotation':\n      return wrapIntoNullableIfNeeded('NSNumber *');\n    case 'Int32TypeAnnotation':\n      return wrapIntoNullableIfNeeded('NSNumber *');\n    case 'BooleanTypeAnnotation':\n      return wrapIntoNullableIfNeeded('NSNumber *');\n    case 'EnumDeclaration':\n      switch (typeAnnotation.memberType) {\n        case 'NumberTypeAnnotation':\n          return wrapIntoNullableIfNeeded('NSNumber *');\n        case 'StringTypeAnnotation':\n          return wrapIntoNullableIfNeeded('NSString *');\n        default:\n          throw new Error(\n            `Unsupported enum return type for ${methodName}. Found: ${typeAnnotation.type}`,\n          );\n      }\n    case 'UnionTypeAnnotation':\n      switch (typeAnnotation.memberType) {\n        case 'NumberTypeAnnotation':\n          return wrapIntoNullableIfNeeded('NSNumber *');\n        case 'ObjectTypeAnnotation':\n          return wrapIntoNullableIfNeeded('NSDictionary *');\n        case 'StringTypeAnnotation':\n          // TODO: Can NSString * returns not be _Nullable?\n          // In the legacy codegen, we don't surround NSSTring * with _Nullable\n          return wrapIntoNullableIfNeeded('NSString *');\n        default:\n          throw new Error(\n            `Unsupported union return type for ${methodName}, found: ${typeAnnotation.memberType}\"`,\n          );\n      }\n    case 'GenericObjectTypeAnnotation':\n      return wrapIntoNullableIfNeeded('NSDictionary *');\n    default:\n      typeAnnotation.type;\n      throw new Error(\n        `Unsupported return type for ${methodName}. Found: ${typeAnnotation.type}`,\n      );\n  }\n}\nfunction getReturnJSType(methodName, nullableTypeAnnotation) {\n  const _unwrapNullable13 = unwrapNullable(nullableTypeAnnotation),\n    _unwrapNullable14 = _slicedToArray(_unwrapNullable13, 1),\n    typeAnnotation = _unwrapNullable14[0];\n  switch (typeAnnotation.type) {\n    case 'VoidTypeAnnotation':\n      return 'VoidKind';\n    case 'PromiseTypeAnnotation':\n      return 'PromiseKind';\n    case 'ObjectTypeAnnotation':\n      return 'ObjectKind';\n    case 'TypeAliasTypeAnnotation':\n      return 'ObjectKind';\n    case 'ArrayTypeAnnotation':\n      return 'ArrayKind';\n    case 'ReservedTypeAnnotation':\n      return 'NumberKind';\n    case 'StringTypeAnnotation':\n      return 'StringKind';\n    case 'NumberTypeAnnotation':\n      return 'NumberKind';\n    case 'FloatTypeAnnotation':\n      return 'NumberKind';\n    case 'DoubleTypeAnnotation':\n      return 'NumberKind';\n    case 'Int32TypeAnnotation':\n      return 'NumberKind';\n    case 'BooleanTypeAnnotation':\n      return 'BooleanKind';\n    case 'GenericObjectTypeAnnotation':\n      return 'ObjectKind';\n    case 'EnumDeclaration':\n      switch (typeAnnotation.memberType) {\n        case 'NumberTypeAnnotation':\n          return 'NumberKind';\n        case 'StringTypeAnnotation':\n          return 'StringKind';\n        default:\n          throw new Error(\n            `Unsupported return type for ${methodName}. Found: ${typeAnnotation.type}`,\n          );\n      }\n    case 'UnionTypeAnnotation':\n      switch (typeAnnotation.memberType) {\n        case 'NumberTypeAnnotation':\n          return 'NumberKind';\n        case 'ObjectTypeAnnotation':\n          return 'ObjectKind';\n        case 'StringTypeAnnotation':\n          return 'StringKind';\n        default:\n          throw new Error(\n            `Unsupported return type for ${methodName}. Found: ${typeAnnotation.type}`,\n          );\n      }\n    default:\n      typeAnnotation.type;\n      throw new Error(\n        `Unsupported return type for ${methodName}. Found: ${typeAnnotation.type}`,\n      );\n  }\n}\nfunction serializeConstantsProtocolMethods(\n  hasteModuleName,\n  property,\n  structCollector,\n  resolveAlias,\n) {\n  const _unwrapNullable15 = unwrapNullable(property.typeAnnotation),\n    _unwrapNullable16 = _slicedToArray(_unwrapNullable15, 1),\n    propertyTypeAnnotation = _unwrapNullable16[0];\n  if (propertyTypeAnnotation.params.length !== 0) {\n    throw new Error(\n      `${hasteModuleName}.getConstants() may only accept 0 arguments.`,\n    );\n  }\n  const returnTypeAnnotation = propertyTypeAnnotation.returnTypeAnnotation;\n  if (returnTypeAnnotation.type !== 'ObjectTypeAnnotation') {\n    throw new Error(\n      `${hasteModuleName}.getConstants() may only return an object literal: {...}.`,\n    );\n  }\n  if (returnTypeAnnotation.properties.length === 0) {\n    return [];\n  }\n  const realTypeAnnotation = structCollector.process(\n    'Constants',\n    'CONSTANTS',\n    resolveAlias,\n    returnTypeAnnotation,\n  );\n  invariant(\n    realTypeAnnotation.type === 'TypeAliasTypeAnnotation',\n    \"Unable to generate C++ struct from module's getConstants() method return type.\",\n  );\n  const returnObjCType = `facebook::react::ModuleConstants<JS::${hasteModuleName}::Constants::Builder>`;\n\n  // $FlowFixMe[missing-type-arg]\n  return ['constantsToExport', 'getConstants'].map(methodName => {\n    const protocolMethod = ProtocolMethodTemplate({\n      methodName,\n      returnObjCType,\n      params: '',\n    });\n    return {\n      methodName,\n      protocolMethod,\n      returnJSType: 'ObjectKind',\n      selector: `@selector(${methodName})`,\n      structParamRecords: [],\n      argCount: 0,\n    };\n  });\n}\nmodule.exports = {\n  serializeMethod,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}