{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getNamedPlugins = getNamedPlugins;\nexports.autoAddConfigPluginsAsync = autoAddConfigPluginsAsync;\nvar _pluginResolver = require(\"@expo/config-plugins/build/utils/plugin-resolver\");\nvar _prebuildConfig = require(\"@expo/prebuild-config\");\nvar _modifyConfigPlugins = require(\"../../utils/modifyConfigPlugins\");\nvar debug = require(\"debug\")(\"expo:install:config-plugins\");\nvar AUTO_PLUGINS = (0, _prebuildConfig).getAutoPlugins();\nfunction packageHasConfigPlugin(projectRoot, packageName) {\n  try {\n    var info = (0, _pluginResolver).resolveConfigPluginFunctionWithInfo(projectRoot, packageName);\n    if (info.isPluginFile) {\n      return info.plugin;\n    }\n  } catch (_unused) {}\n  return false;\n}\nfunction getNamedPlugins(plugins) {\n  var namedPlugins = [];\n  for (var plugin of plugins) {\n    try {\n      var _normalizeStaticPlugi = (0, _pluginResolver).normalizeStaticPlugin(plugin),\n        _normalizeStaticPlugi2 = _slicedToArray(_normalizeStaticPlugi, 1),\n        normal = _normalizeStaticPlugi2[0];\n      if (typeof normal === \"string\") {\n        namedPlugins.push(normal);\n      }\n    } catch (_unused2) {}\n  }\n  return namedPlugins;\n}\nfunction autoAddConfigPluginsAsync(_x, _x2, _x3) {\n  return _autoAddConfigPluginsAsync.apply(this, arguments);\n}\nfunction _autoAddConfigPluginsAsync() {\n  _autoAddConfigPluginsAsync = _asyncToGenerator(function* (projectRoot, exp, packages) {\n    debug(\"Checking config plugins...\");\n    var currentPlugins = exp.plugins || [];\n    var normalized = getNamedPlugins(currentPlugins);\n    debug(`Existing plugins: ${normalized.join(\", \")}`);\n    var plugins = packages.filter(function (pkg) {\n      if (normalized.includes(pkg)) {\n        return false;\n      }\n      var plugin = packageHasConfigPlugin(projectRoot, pkg);\n      debug(`Package \"${pkg}\" has plugin: ${!!plugin}` + (plugin ? ` (args: ${plugin.length})` : \"\"));\n      if (AUTO_PLUGINS.includes(pkg)) {\n        debug(`Package \"${pkg}\" is an auto plugin, skipping...`);\n        return false;\n      }\n      return !!plugin;\n    });\n    yield (0, _modifyConfigPlugins).attemptAddingPluginsAsync(projectRoot, exp, plugins);\n  });\n  return _autoAddConfigPluginsAsync.apply(this, arguments);\n}","map":{"version":3,"names":["_asyncToGenerator","require","_slicedToArray","getNamedPlugins","autoAddConfigPluginsAsync","_pluginResolver","_prebuildConfig","_modifyConfigPlugins","debug","AUTO_PLUGINS","getAutoPlugins","packageHasConfigPlugin","projectRoot","packageName","info","resolveConfigPluginFunctionWithInfo","isPluginFile","plugin","_unused","plugins","namedPlugins","_normalizeStaticPlugi","normalizeStaticPlugin","_normalizeStaticPlugi2","normal","push","_unused2","_x","_x2","_x3","_autoAddConfigPluginsAsync","apply","arguments","exp","packages","currentPlugins","normalized","join","filter","pkg","includes","length","attemptAddingPluginsAsync"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\cli\\src\\install\\utils\\autoAddConfigPlugins.ts"],"sourcesContent":["import { ExpoConfig } from '@expo/config';\nimport {\n  normalizeStaticPlugin,\n  resolveConfigPluginFunctionWithInfo,\n} from '@expo/config-plugins/build/utils/plugin-resolver';\nimport { getAutoPlugins } from '@expo/prebuild-config';\n\nimport { attemptAddingPluginsAsync } from '../../utils/modifyConfigPlugins';\n\nconst debug = require('debug')('expo:install:config-plugins') as typeof console.log;\n\nconst AUTO_PLUGINS = getAutoPlugins();\n\n/**\n * Resolve if a package has a config plugin.\n * For sanity, we'll only support config plugins that use the `app.config.js` entry file,\n * this is because a package like `lodash` could be a \"valid\" config plugin and break the prebuild process.\n *\n * @param projectRoot\n * @param packageName\n * @returns\n */\nfunction packageHasConfigPlugin(projectRoot: string, packageName: string) {\n  try {\n    const info = resolveConfigPluginFunctionWithInfo(projectRoot, packageName);\n    if (info.isPluginFile) {\n      return info.plugin;\n    }\n  } catch {}\n  return false;\n}\n\n/**\n * Get a list of plugins that were are supplied as string module IDs.\n * @example\n * ```json\n * {\n *   \"plugins\": [\n *     \"expo-camera\",\n *     [\"react-native-firebase\", ...]\n *   ]\n * }\n * ```\n *   ↓ ↓ ↓ ↓ ↓ ↓\n *\n * `['expo-camera', 'react-native-firebase']`\n *\n */\nexport function getNamedPlugins(plugins: NonNullable<ExpoConfig['plugins']>): string[] {\n  const namedPlugins: string[] = [];\n  for (const plugin of plugins) {\n    try {\n      // @ts-ignore\n      const [normal] = normalizeStaticPlugin(plugin);\n      if (typeof normal === 'string') {\n        namedPlugins.push(normal);\n      }\n    } catch {\n      // ignore assertions\n    }\n  }\n  return namedPlugins;\n}\n\n/** Attempts to ensure that non-auto plugins are added to the `app.json` `plugins` array when modules with Expo Config Plugins are installed. */\nexport async function autoAddConfigPluginsAsync(\n  projectRoot: string,\n  exp: Pick<ExpoConfig, 'plugins'>,\n  packages: string[]\n) {\n  debug('Checking config plugins...');\n\n  const currentPlugins = exp.plugins || [];\n  const normalized = getNamedPlugins(currentPlugins);\n\n  debug(`Existing plugins: ${normalized.join(', ')}`);\n\n  const plugins = packages.filter((pkg) => {\n    if (normalized.includes(pkg)) {\n      // already included in plugins array\n      return false;\n    }\n    // Check if the package has a valid plugin. Must be a well-made plugin for it to work with this.\n    const plugin = packageHasConfigPlugin(projectRoot, pkg);\n\n    debug(`Package \"${pkg}\" has plugin: ${!!plugin}` + (plugin ? ` (args: ${plugin.length})` : ''));\n\n    if (AUTO_PLUGINS.includes(pkg)) {\n      debug(`Package \"${pkg}\" is an auto plugin, skipping...`);\n      return false;\n    }\n\n    return !!plugin;\n  });\n\n  await attemptAddingPluginsAsync(projectRoot, exp, plugins);\n}\n"],"mappings":"AAAA;;AAAA,IAAAA,iBAAA,GAAAC,OAAA;AAAA,IAAAC,cAAA,GAAAD,OAAA;;;;QAgDgBE,eAAe,GAAfA,eAAe;QAiBTC,yBAAyB,GAAzBA,yBAAyB;AA7DxC,IAAAC,eAAkD,GAAAJ,OAAA,CAAlD,kDAAkD;AAC1B,IAAAK,eAAuB,GAAAL,OAAA,CAAvB,uBAAuB;AAEZ,IAAAM,oBAAiC,GAAAN,OAAA;AAE3E,IAAMO,KAAK,GAAGP,OAAO,CAAC,OAAO,CAAC,CAAC,6BAA6B,CAAC;AAE7D,IAAMQ,YAAY,GAAG,IAAAH,eAAc,EAAEI,cAAF,EAAE;AAWrC,SAASC,sBAAsBA,CAACC,WAAmB,EAAEC,WAAmB,EAAE;EACxE,IAAI;IACF,IAAMC,IAAI,GAAG,IAAAT,eAAmC,EAA0BU,mCAA1B,CAACH,WAAW,EAAEC,WAAW,CAAC;IAC1E,IAAIC,IAAI,CAACE,YAAY,EAAE;MACrB,OAAOF,IAAI,CAACG,MAAM;;GAErB,CAAC,OAAAC,OAAA,EAAM;EACR,OAAO,KAAK;;AAmBP,SAASf,eAAeA,CAACgB,OAA2C,EAAY;EACrF,IAAMC,YAAY,GAAa,EAAE;EACjC,KAAK,IAAMH,MAAM,IAAIE,OAAO,EAAE;IAC5B,IAAI;MAEF,IAAAE,qBAAA,GAAiB,IAAAhB,eAAqB,EAAQiB,qBAAR,CAACL,MAAM,CAAC;QAAAM,sBAAA,GAAArB,cAAA,CAAAmB,qBAAA;QAAvCG,MAAM,GAAAD,sBAAA;MACb,IAAI,OAAOC,MAAM,KAAK,QAAQ,EAAE;QAC9BJ,YAAY,CAACK,IAAI,CAACD,MAAM,CAAC;;KAE5B,CAAC,OAAAE,QAAA,EAAM,C;;EAIV,OAAON,YAAY;;AACpB,SAGqBhB,yBAAyBA,CAAAuB,EAAA,EAAAC,GAAA,EAAAC,GAAA;EAAA,OAAAC,0BAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAF,2BAAA;EAAAA,0BAAA,GAAA9B,iBAAA,CAAxC,WACLY,WAAmB,EACnBqB,GAAgC,EAChCC,QAAkB,EAClB;IACA1B,KAAK,CAAC,4BAA4B,CAAC;IAEnC,IAAM2B,cAAc,GAAGF,GAAG,CAACd,OAAO,IAAI,EAAE;IACxC,IAAMiB,UAAU,GAAGjC,eAAe,CAACgC,cAAc,CAAC;IAElD3B,KAAK,CAAE,qBAAoB4B,UAAU,CAACC,IAAI,CAAC,IAAI,CAAE,EAAC,CAAC;IAEnD,IAAMlB,OAAO,GAAGe,QAAQ,CAACI,MAAM,CAAC,UAACC,GAAG,EAAK;MACvC,IAAIH,UAAU,CAACI,QAAQ,CAACD,GAAG,CAAC,EAAE;QAE5B,OAAO,KAAK;;MAGd,IAAMtB,MAAM,GAAGN,sBAAsB,CAACC,WAAW,EAAE2B,GAAG,CAAC;MAEvD/B,KAAK,CAAE,YAAW+B,GAAI,iBAAgB,CAAC,CAACtB,MAAO,EAAC,IAAIA,MAAM,GAAI,WAAUA,MAAM,CAACwB,MAAO,GAAE,GAAG,EAAE,CAAC,CAAC;MAE/F,IAAIhC,YAAY,CAAC+B,QAAQ,CAACD,GAAG,CAAC,EAAE;QAC9B/B,KAAK,CAAE,YAAW+B,GAAI,kCAAiC,CAAC;QACxD,OAAO,KAAK;;MAGd,OAAO,CAAC,CAACtB,MAAM;KAChB,CAAC;IAEF,MAAM,IAAAV,oBAAyB,EAA2BmC,yBAA3B,CAAC9B,WAAW,EAAEqB,GAAG,EAAEd,OAAO,CAAC;GAC3D;EAAA,OAAAW,0BAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}