{"ast":null,"code":"export {};","map":{"version":3,"names":[],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\expo-asset\\src\\PlatformUtils.ts"],"sourcesContent":["import computeMd5 from 'blueimp-md5';\nimport Constants from 'expo-constants';\nimport { Manifest } from 'expo-constants/build/Constants.types';\nimport * as FileSystem from 'expo-file-system';\nimport { NativeModulesProxy } from 'expo-modules-core';\n\nimport { getManifestBaseUrl } from './AssetUris';\n\n// Constants.appOwnership is only available in managed apps (Expo client and standalone)\nexport const IS_MANAGED_ENV = !!Constants.appOwnership;\n\n// In the future (SDK38+) expo-updates is likely to be used in managed apps, so we decide\n// that you are in a bare app with updates if you're not in a managed app and you have\n// local assets available.\nexport const IS_BARE_ENV_WITH_UPDATES =\n  !IS_MANAGED_ENV &&\n  !!NativeModulesProxy.ExpoUpdates?.isEnabled &&\n  // if expo-updates is installed but we're running directly from the embedded bundle, we don't want\n  // to override the AssetSourceResolver\n  !NativeModulesProxy.ExpoUpdates?.isUsingEmbeddedAssets;\n\nexport const IS_ENV_WITH_UPDATES_ENABLED = IS_MANAGED_ENV || IS_BARE_ENV_WITH_UPDATES;\n\n// If it's not managed or bare w/ updates, then it must be bare w/o updates!\nexport const IS_BARE_ENV_WITHOUT_UPDATES = !IS_MANAGED_ENV && !IS_BARE_ENV_WITH_UPDATES;\n\n// Get the localAssets property from the ExpoUpdates native module so that we do\n// not need to include expo-updates as a dependency of expo-asset\nexport function getLocalAssets() {\n  return NativeModulesProxy.ExpoUpdates?.localAssets ?? {};\n}\n\nexport function getManifest(): { [key: string]: any } {\n  return Constants.__unsafeNoWarnManifest ?? {};\n}\n\nexport function getManifest2(): Manifest | undefined {\n  return Constants.__unsafeNoWarnManifest2;\n}\n\n// Compute manifest base URL if available\nexport const manifestBaseUrl = Constants.experienceUrl\n  ? getManifestBaseUrl(Constants.experienceUrl)\n  : null;\n\n// TODO: how should this behave in bare app with updates? re: hashAssetFiles\nexport async function downloadAsync(uri, hash, type, name): Promise<string> {\n  if (IS_MANAGED_ENV) {\n    return _downloadAsyncManagedEnv(uri, hash, type, name);\n  }\n\n  return _downloadAsyncUnmanagedEnv(uri, hash, type);\n}\n\n/**\n * Check if the file exists on disk already, perform integrity check if so.\n * Otherwise, download it.\n */\nasync function _downloadAsyncManagedEnv(uri, hash, type, name): Promise<string> {\n  const cacheFileId = hash || computeMd5(uri);\n  const localUri = `${FileSystem.cacheDirectory}ExponentAsset-${cacheFileId}.${type}`;\n  const fileInfo = await FileSystem.getInfoAsync(localUri, {\n    md5: true,\n  });\n  if (!fileInfo.exists || (hash !== null && fileInfo.md5 !== hash)) {\n    const { md5 } = await FileSystem.downloadAsync(uri, localUri, {\n      md5: true,\n    });\n    if (hash !== null && md5 !== hash) {\n      throw new Error(\n        `Downloaded file for asset '${name}.${type}' ` +\n          `Located at ${uri} ` +\n          `failed MD5 integrity check`\n      );\n    }\n  }\n  return localUri;\n}\n\n/**\n * Just download the asset, don't perform integrity check because we don't have\n * the hash to compare it with (we don't have hashAssetFiles plugin). Hash is\n * only used for the file name.\n */\nasync function _downloadAsyncUnmanagedEnv(uri, hash, type): Promise<string> {\n  // TODO: does this make sense to bail out if it's already at a file URL\n  // because it's already available locally?\n  if (uri.startsWith('file://')) {\n    return uri;\n  }\n\n  const cacheFileId = hash || computeMd5(uri);\n  const localUri = `${FileSystem.cacheDirectory}ExponentAsset-${cacheFileId}.${type}`;\n\n  // We don't check the FileSystem for an existing version of the asset and we\n  // also don't perform an integrity check!\n  await FileSystem.downloadAsync(uri, localUri);\n  return localUri;\n}\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}