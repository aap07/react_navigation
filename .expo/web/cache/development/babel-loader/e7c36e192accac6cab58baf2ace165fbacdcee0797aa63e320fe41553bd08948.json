{"ast":null,"code":"import { resolveBlockScalar } from \"../compose/resolve-block-scalar.js\";\nimport { resolveFlowScalar } from \"../compose/resolve-flow-scalar.js\";\nimport { YAMLParseError } from \"../errors.js\";\nimport { stringifyString } from \"../stringify/stringifyString.js\";\nfunction resolveAsScalar(token) {\n  var strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var onError = arguments.length > 2 ? arguments[2] : undefined;\n  if (token) {\n    var _onError = function _onError(pos, code, message) {\n      var offset = typeof pos === 'number' ? pos : Array.isArray(pos) ? pos[0] : pos.offset;\n      if (onError) onError(offset, code, message);else throw new YAMLParseError([offset, offset + 1], code, message);\n    };\n    switch (token.type) {\n      case 'scalar':\n      case 'single-quoted-scalar':\n      case 'double-quoted-scalar':\n        return resolveFlowScalar(token, strict, _onError);\n      case 'block-scalar':\n        return resolveBlockScalar(token, strict, _onError);\n    }\n  }\n  return null;\n}\nfunction createScalarToken(value, context) {\n  var _context$end;\n  var _context$implicitKey = context.implicitKey,\n    implicitKey = _context$implicitKey === void 0 ? false : _context$implicitKey,\n    indent = context.indent,\n    _context$inFlow = context.inFlow,\n    inFlow = _context$inFlow === void 0 ? false : _context$inFlow,\n    _context$offset = context.offset,\n    offset = _context$offset === void 0 ? -1 : _context$offset,\n    _context$type = context.type,\n    type = _context$type === void 0 ? 'PLAIN' : _context$type;\n  var source = stringifyString({\n    type: type,\n    value: value\n  }, {\n    implicitKey: implicitKey,\n    indent: indent > 0 ? ' '.repeat(indent) : '',\n    inFlow: inFlow,\n    options: {\n      blockQuote: true,\n      lineWidth: -1\n    }\n  });\n  var end = (_context$end = context.end) != null ? _context$end : [{\n    type: 'newline',\n    offset: -1,\n    indent: indent,\n    source: '\\n'\n  }];\n  switch (source[0]) {\n    case '|':\n    case '>':\n      {\n        var he = source.indexOf('\\n');\n        var head = source.substring(0, he);\n        var body = source.substring(he + 1) + '\\n';\n        var props = [{\n          type: 'block-scalar-header',\n          offset: offset,\n          indent: indent,\n          source: head\n        }];\n        if (!addEndtoBlockProps(props, end)) props.push({\n          type: 'newline',\n          offset: -1,\n          indent: indent,\n          source: '\\n'\n        });\n        return {\n          type: 'block-scalar',\n          offset: offset,\n          indent: indent,\n          props: props,\n          source: body\n        };\n      }\n    case '\"':\n      return {\n        type: 'double-quoted-scalar',\n        offset: offset,\n        indent: indent,\n        source: source,\n        end: end\n      };\n    case \"'\":\n      return {\n        type: 'single-quoted-scalar',\n        offset: offset,\n        indent: indent,\n        source: source,\n        end: end\n      };\n    default:\n      return {\n        type: 'scalar',\n        offset: offset,\n        indent: indent,\n        source: source,\n        end: end\n      };\n  }\n}\nfunction setScalarValue(token, value) {\n  var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _context$afterKey = context.afterKey,\n    afterKey = _context$afterKey === void 0 ? false : _context$afterKey,\n    _context$implicitKey2 = context.implicitKey,\n    implicitKey = _context$implicitKey2 === void 0 ? false : _context$implicitKey2,\n    _context$inFlow2 = context.inFlow,\n    inFlow = _context$inFlow2 === void 0 ? false : _context$inFlow2,\n    type = context.type;\n  var indent = 'indent' in token ? token.indent : null;\n  if (afterKey && typeof indent === 'number') indent += 2;\n  if (!type) switch (token.type) {\n    case 'single-quoted-scalar':\n      type = 'QUOTE_SINGLE';\n      break;\n    case 'double-quoted-scalar':\n      type = 'QUOTE_DOUBLE';\n      break;\n    case 'block-scalar':\n      {\n        var header = token.props[0];\n        if (header.type !== 'block-scalar-header') throw new Error('Invalid block scalar header');\n        type = header.source[0] === '>' ? 'BLOCK_FOLDED' : 'BLOCK_LITERAL';\n        break;\n      }\n    default:\n      type = 'PLAIN';\n  }\n  var source = stringifyString({\n    type: type,\n    value: value\n  }, {\n    implicitKey: implicitKey || indent === null,\n    indent: indent !== null && indent > 0 ? ' '.repeat(indent) : '',\n    inFlow: inFlow,\n    options: {\n      blockQuote: true,\n      lineWidth: -1\n    }\n  });\n  switch (source[0]) {\n    case '|':\n    case '>':\n      setBlockScalarValue(token, source);\n      break;\n    case '\"':\n      setFlowScalarValue(token, source, 'double-quoted-scalar');\n      break;\n    case \"'\":\n      setFlowScalarValue(token, source, 'single-quoted-scalar');\n      break;\n    default:\n      setFlowScalarValue(token, source, 'scalar');\n  }\n}\nfunction setBlockScalarValue(token, source) {\n  var he = source.indexOf('\\n');\n  var head = source.substring(0, he);\n  var body = source.substring(he + 1) + '\\n';\n  if (token.type === 'block-scalar') {\n    var header = token.props[0];\n    if (header.type !== 'block-scalar-header') throw new Error('Invalid block scalar header');\n    header.source = head;\n    token.source = body;\n  } else {\n    var offset = token.offset;\n    var indent = 'indent' in token ? token.indent : -1;\n    var props = [{\n      type: 'block-scalar-header',\n      offset: offset,\n      indent: indent,\n      source: head\n    }];\n    if (!addEndtoBlockProps(props, 'end' in token ? token.end : undefined)) props.push({\n      type: 'newline',\n      offset: -1,\n      indent: indent,\n      source: '\\n'\n    });\n    for (var key of Object.keys(token)) if (key !== 'type' && key !== 'offset') delete token[key];\n    Object.assign(token, {\n      type: 'block-scalar',\n      indent: indent,\n      props: props,\n      source: body\n    });\n  }\n}\nfunction addEndtoBlockProps(props, end) {\n  if (end) for (var st of end) switch (st.type) {\n    case 'space':\n    case 'comment':\n      props.push(st);\n      break;\n    case 'newline':\n      props.push(st);\n      return true;\n  }\n  return false;\n}\nfunction setFlowScalarValue(token, source, type) {\n  switch (token.type) {\n    case 'scalar':\n    case 'double-quoted-scalar':\n    case 'single-quoted-scalar':\n      token.type = type;\n      token.source = source;\n      break;\n    case 'block-scalar':\n      {\n        var end = token.props.slice(1);\n        var oa = source.length;\n        if (token.props[0].type === 'block-scalar-header') oa -= token.props[0].source.length;\n        for (var tok of end) tok.offset += oa;\n        delete token.props;\n        Object.assign(token, {\n          type: type,\n          source: source,\n          end: end\n        });\n        break;\n      }\n    case 'block-map':\n    case 'block-seq':\n      {\n        var offset = token.offset + source.length;\n        var nl = {\n          type: 'newline',\n          offset: offset,\n          indent: token.indent,\n          source: '\\n'\n        };\n        delete token.items;\n        Object.assign(token, {\n          type: type,\n          source: source,\n          end: [nl]\n        });\n        break;\n      }\n    default:\n      {\n        var indent = 'indent' in token ? token.indent : -1;\n        var _end = 'end' in token && Array.isArray(token.end) ? token.end.filter(function (st) {\n          return st.type === 'space' || st.type === 'comment' || st.type === 'newline';\n        }) : [];\n        for (var key of Object.keys(token)) if (key !== 'type' && key !== 'offset') delete token[key];\n        Object.assign(token, {\n          type: type,\n          indent: indent,\n          source: source,\n          end: _end\n        });\n      }\n  }\n}\nexport { createScalarToken, resolveAsScalar, setScalarValue };","map":{"version":3,"names":["resolveBlockScalar","resolveFlowScalar","YAMLParseError","stringifyString","resolveAsScalar","token","strict","arguments","length","undefined","onError","_onError","pos","code","message","offset","Array","isArray","type","createScalarToken","value","context","_context$end","_context$implicitKey","implicitKey","indent","_context$inFlow","inFlow","_context$offset","_context$type","source","repeat","options","blockQuote","lineWidth","end","he","indexOf","head","substring","body","props","addEndtoBlockProps","push","setScalarValue","_context$afterKey","afterKey","_context$implicitKey2","_context$inFlow2","header","Error","setBlockScalarValue","setFlowScalarValue","key","Object","keys","assign","st","slice","oa","tok","nl","items","filter"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native-community/cli-doctor/node_modules/yaml/browser/dist/parse/cst-scalar.js"],"sourcesContent":["import { resolveBlockScalar } from '../compose/resolve-block-scalar.js';\nimport { resolveFlowScalar } from '../compose/resolve-flow-scalar.js';\nimport { YAMLParseError } from '../errors.js';\nimport { stringifyString } from '../stringify/stringifyString.js';\n\nfunction resolveAsScalar(token, strict = true, onError) {\n    if (token) {\n        const _onError = (pos, code, message) => {\n            const offset = typeof pos === 'number' ? pos : Array.isArray(pos) ? pos[0] : pos.offset;\n            if (onError)\n                onError(offset, code, message);\n            else\n                throw new YAMLParseError([offset, offset + 1], code, message);\n        };\n        switch (token.type) {\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return resolveFlowScalar(token, strict, _onError);\n            case 'block-scalar':\n                return resolveBlockScalar(token, strict, _onError);\n        }\n    }\n    return null;\n}\n/**\n * Create a new scalar token with `value`\n *\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\n * as this function does not support any schema operations and won't check for such conflicts.\n *\n * @param value The string representation of the value, which will have its content properly indented.\n * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\n * @param context.indent The indent level of the token.\n * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.\n * @param context.offset The offset position of the token.\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\n */\nfunction createScalarToken(value, context) {\n    const { implicitKey = false, indent, inFlow = false, offset = -1, type = 'PLAIN' } = context;\n    const source = stringifyString({ type, value }, {\n        implicitKey,\n        indent: indent > 0 ? ' '.repeat(indent) : '',\n        inFlow,\n        options: { blockQuote: true, lineWidth: -1 }\n    });\n    const end = context.end ?? [\n        { type: 'newline', offset: -1, indent, source: '\\n' }\n    ];\n    switch (source[0]) {\n        case '|':\n        case '>': {\n            const he = source.indexOf('\\n');\n            const head = source.substring(0, he);\n            const body = source.substring(he + 1) + '\\n';\n            const props = [\n                { type: 'block-scalar-header', offset, indent, source: head }\n            ];\n            if (!addEndtoBlockProps(props, end))\n                props.push({ type: 'newline', offset: -1, indent, source: '\\n' });\n            return { type: 'block-scalar', offset, indent, props, source: body };\n        }\n        case '\"':\n            return { type: 'double-quoted-scalar', offset, indent, source, end };\n        case \"'\":\n            return { type: 'single-quoted-scalar', offset, indent, source, end };\n        default:\n            return { type: 'scalar', offset, indent, source, end };\n    }\n}\n/**\n * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.\n *\n * Best efforts are made to retain any comments previously associated with the `token`,\n * though all contents within a collection's `items` will be overwritten.\n *\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\n * as this function does not support any schema operations and won't check for such conflicts.\n *\n * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.\n * @param value The string representation of the value, which will have its content properly indented.\n * @param context.afterKey In most cases, values after a key should have an additional level of indentation.\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\n * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\n */\nfunction setScalarValue(token, value, context = {}) {\n    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;\n    let indent = 'indent' in token ? token.indent : null;\n    if (afterKey && typeof indent === 'number')\n        indent += 2;\n    if (!type)\n        switch (token.type) {\n            case 'single-quoted-scalar':\n                type = 'QUOTE_SINGLE';\n                break;\n            case 'double-quoted-scalar':\n                type = 'QUOTE_DOUBLE';\n                break;\n            case 'block-scalar': {\n                const header = token.props[0];\n                if (header.type !== 'block-scalar-header')\n                    throw new Error('Invalid block scalar header');\n                type = header.source[0] === '>' ? 'BLOCK_FOLDED' : 'BLOCK_LITERAL';\n                break;\n            }\n            default:\n                type = 'PLAIN';\n        }\n    const source = stringifyString({ type, value }, {\n        implicitKey: implicitKey || indent === null,\n        indent: indent !== null && indent > 0 ? ' '.repeat(indent) : '',\n        inFlow,\n        options: { blockQuote: true, lineWidth: -1 }\n    });\n    switch (source[0]) {\n        case '|':\n        case '>':\n            setBlockScalarValue(token, source);\n            break;\n        case '\"':\n            setFlowScalarValue(token, source, 'double-quoted-scalar');\n            break;\n        case \"'\":\n            setFlowScalarValue(token, source, 'single-quoted-scalar');\n            break;\n        default:\n            setFlowScalarValue(token, source, 'scalar');\n    }\n}\nfunction setBlockScalarValue(token, source) {\n    const he = source.indexOf('\\n');\n    const head = source.substring(0, he);\n    const body = source.substring(he + 1) + '\\n';\n    if (token.type === 'block-scalar') {\n        const header = token.props[0];\n        if (header.type !== 'block-scalar-header')\n            throw new Error('Invalid block scalar header');\n        header.source = head;\n        token.source = body;\n    }\n    else {\n        const { offset } = token;\n        const indent = 'indent' in token ? token.indent : -1;\n        const props = [\n            { type: 'block-scalar-header', offset, indent, source: head }\n        ];\n        if (!addEndtoBlockProps(props, 'end' in token ? token.end : undefined))\n            props.push({ type: 'newline', offset: -1, indent, source: '\\n' });\n        for (const key of Object.keys(token))\n            if (key !== 'type' && key !== 'offset')\n                delete token[key];\n        Object.assign(token, { type: 'block-scalar', indent, props, source: body });\n    }\n}\n/** @returns `true` if last token is a newline */\nfunction addEndtoBlockProps(props, end) {\n    if (end)\n        for (const st of end)\n            switch (st.type) {\n                case 'space':\n                case 'comment':\n                    props.push(st);\n                    break;\n                case 'newline':\n                    props.push(st);\n                    return true;\n            }\n    return false;\n}\nfunction setFlowScalarValue(token, source, type) {\n    switch (token.type) {\n        case 'scalar':\n        case 'double-quoted-scalar':\n        case 'single-quoted-scalar':\n            token.type = type;\n            token.source = source;\n            break;\n        case 'block-scalar': {\n            const end = token.props.slice(1);\n            let oa = source.length;\n            if (token.props[0].type === 'block-scalar-header')\n                oa -= token.props[0].source.length;\n            for (const tok of end)\n                tok.offset += oa;\n            delete token.props;\n            Object.assign(token, { type, source, end });\n            break;\n        }\n        case 'block-map':\n        case 'block-seq': {\n            const offset = token.offset + source.length;\n            const nl = { type: 'newline', offset, indent: token.indent, source: '\\n' };\n            delete token.items;\n            Object.assign(token, { type, source, end: [nl] });\n            break;\n        }\n        default: {\n            const indent = 'indent' in token ? token.indent : -1;\n            const end = 'end' in token && Array.isArray(token.end)\n                ? token.end.filter(st => st.type === 'space' ||\n                    st.type === 'comment' ||\n                    st.type === 'newline')\n                : [];\n            for (const key of Object.keys(token))\n                if (key !== 'type' && key !== 'offset')\n                    delete token[key];\n            Object.assign(token, { type, indent, source, end });\n        }\n    }\n}\n\nexport { createScalarToken, resolveAsScalar, setScalarValue };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}