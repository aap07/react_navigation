{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nvar _toArray = require(\"@babel/runtime/helpers/toArray\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveStringOrBooleanArgsAsync = resolveStringOrBooleanArgsAsync;\nexports.resolveCustomBooleanArgsAsync = resolveCustomBooleanArgsAsync;\nexports._resolveStringOrBooleanArgs = _resolveStringOrBooleanArgs;\nexports.collapseAliases = collapseAliases;\nexports.assertUnknownArgs = assertUnknownArgs;\nexports.assertDuplicateArgs = assertDuplicateArgs;\nvar _array = require(\"./array\");\nvar _errors = require(\"./errors\");\nfunction splitArgs(args) {\n  var result = [];\n  for (var arg of args) {\n    if (arg.startsWith(\"-\")) {\n      var _arg$split = arg.split(\"=\"),\n        _arg$split2 = _toArray(_arg$split),\n        key = _arg$split2[0],\n        props = _arg$split2.slice(1);\n      result.push(key);\n      if (props.length) {\n        result.push(props.join(\"=\"));\n      }\n    } else {\n      result.push(arg);\n    }\n  }\n  return result;\n}\nfunction resolveStringOrBooleanArgsAsync(_x, _x2, _x3) {\n  return _resolveStringOrBooleanArgsAsync.apply(this, arguments);\n}\nfunction _resolveStringOrBooleanArgsAsync() {\n  _resolveStringOrBooleanArgsAsync = _asyncToGenerator(function* (args, rawMap, extraArgs) {\n    args = splitArgs(args);\n    assertUnknownArgs(_objectSpread(_objectSpread({}, rawMap), extraArgs), args);\n    args = collapseAliases(extraArgs, args);\n    return _resolveStringOrBooleanArgs(_objectSpread(_objectSpread({}, rawMap), extraArgs), args);\n  });\n  return _resolveStringOrBooleanArgsAsync.apply(this, arguments);\n}\nfunction resolveCustomBooleanArgsAsync(_x4, _x5, _x6) {\n  return _resolveCustomBooleanArgsAsync.apply(this, arguments);\n}\nfunction _resolveCustomBooleanArgsAsync() {\n  _resolveCustomBooleanArgsAsync = _asyncToGenerator(function* (args, rawMap, extraArgs) {\n    var results = yield resolveStringOrBooleanArgsAsync(args, rawMap, extraArgs);\n    return _objectSpread(_objectSpread({}, results), {}, {\n      args: Object.fromEntries(Object.entries(results.args).map(function (_ref11) {\n        var _ref12 = _slicedToArray(_ref11, 2),\n          key = _ref12[0],\n          value = _ref12[1];\n        if (extraArgs[key]) {\n          if (typeof value === \"string\") {\n            if (![\"true\", \"false\"].includes(value)) {\n              throw new _errors.CommandError(\"BAD_ARGS\", `Invalid boolean argument: ${key}=${value}. Expected one of: true, false`);\n            }\n            return [key, value === \"true\"];\n          }\n        }\n        return [key, value];\n      }))\n    });\n  });\n  return _resolveCustomBooleanArgsAsync.apply(this, arguments);\n}\nfunction _resolveStringOrBooleanArgs(arg, args) {\n  var projectRoot = \".\";\n  var settings = {};\n  var possibleArgs = Object.entries(arg).filter(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      value = _ref2[1];\n    return typeof value !== \"string\";\n  }).map(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 1),\n      key = _ref4[0];\n    return key;\n  });\n  for (var i = args.length - 1; i > -1; i--) {\n    var value = args[i];\n    if (value.startsWith(\"--\")) {\n      settings[value] = true;\n    } else {\n      var nextValue = i > 0 ? args[i - 1] : null;\n      if (nextValue && possibleArgs.includes(nextValue)) {\n        settings[nextValue] = value;\n        i--;\n      } else if (i === args.length - 1) {\n        projectRoot = value;\n      } else {\n        throw new _errors.CommandError(\"BAD_ARGS\", `Unknown argument: ${value}`);\n      }\n    }\n  }\n  return {\n    args: settings,\n    projectRoot: projectRoot\n  };\n}\nfunction collapseAliases(arg, args) {\n  var aliasMap = getAliasTuples(arg);\n  for (var _ref5 of aliasMap) {\n    var _ref6 = _slicedToArray(_ref5, 2);\n    var arg1 = _ref6[0];\n    var alias = _ref6[1];\n    args = (0, _array).replaceValue(args, arg1, alias);\n  }\n  assertDuplicateArgs(args, aliasMap);\n  return args;\n}\nfunction assertUnknownArgs(arg2, args) {\n  var allowedArgs = Object.keys(arg2);\n  var unknownArgs = args.filter(function (arg) {\n    return !allowedArgs.includes(arg) && arg.startsWith(\"-\");\n  });\n  if (unknownArgs.length > 0) {\n    throw new _errors.CommandError(`Unknown arguments: ${unknownArgs.join(\", \")}`);\n  }\n}\nfunction getAliasTuples(arg) {\n  return Object.entries(arg).filter(function (_ref7) {\n    var _ref8 = _slicedToArray(_ref7, 2),\n      value = _ref8[1];\n    return typeof value === \"string\";\n  });\n}\nfunction assertDuplicateArgs(args, argNameAliasTuple) {\n  var _loop = function _loop(argName, argNameAlias) {\n    if (args.filter(function (a) {\n      return [argName, argNameAlias].includes(a);\n    }).length > 1) {\n      throw new _errors.CommandError(\"BAD_ARGS\", `Can only provide one instance of ${argName} or ${argNameAlias}`);\n    }\n  };\n  for (var _ref9 of argNameAliasTuple) {\n    var _ref10 = _slicedToArray(_ref9, 2);\n    var argName = _ref10[0];\n    var argNameAlias = _ref10[1];\n    _loop(argName, argNameAlias);\n  }\n}","map":{"version":3,"names":["_defineProperty","require","_slicedToArray","_asyncToGenerator","_toArray","ownKeys","e","r","t","Object","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","length","forEach","getOwnPropertyDescriptors","defineProperties","defineProperty","resolveStringOrBooleanArgsAsync","resolveCustomBooleanArgsAsync","_resolveStringOrBooleanArgs","collapseAliases","assertUnknownArgs","assertDuplicateArgs","_array","_errors","splitArgs","args","result","arg","startsWith","_arg$split","split","_arg$split2","key","props","slice","join","_x","_x2","_x3","_resolveStringOrBooleanArgsAsync","rawMap","extraArgs","_x4","_x5","_x6","_resolveCustomBooleanArgsAsync","results","fromEntries","entries","map","_ref11","_ref12","value","includes","CommandError","projectRoot","settings","possibleArgs","_ref","_ref2","_ref3","_ref4","i","nextValue","aliasMap","getAliasTuples","_ref5","_ref6","arg1","alias","replaceValue","arg2","allowedArgs","unknownArgs","_ref7","_ref8","argNameAliasTuple","_loop","argName","argNameAlias","a","_ref9","_ref10"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\cli\\src\\utils\\resolveArgs.ts"],"sourcesContent":["import arg, { Spec } from 'arg';\n\nimport { replaceValue } from './array';\nimport { CommandError } from './errors';\n\n/** Split up arguments that are formatted like `--foo=bar` or `-f=\"bar\"` to `['--foo', 'bar']` */\nfunction splitArgs(args: string[]): string[] {\n  const result: string[] = [];\n\n  for (const arg of args) {\n    if (arg.startsWith('-')) {\n      const [key, ...props] = arg.split('=');\n      result.push(key);\n      if (props.length) {\n        result.push(props.join('='));\n      }\n    } else {\n      result.push(arg);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Enables the resolution of arguments that can either be a string or a boolean.\n *\n * @param args arguments that were passed to the command.\n * @param rawMap raw map of arguments that are passed to the command.\n * @param extraArgs extra arguments and aliases that should be resolved as string or boolean.\n * @returns parsed arguments and project root.\n */\nexport async function resolveStringOrBooleanArgsAsync(\n  args: string[],\n  rawMap: arg.Spec,\n  extraArgs: arg.Spec\n) {\n  args = splitArgs(args);\n\n  // Assert any missing arguments\n  assertUnknownArgs(\n    {\n      ...rawMap,\n      ...extraArgs,\n    },\n    args\n  );\n\n  // Collapse aliases into fully qualified arguments.\n  args = collapseAliases(extraArgs, args);\n\n  // Resolve all of the string or boolean arguments and the project root.\n  return _resolveStringOrBooleanArgs({ ...rawMap, ...extraArgs }, args);\n}\n\n/**\n * Enables the resolution of boolean arguments that can be formatted like `--foo=true` or `--foo false`\n *\n * @param args arguments that were passed to the command.\n * @param rawMap raw map of arguments that are passed to the command.\n * @param extraArgs extra arguments and aliases that should be resolved as string or boolean.\n * @returns parsed arguments and project root.\n */\nexport async function resolveCustomBooleanArgsAsync(\n  args: string[],\n  rawMap: arg.Spec,\n  extraArgs: arg.Spec\n) {\n  const results = await resolveStringOrBooleanArgsAsync(args, rawMap, extraArgs);\n\n  return {\n    ...results,\n    args: Object.fromEntries(\n      Object.entries(results.args).map(([key, value]) => {\n        if (extraArgs[key]) {\n          if (typeof value === 'string') {\n            if (!['true', 'false'].includes(value)) {\n              throw new CommandError(\n                'BAD_ARGS',\n                `Invalid boolean argument: ${key}=${value}. Expected one of: true, false`\n              );\n            }\n            return [key, value === 'true'];\n          }\n        }\n        return [key, value];\n      })\n    ),\n  };\n}\n\nexport function _resolveStringOrBooleanArgs(arg: Spec, args: string[]) {\n  // Default project root, if a custom one is defined then it will overwrite this.\n  let projectRoot: string = '.';\n  // The resolved arguments.\n  const settings: Record<string, string | boolean | undefined> = {};\n\n  // Create a list of possible arguments, this will filter out aliases.\n  const possibleArgs = Object.entries(arg)\n    .filter(([, value]) => typeof value !== 'string')\n    .map(([key]) => key);\n\n  // Loop over arguments in reverse order so we can resolve if a value belongs to a flag.\n  for (let i = args.length - 1; i > -1; i--) {\n    const value = args[i];\n    // At this point we should have converted all aliases to fully qualified arguments.\n    if (value.startsWith('--')) {\n      // If we ever find an argument then it must be a boolean because we are checking in reverse\n      // and removing arguments from the array if we find a string.\n      settings[value] = true;\n    } else {\n      // Get the previous argument in the array.\n      const nextValue = i > 0 ? args[i - 1] : null;\n      if (nextValue && possibleArgs.includes(nextValue)) {\n        settings[nextValue] = value;\n        i--;\n      } else if (\n        // If the last value is not a flag and it doesn't have a recognized flag before it (instead having a string value or nothing)\n        // then it must be the project root.\n        i ===\n        args.length - 1\n      ) {\n        projectRoot = value;\n      } else {\n        // This will asserts if two strings are passed in a row and not at the end of the line.\n        throw new CommandError('BAD_ARGS', `Unknown argument: ${value}`);\n      }\n    }\n  }\n\n  return {\n    args: settings,\n    projectRoot,\n  };\n}\n\n/** Convert all aliases to fully qualified flag names. */\nexport function collapseAliases(arg: Spec, args: string[]): string[] {\n  const aliasMap = getAliasTuples(arg);\n\n  for (const [arg, alias] of aliasMap) {\n    args = replaceValue(args, arg, alias);\n  }\n\n  // Assert if there are duplicate flags after we collapse the aliases.\n  assertDuplicateArgs(args, aliasMap);\n  return args;\n}\n\n/** Assert that the spec has unknown arguments. */\nexport function assertUnknownArgs(arg: Spec, args: string[]) {\n  const allowedArgs = Object.keys(arg);\n  const unknownArgs = args.filter((arg) => !allowedArgs.includes(arg) && arg.startsWith('-'));\n  if (unknownArgs.length > 0) {\n    throw new CommandError(`Unknown arguments: ${unknownArgs.join(', ')}`);\n  }\n}\n\nfunction getAliasTuples(arg: Spec): [string, string][] {\n  return Object.entries(arg).filter(([, value]) => typeof value === 'string') as [string, string][];\n}\n\n/** Asserts that a duplicate flag has been used, this naively throws without knowing if an alias or flag were used as the duplicate. */\nexport function assertDuplicateArgs(args: string[], argNameAliasTuple: [string, string][]) {\n  for (const [argName, argNameAlias] of argNameAliasTuple) {\n    if (args.filter((a) => [argName, argNameAlias].includes(a)).length > 1) {\n      throw new CommandError(\n        'BAD_ARGS',\n        `Can only provide one instance of ${argName} or ${argNameAlias}`\n      );\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}