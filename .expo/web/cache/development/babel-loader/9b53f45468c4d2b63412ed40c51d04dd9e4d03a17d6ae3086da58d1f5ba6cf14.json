{"ast":null,"code":"var _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar fs = require('fs');\nfunction extractGlyphMapFromCss(files, selectorPattern) {\n  var styleRulePattern = '(\\\\.[A-Za-z0-9_.:, \\\\n\\\\t-]+)\\\\{[^}]*content: ?[\"\\\\\\'](?:\\\\\\\\([A-Fa-f0-9]+)|([^\"\\\\\\']+))[\"\\\\\\'][^}]*\\\\}';\n  var allStyleRules = new RegExp(styleRulePattern, 'g');\n  var singleStyleRules = new RegExp(styleRulePattern);\n  var allSelectors = new RegExp(selectorPattern, 'g');\n  var singleSelector = new RegExp(selectorPattern);\n  var extractGlyphFromRule = function extractGlyphFromRule(rule) {\n    var ruleParts = rule.match(singleStyleRules);\n    if (ruleParts[2]) {\n      return parseInt(ruleParts[2], 16);\n    }\n    if (ruleParts[3].length > 1) {\n      return ruleParts[3];\n    }\n    return ruleParts[3].charCodeAt();\n  };\n  var extractSelectorsFromRule = function extractSelectorsFromRule(rule) {\n    var ruleParts = rule.match(singleStyleRules);\n    var selectors = ruleParts[1].match(allSelectors) || [];\n    return selectors.map(function (selector) {\n      return selector.match(singleSelector)[1];\n    });\n  };\n  return (typeof files === 'string' ? [files] : files).map(function (fileName) {\n    return fs.readFileSync(fileName, {\n      encoding: 'utf8'\n    });\n  }).map(function (contents) {\n    return contents.match(allStyleRules) || [];\n  }).reduce(function (acc, rules) {\n    return acc.concat(rules);\n  }, []).map(function (rule) {\n    var glyph = extractGlyphFromRule(rule);\n    var selectors = extractSelectorsFromRule(rule);\n    return selectors.map(function (selector) {\n      return [selector, glyph];\n    });\n  }).reduce(function (acc, glyphs) {\n    return Object.assign(acc, Object.fromEntries(glyphs));\n  }, {});\n}\nfunction escapeRegExp(str) {\n  return str.replace(/[-[\\]/{}()*+?.\\\\^$|]/g, '\\\\$&');\n}\nfunction generateIconSetFromCss(cssFiles, selectorPrefix, template) {\n  var data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var glyphMap = extractGlyphMapFromCss(cssFiles, `${escapeRegExp(selectorPrefix)}([A-Za-z0-9_-]+)::?before`);\n  var content = JSON.stringify(glyphMap, null, '  ');\n  if (template) {\n    var templateVariables = _objectSpread({\n      glyphMap: content\n    }, data);\n    return template.replace(/\\${([^}]*)}/g, function (_, key) {\n      return templateVariables[key];\n    });\n  }\n  return content;\n}\nmodule.exports = generateIconSetFromCss;","map":{"version":3,"names":["fs","require","extractGlyphMapFromCss","files","selectorPattern","styleRulePattern","allStyleRules","RegExp","singleStyleRules","allSelectors","singleSelector","extractGlyphFromRule","rule","ruleParts","match","parseInt","length","charCodeAt","extractSelectorsFromRule","selectors","map","selector","fileName","readFileSync","encoding","contents","reduce","acc","rules","concat","glyph","glyphs","Object","assign","fromEntries","escapeRegExp","str","replace","generateIconSetFromCss","cssFiles","selectorPrefix","template","data","arguments","undefined","glyphMap","content","JSON","stringify","templateVariables","_objectSpread","_","key","module","exports"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@expo/vector-icons/build/vendor/react-native-vector-icons/lib/generate-icon-set-from-css.js"],"sourcesContent":["const fs = require('fs');\n\nfunction extractGlyphMapFromCss(files, selectorPattern) {\n  const styleRulePattern =\n    '(\\\\.[A-Za-z0-9_.:, \\\\n\\\\t-]+)\\\\{[^}]*content: ?[\"\\\\\\'](?:\\\\\\\\([A-Fa-f0-9]+)|([^\"\\\\\\']+))[\"\\\\\\'][^}]*\\\\}';\n  const allStyleRules = new RegExp(styleRulePattern, 'g');\n  const singleStyleRules = new RegExp(styleRulePattern);\n  const allSelectors = new RegExp(selectorPattern, 'g');\n  const singleSelector = new RegExp(selectorPattern);\n\n  const extractGlyphFromRule = rule => {\n    const ruleParts = rule.match(singleStyleRules);\n    if (ruleParts[2]) {\n      // Hex value in CSS\n      return parseInt(ruleParts[2], 16);\n    }\n    if (ruleParts[3].length > 1) {\n      // String value in CSS that we'll keep as a string because it's not a single character\n      return ruleParts[3];\n    }\n    // String value in CSS that we'll convert to a charcode\n    return ruleParts[3].charCodeAt();\n  };\n\n  const extractSelectorsFromRule = rule => {\n    const ruleParts = rule.match(singleStyleRules);\n    const selectors = ruleParts[1].match(allSelectors) || [];\n    return selectors.map(selector => selector.match(singleSelector)[1]);\n  };\n\n  return (typeof files === 'string' ? [files] : files)\n    .map(fileName => fs.readFileSync(fileName, { encoding: 'utf8' }))\n    .map(contents => contents.match(allStyleRules) || [])\n    .reduce((acc, rules) => acc.concat(rules), [])\n    .map(rule => {\n      const glyph = extractGlyphFromRule(rule);\n      const selectors = extractSelectorsFromRule(rule);\n      return selectors.map(selector => [selector, glyph]);\n    })\n    .reduce(\n      (acc, glyphs) => Object.assign(acc, Object.fromEntries(glyphs)),\n      {}\n    );\n}\n\nfunction escapeRegExp(str) {\n  return str.replace(/[-[\\]/{}()*+?.\\\\^$|]/g, '\\\\$&');\n}\n\nfunction generateIconSetFromCss(cssFiles, selectorPrefix, template, data = {}) {\n  const glyphMap = extractGlyphMapFromCss(\n    cssFiles,\n    `${escapeRegExp(selectorPrefix)}([A-Za-z0-9_-]+)::?before`\n  );\n  const content = JSON.stringify(glyphMap, null, '  ');\n  if (template) {\n    const templateVariables = { glyphMap: content, ...data };\n    return template.replace(/\\${([^}]*)}/g, (_, key) => templateVariables[key]);\n  }\n  return content;\n}\n\nmodule.exports = generateIconSetFromCss;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}