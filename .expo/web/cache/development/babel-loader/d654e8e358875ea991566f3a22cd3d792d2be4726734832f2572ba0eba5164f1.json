{"ast":null,"code":"'use strict';\n\nvar Pair = require(\"../nodes/Pair.js\");\nvar YAMLMap = require(\"../nodes/YAMLMap.js\");\nvar resolveProps = require(\"./resolve-props.js\");\nvar utilContainsNewline = require(\"./util-contains-newline.js\");\nvar utilFlowIndentCheck = require(\"./util-flow-indent-check.js\");\nvar utilMapIncludes = require(\"./util-map-includes.js\");\nvar startColMsg = 'All mapping items must start at the same column';\nfunction resolveBlockMap(_ref, ctx, bm, onError, tag) {\n  var _tag$nodeClass, _commentEnd;\n  var composeNode = _ref.composeNode,\n    composeEmptyNode = _ref.composeEmptyNode;\n  var NodeClass = (_tag$nodeClass = tag == null ? void 0 : tag.nodeClass) != null ? _tag$nodeClass : YAMLMap.YAMLMap;\n  var map = new NodeClass(ctx.schema);\n  if (ctx.atRoot) ctx.atRoot = false;\n  var offset = bm.offset;\n  var commentEnd = null;\n  for (var collItem of bm.items) {\n    var _keyProps$found;\n    var start = collItem.start,\n      key = collItem.key,\n      sep = collItem.sep,\n      value = collItem.value;\n    var keyProps = resolveProps.resolveProps(start, {\n      indicator: 'explicit-key-ind',\n      next: key != null ? key : sep == null ? void 0 : sep[0],\n      offset: offset,\n      onError: onError,\n      startOnNewline: true\n    });\n    var implicitKey = !keyProps.found;\n    if (implicitKey) {\n      if (key) {\n        if (key.type === 'block-seq') onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');else if ('indent' in key && key.indent !== bm.indent) onError(offset, 'BAD_INDENT', startColMsg);\n      }\n      if (!keyProps.anchor && !keyProps.tag && !sep) {\n        commentEnd = keyProps.end;\n        if (keyProps.comment) {\n          if (map.comment) map.comment += '\\n' + keyProps.comment;else map.comment = keyProps.comment;\n        }\n        continue;\n      }\n      if (keyProps.hasNewlineAfterProp || utilContainsNewline.containsNewline(key)) {\n        onError(key != null ? key : start[start.length - 1], 'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');\n      }\n    } else if (((_keyProps$found = keyProps.found) == null ? void 0 : _keyProps$found.indent) !== bm.indent) {\n      onError(offset, 'BAD_INDENT', startColMsg);\n    }\n    var keyStart = keyProps.end;\n    var keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);\n    if (ctx.schema.compat) utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);\n    if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode)) onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\n    var valueProps = resolveProps.resolveProps(sep != null ? sep : [], {\n      indicator: 'map-value-ind',\n      next: value,\n      offset: keyNode.range[2],\n      onError: onError,\n      startOnNewline: !key || key.type === 'block-scalar'\n    });\n    offset = valueProps.end;\n    if (valueProps.found) {\n      if (implicitKey) {\n        if ((value == null ? void 0 : value.type) === 'block-map' && !valueProps.hasNewline) onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');\n        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024) onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');\n      }\n      var valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);\n      if (ctx.schema.compat) utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);\n      offset = valueNode.range[2];\n      var pair = new Pair.Pair(keyNode, valueNode);\n      if (ctx.options.keepSourceTokens) pair.srcToken = collItem;\n      map.items.push(pair);\n    } else {\n      if (implicitKey) onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');\n      if (valueProps.comment) {\n        if (keyNode.comment) keyNode.comment += '\\n' + valueProps.comment;else keyNode.comment = valueProps.comment;\n      }\n      var _pair = new Pair.Pair(keyNode);\n      if (ctx.options.keepSourceTokens) _pair.srcToken = collItem;\n      map.items.push(_pair);\n    }\n  }\n  if (commentEnd && commentEnd < offset) onError(commentEnd, 'IMPOSSIBLE', 'Map comment with trailing content');\n  map.range = [bm.offset, offset, (_commentEnd = commentEnd) != null ? _commentEnd : offset];\n  return map;\n}\nexports.resolveBlockMap = resolveBlockMap;","map":{"version":3,"names":["Pair","require","YAMLMap","resolveProps","utilContainsNewline","utilFlowIndentCheck","utilMapIncludes","startColMsg","resolveBlockMap","_ref","ctx","bm","onError","tag","_tag$nodeClass","_commentEnd","composeNode","composeEmptyNode","NodeClass","nodeClass","map","schema","atRoot","offset","commentEnd","collItem","items","_keyProps$found","start","key","sep","value","keyProps","indicator","next","startOnNewline","implicitKey","found","type","indent","anchor","end","comment","hasNewlineAfterProp","containsNewline","length","keyStart","keyNode","compat","flowIndentCheck","mapIncludes","valueProps","range","hasNewline","options","strict","valueNode","pair","keepSourceTokens","srcToken","push","exports"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native-community/cli-doctor/node_modules/yaml/dist/compose/resolve-block-map.js"],"sourcesContent":["'use strict';\n\nvar Pair = require('../nodes/Pair.js');\nvar YAMLMap = require('../nodes/YAMLMap.js');\nvar resolveProps = require('./resolve-props.js');\nvar utilContainsNewline = require('./util-contains-newline.js');\nvar utilFlowIndentCheck = require('./util-flow-indent-check.js');\nvar utilMapIncludes = require('./util-map-includes.js');\n\nconst startColMsg = 'All mapping items must start at the same column';\nfunction resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {\n    const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;\n    const map = new NodeClass(ctx.schema);\n    if (ctx.atRoot)\n        ctx.atRoot = false;\n    let offset = bm.offset;\n    let commentEnd = null;\n    for (const collItem of bm.items) {\n        const { start, key, sep, value } = collItem;\n        // key properties\n        const keyProps = resolveProps.resolveProps(start, {\n            indicator: 'explicit-key-ind',\n            next: key ?? sep?.[0],\n            offset,\n            onError,\n            startOnNewline: true\n        });\n        const implicitKey = !keyProps.found;\n        if (implicitKey) {\n            if (key) {\n                if (key.type === 'block-seq')\n                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');\n                else if ('indent' in key && key.indent !== bm.indent)\n                    onError(offset, 'BAD_INDENT', startColMsg);\n            }\n            if (!keyProps.anchor && !keyProps.tag && !sep) {\n                commentEnd = keyProps.end;\n                if (keyProps.comment) {\n                    if (map.comment)\n                        map.comment += '\\n' + keyProps.comment;\n                    else\n                        map.comment = keyProps.comment;\n                }\n                continue;\n            }\n            if (keyProps.hasNewlineAfterProp || utilContainsNewline.containsNewline(key)) {\n                onError(key ?? start[start.length - 1], 'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');\n            }\n        }\n        else if (keyProps.found?.indent !== bm.indent) {\n            onError(offset, 'BAD_INDENT', startColMsg);\n        }\n        // key value\n        const keyStart = keyProps.end;\n        const keyNode = key\n            ? composeNode(ctx, key, keyProps, onError)\n            : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);\n        if (ctx.schema.compat)\n            utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);\n        if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))\n            onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\n        // value properties\n        const valueProps = resolveProps.resolveProps(sep ?? [], {\n            indicator: 'map-value-ind',\n            next: value,\n            offset: keyNode.range[2],\n            onError,\n            startOnNewline: !key || key.type === 'block-scalar'\n        });\n        offset = valueProps.end;\n        if (valueProps.found) {\n            if (implicitKey) {\n                if (value?.type === 'block-map' && !valueProps.hasNewline)\n                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');\n                if (ctx.options.strict &&\n                    keyProps.start < valueProps.found.offset - 1024)\n                    onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');\n            }\n            // value value\n            const valueNode = value\n                ? composeNode(ctx, value, valueProps, onError)\n                : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);\n            if (ctx.schema.compat)\n                utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);\n            offset = valueNode.range[2];\n            const pair = new Pair.Pair(keyNode, valueNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            map.items.push(pair);\n        }\n        else {\n            // key with no value\n            if (implicitKey)\n                onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');\n            if (valueProps.comment) {\n                if (keyNode.comment)\n                    keyNode.comment += '\\n' + valueProps.comment;\n                else\n                    keyNode.comment = valueProps.comment;\n            }\n            const pair = new Pair.Pair(keyNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            map.items.push(pair);\n        }\n    }\n    if (commentEnd && commentEnd < offset)\n        onError(commentEnd, 'IMPOSSIBLE', 'Map comment with trailing content');\n    map.range = [bm.offset, offset, commentEnd ?? offset];\n    return map;\n}\n\nexports.resolveBlockMap = resolveBlockMap;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}