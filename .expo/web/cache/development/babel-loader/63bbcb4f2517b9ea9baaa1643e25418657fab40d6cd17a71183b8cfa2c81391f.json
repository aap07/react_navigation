{"ast":null,"code":"import { Scalar } from \"../nodes/Scalar.js\";\nimport { foldFlowLines, FOLD_QUOTED, FOLD_FLOW, FOLD_BLOCK } from \"./foldFlowLines.js\";\nvar getFoldOptions = function getFoldOptions(ctx, isBlock) {\n  return {\n    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,\n    lineWidth: ctx.options.lineWidth,\n    minContentWidth: ctx.options.minContentWidth\n  };\n};\nvar containsDocumentMarker = function containsDocumentMarker(str) {\n  return /^(%|---|\\.\\.\\.)/m.test(str);\n};\nfunction lineLengthOverLimit(str, lineWidth, indentLength) {\n  if (!lineWidth || lineWidth < 0) return false;\n  var limit = lineWidth - indentLength;\n  var strLen = str.length;\n  if (strLen <= limit) return false;\n  for (var i = 0, start = 0; i < strLen; ++i) {\n    if (str[i] === '\\n') {\n      if (i - start > limit) return true;\n      start = i + 1;\n      if (strLen - start <= limit) return false;\n    }\n  }\n  return true;\n}\nfunction doubleQuotedString(value, ctx) {\n  var json = JSON.stringify(value);\n  if (ctx.options.doubleQuotedAsJSON) return json;\n  var implicitKey = ctx.implicitKey;\n  var minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;\n  var indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  var str = '';\n  var start = 0;\n  for (var i = 0, ch = json[i]; ch; ch = json[++i]) {\n    if (ch === ' ' && json[i + 1] === '\\\\' && json[i + 2] === 'n') {\n      str += json.slice(start, i) + '\\\\ ';\n      i += 1;\n      start = i;\n      ch = '\\\\';\n    }\n    if (ch === '\\\\') switch (json[i + 1]) {\n      case 'u':\n        {\n          str += json.slice(start, i);\n          var code = json.substr(i + 2, 4);\n          switch (code) {\n            case '0000':\n              str += '\\\\0';\n              break;\n            case '0007':\n              str += '\\\\a';\n              break;\n            case '000b':\n              str += '\\\\v';\n              break;\n            case '001b':\n              str += '\\\\e';\n              break;\n            case '0085':\n              str += '\\\\N';\n              break;\n            case '00a0':\n              str += '\\\\_';\n              break;\n            case '2028':\n              str += '\\\\L';\n              break;\n            case '2029':\n              str += '\\\\P';\n              break;\n            default:\n              if (code.substr(0, 2) === '00') str += '\\\\x' + code.substr(2);else str += json.substr(i, 6);\n          }\n          i += 5;\n          start = i + 1;\n        }\n        break;\n      case 'n':\n        if (implicitKey || json[i + 2] === '\"' || json.length < minMultiLineLength) {\n          i += 1;\n        } else {\n          str += json.slice(start, i) + '\\n\\n';\n          while (json[i + 2] === '\\\\' && json[i + 3] === 'n' && json[i + 4] !== '\"') {\n            str += '\\n';\n            i += 2;\n          }\n          str += indent;\n          if (json[i + 2] === ' ') str += '\\\\';\n          i += 1;\n          start = i + 1;\n        }\n        break;\n      default:\n        i += 1;\n    }\n  }\n  str = start ? str + json.slice(start) : json;\n  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));\n}\nfunction singleQuotedString(value, ctx) {\n  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes('\\n') || /[ \\t]\\n|\\n[ \\t]/.test(value)) return doubleQuotedString(value, ctx);\n  var indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  var res = \"'\" + value.replace(/'/g, \"''\").replace(/\\n+/g, `$&\\n${indent}`) + \"'\";\n  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));\n}\nfunction quotedString(value, ctx) {\n  var singleQuote = ctx.options.singleQuote;\n  var qs;\n  if (singleQuote === false) qs = doubleQuotedString;else {\n    var hasDouble = value.includes('\"');\n    var hasSingle = value.includes(\"'\");\n    if (hasDouble && !hasSingle) qs = singleQuotedString;else if (hasSingle && !hasDouble) qs = doubleQuotedString;else qs = singleQuote ? singleQuotedString : doubleQuotedString;\n  }\n  return qs(value, ctx);\n}\nvar blockEndNewlines;\ntry {\n  blockEndNewlines = new RegExp('(^|(?<!\\n))\\n+(?!\\n|$)', 'g');\n} catch (_unused) {\n  blockEndNewlines = /\\n+(?!\\n|$)/g;\n}\nfunction blockString(_ref, ctx, onComment, onChompKeep) {\n  var comment = _ref.comment,\n    type = _ref.type,\n    value = _ref.value;\n  var _ctx$options = ctx.options,\n    blockQuote = _ctx$options.blockQuote,\n    commentString = _ctx$options.commentString,\n    lineWidth = _ctx$options.lineWidth;\n  if (!blockQuote || /\\n[\\t ]+$/.test(value) || /^\\s*$/.test(value)) {\n    return quotedString(value, ctx);\n  }\n  var indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');\n  var literal = blockQuote === 'literal' ? true : blockQuote === 'folded' || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);\n  if (!value) return literal ? '|\\n' : '>\\n';\n  var chomp;\n  var endStart;\n  for (endStart = value.length; endStart > 0; --endStart) {\n    var ch = value[endStart - 1];\n    if (ch !== '\\n' && ch !== '\\t' && ch !== ' ') break;\n  }\n  var end = value.substring(endStart);\n  var endNlPos = end.indexOf('\\n');\n  if (endNlPos === -1) {\n    chomp = '-';\n  } else if (value === end || endNlPos !== end.length - 1) {\n    chomp = '+';\n    if (onChompKeep) onChompKeep();\n  } else {\n    chomp = '';\n  }\n  if (end) {\n    value = value.slice(0, -end.length);\n    if (end[end.length - 1] === '\\n') end = end.slice(0, -1);\n    end = end.replace(blockEndNewlines, `$&${indent}`);\n  }\n  var startWithSpace = false;\n  var startEnd;\n  var startNlPos = -1;\n  for (startEnd = 0; startEnd < value.length; ++startEnd) {\n    var _ch = value[startEnd];\n    if (_ch === ' ') startWithSpace = true;else if (_ch === '\\n') startNlPos = startEnd;else break;\n  }\n  var start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);\n  if (start) {\n    value = value.substring(start.length);\n    start = start.replace(/\\n+/g, `$&${indent}`);\n  }\n  var indentSize = indent ? '2' : '1';\n  var header = (literal ? '|' : '>') + (startWithSpace ? indentSize : '') + chomp;\n  if (comment) {\n    header += ' ' + commentString(comment.replace(/ ?[\\r\\n]+/g, ' '));\n    if (onComment) onComment();\n  }\n  if (literal) {\n    value = value.replace(/\\n+/g, `$&${indent}`);\n    return `${header}\\n${indent}${start}${value}${end}`;\n  }\n  value = value.replace(/\\n+/g, '\\n$&').replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g, '$1$2').replace(/\\n+/g, `$&${indent}`);\n  var body = foldFlowLines(`${start}${value}${end}`, indent, FOLD_BLOCK, getFoldOptions(ctx, true));\n  return `${header}\\n${indent}${body}`;\n}\nfunction plainString(item, ctx, onComment, onChompKeep) {\n  var type = item.type,\n    value = item.value;\n  var actualString = ctx.actualString,\n    implicitKey = ctx.implicitKey,\n    indent = ctx.indent,\n    indentStep = ctx.indentStep,\n    inFlow = ctx.inFlow;\n  if (implicitKey && value.includes('\\n') || inFlow && /[[\\]{},]/.test(value)) {\n    return quotedString(value, ctx);\n  }\n  if (!value || /^[\\n\\t ,[\\]{}#&*!|>'\"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(value)) {\n    return implicitKey || inFlow || !value.includes('\\n') ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);\n  }\n  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value.includes('\\n')) {\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n  if (containsDocumentMarker(value)) {\n    if (indent === '') {\n      ctx.forceBlockIndent = true;\n      return blockString(item, ctx, onComment, onChompKeep);\n    } else if (implicitKey && indent === indentStep) {\n      return quotedString(value, ctx);\n    }\n  }\n  var str = value.replace(/\\n+/g, `$&\\n${indent}`);\n  if (actualString) {\n    var test = function test(tag) {\n      var _tag$test;\n      return tag.default && tag.tag !== 'tag:yaml.org,2002:str' && ((_tag$test = tag.test) == null ? void 0 : _tag$test.test(str));\n    };\n    var _ctx$doc$schema = ctx.doc.schema,\n      compat = _ctx$doc$schema.compat,\n      tags = _ctx$doc$schema.tags;\n    if (tags.some(test) || compat != null && compat.some(test)) return quotedString(value, ctx);\n  }\n  return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));\n}\nfunction stringifyString(item, ctx, onComment, onChompKeep) {\n  var implicitKey = ctx.implicitKey,\n    inFlow = ctx.inFlow;\n  var ss = typeof item.value === 'string' ? item : Object.assign({}, item, {\n    value: String(item.value)\n  });\n  var type = item.type;\n  if (type !== Scalar.QUOTE_DOUBLE) {\n    if (/(?:[\\0-\\x08\\x0B-\\x1F\\x7F-\\x9F]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/.test(ss.value)) type = Scalar.QUOTE_DOUBLE;\n  }\n  var _stringify = function _stringify(_type) {\n    switch (_type) {\n      case Scalar.BLOCK_FOLDED:\n      case Scalar.BLOCK_LITERAL:\n        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);\n      case Scalar.QUOTE_DOUBLE:\n        return doubleQuotedString(ss.value, ctx);\n      case Scalar.QUOTE_SINGLE:\n        return singleQuotedString(ss.value, ctx);\n      case Scalar.PLAIN:\n        return plainString(ss, ctx, onComment, onChompKeep);\n      default:\n        return null;\n    }\n  };\n  var res = _stringify(type);\n  if (res === null) {\n    var _ctx$options2 = ctx.options,\n      defaultKeyType = _ctx$options2.defaultKeyType,\n      defaultStringType = _ctx$options2.defaultStringType;\n    var t = implicitKey && defaultKeyType || defaultStringType;\n    res = _stringify(t);\n    if (res === null) throw new Error(`Unsupported default string type ${t}`);\n  }\n  return res;\n}\nexport { stringifyString };","map":{"version":3,"names":["Scalar","foldFlowLines","FOLD_QUOTED","FOLD_FLOW","FOLD_BLOCK","getFoldOptions","ctx","isBlock","indentAtStart","indent","length","lineWidth","options","minContentWidth","containsDocumentMarker","str","test","lineLengthOverLimit","indentLength","limit","strLen","i","start","doubleQuotedString","value","json","JSON","stringify","doubleQuotedAsJSON","implicitKey","minMultiLineLength","doubleQuotedMinMultiLineLength","ch","slice","code","substr","singleQuotedString","singleQuote","includes","res","replace","quotedString","qs","hasDouble","hasSingle","blockEndNewlines","RegExp","_unused","blockString","_ref","onComment","onChompKeep","comment","type","_ctx$options","blockQuote","commentString","forceBlockIndent","literal","BLOCK_FOLDED","BLOCK_LITERAL","chomp","endStart","end","substring","endNlPos","indexOf","startWithSpace","startEnd","startNlPos","indentSize","header","body","plainString","item","actualString","indentStep","inFlow","PLAIN","tag","_tag$test","default","_ctx$doc$schema","doc","schema","compat","tags","some","stringifyString","ss","Object","assign","String","QUOTE_DOUBLE","_stringify","_type","QUOTE_SINGLE","_ctx$options2","defaultKeyType","defaultStringType","t","Error"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native-community/cli-doctor/node_modules/yaml/browser/dist/stringify/stringifyString.js"],"sourcesContent":["import { Scalar } from '../nodes/Scalar.js';\nimport { foldFlowLines, FOLD_QUOTED, FOLD_FLOW, FOLD_BLOCK } from './foldFlowLines.js';\n\nconst getFoldOptions = (ctx, isBlock) => ({\n    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,\n    lineWidth: ctx.options.lineWidth,\n    minContentWidth: ctx.options.minContentWidth\n});\n// Also checks for lines starting with %, as parsing the output as YAML 1.1 will\n// presume that's starting a new document.\nconst containsDocumentMarker = (str) => /^(%|---|\\.\\.\\.)/m.test(str);\nfunction lineLengthOverLimit(str, lineWidth, indentLength) {\n    if (!lineWidth || lineWidth < 0)\n        return false;\n    const limit = lineWidth - indentLength;\n    const strLen = str.length;\n    if (strLen <= limit)\n        return false;\n    for (let i = 0, start = 0; i < strLen; ++i) {\n        if (str[i] === '\\n') {\n            if (i - start > limit)\n                return true;\n            start = i + 1;\n            if (strLen - start <= limit)\n                return false;\n        }\n    }\n    return true;\n}\nfunction doubleQuotedString(value, ctx) {\n    const json = JSON.stringify(value);\n    if (ctx.options.doubleQuotedAsJSON)\n        return json;\n    const { implicitKey } = ctx;\n    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;\n    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n    let str = '';\n    let start = 0;\n    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {\n        if (ch === ' ' && json[i + 1] === '\\\\' && json[i + 2] === 'n') {\n            // space before newline needs to be escaped to not be folded\n            str += json.slice(start, i) + '\\\\ ';\n            i += 1;\n            start = i;\n            ch = '\\\\';\n        }\n        if (ch === '\\\\')\n            switch (json[i + 1]) {\n                case 'u':\n                    {\n                        str += json.slice(start, i);\n                        const code = json.substr(i + 2, 4);\n                        switch (code) {\n                            case '0000':\n                                str += '\\\\0';\n                                break;\n                            case '0007':\n                                str += '\\\\a';\n                                break;\n                            case '000b':\n                                str += '\\\\v';\n                                break;\n                            case '001b':\n                                str += '\\\\e';\n                                break;\n                            case '0085':\n                                str += '\\\\N';\n                                break;\n                            case '00a0':\n                                str += '\\\\_';\n                                break;\n                            case '2028':\n                                str += '\\\\L';\n                                break;\n                            case '2029':\n                                str += '\\\\P';\n                                break;\n                            default:\n                                if (code.substr(0, 2) === '00')\n                                    str += '\\\\x' + code.substr(2);\n                                else\n                                    str += json.substr(i, 6);\n                        }\n                        i += 5;\n                        start = i + 1;\n                    }\n                    break;\n                case 'n':\n                    if (implicitKey ||\n                        json[i + 2] === '\"' ||\n                        json.length < minMultiLineLength) {\n                        i += 1;\n                    }\n                    else {\n                        // folding will eat first newline\n                        str += json.slice(start, i) + '\\n\\n';\n                        while (json[i + 2] === '\\\\' &&\n                            json[i + 3] === 'n' &&\n                            json[i + 4] !== '\"') {\n                            str += '\\n';\n                            i += 2;\n                        }\n                        str += indent;\n                        // space after newline needs to be escaped to not be folded\n                        if (json[i + 2] === ' ')\n                            str += '\\\\';\n                        i += 1;\n                        start = i + 1;\n                    }\n                    break;\n                default:\n                    i += 1;\n            }\n    }\n    str = start ? str + json.slice(start) : json;\n    return implicitKey\n        ? str\n        : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));\n}\nfunction singleQuotedString(value, ctx) {\n    if (ctx.options.singleQuote === false ||\n        (ctx.implicitKey && value.includes('\\n')) ||\n        /[ \\t]\\n|\\n[ \\t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline\n    )\n        return doubleQuotedString(value, ctx);\n    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n    const res = \"'\" + value.replace(/'/g, \"''\").replace(/\\n+/g, `$&\\n${indent}`) + \"'\";\n    return ctx.implicitKey\n        ? res\n        : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));\n}\nfunction quotedString(value, ctx) {\n    const { singleQuote } = ctx.options;\n    let qs;\n    if (singleQuote === false)\n        qs = doubleQuotedString;\n    else {\n        const hasDouble = value.includes('\"');\n        const hasSingle = value.includes(\"'\");\n        if (hasDouble && !hasSingle)\n            qs = singleQuotedString;\n        else if (hasSingle && !hasDouble)\n            qs = doubleQuotedString;\n        else\n            qs = singleQuote ? singleQuotedString : doubleQuotedString;\n    }\n    return qs(value, ctx);\n}\n// The negative lookbehind avoids a polynomial search,\n// but isn't supported yet on Safari: https://caniuse.com/js-regexp-lookbehind\nlet blockEndNewlines;\ntry {\n    blockEndNewlines = new RegExp('(^|(?<!\\n))\\n+(?!\\n|$)', 'g');\n}\ncatch {\n    blockEndNewlines = /\\n+(?!\\n|$)/g;\n}\nfunction blockString({ comment, type, value }, ctx, onComment, onChompKeep) {\n    const { blockQuote, commentString, lineWidth } = ctx.options;\n    // 1. Block can't end in whitespace unless the last line is non-empty.\n    // 2. Strings consisting of only whitespace are best rendered explicitly.\n    if (!blockQuote || /\\n[\\t ]+$/.test(value) || /^\\s*$/.test(value)) {\n        return quotedString(value, ctx);\n    }\n    const indent = ctx.indent ||\n        (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');\n    const literal = blockQuote === 'literal'\n        ? true\n        : blockQuote === 'folded' || type === Scalar.BLOCK_FOLDED\n            ? false\n            : type === Scalar.BLOCK_LITERAL\n                ? true\n                : !lineLengthOverLimit(value, lineWidth, indent.length);\n    if (!value)\n        return literal ? '|\\n' : '>\\n';\n    // determine chomping from whitespace at value end\n    let chomp;\n    let endStart;\n    for (endStart = value.length; endStart > 0; --endStart) {\n        const ch = value[endStart - 1];\n        if (ch !== '\\n' && ch !== '\\t' && ch !== ' ')\n            break;\n    }\n    let end = value.substring(endStart);\n    const endNlPos = end.indexOf('\\n');\n    if (endNlPos === -1) {\n        chomp = '-'; // strip\n    }\n    else if (value === end || endNlPos !== end.length - 1) {\n        chomp = '+'; // keep\n        if (onChompKeep)\n            onChompKeep();\n    }\n    else {\n        chomp = ''; // clip\n    }\n    if (end) {\n        value = value.slice(0, -end.length);\n        if (end[end.length - 1] === '\\n')\n            end = end.slice(0, -1);\n        end = end.replace(blockEndNewlines, `$&${indent}`);\n    }\n    // determine indent indicator from whitespace at value start\n    let startWithSpace = false;\n    let startEnd;\n    let startNlPos = -1;\n    for (startEnd = 0; startEnd < value.length; ++startEnd) {\n        const ch = value[startEnd];\n        if (ch === ' ')\n            startWithSpace = true;\n        else if (ch === '\\n')\n            startNlPos = startEnd;\n        else\n            break;\n    }\n    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);\n    if (start) {\n        value = value.substring(start.length);\n        start = start.replace(/\\n+/g, `$&${indent}`);\n    }\n    const indentSize = indent ? '2' : '1'; // root is at -1\n    let header = (literal ? '|' : '>') + (startWithSpace ? indentSize : '') + chomp;\n    if (comment) {\n        header += ' ' + commentString(comment.replace(/ ?[\\r\\n]+/g, ' '));\n        if (onComment)\n            onComment();\n    }\n    if (literal) {\n        value = value.replace(/\\n+/g, `$&${indent}`);\n        return `${header}\\n${indent}${start}${value}${end}`;\n    }\n    value = value\n        .replace(/\\n+/g, '\\n$&')\n        .replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g, '$1$2') // more-indented lines aren't folded\n        //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent\n        .replace(/\\n+/g, `$&${indent}`);\n    const body = foldFlowLines(`${start}${value}${end}`, indent, FOLD_BLOCK, getFoldOptions(ctx, true));\n    return `${header}\\n${indent}${body}`;\n}\nfunction plainString(item, ctx, onComment, onChompKeep) {\n    const { type, value } = item;\n    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;\n    if ((implicitKey && value.includes('\\n')) ||\n        (inFlow && /[[\\]{},]/.test(value))) {\n        return quotedString(value, ctx);\n    }\n    if (!value ||\n        /^[\\n\\t ,[\\]{}#&*!|>'\"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(value)) {\n        // not allowed:\n        // - empty string, '-' or '?'\n        // - start with an indicator character (except [?:-]) or /[?-] /\n        // - '\\n ', ': ' or ' \\n' anywhere\n        // - '#' not preceded by a non-space char\n        // - end with ' ' or ':'\n        return implicitKey || inFlow || !value.includes('\\n')\n            ? quotedString(value, ctx)\n            : blockString(item, ctx, onComment, onChompKeep);\n    }\n    if (!implicitKey &&\n        !inFlow &&\n        type !== Scalar.PLAIN &&\n        value.includes('\\n')) {\n        // Where allowed & type not set explicitly, prefer block style for multiline strings\n        return blockString(item, ctx, onComment, onChompKeep);\n    }\n    if (containsDocumentMarker(value)) {\n        if (indent === '') {\n            ctx.forceBlockIndent = true;\n            return blockString(item, ctx, onComment, onChompKeep);\n        }\n        else if (implicitKey && indent === indentStep) {\n            return quotedString(value, ctx);\n        }\n    }\n    const str = value.replace(/\\n+/g, `$&\\n${indent}`);\n    // Verify that output will be parsed as a string, as e.g. plain numbers and\n    // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),\n    // and others in v1.1.\n    if (actualString) {\n        const test = (tag) => tag.default && tag.tag !== 'tag:yaml.org,2002:str' && tag.test?.test(str);\n        const { compat, tags } = ctx.doc.schema;\n        if (tags.some(test) || compat?.some(test))\n            return quotedString(value, ctx);\n    }\n    return implicitKey\n        ? str\n        : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));\n}\nfunction stringifyString(item, ctx, onComment, onChompKeep) {\n    const { implicitKey, inFlow } = ctx;\n    const ss = typeof item.value === 'string'\n        ? item\n        : Object.assign({}, item, { value: String(item.value) });\n    let { type } = item;\n    if (type !== Scalar.QUOTE_DOUBLE) {\n        // force double quotes on control characters & unpaired surrogates\n        if (/[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f\\u{D800}-\\u{DFFF}]/u.test(ss.value))\n            type = Scalar.QUOTE_DOUBLE;\n    }\n    const _stringify = (_type) => {\n        switch (_type) {\n            case Scalar.BLOCK_FOLDED:\n            case Scalar.BLOCK_LITERAL:\n                return implicitKey || inFlow\n                    ? quotedString(ss.value, ctx) // blocks are not valid inside flow containers\n                    : blockString(ss, ctx, onComment, onChompKeep);\n            case Scalar.QUOTE_DOUBLE:\n                return doubleQuotedString(ss.value, ctx);\n            case Scalar.QUOTE_SINGLE:\n                return singleQuotedString(ss.value, ctx);\n            case Scalar.PLAIN:\n                return plainString(ss, ctx, onComment, onChompKeep);\n            default:\n                return null;\n        }\n    };\n    let res = _stringify(type);\n    if (res === null) {\n        const { defaultKeyType, defaultStringType } = ctx.options;\n        const t = (implicitKey && defaultKeyType) || defaultStringType;\n        res = _stringify(t);\n        if (res === null)\n            throw new Error(`Unsupported default string type ${t}`);\n    }\n    return res;\n}\n\nexport { stringifyString };\n"],"mappings":"AAAA,SAASA,MAAM;AACf,SAASC,aAAa,EAAEC,WAAW,EAAEC,SAAS,EAAEC,UAAU;AAE1D,IAAMC,cAAc,GAAG,SAAjBA,cAAcA,CAAIC,GAAG,EAAEC,OAAO;EAAA,OAAM;IACtCC,aAAa,EAAED,OAAO,GAAGD,GAAG,CAACG,MAAM,CAACC,MAAM,GAAGJ,GAAG,CAACE,aAAa;IAC9DG,SAAS,EAAEL,GAAG,CAACM,OAAO,CAACD,SAAS;IAChCE,eAAe,EAAEP,GAAG,CAACM,OAAO,CAACC;EACjC,CAAC;AAAA,CAAC;AAGF,IAAMC,sBAAsB,GAAG,SAAzBA,sBAAsBA,CAAIC,GAAG;EAAA,OAAK,kBAAkB,CAACC,IAAI,CAACD,GAAG,CAAC;AAAA;AACpE,SAASE,mBAAmBA,CAACF,GAAG,EAAEJ,SAAS,EAAEO,YAAY,EAAE;EACvD,IAAI,CAACP,SAAS,IAAIA,SAAS,GAAG,CAAC,EAC3B,OAAO,KAAK;EAChB,IAAMQ,KAAK,GAAGR,SAAS,GAAGO,YAAY;EACtC,IAAME,MAAM,GAAGL,GAAG,CAACL,MAAM;EACzB,IAAIU,MAAM,IAAID,KAAK,EACf,OAAO,KAAK;EAChB,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEC,KAAK,GAAG,CAAC,EAAED,CAAC,GAAGD,MAAM,EAAE,EAAEC,CAAC,EAAE;IACxC,IAAIN,GAAG,CAACM,CAAC,CAAC,KAAK,IAAI,EAAE;MACjB,IAAIA,CAAC,GAAGC,KAAK,GAAGH,KAAK,EACjB,OAAO,IAAI;MACfG,KAAK,GAAGD,CAAC,GAAG,CAAC;MACb,IAAID,MAAM,GAAGE,KAAK,IAAIH,KAAK,EACvB,OAAO,KAAK;IACpB;EACJ;EACA,OAAO,IAAI;AACf;AACA,SAASI,kBAAkBA,CAACC,KAAK,EAAElB,GAAG,EAAE;EACpC,IAAMmB,IAAI,GAAGC,IAAI,CAACC,SAAS,CAACH,KAAK,CAAC;EAClC,IAAIlB,GAAG,CAACM,OAAO,CAACgB,kBAAkB,EAC9B,OAAOH,IAAI;EACf,IAAQI,WAAW,GAAKvB,GAAG,CAAnBuB,WAAW;EACnB,IAAMC,kBAAkB,GAAGxB,GAAG,CAACM,OAAO,CAACmB,8BAA8B;EACrE,IAAMtB,MAAM,GAAGH,GAAG,CAACG,MAAM,KAAKK,sBAAsB,CAACU,KAAK,CAAC,GAAG,IAAI,GAAG,EAAE,CAAC;EACxE,IAAIT,GAAG,GAAG,EAAE;EACZ,IAAIO,KAAK,GAAG,CAAC;EACb,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEW,EAAE,GAAGP,IAAI,CAACJ,CAAC,CAAC,EAAEW,EAAE,EAAEA,EAAE,GAAGP,IAAI,CAAC,EAAEJ,CAAC,CAAC,EAAE;IAC9C,IAAIW,EAAE,KAAK,GAAG,IAAIP,IAAI,CAACJ,CAAC,GAAG,CAAC,CAAC,KAAK,IAAI,IAAII,IAAI,CAACJ,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;MAE3DN,GAAG,IAAIU,IAAI,CAACQ,KAAK,CAACX,KAAK,EAAED,CAAC,CAAC,GAAG,KAAK;MACnCA,CAAC,IAAI,CAAC;MACNC,KAAK,GAAGD,CAAC;MACTW,EAAE,GAAG,IAAI;IACb;IACA,IAAIA,EAAE,KAAK,IAAI,EACX,QAAQP,IAAI,CAACJ,CAAC,GAAG,CAAC,CAAC;MACf,KAAK,GAAG;QACJ;UACIN,GAAG,IAAIU,IAAI,CAACQ,KAAK,CAACX,KAAK,EAAED,CAAC,CAAC;UAC3B,IAAMa,IAAI,GAAGT,IAAI,CAACU,MAAM,CAACd,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;UAClC,QAAQa,IAAI;YACR,KAAK,MAAM;cACPnB,GAAG,IAAI,KAAK;cACZ;YACJ,KAAK,MAAM;cACPA,GAAG,IAAI,KAAK;cACZ;YACJ,KAAK,MAAM;cACPA,GAAG,IAAI,KAAK;cACZ;YACJ,KAAK,MAAM;cACPA,GAAG,IAAI,KAAK;cACZ;YACJ,KAAK,MAAM;cACPA,GAAG,IAAI,KAAK;cACZ;YACJ,KAAK,MAAM;cACPA,GAAG,IAAI,KAAK;cACZ;YACJ,KAAK,MAAM;cACPA,GAAG,IAAI,KAAK;cACZ;YACJ,KAAK,MAAM;cACPA,GAAG,IAAI,KAAK;cACZ;YACJ;cACI,IAAImB,IAAI,CAACC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,EAC1BpB,GAAG,IAAI,KAAK,GAAGmB,IAAI,CAACC,MAAM,CAAC,CAAC,CAAC,CAAC,KAE9BpB,GAAG,IAAIU,IAAI,CAACU,MAAM,CAACd,CAAC,EAAE,CAAC,CAAC;UACpC;UACAA,CAAC,IAAI,CAAC;UACNC,KAAK,GAAGD,CAAC,GAAG,CAAC;QACjB;QACA;MACJ,KAAK,GAAG;QACJ,IAAIQ,WAAW,IACXJ,IAAI,CAACJ,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,IACnBI,IAAI,CAACf,MAAM,GAAGoB,kBAAkB,EAAE;UAClCT,CAAC,IAAI,CAAC;QACV,CAAC,MACI;UAEDN,GAAG,IAAIU,IAAI,CAACQ,KAAK,CAACX,KAAK,EAAED,CAAC,CAAC,GAAG,MAAM;UACpC,OAAOI,IAAI,CAACJ,CAAC,GAAG,CAAC,CAAC,KAAK,IAAI,IACvBI,IAAI,CAACJ,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,IACnBI,IAAI,CAACJ,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;YACrBN,GAAG,IAAI,IAAI;YACXM,CAAC,IAAI,CAAC;UACV;UACAN,GAAG,IAAIN,MAAM;UAEb,IAAIgB,IAAI,CAACJ,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,EACnBN,GAAG,IAAI,IAAI;UACfM,CAAC,IAAI,CAAC;UACNC,KAAK,GAAGD,CAAC,GAAG,CAAC;QACjB;QACA;MACJ;QACIA,CAAC,IAAI,CAAC;IACd;EACR;EACAN,GAAG,GAAGO,KAAK,GAAGP,GAAG,GAAGU,IAAI,CAACQ,KAAK,CAACX,KAAK,CAAC,GAAGG,IAAI;EAC5C,OAAOI,WAAW,GACZd,GAAG,GACHd,aAAa,CAACc,GAAG,EAAEN,MAAM,EAAEP,WAAW,EAAEG,cAAc,CAACC,GAAG,EAAE,KAAK,CAAC,CAAC;AAC7E;AACA,SAAS8B,kBAAkBA,CAACZ,KAAK,EAAElB,GAAG,EAAE;EACpC,IAAIA,GAAG,CAACM,OAAO,CAACyB,WAAW,KAAK,KAAK,IAChC/B,GAAG,CAACuB,WAAW,IAAIL,KAAK,CAACc,QAAQ,CAAC,IAAI,CAAE,IACzC,iBAAiB,CAACtB,IAAI,CAACQ,KAAK,CAAC,EAE7B,OAAOD,kBAAkB,CAACC,KAAK,EAAElB,GAAG,CAAC;EACzC,IAAMG,MAAM,GAAGH,GAAG,CAACG,MAAM,KAAKK,sBAAsB,CAACU,KAAK,CAAC,GAAG,IAAI,GAAG,EAAE,CAAC;EACxE,IAAMe,GAAG,GAAG,GAAG,GAAGf,KAAK,CAACgB,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,CAACA,OAAO,CAAC,MAAM,EAAG,OAAM/B,MAAO,EAAC,CAAC,GAAG,GAAG;EAClF,OAAOH,GAAG,CAACuB,WAAW,GAChBU,GAAG,GACHtC,aAAa,CAACsC,GAAG,EAAE9B,MAAM,EAAEN,SAAS,EAAEE,cAAc,CAACC,GAAG,EAAE,KAAK,CAAC,CAAC;AAC3E;AACA,SAASmC,YAAYA,CAACjB,KAAK,EAAElB,GAAG,EAAE;EAC9B,IAAQ+B,WAAW,GAAK/B,GAAG,CAACM,OAAO,CAA3ByB,WAAW;EACnB,IAAIK,EAAE;EACN,IAAIL,WAAW,KAAK,KAAK,EACrBK,EAAE,GAAGnB,kBAAkB,CAAC,KACvB;IACD,IAAMoB,SAAS,GAAGnB,KAAK,CAACc,QAAQ,CAAC,GAAG,CAAC;IACrC,IAAMM,SAAS,GAAGpB,KAAK,CAACc,QAAQ,CAAC,GAAG,CAAC;IACrC,IAAIK,SAAS,IAAI,CAACC,SAAS,EACvBF,EAAE,GAAGN,kBAAkB,CAAC,KACvB,IAAIQ,SAAS,IAAI,CAACD,SAAS,EAC5BD,EAAE,GAAGnB,kBAAkB,CAAC,KAExBmB,EAAE,GAAGL,WAAW,GAAGD,kBAAkB,GAAGb,kBAAkB;EAClE;EACA,OAAOmB,EAAE,CAAClB,KAAK,EAAElB,GAAG,CAAC;AACzB;AAGA,IAAIuC,gBAAgB;AACpB,IAAI;EACAA,gBAAgB,GAAG,IAAIC,MAAM,CAAC,wBAAwB,EAAE,GAAG,CAAC;AAChE,CAAC,CACD,OAAAC,OAAA,EAAM;EACFF,gBAAgB,GAAG,cAAc;AACrC;AACA,SAASG,WAAWA,CAAAC,IAAA,EAA2B3C,GAAG,EAAE4C,SAAS,EAAEC,WAAW,EAAE;EAAA,IAArDC,OAAO,GAAAH,IAAA,CAAPG,OAAO;IAAEC,IAAI,GAAAJ,IAAA,CAAJI,IAAI;IAAE7B,KAAK,GAAAyB,IAAA,CAALzB,KAAK;EACvC,IAAA8B,YAAA,GAAiDhD,GAAG,CAACM,OAAO;IAApD2C,UAAU,GAAAD,YAAA,CAAVC,UAAU;IAAEC,aAAa,GAAAF,YAAA,CAAbE,aAAa;IAAE7C,SAAS,GAAA2C,YAAA,CAAT3C,SAAS;EAG5C,IAAI,CAAC4C,UAAU,IAAI,WAAW,CAACvC,IAAI,CAACQ,KAAK,CAAC,IAAI,OAAO,CAACR,IAAI,CAACQ,KAAK,CAAC,EAAE;IAC/D,OAAOiB,YAAY,CAACjB,KAAK,EAAElB,GAAG,CAAC;EACnC;EACA,IAAMG,MAAM,GAAGH,GAAG,CAACG,MAAM,KACpBH,GAAG,CAACmD,gBAAgB,IAAI3C,sBAAsB,CAACU,KAAK,CAAC,GAAG,IAAI,GAAG,EAAE,CAAC;EACvE,IAAMkC,OAAO,GAAGH,UAAU,KAAK,SAAS,GAClC,IAAI,GACJA,UAAU,KAAK,QAAQ,IAAIF,IAAI,KAAKrD,MAAM,CAAC2D,YAAY,GACnD,KAAK,GACLN,IAAI,KAAKrD,MAAM,CAAC4D,aAAa,GACzB,IAAI,GACJ,CAAC3C,mBAAmB,CAACO,KAAK,EAAEb,SAAS,EAAEF,MAAM,CAACC,MAAM,CAAC;EACnE,IAAI,CAACc,KAAK,EACN,OAAOkC,OAAO,GAAG,KAAK,GAAG,KAAK;EAElC,IAAIG,KAAK;EACT,IAAIC,QAAQ;EACZ,KAAKA,QAAQ,GAAGtC,KAAK,CAACd,MAAM,EAAEoD,QAAQ,GAAG,CAAC,EAAE,EAAEA,QAAQ,EAAE;IACpD,IAAM9B,EAAE,GAAGR,KAAK,CAACsC,QAAQ,GAAG,CAAC,CAAC;IAC9B,IAAI9B,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK,GAAG,EACxC;EACR;EACA,IAAI+B,GAAG,GAAGvC,KAAK,CAACwC,SAAS,CAACF,QAAQ,CAAC;EACnC,IAAMG,QAAQ,GAAGF,GAAG,CAACG,OAAO,CAAC,IAAI,CAAC;EAClC,IAAID,QAAQ,KAAK,CAAC,CAAC,EAAE;IACjBJ,KAAK,GAAG,GAAG;EACf,CAAC,MACI,IAAIrC,KAAK,KAAKuC,GAAG,IAAIE,QAAQ,KAAKF,GAAG,CAACrD,MAAM,GAAG,CAAC,EAAE;IACnDmD,KAAK,GAAG,GAAG;IACX,IAAIV,WAAW,EACXA,WAAW,CAAC,CAAC;EACrB,CAAC,MACI;IACDU,KAAK,GAAG,EAAE;EACd;EACA,IAAIE,GAAG,EAAE;IACLvC,KAAK,GAAGA,KAAK,CAACS,KAAK,CAAC,CAAC,EAAE,CAAC8B,GAAG,CAACrD,MAAM,CAAC;IACnC,IAAIqD,GAAG,CAACA,GAAG,CAACrD,MAAM,GAAG,CAAC,CAAC,KAAK,IAAI,EAC5BqD,GAAG,GAAGA,GAAG,CAAC9B,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAC1B8B,GAAG,GAAGA,GAAG,CAACvB,OAAO,CAACK,gBAAgB,EAAG,KAAIpC,MAAO,EAAC,CAAC;EACtD;EAEA,IAAI0D,cAAc,GAAG,KAAK;EAC1B,IAAIC,QAAQ;EACZ,IAAIC,UAAU,GAAG,CAAC,CAAC;EACnB,KAAKD,QAAQ,GAAG,CAAC,EAAEA,QAAQ,GAAG5C,KAAK,CAACd,MAAM,EAAE,EAAE0D,QAAQ,EAAE;IACpD,IAAMpC,GAAE,GAAGR,KAAK,CAAC4C,QAAQ,CAAC;IAC1B,IAAIpC,GAAE,KAAK,GAAG,EACVmC,cAAc,GAAG,IAAI,CAAC,KACrB,IAAInC,GAAE,KAAK,IAAI,EAChBqC,UAAU,GAAGD,QAAQ,CAAC,KAEtB;EACR;EACA,IAAI9C,KAAK,GAAGE,KAAK,CAACwC,SAAS,CAAC,CAAC,EAAEK,UAAU,GAAGD,QAAQ,GAAGC,UAAU,GAAG,CAAC,GAAGD,QAAQ,CAAC;EACjF,IAAI9C,KAAK,EAAE;IACPE,KAAK,GAAGA,KAAK,CAACwC,SAAS,CAAC1C,KAAK,CAACZ,MAAM,CAAC;IACrCY,KAAK,GAAGA,KAAK,CAACkB,OAAO,CAAC,MAAM,EAAG,KAAI/B,MAAO,EAAC,CAAC;EAChD;EACA,IAAM6D,UAAU,GAAG7D,MAAM,GAAG,GAAG,GAAG,GAAG;EACrC,IAAI8D,MAAM,GAAG,CAACb,OAAO,GAAG,GAAG,GAAG,GAAG,KAAKS,cAAc,GAAGG,UAAU,GAAG,EAAE,CAAC,GAAGT,KAAK;EAC/E,IAAIT,OAAO,EAAE;IACTmB,MAAM,IAAI,GAAG,GAAGf,aAAa,CAACJ,OAAO,CAACZ,OAAO,CAAC,YAAY,EAAE,GAAG,CAAC,CAAC;IACjE,IAAIU,SAAS,EACTA,SAAS,CAAC,CAAC;EACnB;EACA,IAAIQ,OAAO,EAAE;IACTlC,KAAK,GAAGA,KAAK,CAACgB,OAAO,CAAC,MAAM,EAAG,KAAI/B,MAAO,EAAC,CAAC;IAC5C,OAAQ,GAAE8D,MAAO,KAAI9D,MAAO,GAAEa,KAAM,GAAEE,KAAM,GAAEuC,GAAI,EAAC;EACvD;EACAvC,KAAK,GAAGA,KAAK,CACRgB,OAAO,CAAC,MAAM,EAAE,MAAM,CAAC,CACvBA,OAAO,CAAC,gDAAgD,EAAE,MAAM,CAAC,CAEjEA,OAAO,CAAC,MAAM,EAAG,KAAI/B,MAAO,EAAC,CAAC;EACnC,IAAM+D,IAAI,GAAGvE,aAAa,CAAE,GAAEqB,KAAM,GAAEE,KAAM,GAAEuC,GAAI,EAAC,EAAEtD,MAAM,EAAEL,UAAU,EAAEC,cAAc,CAACC,GAAG,EAAE,IAAI,CAAC,CAAC;EACnG,OAAQ,GAAEiE,MAAO,KAAI9D,MAAO,GAAE+D,IAAK,EAAC;AACxC;AACA,SAASC,WAAWA,CAACC,IAAI,EAAEpE,GAAG,EAAE4C,SAAS,EAAEC,WAAW,EAAE;EACpD,IAAQE,IAAI,GAAYqB,IAAI,CAApBrB,IAAI;IAAE7B,KAAK,GAAKkD,IAAI,CAAdlD,KAAK;EACnB,IAAQmD,YAAY,GAA8CrE,GAAG,CAA7DqE,YAAY;IAAE9C,WAAW,GAAiCvB,GAAG,CAA/CuB,WAAW;IAAEpB,MAAM,GAAyBH,GAAG,CAAlCG,MAAM;IAAEmE,UAAU,GAAatE,GAAG,CAA1BsE,UAAU;IAAEC,MAAM,GAAKvE,GAAG,CAAduE,MAAM;EAC7D,IAAKhD,WAAW,IAAIL,KAAK,CAACc,QAAQ,CAAC,IAAI,CAAC,IACnCuC,MAAM,IAAI,UAAU,CAAC7D,IAAI,CAACQ,KAAK,CAAE,EAAE;IACpC,OAAOiB,YAAY,CAACjB,KAAK,EAAElB,GAAG,CAAC;EACnC;EACA,IAAI,CAACkB,KAAK,IACN,mFAAmF,CAACR,IAAI,CAACQ,KAAK,CAAC,EAAE;IAOjG,OAAOK,WAAW,IAAIgD,MAAM,IAAI,CAACrD,KAAK,CAACc,QAAQ,CAAC,IAAI,CAAC,GAC/CG,YAAY,CAACjB,KAAK,EAAElB,GAAG,CAAC,GACxB0C,WAAW,CAAC0B,IAAI,EAAEpE,GAAG,EAAE4C,SAAS,EAAEC,WAAW,CAAC;EACxD;EACA,IAAI,CAACtB,WAAW,IACZ,CAACgD,MAAM,IACPxB,IAAI,KAAKrD,MAAM,CAAC8E,KAAK,IACrBtD,KAAK,CAACc,QAAQ,CAAC,IAAI,CAAC,EAAE;IAEtB,OAAOU,WAAW,CAAC0B,IAAI,EAAEpE,GAAG,EAAE4C,SAAS,EAAEC,WAAW,CAAC;EACzD;EACA,IAAIrC,sBAAsB,CAACU,KAAK,CAAC,EAAE;IAC/B,IAAIf,MAAM,KAAK,EAAE,EAAE;MACfH,GAAG,CAACmD,gBAAgB,GAAG,IAAI;MAC3B,OAAOT,WAAW,CAAC0B,IAAI,EAAEpE,GAAG,EAAE4C,SAAS,EAAEC,WAAW,CAAC;IACzD,CAAC,MACI,IAAItB,WAAW,IAAIpB,MAAM,KAAKmE,UAAU,EAAE;MAC3C,OAAOnC,YAAY,CAACjB,KAAK,EAAElB,GAAG,CAAC;IACnC;EACJ;EACA,IAAMS,GAAG,GAAGS,KAAK,CAACgB,OAAO,CAAC,MAAM,EAAG,OAAM/B,MAAO,EAAC,CAAC;EAIlD,IAAIkE,YAAY,EAAE;IACd,IAAM3D,IAAI,GAAG,SAAPA,IAAIA,CAAI+D,GAAG;MAAA,IAAAC,SAAA;MAAA,OAAKD,GAAG,CAACE,OAAO,IAAIF,GAAG,CAACA,GAAG,KAAK,uBAAuB,MAAAC,SAAA,GAAID,GAAG,CAAC/D,IAAI,qBAARgE,SAAA,CAAUhE,IAAI,CAACD,GAAG,CAAC;IAAA;IAC/F,IAAAmE,eAAA,GAAyB5E,GAAG,CAAC6E,GAAG,CAACC,MAAM;MAA/BC,MAAM,GAAAH,eAAA,CAANG,MAAM;MAAEC,IAAI,GAAAJ,eAAA,CAAJI,IAAI;IACpB,IAAIA,IAAI,CAACC,IAAI,CAACvE,IAAI,CAAC,IAAIqE,MAAM,YAANA,MAAM,CAAEE,IAAI,CAACvE,IAAI,CAAC,EACrC,OAAOyB,YAAY,CAACjB,KAAK,EAAElB,GAAG,CAAC;EACvC;EACA,OAAOuB,WAAW,GACZd,GAAG,GACHd,aAAa,CAACc,GAAG,EAAEN,MAAM,EAAEN,SAAS,EAAEE,cAAc,CAACC,GAAG,EAAE,KAAK,CAAC,CAAC;AAC3E;AACA,SAASkF,eAAeA,CAACd,IAAI,EAAEpE,GAAG,EAAE4C,SAAS,EAAEC,WAAW,EAAE;EACxD,IAAQtB,WAAW,GAAavB,GAAG,CAA3BuB,WAAW;IAAEgD,MAAM,GAAKvE,GAAG,CAAduE,MAAM;EAC3B,IAAMY,EAAE,GAAG,OAAOf,IAAI,CAAClD,KAAK,KAAK,QAAQ,GACnCkD,IAAI,GACJgB,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEjB,IAAI,EAAE;IAAElD,KAAK,EAAEoE,MAAM,CAAClB,IAAI,CAAClD,KAAK;EAAE,CAAC,CAAC;EAC5D,IAAM6B,IAAI,GAAKqB,IAAI,CAAbrB,IAAI;EACV,IAAIA,IAAI,KAAKrD,MAAM,CAAC6F,YAAY,EAAE;IAE9B,IAAI,0GAAiD,CAAC7E,IAAI,CAACyE,EAAE,CAACjE,KAAK,CAAC,EAChE6B,IAAI,GAAGrD,MAAM,CAAC6F,YAAY;EAClC;EACA,IAAMC,UAAU,GAAG,SAAbA,UAAUA,CAAIC,KAAK,EAAK;IAC1B,QAAQA,KAAK;MACT,KAAK/F,MAAM,CAAC2D,YAAY;MACxB,KAAK3D,MAAM,CAAC4D,aAAa;QACrB,OAAO/B,WAAW,IAAIgD,MAAM,GACtBpC,YAAY,CAACgD,EAAE,CAACjE,KAAK,EAAElB,GAAG,CAAC,GAC3B0C,WAAW,CAACyC,EAAE,EAAEnF,GAAG,EAAE4C,SAAS,EAAEC,WAAW,CAAC;MACtD,KAAKnD,MAAM,CAAC6F,YAAY;QACpB,OAAOtE,kBAAkB,CAACkE,EAAE,CAACjE,KAAK,EAAElB,GAAG,CAAC;MAC5C,KAAKN,MAAM,CAACgG,YAAY;QACpB,OAAO5D,kBAAkB,CAACqD,EAAE,CAACjE,KAAK,EAAElB,GAAG,CAAC;MAC5C,KAAKN,MAAM,CAAC8E,KAAK;QACb,OAAOL,WAAW,CAACgB,EAAE,EAAEnF,GAAG,EAAE4C,SAAS,EAAEC,WAAW,CAAC;MACvD;QACI,OAAO,IAAI;IACnB;EACJ,CAAC;EACD,IAAIZ,GAAG,GAAGuD,UAAU,CAACzC,IAAI,CAAC;EAC1B,IAAId,GAAG,KAAK,IAAI,EAAE;IACd,IAAA0D,aAAA,GAA8C3F,GAAG,CAACM,OAAO;MAAjDsF,cAAc,GAAAD,aAAA,CAAdC,cAAc;MAAEC,iBAAiB,GAAAF,aAAA,CAAjBE,iBAAiB;IACzC,IAAMC,CAAC,GAAIvE,WAAW,IAAIqE,cAAc,IAAKC,iBAAiB;IAC9D5D,GAAG,GAAGuD,UAAU,CAACM,CAAC,CAAC;IACnB,IAAI7D,GAAG,KAAK,IAAI,EACZ,MAAM,IAAI8D,KAAK,CAAE,mCAAkCD,CAAE,EAAC,CAAC;EAC/D;EACA,OAAO7D,GAAG;AACd;AAEA,SAASiD,eAAe"},"metadata":{},"sourceType":"module","externalDependencies":[]}