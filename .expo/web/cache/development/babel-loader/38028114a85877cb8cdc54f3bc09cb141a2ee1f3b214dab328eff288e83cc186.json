{"ast":null,"code":"'use strict';\n\nvar identity = require(\"../nodes/identity.js\");\nvar Scalar = require(\"../nodes/Scalar.js\");\nvar resolveBlockScalar = require(\"./resolve-block-scalar.js\");\nvar resolveFlowScalar = require(\"./resolve-flow-scalar.js\");\nfunction composeScalar(ctx, token, tagToken, onError) {\n  var _ref = token.type === 'block-scalar' ? resolveBlockScalar.resolveBlockScalar(token, ctx.options.strict, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError),\n    value = _ref.value,\n    type = _ref.type,\n    comment = _ref.comment,\n    range = _ref.range;\n  var tagName = tagToken ? ctx.directives.tagName(tagToken.source, function (msg) {\n    return onError(tagToken, 'TAG_RESOLVE_FAILED', msg);\n  }) : null;\n  var tag = tagToken && tagName ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError) : token.type === 'scalar' ? findScalarTagByTest(ctx, value, token, onError) : ctx.schema[identity.SCALAR];\n  var scalar;\n  try {\n    var res = tag.resolve(value, function (msg) {\n      return onError(tagToken != null ? tagToken : token, 'TAG_RESOLVE_FAILED', msg);\n    }, ctx.options);\n    scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);\n  } catch (error) {\n    var msg = error instanceof Error ? error.message : String(error);\n    onError(tagToken != null ? tagToken : token, 'TAG_RESOLVE_FAILED', msg);\n    scalar = new Scalar.Scalar(value);\n  }\n  scalar.range = range;\n  scalar.source = value;\n  if (type) scalar.type = type;\n  if (tagName) scalar.tag = tagName;\n  if (tag.format) scalar.format = tag.format;\n  if (comment) scalar.comment = comment;\n  return scalar;\n}\nfunction findScalarTagByName(schema, value, tagName, tagToken, onError) {\n  if (tagName === '!') return schema[identity.SCALAR];\n  var matchWithTest = [];\n  for (var tag of schema.tags) {\n    if (!tag.collection && tag.tag === tagName) {\n      if (tag.default && tag.test) matchWithTest.push(tag);else return tag;\n    }\n  }\n  for (var _tag of matchWithTest) {\n    var _tag$test;\n    if ((_tag$test = _tag.test) != null && _tag$test.test(value)) return _tag;\n  }\n  var kt = schema.knownTags[tagName];\n  if (kt && !kt.collection) {\n    schema.tags.push(Object.assign({}, kt, {\n      default: false,\n      test: undefined\n    }));\n    return kt;\n  }\n  onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');\n  return schema[identity.SCALAR];\n}\nfunction findScalarTagByTest(_ref2, value, token, onError) {\n  var directives = _ref2.directives,\n    schema = _ref2.schema;\n  var tag = schema.tags.find(function (tag) {\n    var _tag$test2;\n    return tag.default && ((_tag$test2 = tag.test) == null ? void 0 : _tag$test2.test(value));\n  }) || schema[identity.SCALAR];\n  if (schema.compat) {\n    var _schema$compat$find;\n    var compat = (_schema$compat$find = schema.compat.find(function (tag) {\n      var _tag$test3;\n      return tag.default && ((_tag$test3 = tag.test) == null ? void 0 : _tag$test3.test(value));\n    })) != null ? _schema$compat$find : schema[identity.SCALAR];\n    if (tag.tag !== compat.tag) {\n      var ts = directives.tagString(tag.tag);\n      var cs = directives.tagString(compat.tag);\n      var msg = `Value may be parsed as either ${ts} or ${cs}`;\n      onError(token, 'TAG_RESOLVE_FAILED', msg, true);\n    }\n  }\n  return tag;\n}\nexports.composeScalar = composeScalar;","map":{"version":3,"names":["identity","require","Scalar","resolveBlockScalar","resolveFlowScalar","composeScalar","ctx","token","tagToken","onError","_ref","type","options","strict","value","comment","range","tagName","directives","source","msg","tag","findScalarTagByName","schema","findScalarTagByTest","SCALAR","scalar","res","resolve","isScalar","error","Error","message","String","format","matchWithTest","tags","collection","default","test","push","_tag$test","kt","knownTags","Object","assign","undefined","_ref2","find","_tag$test2","compat","_schema$compat$find","_tag$test3","ts","tagString","cs","exports"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native-community/cli-doctor/node_modules/yaml/dist/compose/compose-scalar.js"],"sourcesContent":["'use strict';\n\nvar identity = require('../nodes/identity.js');\nvar Scalar = require('../nodes/Scalar.js');\nvar resolveBlockScalar = require('./resolve-block-scalar.js');\nvar resolveFlowScalar = require('./resolve-flow-scalar.js');\n\nfunction composeScalar(ctx, token, tagToken, onError) {\n    const { value, type, comment, range } = token.type === 'block-scalar'\n        ? resolveBlockScalar.resolveBlockScalar(token, ctx.options.strict, onError)\n        : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);\n    const tagName = tagToken\n        ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg))\n        : null;\n    const tag = tagToken && tagName\n        ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError)\n        : token.type === 'scalar'\n            ? findScalarTagByTest(ctx, value, token, onError)\n            : ctx.schema[identity.SCALAR];\n    let scalar;\n    try {\n        const res = tag.resolve(value, msg => onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg), ctx.options);\n        scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);\n    }\n    catch (error) {\n        const msg = error instanceof Error ? error.message : String(error);\n        onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg);\n        scalar = new Scalar.Scalar(value);\n    }\n    scalar.range = range;\n    scalar.source = value;\n    if (type)\n        scalar.type = type;\n    if (tagName)\n        scalar.tag = tagName;\n    if (tag.format)\n        scalar.format = tag.format;\n    if (comment)\n        scalar.comment = comment;\n    return scalar;\n}\nfunction findScalarTagByName(schema, value, tagName, tagToken, onError) {\n    if (tagName === '!')\n        return schema[identity.SCALAR]; // non-specific tag\n    const matchWithTest = [];\n    for (const tag of schema.tags) {\n        if (!tag.collection && tag.tag === tagName) {\n            if (tag.default && tag.test)\n                matchWithTest.push(tag);\n            else\n                return tag;\n        }\n    }\n    for (const tag of matchWithTest)\n        if (tag.test?.test(value))\n            return tag;\n    const kt = schema.knownTags[tagName];\n    if (kt && !kt.collection) {\n        // Ensure that the known tag is available for stringifying,\n        // but does not get used by default.\n        schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));\n        return kt;\n    }\n    onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');\n    return schema[identity.SCALAR];\n}\nfunction findScalarTagByTest({ directives, schema }, value, token, onError) {\n    const tag = schema.tags.find(tag => tag.default && tag.test?.test(value)) || schema[identity.SCALAR];\n    if (schema.compat) {\n        const compat = schema.compat.find(tag => tag.default && tag.test?.test(value)) ??\n            schema[identity.SCALAR];\n        if (tag.tag !== compat.tag) {\n            const ts = directives.tagString(tag.tag);\n            const cs = directives.tagString(compat.tag);\n            const msg = `Value may be parsed as either ${ts} or ${cs}`;\n            onError(token, 'TAG_RESOLVE_FAILED', msg, true);\n        }\n    }\n    return tag;\n}\n\nexports.composeScalar = composeScalar;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}