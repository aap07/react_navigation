{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nvar _require = require(\"./ComponentsGeneratorUtils.js\"),\n  getNativeTypeFromAnnotation = _require.getNativeTypeFromAnnotation,\n  getLocalImports = _require.getLocalImports;\nvar _require2 = require(\"./CppHelpers.js\"),\n  convertDefaultTypeToString = _require2.convertDefaultTypeToString,\n  getEnumMaskName = _require2.getEnumMaskName,\n  generateStructName = _require2.generateStructName,\n  toIntEnumValueName = _require2.toIntEnumValueName;\nvar _require3 = require(\"../Utils\"),\n  getEnumName = _require3.getEnumName,\n  toSafeCppString = _require3.toSafeCppString;\nvar FileTemplate = function FileTemplate(_ref) {\n  var imports = _ref.imports,\n    componentClasses = _ref.componentClasses;\n  return `\n/**\n * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).\n *\n * Do not edit this file as changes may cause incorrect behavior and will be lost\n * once the code is regenerated.\n *\n * ${'@'}generated by codegen project: GeneratePropsH.js\n */\n#pragma once\n\n${imports}\n\nnamespace facebook {\nnamespace react {\n\n${componentClasses}\n\n} // namespace react\n} // namespace facebook\n`;\n};\nvar ClassTemplate = function ClassTemplate(_ref2) {\n  var enums = _ref2.enums,\n    structs = _ref2.structs,\n    className = _ref2.className,\n    props = _ref2.props,\n    extendClasses = _ref2.extendClasses;\n  return `\n${enums}\n${structs}\nclass JSI_EXPORT ${className} final${extendClasses} {\n public:\n  ${className}() = default;\n  ${className}(const PropsParserContext& context, const ${className} &sourceProps, const RawProps &rawProps);\n\n#pragma mark - Props\n\n  ${props}\n};\n`.trim();\n};\nvar EnumTemplate = function EnumTemplate(_ref3) {\n  var enumName = _ref3.enumName,\n    values = _ref3.values,\n    fromCases = _ref3.fromCases,\n    toCases = _ref3.toCases;\n  return `\nenum class ${enumName} { ${values} };\n\nstatic inline void fromRawValue(const PropsParserContext& context, const RawValue &value, ${enumName} &result) {\n  auto string = (std::string)value;\n  ${fromCases}\n  abort();\n}\n\nstatic inline std::string toString(const ${enumName} &value) {\n  switch (value) {\n    ${toCases}\n  }\n}\n`.trim();\n};\nvar IntEnumTemplate = function IntEnumTemplate(_ref4) {\n  var enumName = _ref4.enumName,\n    values = _ref4.values,\n    fromCases = _ref4.fromCases,\n    toCases = _ref4.toCases;\n  return `\nenum class ${enumName} { ${values} };\n\nstatic inline void fromRawValue(const PropsParserContext& context, const RawValue &value, ${enumName} &result) {\n  assert(value.hasType<int>());\n  auto integerValue = (int)value;\n  switch (integerValue) {${fromCases}\n  }\n  abort();\n}\n\nstatic inline std::string toString(const ${enumName} &value) {\n  switch (value) {\n    ${toCases}\n  }\n}\n`.trim();\n};\nvar StructTemplate = function StructTemplate(_ref5) {\n  var structName = _ref5.structName,\n    fields = _ref5.fields,\n    fromCases = _ref5.fromCases;\n  return `struct ${structName} {\n  ${fields}\n};\n\nstatic inline void fromRawValue(const PropsParserContext& context, const RawValue &value, ${structName} &result) {\n  auto map = (butter::map<std::string, RawValue>)value;\n\n  ${fromCases}\n}\n\nstatic inline std::string toString(const ${structName} &value) {\n  return \"[Object ${structName}]\";\n}\n`.trim();\n};\nvar ArrayConversionFunctionTemplate = function ArrayConversionFunctionTemplate(_ref6) {\n  var structName = _ref6.structName;\n  return `static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<${structName}> &result) {\n  auto items = (std::vector<RawValue>)value;\n  for (const auto &item : items) {\n    ${structName} newItem;\n    fromRawValue(context, item, newItem);\n    result.emplace_back(newItem);\n  }\n}\n`;\n};\nvar DoubleArrayConversionFunctionTemplate = function DoubleArrayConversionFunctionTemplate(_ref7) {\n  var structName = _ref7.structName;\n  return `static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<std::vector<${structName}>> &result) {\n  auto items = (std::vector<std::vector<RawValue>>)value;\n  for (const std::vector<RawValue> &item : items) {\n    auto nestedArray = std::vector<${structName}>{};\n    for (const RawValue &nestedItem : item) {\n      ${structName} newItem;\n      fromRawValue(context, nestedItem, newItem);\n      nestedArray.emplace_back(newItem);\n    }\n    result.emplace_back(nestedArray);\n  }\n}\n`;\n};\nvar ArrayEnumTemplate = function ArrayEnumTemplate(_ref8) {\n  var enumName = _ref8.enumName,\n    enumMask = _ref8.enumMask,\n    values = _ref8.values,\n    fromCases = _ref8.fromCases,\n    toCases = _ref8.toCases;\n  return `\nusing ${enumMask} = uint32_t;\n\nenum class ${enumName}: ${enumMask} {\n  ${values}\n};\n\nconstexpr bool operator&(\n  ${enumMask} const lhs,\n  enum ${enumName} const rhs) {\n  return lhs & static_cast<${enumMask}>(rhs);\n}\n\nconstexpr ${enumMask} operator|(\n  ${enumMask} const lhs,\n  enum ${enumName} const rhs) {\n  return lhs | static_cast<${enumMask}>(rhs);\n}\n\nconstexpr void operator|=(\n  ${enumMask} &lhs,\n  enum ${enumName} const rhs) {\n  lhs = lhs | static_cast<${enumMask}>(rhs);\n}\n\nstatic inline void fromRawValue(const PropsParserContext& context, const RawValue &value, ${enumMask} &result) {\n  auto items = std::vector<std::string>{value};\n  for (const auto &item : items) {\n    ${fromCases}\n    abort();\n  }\n}\n\nstatic inline std::string toString(const ${enumMask} &value) {\n    auto result = std::string{};\n    auto separator = std::string{\", \"};\n\n    ${toCases}\n    if (!result.empty()) {\n      result.erase(result.length() - separator.length());\n    }\n    return result;\n}\n`.trim();\n};\nfunction getClassExtendString(component) {\n  if (component.extendsProps.length === 0) {\n    throw new Error('Invalid: component.extendsProps is empty');\n  }\n  var extendString = ' : ' + component.extendsProps.map(function (extendProps) {\n    switch (extendProps.type) {\n      case 'ReactNativeBuiltInType':\n        switch (extendProps.knownTypeName) {\n          case 'ReactNativeCoreViewProps':\n            return 'public ViewProps';\n          default:\n            extendProps.knownTypeName;\n            throw new Error('Invalid knownTypeName');\n        }\n      default:\n        extendProps.type;\n        throw new Error('Invalid extended type');\n    }\n  }).join(' ');\n  return extendString;\n}\nfunction convertValueToEnumOption(value) {\n  return toSafeCppString(value);\n}\nfunction generateArrayEnumString(componentName, name, options) {\n  var enumName = getEnumName(componentName, name);\n  var values = options.map(function (option, index) {\n    return `${toSafeCppString(option)} = 1 << ${index}`;\n  }).join(',\\n  ');\n  var fromCases = options.map(function (option) {\n    return `if (item == \"${option}\") {\n      result |= ${enumName}::${toSafeCppString(option)};\n      continue;\n    }`;\n  }).join('\\n    ');\n  var toCases = options.map(function (option) {\n    return `if (value & ${enumName}::${toSafeCppString(option)}) {\n      result += \"${option}\" + separator;\n    }`;\n  }).join('\\n' + '    ');\n  return ArrayEnumTemplate({\n    enumName: enumName,\n    enumMask: getEnumMaskName(enumName),\n    values: values,\n    fromCases: fromCases,\n    toCases: toCases\n  });\n}\nfunction generateStringEnum(componentName, prop) {\n  var typeAnnotation = prop.typeAnnotation;\n  if (typeAnnotation.type === 'StringEnumTypeAnnotation') {\n    var values = typeAnnotation.options;\n    var enumName = getEnumName(componentName, prop.name);\n    var fromCases = values.map(function (value) {\n      return `if (string == \"${value}\") { result = ${enumName}::${convertValueToEnumOption(value)}; return; }`;\n    }).join('\\n' + '  ');\n    var toCases = values.map(function (value) {\n      return `case ${enumName}::${convertValueToEnumOption(value)}: return \"${value}\";`;\n    }).join('\\n' + '    ');\n    return EnumTemplate({\n      enumName: enumName,\n      values: values.map(toSafeCppString).join(', '),\n      fromCases: fromCases,\n      toCases: toCases\n    });\n  }\n  return '';\n}\nfunction generateIntEnum(componentName, prop) {\n  var typeAnnotation = prop.typeAnnotation;\n  if (typeAnnotation.type === 'Int32EnumTypeAnnotation') {\n    var values = typeAnnotation.options;\n    var enumName = getEnumName(componentName, prop.name);\n    var fromCases = values.map(function (value) {\n      return `\n    case ${value}:\n      result = ${enumName}::${toIntEnumValueName(prop.name, value)};\n      return;`;\n    }).join('');\n    var toCases = values.map(function (value) {\n      return `case ${enumName}::${toIntEnumValueName(prop.name, value)}: return \"${value}\";`;\n    }).join('\\n' + '    ');\n    var valueVariables = values.map(function (val) {\n      return `${toIntEnumValueName(prop.name, val)} = ${val}`;\n    }).join(', ');\n    return IntEnumTemplate({\n      enumName: enumName,\n      values: valueVariables,\n      fromCases: fromCases,\n      toCases: toCases\n    });\n  }\n  return '';\n}\nfunction generateEnumString(componentName, component) {\n  return component.props.map(function (prop) {\n    if (prop.typeAnnotation.type === 'ArrayTypeAnnotation' && prop.typeAnnotation.elementType.type === 'StringEnumTypeAnnotation') {\n      return generateArrayEnumString(componentName, prop.name, prop.typeAnnotation.elementType.options);\n    }\n    if (prop.typeAnnotation.type === 'StringEnumTypeAnnotation') {\n      return generateStringEnum(componentName, prop);\n    }\n    if (prop.typeAnnotation.type === 'Int32EnumTypeAnnotation') {\n      return generateIntEnum(componentName, prop);\n    }\n    if (prop.typeAnnotation.type === 'ObjectTypeAnnotation') {\n      return prop.typeAnnotation.properties.map(function (property) {\n        if (property.typeAnnotation.type === 'StringEnumTypeAnnotation') {\n          return generateStringEnum(componentName, property);\n        } else if (property.typeAnnotation.type === 'Int32EnumTypeAnnotation') {\n          return generateIntEnum(componentName, property);\n        }\n        return null;\n      }).filter(Boolean).join('\\n');\n    }\n  }).filter(Boolean).join('\\n');\n}\nfunction generatePropsString(componentName, props) {\n  return props.map(function (prop) {\n    var nativeType = getNativeTypeFromAnnotation(componentName, prop, []);\n    var defaultValue = convertDefaultTypeToString(componentName, prop);\n    return `${nativeType} ${prop.name}{${defaultValue}};`;\n  }).join('\\n' + '  ');\n}\nfunction getExtendsImports(extendsProps) {\n  var imports = new Set();\n  imports.add('#include <react/renderer/core/PropsParserContext.h>');\n  imports.add('#include <jsi/jsi.h>');\n  extendsProps.forEach(function (extendProps) {\n    switch (extendProps.type) {\n      case 'ReactNativeBuiltInType':\n        switch (extendProps.knownTypeName) {\n          case 'ReactNativeCoreViewProps':\n            imports.add('#include <react/renderer/components/view/ViewProps.h>');\n            return;\n          default:\n            extendProps.knownTypeName;\n            throw new Error('Invalid knownTypeName');\n        }\n      default:\n        extendProps.type;\n        throw new Error('Invalid extended type');\n    }\n  });\n  return imports;\n}\nfunction generateStructsForComponent(componentName, component) {\n  var structs = generateStructs(componentName, component.props, []);\n  var structArray = Array.from(structs.values());\n  if (structArray.length < 1) {\n    return '';\n  }\n  return structArray.join('\\n\\n');\n}\nfunction generateStructs(componentName, properties, nameParts) {\n  var structs = new Map();\n  properties.forEach(function (prop) {\n    var typeAnnotation = prop.typeAnnotation;\n    if (typeAnnotation.type === 'ObjectTypeAnnotation') {\n      var elementProperties = typeAnnotation.properties;\n      var nestedStructs = generateStructs(componentName, elementProperties, nameParts.concat([prop.name]));\n      nestedStructs.forEach(function (value, key) {\n        structs.set(key, value);\n      });\n      generateStruct(structs, componentName, nameParts.concat([prop.name]), typeAnnotation.properties);\n    }\n    if (prop.typeAnnotation.type === 'ArrayTypeAnnotation' && prop.typeAnnotation.elementType.type === 'ObjectTypeAnnotation') {\n      var _elementProperties = prop.typeAnnotation.elementType.properties;\n      var _nestedStructs = generateStructs(componentName, _elementProperties, nameParts.concat([prop.name]));\n      _nestedStructs.forEach(function (value, key) {\n        structs.set(key, value);\n      });\n      generateStruct(structs, componentName, nameParts.concat([prop.name]), _elementProperties);\n      structs.set(`${[componentName].concat(_toConsumableArray(nameParts.concat([prop.name]))).join('')}ArrayStruct`, ArrayConversionFunctionTemplate({\n        structName: generateStructName(componentName, nameParts.concat([prop.name]))\n      }));\n    }\n    if (prop.typeAnnotation.type === 'ArrayTypeAnnotation' && prop.typeAnnotation.elementType.type === 'ArrayTypeAnnotation' && prop.typeAnnotation.elementType.elementType.type === 'ObjectTypeAnnotation') {\n      var _elementProperties2 = prop.typeAnnotation.elementType.elementType.properties;\n      var _nestedStructs2 = generateStructs(componentName, _elementProperties2, nameParts.concat([prop.name]));\n      _nestedStructs2.forEach(function (value, key) {\n        structs.set(key, value);\n      });\n      generateStruct(structs, componentName, nameParts.concat([prop.name]), _elementProperties2);\n      structs.set(`${[componentName].concat(_toConsumableArray(nameParts.concat([prop.name]))).join('')}ArrayArrayStruct`, DoubleArrayConversionFunctionTemplate({\n        structName: generateStructName(componentName, nameParts.concat([prop.name]))\n      }));\n    }\n  });\n  return structs;\n}\nfunction generateStruct(structs, componentName, nameParts, properties) {\n  var structNameParts = nameParts;\n  var structName = generateStructName(componentName, structNameParts);\n  var fields = properties.map(function (property) {\n    return `${getNativeTypeFromAnnotation(componentName, property, structNameParts)} ${property.name};`;\n  }).join('\\n' + '  ');\n  properties.forEach(function (property) {\n    var name = property.name;\n    switch (property.typeAnnotation.type) {\n      case 'BooleanTypeAnnotation':\n        return;\n      case 'StringTypeAnnotation':\n        return;\n      case 'Int32TypeAnnotation':\n        return;\n      case 'DoubleTypeAnnotation':\n        return;\n      case 'FloatTypeAnnotation':\n        return;\n      case 'ReservedPropTypeAnnotation':\n        return;\n      case 'ArrayTypeAnnotation':\n        return;\n      case 'StringEnumTypeAnnotation':\n        return;\n      case 'Int32EnumTypeAnnotation':\n        return;\n      case 'ObjectTypeAnnotation':\n        var props = property.typeAnnotation.properties;\n        if (props == null) {\n          throw new Error(`Properties are expected for ObjectTypeAnnotation (see ${name} in ${componentName})`);\n        }\n        generateStruct(structs, componentName, nameParts.concat([name]), props);\n        return;\n      case 'MixedTypeAnnotation':\n        return;\n      default:\n        property.typeAnnotation.type;\n        throw new Error(`Received invalid component property type ${property.typeAnnotation.type}`);\n    }\n  });\n  var fromCases = properties.map(function (property) {\n    var variable = 'tmp_' + property.name;\n    return `auto ${variable} = map.find(\"${property.name}\");\n  if (${variable} != map.end()) {\n    fromRawValue(context, ${variable}->second, result.${property.name});\n  }`;\n  }).join('\\n  ');\n  structs.set(structName, StructTemplate({\n    structName: structName,\n    fields: fields,\n    fromCases: fromCases\n  }));\n}\nmodule.exports = {\n  generate: function generate(libraryName, schema, packageName) {\n    var assumeNonnull = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var fileName = 'Props.h';\n    var allImports = new Set();\n    var componentClasses = Object.keys(schema.modules).map(function (moduleName) {\n      var module = schema.modules[moduleName];\n      if (module.type !== 'Component') {\n        return;\n      }\n      var components = module.components;\n      if (components == null) {\n        return null;\n      }\n      return Object.keys(components).map(function (componentName) {\n        var component = components[componentName];\n        var newName = `${componentName}Props`;\n        var structString = generateStructsForComponent(componentName, component);\n        var enumString = generateEnumString(componentName, component);\n        var propsString = generatePropsString(componentName, component.props);\n        var extendString = getClassExtendString(component);\n        var extendsImports = getExtendsImports(component.extendsProps);\n        var imports = getLocalImports(component.props);\n        extendsImports.forEach(allImports.add, allImports);\n        imports.forEach(allImports.add, allImports);\n        var replacedTemplate = ClassTemplate({\n          enums: enumString,\n          structs: structString,\n          className: newName,\n          extendClasses: extendString,\n          props: propsString\n        });\n        return replacedTemplate;\n      }).join('\\n\\n');\n    }).filter(Boolean).join('\\n\\n');\n    var replacedTemplate = FileTemplate({\n      componentClasses: componentClasses,\n      imports: Array.from(allImports).sort().join('\\n')\n    });\n    return new Map([[fileName, replacedTemplate]]);\n  }\n};","map":{"version":3,"names":["_toConsumableArray","require","_require","getNativeTypeFromAnnotation","getLocalImports","_require2","convertDefaultTypeToString","getEnumMaskName","generateStructName","toIntEnumValueName","_require3","getEnumName","toSafeCppString","FileTemplate","_ref","imports","componentClasses","ClassTemplate","_ref2","enums","structs","className","props","extendClasses","trim","EnumTemplate","_ref3","enumName","values","fromCases","toCases","IntEnumTemplate","_ref4","StructTemplate","_ref5","structName","fields","ArrayConversionFunctionTemplate","_ref6","DoubleArrayConversionFunctionTemplate","_ref7","ArrayEnumTemplate","_ref8","enumMask","getClassExtendString","component","extendsProps","length","Error","extendString","map","extendProps","type","knownTypeName","join","convertValueToEnumOption","value","generateArrayEnumString","componentName","name","options","option","index","generateStringEnum","prop","typeAnnotation","generateIntEnum","valueVariables","val","generateEnumString","elementType","properties","property","filter","Boolean","generatePropsString","nativeType","defaultValue","getExtendsImports","Set","add","forEach","generateStructsForComponent","generateStructs","structArray","Array","from","nameParts","Map","elementProperties","nestedStructs","concat","key","set","generateStruct","structNameParts","variable","module","exports","generate","libraryName","schema","packageName","assumeNonnull","arguments","undefined","fileName","allImports","Object","keys","modules","moduleName","components","newName","structString","enumString","propsString","extendsImports","replacedTemplate","sort"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native/codegen/lib/generators/components/GeneratePropsH.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\n'use strict';\n\nconst _require = require('./ComponentsGeneratorUtils.js'),\n  getNativeTypeFromAnnotation = _require.getNativeTypeFromAnnotation,\n  getLocalImports = _require.getLocalImports;\nconst _require2 = require('./CppHelpers.js'),\n  convertDefaultTypeToString = _require2.convertDefaultTypeToString,\n  getEnumMaskName = _require2.getEnumMaskName,\n  generateStructName = _require2.generateStructName,\n  toIntEnumValueName = _require2.toIntEnumValueName;\nconst _require3 = require('../Utils'),\n  getEnumName = _require3.getEnumName,\n  toSafeCppString = _require3.toSafeCppString;\nconst FileTemplate = ({imports, componentClasses}) => `\n/**\n * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).\n *\n * Do not edit this file as changes may cause incorrect behavior and will be lost\n * once the code is regenerated.\n *\n * ${'@'}generated by codegen project: GeneratePropsH.js\n */\n#pragma once\n\n${imports}\n\nnamespace facebook {\nnamespace react {\n\n${componentClasses}\n\n} // namespace react\n} // namespace facebook\n`;\nconst ClassTemplate = ({enums, structs, className, props, extendClasses}) =>\n  `\n${enums}\n${structs}\nclass JSI_EXPORT ${className} final${extendClasses} {\n public:\n  ${className}() = default;\n  ${className}(const PropsParserContext& context, const ${className} &sourceProps, const RawProps &rawProps);\n\n#pragma mark - Props\n\n  ${props}\n};\n`.trim();\nconst EnumTemplate = ({enumName, values, fromCases, toCases}) =>\n  `\nenum class ${enumName} { ${values} };\n\nstatic inline void fromRawValue(const PropsParserContext& context, const RawValue &value, ${enumName} &result) {\n  auto string = (std::string)value;\n  ${fromCases}\n  abort();\n}\n\nstatic inline std::string toString(const ${enumName} &value) {\n  switch (value) {\n    ${toCases}\n  }\n}\n`.trim();\nconst IntEnumTemplate = ({enumName, values, fromCases, toCases}) =>\n  `\nenum class ${enumName} { ${values} };\n\nstatic inline void fromRawValue(const PropsParserContext& context, const RawValue &value, ${enumName} &result) {\n  assert(value.hasType<int>());\n  auto integerValue = (int)value;\n  switch (integerValue) {${fromCases}\n  }\n  abort();\n}\n\nstatic inline std::string toString(const ${enumName} &value) {\n  switch (value) {\n    ${toCases}\n  }\n}\n`.trim();\nconst StructTemplate = ({structName, fields, fromCases}) =>\n  `struct ${structName} {\n  ${fields}\n};\n\nstatic inline void fromRawValue(const PropsParserContext& context, const RawValue &value, ${structName} &result) {\n  auto map = (butter::map<std::string, RawValue>)value;\n\n  ${fromCases}\n}\n\nstatic inline std::string toString(const ${structName} &value) {\n  return \"[Object ${structName}]\";\n}\n`.trim();\nconst ArrayConversionFunctionTemplate = ({\n  structName,\n}) => `static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<${structName}> &result) {\n  auto items = (std::vector<RawValue>)value;\n  for (const auto &item : items) {\n    ${structName} newItem;\n    fromRawValue(context, item, newItem);\n    result.emplace_back(newItem);\n  }\n}\n`;\nconst DoubleArrayConversionFunctionTemplate = ({\n  structName,\n}) => `static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<std::vector<${structName}>> &result) {\n  auto items = (std::vector<std::vector<RawValue>>)value;\n  for (const std::vector<RawValue> &item : items) {\n    auto nestedArray = std::vector<${structName}>{};\n    for (const RawValue &nestedItem : item) {\n      ${structName} newItem;\n      fromRawValue(context, nestedItem, newItem);\n      nestedArray.emplace_back(newItem);\n    }\n    result.emplace_back(nestedArray);\n  }\n}\n`;\nconst ArrayEnumTemplate = ({enumName, enumMask, values, fromCases, toCases}) =>\n  `\nusing ${enumMask} = uint32_t;\n\nenum class ${enumName}: ${enumMask} {\n  ${values}\n};\n\nconstexpr bool operator&(\n  ${enumMask} const lhs,\n  enum ${enumName} const rhs) {\n  return lhs & static_cast<${enumMask}>(rhs);\n}\n\nconstexpr ${enumMask} operator|(\n  ${enumMask} const lhs,\n  enum ${enumName} const rhs) {\n  return lhs | static_cast<${enumMask}>(rhs);\n}\n\nconstexpr void operator|=(\n  ${enumMask} &lhs,\n  enum ${enumName} const rhs) {\n  lhs = lhs | static_cast<${enumMask}>(rhs);\n}\n\nstatic inline void fromRawValue(const PropsParserContext& context, const RawValue &value, ${enumMask} &result) {\n  auto items = std::vector<std::string>{value};\n  for (const auto &item : items) {\n    ${fromCases}\n    abort();\n  }\n}\n\nstatic inline std::string toString(const ${enumMask} &value) {\n    auto result = std::string{};\n    auto separator = std::string{\", \"};\n\n    ${toCases}\n    if (!result.empty()) {\n      result.erase(result.length() - separator.length());\n    }\n    return result;\n}\n`.trim();\nfunction getClassExtendString(component) {\n  if (component.extendsProps.length === 0) {\n    throw new Error('Invalid: component.extendsProps is empty');\n  }\n  const extendString =\n    ' : ' +\n    component.extendsProps\n      .map(extendProps => {\n        switch (extendProps.type) {\n          case 'ReactNativeBuiltInType':\n            switch (extendProps.knownTypeName) {\n              case 'ReactNativeCoreViewProps':\n                return 'public ViewProps';\n              default:\n                extendProps.knownTypeName;\n                throw new Error('Invalid knownTypeName');\n            }\n          default:\n            extendProps.type;\n            throw new Error('Invalid extended type');\n        }\n      })\n      .join(' ');\n  return extendString;\n}\nfunction convertValueToEnumOption(value) {\n  return toSafeCppString(value);\n}\nfunction generateArrayEnumString(componentName, name, options) {\n  const enumName = getEnumName(componentName, name);\n  const values = options\n    .map((option, index) => `${toSafeCppString(option)} = 1 << ${index}`)\n    .join(',\\n  ');\n  const fromCases = options\n    .map(\n      option => `if (item == \"${option}\") {\n      result |= ${enumName}::${toSafeCppString(option)};\n      continue;\n    }`,\n    )\n    .join('\\n    ');\n  const toCases = options\n    .map(\n      option => `if (value & ${enumName}::${toSafeCppString(option)}) {\n      result += \"${option}\" + separator;\n    }`,\n    )\n    .join('\\n' + '    ');\n  return ArrayEnumTemplate({\n    enumName,\n    enumMask: getEnumMaskName(enumName),\n    values,\n    fromCases,\n    toCases,\n  });\n}\nfunction generateStringEnum(componentName, prop) {\n  const typeAnnotation = prop.typeAnnotation;\n  if (typeAnnotation.type === 'StringEnumTypeAnnotation') {\n    const values = typeAnnotation.options;\n    const enumName = getEnumName(componentName, prop.name);\n    const fromCases = values\n      .map(\n        value =>\n          `if (string == \"${value}\") { result = ${enumName}::${convertValueToEnumOption(\n            value,\n          )}; return; }`,\n      )\n      .join('\\n' + '  ');\n    const toCases = values\n      .map(\n        value =>\n          `case ${enumName}::${convertValueToEnumOption(\n            value,\n          )}: return \"${value}\";`,\n      )\n      .join('\\n' + '    ');\n    return EnumTemplate({\n      enumName,\n      values: values.map(toSafeCppString).join(', '),\n      fromCases: fromCases,\n      toCases: toCases,\n    });\n  }\n  return '';\n}\nfunction generateIntEnum(componentName, prop) {\n  const typeAnnotation = prop.typeAnnotation;\n  if (typeAnnotation.type === 'Int32EnumTypeAnnotation') {\n    const values = typeAnnotation.options;\n    const enumName = getEnumName(componentName, prop.name);\n    const fromCases = values\n      .map(\n        value => `\n    case ${value}:\n      result = ${enumName}::${toIntEnumValueName(prop.name, value)};\n      return;`,\n      )\n      .join('');\n    const toCases = values\n      .map(\n        value =>\n          `case ${enumName}::${toIntEnumValueName(\n            prop.name,\n            value,\n          )}: return \"${value}\";`,\n      )\n      .join('\\n' + '    ');\n    const valueVariables = values\n      .map(val => `${toIntEnumValueName(prop.name, val)} = ${val}`)\n      .join(', ');\n    return IntEnumTemplate({\n      enumName,\n      values: valueVariables,\n      fromCases,\n      toCases,\n    });\n  }\n  return '';\n}\nfunction generateEnumString(componentName, component) {\n  return component.props\n    .map(prop => {\n      if (\n        prop.typeAnnotation.type === 'ArrayTypeAnnotation' &&\n        prop.typeAnnotation.elementType.type === 'StringEnumTypeAnnotation'\n      ) {\n        return generateArrayEnumString(\n          componentName,\n          prop.name,\n          prop.typeAnnotation.elementType.options,\n        );\n      }\n      if (prop.typeAnnotation.type === 'StringEnumTypeAnnotation') {\n        return generateStringEnum(componentName, prop);\n      }\n      if (prop.typeAnnotation.type === 'Int32EnumTypeAnnotation') {\n        return generateIntEnum(componentName, prop);\n      }\n      if (prop.typeAnnotation.type === 'ObjectTypeAnnotation') {\n        return prop.typeAnnotation.properties\n          .map(property => {\n            if (property.typeAnnotation.type === 'StringEnumTypeAnnotation') {\n              return generateStringEnum(componentName, property);\n            } else if (\n              property.typeAnnotation.type === 'Int32EnumTypeAnnotation'\n            ) {\n              return generateIntEnum(componentName, property);\n            }\n            return null;\n          })\n          .filter(Boolean)\n          .join('\\n');\n      }\n    })\n    .filter(Boolean)\n    .join('\\n');\n}\nfunction generatePropsString(componentName, props) {\n  return props\n    .map(prop => {\n      const nativeType = getNativeTypeFromAnnotation(componentName, prop, []);\n      const defaultValue = convertDefaultTypeToString(componentName, prop);\n      return `${nativeType} ${prop.name}{${defaultValue}};`;\n    })\n    .join('\\n' + '  ');\n}\nfunction getExtendsImports(extendsProps) {\n  const imports = new Set();\n  imports.add('#include <react/renderer/core/PropsParserContext.h>');\n  imports.add('#include <jsi/jsi.h>');\n  extendsProps.forEach(extendProps => {\n    switch (extendProps.type) {\n      case 'ReactNativeBuiltInType':\n        switch (extendProps.knownTypeName) {\n          case 'ReactNativeCoreViewProps':\n            imports.add(\n              '#include <react/renderer/components/view/ViewProps.h>',\n            );\n            return;\n          default:\n            extendProps.knownTypeName;\n            throw new Error('Invalid knownTypeName');\n        }\n      default:\n        extendProps.type;\n        throw new Error('Invalid extended type');\n    }\n  });\n  return imports;\n}\nfunction generateStructsForComponent(componentName, component) {\n  const structs = generateStructs(componentName, component.props, []);\n  const structArray = Array.from(structs.values());\n  if (structArray.length < 1) {\n    return '';\n  }\n  return structArray.join('\\n\\n');\n}\nfunction generateStructs(componentName, properties, nameParts) {\n  const structs = new Map();\n  properties.forEach(prop => {\n    const typeAnnotation = prop.typeAnnotation;\n    if (typeAnnotation.type === 'ObjectTypeAnnotation') {\n      // Recursively visit all of the object properties.\n      // Note: this is depth first so that the nested structs are ordered first.\n      const elementProperties = typeAnnotation.properties;\n      const nestedStructs = generateStructs(\n        componentName,\n        elementProperties,\n        nameParts.concat([prop.name]),\n      );\n      nestedStructs.forEach(function (value, key) {\n        structs.set(key, value);\n      });\n      generateStruct(\n        structs,\n        componentName,\n        nameParts.concat([prop.name]),\n        typeAnnotation.properties,\n      );\n    }\n    if (\n      prop.typeAnnotation.type === 'ArrayTypeAnnotation' &&\n      prop.typeAnnotation.elementType.type === 'ObjectTypeAnnotation'\n    ) {\n      // Recursively visit all of the object properties.\n      // Note: this is depth first so that the nested structs are ordered first.\n      const elementProperties = prop.typeAnnotation.elementType.properties;\n      const nestedStructs = generateStructs(\n        componentName,\n        elementProperties,\n        nameParts.concat([prop.name]),\n      );\n      nestedStructs.forEach(function (value, key) {\n        structs.set(key, value);\n      });\n\n      // Generate this struct and its conversion function.\n      generateStruct(\n        structs,\n        componentName,\n        nameParts.concat([prop.name]),\n        elementProperties,\n      );\n\n      // Generate the conversion function for std:vector<Object>.\n      // Note: This needs to be at the end since it references the struct above.\n      structs.set(\n        `${[componentName, ...nameParts.concat([prop.name])].join(\n          '',\n        )}ArrayStruct`,\n        ArrayConversionFunctionTemplate({\n          structName: generateStructName(\n            componentName,\n            nameParts.concat([prop.name]),\n          ),\n        }),\n      );\n    }\n    if (\n      prop.typeAnnotation.type === 'ArrayTypeAnnotation' &&\n      prop.typeAnnotation.elementType.type === 'ArrayTypeAnnotation' &&\n      prop.typeAnnotation.elementType.elementType.type ===\n        'ObjectTypeAnnotation'\n    ) {\n      // Recursively visit all of the object properties.\n      // Note: this is depth first so that the nested structs are ordered first.\n      const elementProperties =\n        prop.typeAnnotation.elementType.elementType.properties;\n      const nestedStructs = generateStructs(\n        componentName,\n        elementProperties,\n        nameParts.concat([prop.name]),\n      );\n      nestedStructs.forEach(function (value, key) {\n        structs.set(key, value);\n      });\n\n      // Generate this struct and its conversion function.\n      generateStruct(\n        structs,\n        componentName,\n        nameParts.concat([prop.name]),\n        elementProperties,\n      );\n\n      // Generate the conversion function for std:vector<Object>.\n      // Note: This needs to be at the end since it references the struct above.\n      structs.set(\n        `${[componentName, ...nameParts.concat([prop.name])].join(\n          '',\n        )}ArrayArrayStruct`,\n        DoubleArrayConversionFunctionTemplate({\n          structName: generateStructName(\n            componentName,\n            nameParts.concat([prop.name]),\n          ),\n        }),\n      );\n    }\n  });\n  return structs;\n}\nfunction generateStruct(structs, componentName, nameParts, properties) {\n  const structNameParts = nameParts;\n  const structName = generateStructName(componentName, structNameParts);\n  const fields = properties\n    .map(property => {\n      return `${getNativeTypeFromAnnotation(\n        componentName,\n        property,\n        structNameParts,\n      )} ${property.name};`;\n    })\n    .join('\\n' + '  ');\n  properties.forEach(property => {\n    const name = property.name;\n    switch (property.typeAnnotation.type) {\n      case 'BooleanTypeAnnotation':\n        return;\n      case 'StringTypeAnnotation':\n        return;\n      case 'Int32TypeAnnotation':\n        return;\n      case 'DoubleTypeAnnotation':\n        return;\n      case 'FloatTypeAnnotation':\n        return;\n      case 'ReservedPropTypeAnnotation':\n        return;\n      case 'ArrayTypeAnnotation':\n        return;\n      case 'StringEnumTypeAnnotation':\n        return;\n      case 'Int32EnumTypeAnnotation':\n        return;\n      case 'ObjectTypeAnnotation':\n        const props = property.typeAnnotation.properties;\n        if (props == null) {\n          throw new Error(\n            `Properties are expected for ObjectTypeAnnotation (see ${name} in ${componentName})`,\n          );\n        }\n        generateStruct(structs, componentName, nameParts.concat([name]), props);\n        return;\n      case 'MixedTypeAnnotation':\n        return;\n      default:\n        property.typeAnnotation.type;\n        throw new Error(\n          `Received invalid component property type ${property.typeAnnotation.type}`,\n        );\n    }\n  });\n  const fromCases = properties\n    .map(property => {\n      const variable = 'tmp_' + property.name;\n      return `auto ${variable} = map.find(\"${property.name}\");\n  if (${variable} != map.end()) {\n    fromRawValue(context, ${variable}->second, result.${property.name});\n  }`;\n    })\n    .join('\\n  ');\n  structs.set(\n    structName,\n    StructTemplate({\n      structName,\n      fields,\n      fromCases,\n    }),\n  );\n}\nmodule.exports = {\n  generate(libraryName, schema, packageName, assumeNonnull = false) {\n    const fileName = 'Props.h';\n    const allImports = new Set();\n    const componentClasses = Object.keys(schema.modules)\n      .map(moduleName => {\n        const module = schema.modules[moduleName];\n        if (module.type !== 'Component') {\n          return;\n        }\n        const components = module.components;\n        // No components in this module\n        if (components == null) {\n          return null;\n        }\n        return Object.keys(components)\n          .map(componentName => {\n            const component = components[componentName];\n            const newName = `${componentName}Props`;\n            const structString = generateStructsForComponent(\n              componentName,\n              component,\n            );\n            const enumString = generateEnumString(componentName, component);\n            const propsString = generatePropsString(\n              componentName,\n              component.props,\n            );\n            const extendString = getClassExtendString(component);\n            const extendsImports = getExtendsImports(component.extendsProps);\n            const imports = getLocalImports(component.props);\n\n            // $FlowFixMe[method-unbinding] added when improving typing for this parameters\n            extendsImports.forEach(allImports.add, allImports);\n            // $FlowFixMe[method-unbinding] added when improving typing for this parameters\n            imports.forEach(allImports.add, allImports);\n            const replacedTemplate = ClassTemplate({\n              enums: enumString,\n              structs: structString,\n              className: newName,\n              extendClasses: extendString,\n              props: propsString,\n            });\n            return replacedTemplate;\n          })\n          .join('\\n\\n');\n      })\n      .filter(Boolean)\n      .join('\\n\\n');\n    const replacedTemplate = FileTemplate({\n      componentClasses,\n      imports: Array.from(allImports).sort().join('\\n'),\n    });\n    return new Map([[fileName, replacedTemplate]]);\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}