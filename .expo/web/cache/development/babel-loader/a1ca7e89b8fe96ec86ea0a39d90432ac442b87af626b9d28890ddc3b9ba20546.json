{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar Log = _interopRequireWildcard(require(\"../../log\"));\nvar _errors = require(\"../../utils/errors\");\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nvar CTRL_C = \"\\x03\";\nvar debug = require(\"debug\")(\"expo:start:interface:keyPressHandler\");\nvar KeyPressHandler = function () {\n  function KeyPressHandler(onPress) {\n    var _this = this;\n    _classCallCheck(this, KeyPressHandler);\n    this.onPress = onPress;\n    this.isInterceptingKeyStrokes = false;\n    this.isHandlingKeyPress = false;\n    this.handleKeypress = function () {\n      var _ref = _asyncToGenerator(function* (key) {\n        if (_this.isHandlingKeyPress && key !== CTRL_C) {\n          return;\n        }\n        _this.isHandlingKeyPress = true;\n        try {\n          debug(`Key pressed: ${key}`);\n          yield _this.onPress(key);\n        } catch (error) {\n          yield (0, _errors).logCmdError(error);\n        } finally {\n          _this.isHandlingKeyPress = false;\n        }\n      });\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n  }\n  _createClass(KeyPressHandler, [{\n    key: \"createInteractionListener\",\n    value: function createInteractionListener() {\n      var _this2 = this;\n      var wasIntercepting = false;\n      var listener = function listener(_ref2) {\n        var pause = _ref2.pause;\n        if (pause) {\n          wasIntercepting = _this2.isInterceptingKeyStrokes;\n          _this2.stopInterceptingKeyStrokes();\n        } else if (wasIntercepting) {\n          _this2.startInterceptingKeyStrokes();\n        }\n      };\n      return listener;\n    }\n  }, {\n    key: \"startInterceptingKeyStrokes\",\n    value: function startInterceptingKeyStrokes() {\n      if (this.isInterceptingKeyStrokes) {\n        return;\n      }\n      this.isInterceptingKeyStrokes = true;\n      var _process = process,\n        stdin = _process.stdin;\n      if (!stdin.setRawMode) {\n        Log.warn(\"Using a non-interactive terminal, keyboard commands are disabled.\");\n        return;\n      }\n      stdin.setRawMode(true);\n      stdin.resume();\n      stdin.setEncoding(\"utf8\");\n      stdin.on(\"data\", this.handleKeypress);\n    }\n  }, {\n    key: \"stopInterceptingKeyStrokes\",\n    value: function stopInterceptingKeyStrokes() {\n      if (!this.isInterceptingKeyStrokes) {\n        return;\n      }\n      this.isInterceptingKeyStrokes = false;\n      var _process2 = process,\n        stdin = _process2.stdin;\n      stdin.removeListener(\"data\", this.handleKeypress);\n      if (!stdin.setRawMode) {\n        Log.warn(\"Using a non-interactive terminal, keyboard commands are disabled.\");\n        return;\n      }\n      stdin.setRawMode(false);\n      stdin.resume();\n    }\n  }]);\n  return KeyPressHandler;\n}();\nexports.KeyPressHandler = KeyPressHandler;","map":{"version":3,"names":["_asyncToGenerator","require","_classCallCheck","_createClass","Log","_interopRequireWildcard","_errors","CTRL_C","debug","KeyPressHandler","onPress","_this","isInterceptingKeyStrokes","isHandlingKeyPress","handleKeypress","_ref","key","error","logCmdError","_x","apply","arguments","value","createInteractionListener","_this2","wasIntercepting","listener","_ref2","pause","stopInterceptingKeyStrokes","startInterceptingKeyStrokes","_process","process","stdin","setRawMode","warn","resume","setEncoding","on","_process2","removeListener"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\cli\\src\\start\\interface\\KeyPressHandler.ts"],"sourcesContent":["import * as Log from '../../log';\nimport { logCmdError } from '../../utils/errors';\n\nconst CTRL_C = '\\u0003';\n\nconst debug = require('debug')('expo:start:interface:keyPressHandler') as typeof console.log;\n\n/** An abstract key stroke interceptor. */\nexport class KeyPressHandler {\n  private isInterceptingKeyStrokes = false;\n  private isHandlingKeyPress = false;\n\n  constructor(public onPress: (key: string) => Promise<any>) {}\n\n  /** Start observing interaction pause listeners. */\n  createInteractionListener() {\n    // Support observing prompts.\n    let wasIntercepting = false;\n\n    const listener = ({ pause }: { pause: boolean }) => {\n      if (pause) {\n        // Track if we were already intercepting key strokes before pausing, so we can\n        // resume after pausing.\n        wasIntercepting = this.isInterceptingKeyStrokes;\n        this.stopInterceptingKeyStrokes();\n      } else if (wasIntercepting) {\n        // Only start if we were previously intercepting.\n        this.startInterceptingKeyStrokes();\n      }\n    };\n\n    return listener;\n  }\n\n  private handleKeypress = async (key: string) => {\n    // Prevent sending another event until the previous event has finished.\n    if (this.isHandlingKeyPress && key !== CTRL_C) {\n      return;\n    }\n    this.isHandlingKeyPress = true;\n    try {\n      debug(`Key pressed: ${key}`);\n      await this.onPress(key);\n    } catch (error: any) {\n      await logCmdError(error);\n    } finally {\n      this.isHandlingKeyPress = false;\n    }\n  };\n\n  /** Start intercepting all key strokes and passing them to the input `onPress` method. */\n  startInterceptingKeyStrokes() {\n    if (this.isInterceptingKeyStrokes) {\n      return;\n    }\n    this.isInterceptingKeyStrokes = true;\n    const { stdin } = process;\n    // TODO: This might be here because of an old Node version.\n    if (!stdin.setRawMode) {\n      Log.warn('Using a non-interactive terminal, keyboard commands are disabled.');\n      return;\n    }\n    stdin.setRawMode(true);\n    stdin.resume();\n    stdin.setEncoding('utf8');\n    stdin.on('data', this.handleKeypress);\n  }\n\n  /** Stop intercepting all key strokes. */\n  stopInterceptingKeyStrokes() {\n    if (!this.isInterceptingKeyStrokes) {\n      return;\n    }\n    this.isInterceptingKeyStrokes = false;\n    const { stdin } = process;\n    stdin.removeListener('data', this.handleKeypress);\n    // TODO: This might be here because of an old Node version.\n    if (!stdin.setRawMode) {\n      Log.warn('Using a non-interactive terminal, keyboard commands are disabled.');\n      return;\n    }\n    stdin.setRawMode(false);\n    stdin.resume();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}