{"ast":null,"code":"export {};","map":{"version":3,"names":[],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native-community/cli-doctor/node_modules/yaml/dist/parse/cst-scalar.d.ts"],"sourcesContent":["import { ErrorCode } from '../errors.js';\nimport { Range } from '../nodes/Node.js';\nimport type { Scalar } from '../nodes/Scalar.js';\nimport type { BlockScalar, FlowScalar, SourceToken, Token } from './cst.js';\n/**\n * If `token` is a CST flow or block scalar, determine its string value and a few other attributes.\n * Otherwise, return `null`.\n */\nexport declare function resolveAsScalar(token: FlowScalar | BlockScalar, strict?: boolean, onError?: (offset: number, code: ErrorCode, message: string) => void): {\n    value: string;\n    type: Scalar.Type | null;\n    comment: string;\n    range: Range;\n};\nexport declare function resolveAsScalar(token: Token | null | undefined, strict?: boolean, onError?: (offset: number, code: ErrorCode, message: string) => void): {\n    value: string;\n    type: Scalar.Type | null;\n    comment: string;\n    range: Range;\n} | null;\n/**\n * Create a new scalar token with `value`\n *\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\n * as this function does not support any schema operations and won't check for such conflicts.\n *\n * @param value The string representation of the value, which will have its content properly indented.\n * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\n * @param context.indent The indent level of the token.\n * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.\n * @param context.offset The offset position of the token.\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\n */\nexport declare function createScalarToken(value: string, context: {\n    end?: SourceToken[];\n    implicitKey?: boolean;\n    indent: number;\n    inFlow?: boolean;\n    offset?: number;\n    type?: Scalar.Type;\n}): BlockScalar | FlowScalar;\n/**\n * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.\n *\n * Best efforts are made to retain any comments previously associated with the `token`,\n * though all contents within a collection's `items` will be overwritten.\n *\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\n * as this function does not support any schema operations and won't check for such conflicts.\n *\n * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.\n * @param value The string representation of the value, which will have its content properly indented.\n * @param context.afterKey In most cases, values after a key should have an additional level of indentation.\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\n * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\n */\nexport declare function setScalarValue(token: Token, value: string, context?: {\n    afterKey?: boolean;\n    implicitKey?: boolean;\n    inFlow?: boolean;\n    type?: Scalar.Type;\n}): void;\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}