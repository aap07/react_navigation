{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isUrlAvailableAsync = isUrlAvailableAsync;\nexports.isUrlOk = isUrlOk;\nexports.validateUrl = validateUrl;\nexports.stripPort = stripPort;\nexports.stripExtension = stripExtension;\nvar _dns = _interopRequireDefault(require(\"dns\"));\nvar _url = require(\"url\");\nvar _client = require(\"../api/rest/client\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction isUrlAvailableAsync(url) {\n  return new Promise(function (resolve) {\n    _dns.default.lookup(url, function (err) {\n      resolve(!err);\n    });\n  });\n}\nfunction isUrlOk(_x) {\n  return _isUrlOk.apply(this, arguments);\n}\nfunction _isUrlOk() {\n  _isUrlOk = _asyncToGenerator(function* (url) {\n    try {\n      var res = yield (0, _client).fetchAsync(url);\n      return res.ok;\n    } catch (_unused2) {\n      return false;\n    }\n  });\n  return _isUrlOk.apply(this, arguments);\n}\nfunction validateUrl(urlString) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    protocols = _ref.protocols,\n    requireProtocol = _ref.requireProtocol;\n  try {\n    var results = new _url.URL(urlString);\n    if (!results.protocol && !requireProtocol) {\n      return true;\n    }\n    return protocols ? results.protocol ? protocols.map(function (x) {\n      return `${x.toLowerCase()}:`;\n    }).includes(results.protocol) : false : true;\n  } catch (_unused) {\n    return false;\n  }\n}\nfunction stripPort(host) {\n  var ref;\n  var ref1;\n  return (ref1 = (ref = coerceUrl(host)) == null ? void 0 : ref.hostname) != null ? ref1 : null;\n}\nfunction coerceUrl(urlString) {\n  if (!urlString) {\n    return null;\n  }\n  try {\n    return new _url.URL(\"/\", urlString);\n  } catch (error) {\n    if (error.code !== \"ERR_INVALID_URL\") {\n      throw error;\n    }\n    return new _url.URL(\"/\", `http://${urlString}`);\n  }\n}\nfunction stripExtension(url, extension) {\n  return url.replace(new RegExp(`.${extension}$`), \"\");\n}","map":{"version":3,"names":["_asyncToGenerator","require","isUrlAvailableAsync","isUrlOk","validateUrl","stripPort","stripExtension","_dns","_interopRequireDefault","_url","_client","url","Promise","resolve","default","lookup","err","_x","_isUrlOk","apply","arguments","res","fetchAsync","ok","_unused2","urlString","_ref","length","undefined","protocols","requireProtocol","results","URL","protocol","map","x","toLowerCase","includes","_unused","host","ref","ref1","coerceUrl","hostname","error","code","extension","replace","RegExp"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\cli\\src\\utils\\url.ts"],"sourcesContent":["import dns from 'dns';\nimport { URL } from 'url';\n\nimport { fetchAsync } from '../api/rest/client';\n\n/** Check if a server is available based on the URL. */\nexport function isUrlAvailableAsync(url: string): Promise<boolean> {\n  return new Promise<boolean>((resolve) => {\n    dns.lookup(url, (err) => {\n      resolve(!err);\n    });\n  });\n}\n\n/** Check if a request to the given URL is `ok` (status 200). */\nexport async function isUrlOk(url: string): Promise<boolean> {\n  try {\n    const res = await fetchAsync(url);\n    return res.ok;\n  } catch {\n    return false;\n  }\n}\n\n/** Determine if a string is a valid URL, can optionally ensure certain protocols (like `https` or `exp`) are adhered to. */\nexport function validateUrl(\n  urlString: string,\n  {\n    protocols,\n    requireProtocol,\n  }: {\n    /** Set of allowed protocols for the string to adhere to. @example ['exp', 'https'] */\n    protocols?: string[];\n    /** Ensure the URL has a protocol component (prefix before `://`). */\n    requireProtocol?: boolean;\n  } = {}\n) {\n  try {\n    const results = new URL(urlString);\n    if (!results.protocol && !requireProtocol) {\n      return true;\n    }\n    return protocols\n      ? results.protocol\n        ? protocols.map((x) => `${x.toLowerCase()}:`).includes(results.protocol)\n        : false\n      : true;\n  } catch {\n    return false;\n  }\n}\n\n/** Remove the port from a given `host` URL string. */\nexport function stripPort(host?: string): string | null {\n  return coerceUrl(host)?.hostname ?? null;\n}\n\nfunction coerceUrl(urlString?: string): URL | null {\n  if (!urlString) {\n    return null;\n  }\n  try {\n    return new URL('/', urlString);\n  } catch (error: any) {\n    if (error.code !== 'ERR_INVALID_URL') {\n      throw error;\n    }\n    return new URL('/', `http://${urlString}`);\n  }\n}\n\n/** Strip a given extension from a URL string. */\nexport function stripExtension(url: string, extension: string): string {\n  return url.replace(new RegExp(`.${extension}$`), '');\n}\n"],"mappings":"AAAA;;AAAA,IAAAA,iBAAA,GAAAC,OAAA;;;;QAMgBC,mBAAmB,GAAnBA,mBAAmB;QASbC,OAAO,GAAPA,OAAO;QAUbC,WAAW,GAAXA,WAAW;QA4BXC,SAAS,GAATA,SAAS;QAmBTC,cAAc,GAAdA,cAAc;AAxEd,IAAAC,IAAK,GAAAC,sBAAA,CAAAP,OAAA,CAAL,KAAK;AACD,IAAAQ,IAAK,GAAAR,OAAA,CAAL,KAAK;AAEE,IAAAS,OAAoB,GAAAT,OAAA;;;;;;AAGxC,SAASC,mBAAmBA,CAACS,GAAW,EAAoB;EACjE,OAAO,IAAIC,OAAO,CAAU,UAACC,OAAO,EAAK;IACvCN,IAAG,CAAAO,OAAA,CAACC,MAAM,CAACJ,GAAG,EAAE,UAACK,GAAG,EAAK;MACvBH,OAAO,CAAC,CAACG,GAAG,CAAC;KACd,CAAC;GACH,CAAC;;AACH,SAGqBb,OAAOA,CAAAc,EAAA;EAAA,OAAAC,QAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAF,SAAA;EAAAA,QAAA,GAAAlB,iBAAA,CAAtB,WAAuBW,GAAW,EAAoB;IAC3D,IAAI;MACF,IAAMU,GAAG,SAAS,IAAAX,OAAU,EAAKY,UAAL,CAACX,GAAG,CAAC;MACjC,OAAOU,GAAG,CAACE,EAAE;KACd,CAAC,OAAAC,QAAA,EAAM;MACN,OAAO,KAAK;;GAEf;EAAA,OAAAN,QAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAGM,SAAShB,WAAWA,CACzBqB,SAAiB,EAUjB;EAAA,IAAAC,IAAA,GAAAN,SAAA,CAAAO,MAAA,QAAAP,SAAA,QAAAQ,SAAA,GAAAR,SAAA,MADI,EAAE;IAPJS,SAAS,GAAAH,IAAA,CAATG,SAAS;IACTC,eAAe,GAAAJ,IAAA,CAAfI,eAAe;EAQjB,IAAI;IACF,IAAMC,OAAO,GAAG,IAAItB,IAAG,CAAAuB,GAAA,CAACP,SAAS,CAAC;IAClC,IAAI,CAACM,OAAO,CAACE,QAAQ,IAAI,CAACH,eAAe,EAAE;MACzC,OAAO,IAAI;;IAEb,OAAOD,SAAS,GACZE,OAAO,CAACE,QAAQ,GACdJ,SAAS,CAACK,GAAG,CAAC,UAACC,CAAC;MAAA,OAAM,GAAEA,CAAC,CAACC,WAAW,EAAG,GAAE;IAAA,EAAC,CAACC,QAAQ,CAACN,OAAO,CAACE,QAAQ,CAAC,GACtE,KAAK,GACP,IAAI;GACT,CAAC,OAAAK,OAAA,EAAM;IACN,OAAO,KAAK;;;AAKT,SAASjC,SAASA,CAACkC,IAAa,EAAiB;MAC/CC,GAAe;MAAfC,IAAyB;EAAhC,OAAO,CAAAA,IAAyB,GAAzB,CAAAD,GAAe,GAAfE,SAAS,CAACH,IAAI,CAAC,SAAU,GAAzB,MAAyB,GAAzBC,GAAe,CAAEG,QAAQ,YAAzBF,IAAyB,GAAI,IAAI;;AAG1C,SAASC,SAASA,CAACjB,SAAkB,EAAc;EACjD,IAAI,CAACA,SAAS,EAAE;IACd,OAAO,IAAI;;EAEb,IAAI;IACF,OAAO,IAAIhB,IAAG,CAAAuB,GAAA,CAAC,GAAG,EAAEP,SAAS,CAAC;GAC/B,CAAC,OAAOmB,KAAK,EAAO;IACnB,IAAIA,KAAK,CAACC,IAAI,KAAK,iBAAiB,EAAE;MACpC,MAAMD,KAAK;;IAEb,OAAO,IAAInC,IAAG,CAAAuB,GAAA,CAAC,GAAG,EAAG,UAASP,SAAU,EAAC,CAAC;;;AAKvC,SAASnB,cAAcA,CAACK,GAAW,EAAEmC,SAAiB,EAAU;EACrE,OAAOnC,GAAG,CAACoC,OAAO,CAAC,IAAIC,MAAM,CAAE,IAAGF,SAAU,GAAE,CAAC,EAAE,EAAE,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}