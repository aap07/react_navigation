{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError('Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.');\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === 'string') return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === 'Object' && o.constructor) n = o.constructor.name;\n  if (n === 'Map' || n === 'Set') return Array.from(o);\n  if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : 'undefined' != typeof Symbol && arr[Symbol.iterator] || arr['@@iterator'];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, 'string');\n  return typeof key === 'symbol' ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== 'object' || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || 'default');\n    if (typeof res !== 'object') return res;\n    throw new TypeError('@@toPrimitive must return a primitive value.');\n  }\n  return (hint === 'string' ? String : Number)(input);\n}\nvar _require = require(\"../../Utils\"),\n  capitalize = _require.capitalize;\nvar _require2 = require(\"../../../parsers/parsers-commons\"),\n  unwrapNullable = _require2.unwrapNullable,\n  wrapNullable = _require2.wrapNullable;\nvar StructCollector = function () {\n  function StructCollector() {\n    _classCallCheck(this, StructCollector);\n    _defineProperty(this, '_structs', new Map());\n  }\n  _createClass(StructCollector, [{\n    key: \"process\",\n    value: function process(structName, structContext, resolveAlias, nullableTypeAnnotation) {\n      var _unwrapNullable = unwrapNullable(nullableTypeAnnotation),\n        _unwrapNullable2 = _slicedToArray(_unwrapNullable, 2),\n        typeAnnotation = _unwrapNullable2[0],\n        nullable = _unwrapNullable2[1];\n      switch (typeAnnotation.type) {\n        case 'ObjectTypeAnnotation':\n          {\n            this._insertStruct(structName, structContext, resolveAlias, typeAnnotation);\n            return wrapNullable(nullable, {\n              type: 'TypeAliasTypeAnnotation',\n              name: structName\n            });\n          }\n        case 'ArrayTypeAnnotation':\n          {\n            if (typeAnnotation.elementType == null) {\n              return wrapNullable(nullable, {\n                type: 'ArrayTypeAnnotation'\n              });\n            }\n            return wrapNullable(nullable, {\n              type: 'ArrayTypeAnnotation',\n              elementType: this.process(structName + 'Element', structContext, resolveAlias, typeAnnotation.elementType)\n            });\n          }\n        case 'TypeAliasTypeAnnotation':\n          {\n            this._insertAlias(typeAnnotation.name, structContext, resolveAlias);\n            return wrapNullable(nullable, typeAnnotation);\n          }\n        case 'EnumDeclaration':\n          return wrapNullable(nullable, typeAnnotation);\n        case 'MixedTypeAnnotation':\n          throw new Error('Mixed types are unsupported in structs');\n        case 'UnionTypeAnnotation':\n          throw new Error('Union types are unsupported in structs');\n        default:\n          {\n            return wrapNullable(nullable, typeAnnotation);\n          }\n      }\n    }\n  }, {\n    key: \"_insertAlias\",\n    value: function _insertAlias(aliasName, structContext, resolveAlias) {\n      var usedStruct = this._structs.get(aliasName);\n      if (usedStruct == null) {\n        this._insertStruct(aliasName, structContext, resolveAlias, resolveAlias(aliasName));\n      } else if (usedStruct.context !== structContext) {\n        throw new Error(`Tried to use alias '${aliasName}' in a getConstants() return type and inside a regular struct.`);\n      }\n    }\n  }, {\n    key: \"_insertStruct\",\n    value: function _insertStruct(structName, structContext, resolveAlias, objectTypeAnnotation) {\n      var _this = this;\n      var properties = objectTypeAnnotation.properties.map(function (property) {\n        var propertyStructName = structName + capitalize(property.name);\n        return _objectSpread(_objectSpread({}, property), {}, {\n          typeAnnotation: _this.process(propertyStructName, structContext, resolveAlias, property.typeAnnotation)\n        });\n      });\n      switch (structContext) {\n        case 'REGULAR':\n          this._structs.set(structName, {\n            name: structName,\n            context: 'REGULAR',\n            properties: properties\n          });\n          break;\n        case 'CONSTANTS':\n          this._structs.set(structName, {\n            name: structName,\n            context: 'CONSTANTS',\n            properties: properties\n          });\n          break;\n        default:\n          structContext;\n          throw new Error(`Detected an invalid struct context: ${structContext}`);\n      }\n    }\n  }, {\n    key: \"getAllStructs\",\n    value: function getAllStructs() {\n      return _toConsumableArray(this._structs.values());\n    }\n  }, {\n    key: \"getStruct\",\n    value: function getStruct(name) {\n      return this._structs.get(name);\n    }\n  }]);\n  return StructCollector;\n}();\nmodule.exports = {\n  StructCollector: StructCollector\n};","map":{"version":3,"names":["_toConsumableArray","require","_classCallCheck","_createClass","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","_slicedToArray","arr","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","o","minLen","_arrayLikeToArray","n","prototype","toString","call","slice","constructor","name","Array","from","test","len","arr2","_i","Symbol","iterator","_s","_e","_x","_r","_arr","_n","_d","next","done","value","err","return","isArray","obj","_toPropertyKey","configurable","writable","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","Number","_require","capitalize","_require2","unwrapNullable","wrapNullable","StructCollector","Map","process","structName","structContext","resolveAlias","nullableTypeAnnotation","_unwrapNullable","_unwrapNullable2","typeAnnotation","nullable","type","_insertStruct","elementType","_insertAlias","Error","aliasName","usedStruct","_structs","get","context","objectTypeAnnotation","_this","properties","map","property","propertyStructName","set","getAllStructs","values","getStruct","module","exports"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native/codegen/lib/generators/modules/GenerateModuleObjCpp/StructCollector.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\n'use strict';\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly &&\n      (symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      })),\n      keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2\n      ? ownKeys(Object(source), !0).forEach(function (key) {\n          _defineProperty(target, key, source[key]);\n        })\n      : Object.getOwnPropertyDescriptors\n      ? Object.defineProperties(\n          target,\n          Object.getOwnPropertyDescriptors(source),\n        )\n      : ownKeys(Object(source)).forEach(function (key) {\n          Object.defineProperty(\n            target,\n            key,\n            Object.getOwnPropertyDescriptor(source, key),\n          );\n        });\n  }\n  return target;\n}\nfunction _slicedToArray(arr, i) {\n  return (\n    _arrayWithHoles(arr) ||\n    _iterableToArrayLimit(arr, i) ||\n    _unsupportedIterableToArray(arr, i) ||\n    _nonIterableRest()\n  );\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\n    'Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',\n  );\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === 'string') return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === 'Object' && o.constructor) n = o.constructor.name;\n  if (n === 'Map' || n === 'Set') return Array.from(o);\n  if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n    return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i =\n    null == arr\n      ? null\n      : ('undefined' != typeof Symbol && arr[Symbol.iterator]) ||\n        arr['@@iterator'];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (((_x = (_i = _i.call(arr)).next), 0 === i)) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else\n        for (\n          ;\n          !(_n = (_s = _x.call(_i)).done) &&\n          (_arr.push(_s.value), _arr.length !== i);\n          _n = !0\n        );\n    } catch (err) {\n      (_d = !0), (_e = err);\n    } finally {\n      try {\n        if (!_n && null != _i.return && ((_r = _i.return()), Object(_r) !== _r))\n          return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true,\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, 'string');\n  return typeof key === 'symbol' ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== 'object' || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || 'default');\n    if (typeof res !== 'object') return res;\n    throw new TypeError('@@toPrimitive must return a primitive value.');\n  }\n  return (hint === 'string' ? String : Number)(input);\n}\nconst _require = require('../../Utils'),\n  capitalize = _require.capitalize;\nconst _require2 = require('../../../parsers/parsers-commons'),\n  unwrapNullable = _require2.unwrapNullable,\n  wrapNullable = _require2.wrapNullable;\nclass StructCollector {\n  constructor() {\n    _defineProperty(this, '_structs', new Map());\n  }\n  process(structName, structContext, resolveAlias, nullableTypeAnnotation) {\n    const _unwrapNullable = unwrapNullable(nullableTypeAnnotation),\n      _unwrapNullable2 = _slicedToArray(_unwrapNullable, 2),\n      typeAnnotation = _unwrapNullable2[0],\n      nullable = _unwrapNullable2[1];\n    switch (typeAnnotation.type) {\n      case 'ObjectTypeAnnotation': {\n        this._insertStruct(\n          structName,\n          structContext,\n          resolveAlias,\n          typeAnnotation,\n        );\n        return wrapNullable(nullable, {\n          type: 'TypeAliasTypeAnnotation',\n          name: structName,\n        });\n      }\n      case 'ArrayTypeAnnotation': {\n        if (typeAnnotation.elementType == null) {\n          return wrapNullable(nullable, {\n            type: 'ArrayTypeAnnotation',\n          });\n        }\n        return wrapNullable(nullable, {\n          type: 'ArrayTypeAnnotation',\n          elementType: this.process(\n            structName + 'Element',\n            structContext,\n            resolveAlias,\n            typeAnnotation.elementType,\n          ),\n        });\n      }\n      case 'TypeAliasTypeAnnotation': {\n        this._insertAlias(typeAnnotation.name, structContext, resolveAlias);\n        return wrapNullable(nullable, typeAnnotation);\n      }\n      case 'EnumDeclaration':\n        return wrapNullable(nullable, typeAnnotation);\n      case 'MixedTypeAnnotation':\n        throw new Error('Mixed types are unsupported in structs');\n      case 'UnionTypeAnnotation':\n        throw new Error('Union types are unsupported in structs');\n      default: {\n        return wrapNullable(nullable, typeAnnotation);\n      }\n    }\n  }\n  _insertAlias(aliasName, structContext, resolveAlias) {\n    const usedStruct = this._structs.get(aliasName);\n    if (usedStruct == null) {\n      this._insertStruct(\n        aliasName,\n        structContext,\n        resolveAlias,\n        resolveAlias(aliasName),\n      );\n    } else if (usedStruct.context !== structContext) {\n      throw new Error(\n        `Tried to use alias '${aliasName}' in a getConstants() return type and inside a regular struct.`,\n      );\n    }\n  }\n  _insertStruct(structName, structContext, resolveAlias, objectTypeAnnotation) {\n    // $FlowFixMe[missing-type-arg]\n    const properties = objectTypeAnnotation.properties.map(property => {\n      const propertyStructName = structName + capitalize(property.name);\n      return _objectSpread(\n        _objectSpread({}, property),\n        {},\n        {\n          typeAnnotation: this.process(\n            propertyStructName,\n            structContext,\n            resolveAlias,\n            property.typeAnnotation,\n          ),\n        },\n      );\n    });\n    switch (structContext) {\n      case 'REGULAR':\n        this._structs.set(structName, {\n          name: structName,\n          context: 'REGULAR',\n          properties: properties,\n        });\n        break;\n      case 'CONSTANTS':\n        this._structs.set(structName, {\n          name: structName,\n          context: 'CONSTANTS',\n          properties: properties,\n        });\n        break;\n      default:\n        structContext;\n        throw new Error(`Detected an invalid struct context: ${structContext}`);\n    }\n  }\n  getAllStructs() {\n    return [...this._structs.values()];\n  }\n  getStruct(name) {\n    return this._structs.get(name);\n  }\n}\nmodule.exports = {\n  StructCollector,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}