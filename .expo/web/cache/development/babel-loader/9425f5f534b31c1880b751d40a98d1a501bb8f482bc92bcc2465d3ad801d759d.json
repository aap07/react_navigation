{"ast":null,"code":"export {};","map":{"version":3,"names":[],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\expo-modules-core\\src\\NativeModulesProxy.native.ts"],"sourcesContent":["import { NativeModules } from 'react-native';\n\nimport { ProxyNativeModule } from './NativeModulesProxy.types';\n\nconst LegacyNativeProxy = NativeModules.NativeUnimoduleProxy;\n// Fixes `cannot find name 'global'.` in tests\n// @ts-ignore\nconst ExpoNativeProxy = global.expo?.modules?.NativeModulesProxy;\n\nconst modulesConstantsKey = 'modulesConstants';\nconst exportedMethodsKey = 'exportedMethods';\n\nconst NativeModulesProxy: { [moduleName: string]: ProxyNativeModule } = {};\n\nif (LegacyNativeProxy) {\n  // use JSI proxy if available, fallback to legacy RN proxy\n  const NativeProxy = ExpoNativeProxy ?? LegacyNativeProxy;\n\n  Object.keys(NativeProxy[exportedMethodsKey]).forEach((moduleName) => {\n    // copy constants\n    NativeModulesProxy[moduleName] = NativeProxy[modulesConstantsKey][moduleName] || {};\n\n    // copy methods\n    NativeProxy[exportedMethodsKey][moduleName].forEach((methodInfo) => {\n      NativeModulesProxy[moduleName][methodInfo.name] = (...args: unknown[]): Promise<any> => {\n        // Use the new proxy to call methods on legacy modules, if possible.\n        if (ExpoNativeProxy?.callMethod) {\n          return ExpoNativeProxy.callMethod(moduleName, methodInfo.name, args);\n        }\n\n        // Otherwise fall back to the legacy proxy.\n        // This is deprecated and might be removed in SDK47 or later.\n        const { key, argumentsCount } = methodInfo;\n        if (argumentsCount !== args.length) {\n          return Promise.reject(\n            new Error(\n              `Native method ${moduleName}.${methodInfo.name} expects ${argumentsCount} ${\n                argumentsCount === 1 ? 'argument' : 'arguments'\n              } but received ${args.length}`\n            )\n          );\n        }\n        return LegacyNativeProxy.callMethod(moduleName, key, args);\n      };\n    });\n\n    // These are called by EventEmitter (which is a wrapper for NativeEventEmitter)\n    // only on iOS and they use iOS-specific native module, EXReactNativeEventEmitter.\n    //\n    // On Android only {start,stop}Observing are called on the native module\n    // and these should be exported as Expo methods.\n    //\n    // Before the RN 65, addListener/removeListeners weren't called on Android. However, it no longer stays true.\n    // See https://github.com/facebook/react-native/commit/f5502fbda9fe271ff6e1d0da773a3a8ee206a453.\n    // That's why, we check if the `EXReactNativeEventEmitter` exists and only if yes, we use it in the listener implementation.\n    // Otherwise, those methods are NOOP.\n    if (NativeModules.EXReactNativeEventEmitter) {\n      NativeModulesProxy[moduleName].addListener = (...args) =>\n        NativeModules.EXReactNativeEventEmitter.addProxiedListener(moduleName, ...args);\n      NativeModulesProxy[moduleName].removeListeners = (...args) =>\n        NativeModules.EXReactNativeEventEmitter.removeProxiedListeners(moduleName, ...args);\n    } else {\n      // Fixes on Android:\n      // WARN  `new NativeEventEmitter()` was called with a non-null argument without the required `addListener` method.\n      // WARN  `new NativeEventEmitter()` was called with a non-null argument without the required `removeListeners` method.\n      NativeModulesProxy[moduleName].addListener = () => {};\n      NativeModulesProxy[moduleName].removeListeners = () => {};\n    }\n  });\n} else {\n  console.warn(\n    `The \"EXNativeModulesProxy\" native module is not exported through NativeModules; verify that expo-modules-core's native code is linked properly`\n  );\n}\n\nexport default NativeModulesProxy;\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}