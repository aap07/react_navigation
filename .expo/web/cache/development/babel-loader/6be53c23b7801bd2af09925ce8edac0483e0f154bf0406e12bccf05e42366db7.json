{"ast":null,"code":"'use strict';\n\nvar nullthrows = require('nullthrows');\nvar _require = require(\"./CppHelpers\"),\n  getCppTypeForAnnotation = _require.getCppTypeForAnnotation,\n  generateEventStructName = _require.generateEventStructName;\nvar _require2 = require(\"../Utils\"),\n  indent = _require2.indent,\n  toSafeCppString = _require2.toSafeCppString;\nvar FileTemplate = function FileTemplate(_ref) {\n  var componentEmitters = _ref.componentEmitters;\n  return `\n/**\n * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).\n *\n * Do not edit this file as changes may cause incorrect behavior and will be lost\n * once the code is regenerated.\n *\n * ${'@'}generated by codegen project: GenerateEventEmitterH.js\n */\n#pragma once\n\n#include <react/renderer/components/view/ViewEventEmitter.h>\n#include <jsi/jsi.h>\n\nnamespace facebook {\nnamespace react {\n\n${componentEmitters}\n\n} // namespace react\n} // namespace facebook\n`;\n};\nvar ComponentTemplate = function ComponentTemplate(_ref2) {\n  var className = _ref2.className,\n    structs = _ref2.structs,\n    events = _ref2.events;\n  return `\nclass JSI_EXPORT ${className}EventEmitter : public ViewEventEmitter {\n public:\n  using ViewEventEmitter::ViewEventEmitter;\n\n  ${structs}\n\n  ${events}\n};\n`.trim();\n};\nvar StructTemplate = function StructTemplate(_ref3) {\n  var structName = _ref3.structName,\n    fields = _ref3.fields;\n  return `\n  struct ${structName} {\n    ${fields}\n  };\n`.trim();\n};\nvar EnumTemplate = function EnumTemplate(_ref4) {\n  var enumName = _ref4.enumName,\n    values = _ref4.values,\n    toCases = _ref4.toCases;\n  return `enum class ${enumName} {\n  ${values}\n};\n\nstatic char const *toString(const ${enumName} value) {\n  switch (value) {\n    ${toCases}\n  }\n}\n`.trim();\n};\nfunction getNativeTypeFromAnnotation(componentName, eventProperty, nameParts) {\n  var type = eventProperty.typeAnnotation.type;\n  switch (type) {\n    case 'BooleanTypeAnnotation':\n    case 'StringTypeAnnotation':\n    case 'Int32TypeAnnotation':\n    case 'DoubleTypeAnnotation':\n    case 'FloatTypeAnnotation':\n      return getCppTypeForAnnotation(type);\n    case 'StringEnumTypeAnnotation':\n      return generateEventStructName(nameParts.concat([eventProperty.name]));\n    case 'ObjectTypeAnnotation':\n      return generateEventStructName(nameParts.concat([eventProperty.name]));\n    default:\n      type;\n      throw new Error(`Received invalid event property type ${type}`);\n  }\n}\nfunction generateEnum(structs, options, nameParts) {\n  var structName = generateEventStructName(nameParts);\n  var fields = options.map(function (option, index) {\n    return `${toSafeCppString(option)}`;\n  }).join(',\\n  ');\n  var toCases = options.map(function (option) {\n    return `case ${structName}::${toSafeCppString(option)}: return \"${option}\";`;\n  }).join('\\n' + '    ');\n  structs.set(structName, EnumTemplate({\n    enumName: structName,\n    values: fields,\n    toCases: toCases\n  }));\n}\nfunction generateStruct(structs, componentName, nameParts, properties) {\n  var structNameParts = nameParts;\n  var structName = generateEventStructName(structNameParts);\n  var fields = properties.map(function (property) {\n    return `${getNativeTypeFromAnnotation(componentName, property, structNameParts)} ${property.name};`;\n  }).join('\\n' + '  ');\n  properties.forEach(function (property) {\n    var name = property.name,\n      typeAnnotation = property.typeAnnotation;\n    switch (typeAnnotation.type) {\n      case 'BooleanTypeAnnotation':\n        return;\n      case 'StringTypeAnnotation':\n        return;\n      case 'Int32TypeAnnotation':\n        return;\n      case 'DoubleTypeAnnotation':\n        return;\n      case 'FloatTypeAnnotation':\n        return;\n      case 'ObjectTypeAnnotation':\n        generateStruct(structs, componentName, nameParts.concat([name]), nullthrows(typeAnnotation.properties));\n        return;\n      case 'StringEnumTypeAnnotation':\n        generateEnum(structs, typeAnnotation.options, nameParts.concat([name]));\n        return;\n      default:\n        typeAnnotation.type;\n        throw new Error(`Received invalid event property type ${typeAnnotation.type}`);\n    }\n  });\n  structs.set(structName, StructTemplate({\n    structName: structName,\n    fields: fields\n  }));\n}\nfunction generateStructs(componentName, component) {\n  var structs = new Map();\n  component.events.forEach(function (event) {\n    if (event.typeAnnotation.argument) {\n      generateStruct(structs, componentName, [event.name], event.typeAnnotation.argument.properties);\n    }\n  });\n  return Array.from(structs.values()).join('\\n\\n');\n}\nfunction generateEvent(componentName, event) {\n  if (event.typeAnnotation.argument) {\n    var structName = generateEventStructName([event.name]);\n    return `void ${event.name}(${structName} value) const;`;\n  }\n  return `void ${event.name}() const;`;\n}\nfunction generateEvents(componentName, component) {\n  return component.events.map(function (event) {\n    return generateEvent(componentName, event);\n  }).join('\\n\\n' + '  ');\n}\nmodule.exports = {\n  generate: function generate(libraryName, schema, packageName) {\n    var assumeNonnull = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var moduleComponents = Object.keys(schema.modules).map(function (moduleName) {\n      var module = schema.modules[moduleName];\n      if (module.type !== 'Component') {\n        return;\n      }\n      var components = module.components;\n      if (components == null) {\n        return null;\n      }\n      return components;\n    }).filter(Boolean).reduce(function (acc, components) {\n      return Object.assign(acc, components);\n    }, {});\n    var moduleComponentsWithEvents = Object.keys(moduleComponents);\n    var fileName = 'EventEmitters.h';\n    var componentEmitters = moduleComponentsWithEvents.length > 0 ? Object.keys(moduleComponents).map(function (componentName) {\n      var component = moduleComponents[componentName];\n      var replacedTemplate = ComponentTemplate({\n        className: componentName,\n        structs: indent(generateStructs(componentName, component), 2),\n        events: generateEvents(componentName, component)\n      });\n      return replacedTemplate;\n    }).join('\\n') : '';\n    var replacedTemplate = FileTemplate({\n      componentEmitters: componentEmitters\n    });\n    return new Map([[fileName, replacedTemplate]]);\n  }\n};","map":{"version":3,"names":["nullthrows","require","_require","getCppTypeForAnnotation","generateEventStructName","_require2","indent","toSafeCppString","FileTemplate","_ref","componentEmitters","ComponentTemplate","_ref2","className","structs","events","trim","StructTemplate","_ref3","structName","fields","EnumTemplate","_ref4","enumName","values","toCases","getNativeTypeFromAnnotation","componentName","eventProperty","nameParts","type","typeAnnotation","concat","name","Error","generateEnum","options","map","option","index","join","set","generateStruct","properties","structNameParts","property","forEach","generateStructs","component","Map","event","argument","Array","from","generateEvent","generateEvents","module","exports","generate","libraryName","schema","packageName","assumeNonnull","arguments","length","undefined","moduleComponents","Object","keys","modules","moduleName","components","filter","Boolean","reduce","acc","assign","moduleComponentsWithEvents","fileName","replacedTemplate"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native/codegen/lib/generators/components/GenerateEventEmitterH.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\n'use strict';\n\nconst nullthrows = require('nullthrows');\nconst _require = require('./CppHelpers'),\n  getCppTypeForAnnotation = _require.getCppTypeForAnnotation,\n  generateEventStructName = _require.generateEventStructName;\nconst _require2 = require('../Utils'),\n  indent = _require2.indent,\n  toSafeCppString = _require2.toSafeCppString;\nconst FileTemplate = ({componentEmitters}) => `\n/**\n * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).\n *\n * Do not edit this file as changes may cause incorrect behavior and will be lost\n * once the code is regenerated.\n *\n * ${'@'}generated by codegen project: GenerateEventEmitterH.js\n */\n#pragma once\n\n#include <react/renderer/components/view/ViewEventEmitter.h>\n#include <jsi/jsi.h>\n\nnamespace facebook {\nnamespace react {\n\n${componentEmitters}\n\n} // namespace react\n} // namespace facebook\n`;\nconst ComponentTemplate = ({className, structs, events}) =>\n  `\nclass JSI_EXPORT ${className}EventEmitter : public ViewEventEmitter {\n public:\n  using ViewEventEmitter::ViewEventEmitter;\n\n  ${structs}\n\n  ${events}\n};\n`.trim();\nconst StructTemplate = ({structName, fields}) =>\n  `\n  struct ${structName} {\n    ${fields}\n  };\n`.trim();\nconst EnumTemplate = ({enumName, values, toCases}) =>\n  `enum class ${enumName} {\n  ${values}\n};\n\nstatic char const *toString(const ${enumName} value) {\n  switch (value) {\n    ${toCases}\n  }\n}\n`.trim();\nfunction getNativeTypeFromAnnotation(componentName, eventProperty, nameParts) {\n  const type = eventProperty.typeAnnotation.type;\n  switch (type) {\n    case 'BooleanTypeAnnotation':\n    case 'StringTypeAnnotation':\n    case 'Int32TypeAnnotation':\n    case 'DoubleTypeAnnotation':\n    case 'FloatTypeAnnotation':\n      return getCppTypeForAnnotation(type);\n    case 'StringEnumTypeAnnotation':\n      return generateEventStructName(nameParts.concat([eventProperty.name]));\n    case 'ObjectTypeAnnotation':\n      return generateEventStructName(nameParts.concat([eventProperty.name]));\n    default:\n      type;\n      throw new Error(`Received invalid event property type ${type}`);\n  }\n}\nfunction generateEnum(structs, options, nameParts) {\n  const structName = generateEventStructName(nameParts);\n  const fields = options\n    .map((option, index) => `${toSafeCppString(option)}`)\n    .join(',\\n  ');\n  const toCases = options\n    .map(\n      option =>\n        `case ${structName}::${toSafeCppString(option)}: return \"${option}\";`,\n    )\n    .join('\\n' + '    ');\n  structs.set(\n    structName,\n    EnumTemplate({\n      enumName: structName,\n      values: fields,\n      toCases: toCases,\n    }),\n  );\n}\nfunction generateStruct(structs, componentName, nameParts, properties) {\n  const structNameParts = nameParts;\n  const structName = generateEventStructName(structNameParts);\n  const fields = properties\n    .map(property => {\n      return `${getNativeTypeFromAnnotation(\n        componentName,\n        property,\n        structNameParts,\n      )} ${property.name};`;\n    })\n    .join('\\n' + '  ');\n  properties.forEach(property => {\n    const name = property.name,\n      typeAnnotation = property.typeAnnotation;\n    switch (typeAnnotation.type) {\n      case 'BooleanTypeAnnotation':\n        return;\n      case 'StringTypeAnnotation':\n        return;\n      case 'Int32TypeAnnotation':\n        return;\n      case 'DoubleTypeAnnotation':\n        return;\n      case 'FloatTypeAnnotation':\n        return;\n      case 'ObjectTypeAnnotation':\n        generateStruct(\n          structs,\n          componentName,\n          nameParts.concat([name]),\n          nullthrows(typeAnnotation.properties),\n        );\n        return;\n      case 'StringEnumTypeAnnotation':\n        generateEnum(structs, typeAnnotation.options, nameParts.concat([name]));\n        return;\n      default:\n        typeAnnotation.type;\n        throw new Error(\n          `Received invalid event property type ${typeAnnotation.type}`,\n        );\n    }\n  });\n  structs.set(\n    structName,\n    StructTemplate({\n      structName,\n      fields,\n    }),\n  );\n}\nfunction generateStructs(componentName, component) {\n  const structs = new Map();\n  component.events.forEach(event => {\n    if (event.typeAnnotation.argument) {\n      generateStruct(\n        structs,\n        componentName,\n        [event.name],\n        event.typeAnnotation.argument.properties,\n      );\n    }\n  });\n  return Array.from(structs.values()).join('\\n\\n');\n}\nfunction generateEvent(componentName, event) {\n  if (event.typeAnnotation.argument) {\n    const structName = generateEventStructName([event.name]);\n    return `void ${event.name}(${structName} value) const;`;\n  }\n  return `void ${event.name}() const;`;\n}\nfunction generateEvents(componentName, component) {\n  return component.events\n    .map(event => generateEvent(componentName, event))\n    .join('\\n\\n' + '  ');\n}\nmodule.exports = {\n  generate(libraryName, schema, packageName, assumeNonnull = false) {\n    const moduleComponents = Object.keys(schema.modules)\n      .map(moduleName => {\n        const module = schema.modules[moduleName];\n        if (module.type !== 'Component') {\n          return;\n        }\n        const components = module.components;\n        // No components in this module\n        if (components == null) {\n          return null;\n        }\n        return components;\n      })\n      .filter(Boolean)\n      .reduce((acc, components) => Object.assign(acc, components), {});\n    const moduleComponentsWithEvents = Object.keys(moduleComponents);\n    const fileName = 'EventEmitters.h';\n    const componentEmitters =\n      moduleComponentsWithEvents.length > 0\n        ? Object.keys(moduleComponents)\n            .map(componentName => {\n              const component = moduleComponents[componentName];\n              const replacedTemplate = ComponentTemplate({\n                className: componentName,\n                structs: indent(generateStructs(componentName, component), 2),\n                events: generateEvents(componentName, component),\n              });\n              return replacedTemplate;\n            })\n            .join('\\n')\n        : '';\n    const replacedTemplate = FileTemplate({\n      componentEmitters,\n    });\n    return new Map([[fileName, replacedTemplate]]);\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}