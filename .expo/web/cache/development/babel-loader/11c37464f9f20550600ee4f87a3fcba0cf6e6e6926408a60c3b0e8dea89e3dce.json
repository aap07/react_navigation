{"ast":null,"code":"import { ExpoConfig } from '@expo/config-types';\nexport { ExpoConfig };","map":{"version":3,"names":["ExpoConfig"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@expo/config/build/Config.types.d.ts"],"sourcesContent":["import { ModConfig } from '@expo/config-plugins';\nimport { ExpoConfig } from '@expo/config-types';\nexport { ExpoConfig };\nexport type PackageJSONConfig = {\n    dependencies?: Record<string, string>;\n    [key: string]: any;\n};\nexport interface ProjectConfig {\n    /**\n     * Fully evaluated Expo config with default values injected.\n     */\n    exp: ExpoConfig;\n    /**\n     * Dynamic config for processing native files during the generation process.\n     */\n    mods?: ModConfig | null;\n    /**\n     * Project package.json object with default values injected.\n     */\n    pkg: PackageJSONConfig;\n    /**\n     * Unaltered static config (app.config.json, app.json, or custom json config).\n     * For legacy, an empty object will be returned even if no static config exists.\n     */\n    rootConfig: AppJSONConfig;\n    /**\n     * Path to the static json config file if it exists.\n     * If a project has an app.config.js and an app.json then app.json will be returned.\n     * If a project has an app.config.json and an app.json then app.config.json will be returned.\n     * Returns null if no static config file exists.\n     */\n    staticConfigPath: string | null;\n    /**\n     * Path to an app.config.js or app.config.ts.\n     * Returns null if no dynamic config file exists.\n     */\n    dynamicConfigPath: string | null;\n    /**\n     * Returns the type of the value exported from the dynamic config.\n     * This can be used to determine if the dynamic config is potentially extending a static config when (v === 'function').\n     * Returns null if no dynamic config file exists.\n     */\n    dynamicConfigObjectType: string | null;\n}\nexport type AppJSONConfig = {\n    expo: ExpoConfig;\n    [key: string]: any;\n};\nexport type BareAppConfig = {\n    name: string;\n    [key: string]: any;\n};\nexport type HookArguments = {\n    config: any;\n    url: any;\n    exp: ExpoConfig;\n    iosBundle: string | Uint8Array;\n    iosSourceMap: string | null;\n    iosManifest: any;\n    iosManifestUrl: string;\n    androidBundle: string | Uint8Array;\n    androidSourceMap: string | null;\n    androidManifest: any;\n    androidManifestUrl: string;\n    projectRoot: string;\n    log: (msg: any) => void;\n};\nexport type ExpoGoConfig = {\n    mainModuleName: string;\n    __flipperHack: 'React Native packager is running';\n    debuggerHost: string;\n    logUrl: string;\n    developer: {\n        tool: string | null;\n        projectRoot?: string;\n    };\n    packagerOpts: {\n        [key: string]: any;\n    };\n};\nexport type EASConfig = {\n    projectId?: string;\n};\nexport type ClientScopingConfig = {\n    scopeKey?: string;\n};\nexport type ExpoClientConfig = ExpoConfig & {\n    id?: string;\n    releaseId?: string;\n    revisionId?: string;\n    bundleUrl?: string;\n    hostUri?: string;\n    publishedTime?: string;\n};\nexport type ExpoAppManifest = ExpoClientConfig & EASConfig & Partial<ExpoGoConfig> & {\n    sdkVersion: string;\n    bundledAssets?: string[];\n    isKernel?: boolean;\n    kernel?: {\n        androidManifestPath?: string;\n        iosManifestPath?: string;\n    };\n    assetUrlOverride?: string;\n    commitTime?: string;\n    env?: Record<string, any>;\n};\nexport interface ExpoUpdatesManifestAsset {\n    url: string;\n    key: string;\n    contentType: string;\n    hash?: string;\n}\nexport interface ExpoUpdatesManifest {\n    id: string;\n    createdAt: string;\n    runtimeVersion: string;\n    launchAsset: ExpoUpdatesManifestAsset;\n    assets: ExpoUpdatesManifestAsset[];\n    metadata: {\n        [key: string]: string;\n    };\n    extra: ClientScopingConfig & {\n        expoClient?: ExpoClientConfig;\n        expoGo?: ExpoGoConfig;\n        eas?: EASConfig;\n    };\n}\nexport type Hook = {\n    file: string;\n    config: any;\n};\nexport type HookType = 'postPublish' | 'postExport';\nexport declare enum ProjectPrivacy {\n    PUBLIC = \"public\",\n    UNLISTED = \"unlisted\"\n}\nexport type Platform = 'android' | 'ios' | 'web';\nexport type ProjectTarget = 'managed' | 'bare';\nexport type ConfigErrorCode = 'NO_APP_JSON' | 'NOT_OBJECT' | 'NO_EXPO' | 'MODULE_NOT_FOUND' | 'DEPRECATED' | 'INVALID_MODE' | 'INVALID_FORMAT' | 'INVALID_PLUGIN' | 'INVALID_CONFIG';\nexport type ConfigContext = {\n    projectRoot: string;\n    /**\n     * The static config path either app.json, app.config.json, or a custom user-defined config.\n     */\n    staticConfigPath: string | null;\n    packageJsonPath: string | null;\n    config: Partial<ExpoConfig>;\n};\nexport type GetConfigOptions = {\n    isPublicConfig?: boolean;\n    /**\n     * Should the config `mods` be preserved in the config? Used for compiling mods in the eject command.\n     *\n     * @default false\n     */\n    isModdedConfig?: boolean;\n    skipSDKVersionRequirement?: boolean;\n    /**\n     * Dangerously skip resolving plugins.\n     */\n    skipPlugins?: boolean;\n    strict?: boolean;\n};\nexport type WriteConfigOptions = {\n    dryRun?: boolean;\n};\nexport type ConfigFilePaths = {\n    staticConfigPath: string | null;\n    dynamicConfigPath: string | null;\n};\n"],"mappings":"AACA,SAASA,UAAU,QAAQ,oBAAoB;AAC/C,SAASA,UAAU"},"metadata":{},"sourceType":"module","externalDependencies":[]}