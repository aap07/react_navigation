{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport Constants from 'expo-constants';\nimport prettyFormat from 'pretty-format';\nimport parseErrorStack from 'react-native/Libraries/Core/Devtools/parseErrorStack';\nimport symbolicateStackTrace from 'react-native/Libraries/Core/Devtools/symbolicateStackTrace';\nimport ReactNodeFormatter from \"./format/ReactNodeFormatter\";\nexport var EXPO_CONSOLE_METHOD_NAME = '__expoConsoleLog';\nfunction serializeLogDataAsync(_x, _x2) {\n  return _serializeLogDataAsync.apply(this, arguments);\n}\nfunction _serializeLogDataAsync() {\n  _serializeLogDataAsync = _asyncToGenerator(function* (data, level) {\n    var serializedValues;\n    var includesStack = false;\n    if (_stackTraceLogsSupported()) {\n      if (_isUnhandledPromiseRejection(data, level)) {\n        var rawStack = data[0];\n        var syntheticError = {\n          stack: rawStack\n        };\n        var stack = yield _symbolicateErrorAsync(syntheticError);\n        if (!stack.length) {\n          serializedValues = _stringifyLogData(data);\n        } else {\n          var errorMessage = rawStack.split('\\n')[1];\n          serializedValues = [{\n            message: `[Unhandled promise rejection: ${errorMessage}]`,\n            stack: _formatStack(stack)\n          }];\n          includesStack = true;\n        }\n      } else if (data.length === 1 && data[0] instanceof Error) {\n        var serializedError = yield _serializeErrorAsync(data[0]);\n        serializedValues = [serializedError];\n        includesStack = serializedError.hasOwnProperty('stack');\n      } else if (level === 'warn' || level === 'error') {\n        var error = _captureConsoleStackTrace();\n        var _errorMessage = _stringifyLogData(data).join(', ');\n        var _serializedError = yield _serializeErrorAsync(error, _errorMessage);\n        serializedValues = [_serializedError];\n        includesStack = _serializedError.hasOwnProperty('stack');\n      } else {\n        serializedValues = _stringifyLogData(data);\n      }\n    } else {\n      serializedValues = _stringifyLogData(data);\n    }\n    return {\n      body: _toConsumableArray(serializedValues),\n      includesStack: includesStack\n    };\n  });\n  return _serializeLogDataAsync.apply(this, arguments);\n}\nfunction _stringifyLogData(data) {\n  return data.map(function (item) {\n    var LOG_MESSAGE_MAX_LENGTH = 10000;\n    var result = typeof item === 'string' ? item : prettyFormat(item, {\n      plugins: [ReactNodeFormatter]\n    });\n    if (result.length > LOG_MESSAGE_MAX_LENGTH) {\n      var truncatedResult = result.substring(0, LOG_MESSAGE_MAX_LENGTH);\n      truncatedResult += `...(truncated to the first ${LOG_MESSAGE_MAX_LENGTH} characters)`;\n      return truncatedResult;\n    } else {\n      return result;\n    }\n  });\n}\nfunction _serializeErrorAsync(_x3, _x4) {\n  return _serializeErrorAsync2.apply(this, arguments);\n}\nfunction _serializeErrorAsync2() {\n  _serializeErrorAsync2 = _asyncToGenerator(function* (error, message) {\n    if (message == null) {\n      message = error.message;\n    }\n    if (!error.stack || !error.stack.length) {\n      return prettyFormat(error);\n    }\n    var stack = yield _symbolicateErrorAsync(error);\n    var formattedStack = _formatStack(stack);\n    return {\n      message: message,\n      stack: formattedStack\n    };\n  });\n  return _serializeErrorAsync2.apply(this, arguments);\n}\nfunction _symbolicateErrorAsync(_x5) {\n  return _symbolicateErrorAsync2.apply(this, arguments);\n}\nfunction _symbolicateErrorAsync2() {\n  _symbolicateErrorAsync2 = _asyncToGenerator(function* (error) {\n    var parsedStack = parseErrorStack(error == null ? void 0 : error.stack);\n    var symbolicatedStack;\n    try {\n      var _yield$symbolicateSta, _yield$symbolicateSta2;\n      symbolicatedStack = (_yield$symbolicateSta = (_yield$symbolicateSta2 = yield symbolicateStackTrace(parsedStack)) == null ? void 0 : _yield$symbolicateSta2.stack) != null ? _yield$symbolicateSta : null;\n    } catch (_unused) {\n      return parsedStack;\n    }\n    if (!symbolicatedStack) {\n      return parsedStack;\n    }\n    return symbolicatedStack.map(_removeProjectRoot);\n  });\n  return _symbolicateErrorAsync2.apply(this, arguments);\n}\nfunction _formatStack(stack) {\n  return stack.map(function (frame) {\n    var line = `${frame.file}:${frame.lineNumber}`;\n    if (frame.column != null) {\n      line += `:${frame.column}`;\n    }\n    line += ` in ${frame.methodName}`;\n    return line;\n  }).join('\\n');\n}\nfunction _removeProjectRoot(frame) {\n  var filename = frame.file;\n  if (filename == null) {\n    return frame;\n  }\n  var projectRoot = _getProjectRoot();\n  if (projectRoot == null) {\n    return frame;\n  }\n  if (filename.startsWith(projectRoot)) {\n    filename = filename.substring(projectRoot.length);\n    if (filename[0] === '/' || filename[0] === '\\\\') {\n      filename = filename.substring(1);\n    }\n    frame.file = filename;\n  }\n  return frame;\n}\nfunction _stackTraceLogsSupported() {\n  return !!(__DEV__ && _getProjectRoot());\n}\nfunction _isUnhandledPromiseRejection(data, level) {\n  return level === 'warn' && typeof data[0] === 'string' && /^Possible Unhandled Promise Rejection/.test(data[0]);\n}\nfunction _captureConsoleStackTrace() {\n  try {\n    throw new Error();\n  } catch (error) {\n    var stackLines = error.stack.split('\\n');\n    var consoleMethodIndex = stackLines.findIndex(function (frame) {\n      return frame.includes(EXPO_CONSOLE_METHOD_NAME);\n    });\n    if (consoleMethodIndex !== -1) {\n      stackLines = stackLines.slice(consoleMethodIndex + 1);\n      error.stack = stackLines.join('\\n');\n    }\n    return error;\n  }\n}\nfunction _getProjectRoot() {\n  var _Constants$expoGoConf, _Constants$expoGoConf2, _Constants$expoGoConf3;\n  return (_Constants$expoGoConf = (_Constants$expoGoConf2 = Constants.expoGoConfig) == null ? void 0 : (_Constants$expoGoConf3 = _Constants$expoGoConf2.developer) == null ? void 0 : _Constants$expoGoConf3.projectRoot) != null ? _Constants$expoGoConf : null;\n}\nexport default {\n  serializeLogDataAsync: serializeLogDataAsync\n};","map":{"version":3,"names":["Constants","prettyFormat","parseErrorStack","symbolicateStackTrace","ReactNodeFormatter","EXPO_CONSOLE_METHOD_NAME","serializeLogDataAsync","_x","_x2","_serializeLogDataAsync","apply","arguments","_asyncToGenerator","data","level","serializedValues","includesStack","_stackTraceLogsSupported","_isUnhandledPromiseRejection","rawStack","syntheticError","stack","_symbolicateErrorAsync","length","_stringifyLogData","errorMessage","split","message","_formatStack","Error","serializedError","_serializeErrorAsync","hasOwnProperty","error","_captureConsoleStackTrace","join","body","_toConsumableArray","map","item","LOG_MESSAGE_MAX_LENGTH","result","plugins","truncatedResult","substring","_x3","_x4","_serializeErrorAsync2","formattedStack","_x5","_symbolicateErrorAsync2","parsedStack","symbolicatedStack","_yield$symbolicateSta","_yield$symbolicateSta2","_unused","_removeProjectRoot","frame","line","file","lineNumber","column","methodName","filename","projectRoot","_getProjectRoot","startsWith","__DEV__","test","stackLines","consoleMethodIndex","findIndex","includes","slice","_Constants$expoGoConf","_Constants$expoGoConf2","_Constants$expoGoConf3","expoGoConfig","developer"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\expo\\src\\logs\\LogSerialization.ts"],"sourcesContent":["import Constants from 'expo-constants';\nimport prettyFormat from 'pretty-format';\nimport parseErrorStack, { StackFrame } from 'react-native/Libraries/Core/Devtools/parseErrorStack';\nimport symbolicateStackTrace from 'react-native/Libraries/Core/Devtools/symbolicateStackTrace';\n\nimport { LogData, LogLevel } from './RemoteLogging';\nimport ReactNodeFormatter from './format/ReactNodeFormatter';\n\ntype SerializedData = {\n  body: LogData[];\n  includesStack: boolean;\n};\n\nexport const EXPO_CONSOLE_METHOD_NAME = '__expoConsoleLog';\n\nasync function serializeLogDataAsync(data: unknown[], level: LogLevel): Promise<SerializedData> {\n  let serializedValues: readonly LogData[];\n  let includesStack = false;\n\n  if (_stackTraceLogsSupported()) {\n    if (_isUnhandledPromiseRejection(data, level)) {\n      const rawStack = data[0] as string;\n      const syntheticError = { stack: rawStack };\n      const stack = await _symbolicateErrorAsync(syntheticError as Error);\n\n      if (!stack.length) {\n        serializedValues = _stringifyLogData(data);\n      } else {\n        // NOTE: This doesn't handle error messages with newlines\n        const errorMessage = rawStack.split('\\n')[1];\n        serializedValues = [\n          {\n            message: `[Unhandled promise rejection: ${errorMessage}]`,\n            stack: _formatStack(stack),\n          },\n        ];\n        includesStack = true;\n      }\n    } else if (data.length === 1 && data[0] instanceof Error) {\n      // When there's only one argument to the log function and that argument is an error, we\n      // include the error's stack. If there's more than one argument then we don't include the\n      // stack because it's not easy to display nicely in our current UI.\n\n      const serializedError = await _serializeErrorAsync(data[0] as Error);\n      serializedValues = [serializedError];\n      includesStack = serializedError.hasOwnProperty('stack');\n    } else if (level === 'warn' || level === 'error') {\n      // For console.warn and console.error it is usually useful to know the stack that leads to the\n      // warning or error, so we provide this information to help out with debugging\n\n      const error = _captureConsoleStackTrace();\n      // [\"hello\", \"world\"] becomes \"hello, world\"\n      const errorMessage = _stringifyLogData(data).join(', ');\n\n      const serializedError = await _serializeErrorAsync(error, errorMessage);\n      serializedValues = [serializedError];\n      includesStack = serializedError.hasOwnProperty('stack');\n    } else {\n      serializedValues = _stringifyLogData(data);\n    }\n  } else {\n    serializedValues = _stringifyLogData(data);\n  }\n\n  return {\n    body: [...serializedValues],\n    includesStack,\n  };\n}\n\nfunction _stringifyLogData(data: unknown[]): string[] {\n  return data.map((item) => {\n    // define the max length for log msg to be first 10000 characters\n    const LOG_MESSAGE_MAX_LENGTH = 10000;\n    const result =\n      typeof item === 'string' ? item : prettyFormat(item, { plugins: [ReactNodeFormatter] });\n    // check the size of string returned\n    if (result.length > LOG_MESSAGE_MAX_LENGTH) {\n      let truncatedResult = result.substring(0, LOG_MESSAGE_MAX_LENGTH);\n      // truncate the result string to the max length\n      truncatedResult += `...(truncated to the first ${LOG_MESSAGE_MAX_LENGTH} characters)`;\n      return truncatedResult;\n    } else {\n      return result;\n    }\n  });\n}\n\nasync function _serializeErrorAsync(error: Error, message?: string): Promise<LogData> {\n  if (message == null) {\n    message = error.message;\n  }\n\n  if (!error.stack || !error.stack.length) {\n    return prettyFormat(error);\n  }\n\n  const stack = await _symbolicateErrorAsync(error);\n  const formattedStack = _formatStack(stack);\n\n  return { message, stack: formattedStack };\n}\n\nasync function _symbolicateErrorAsync(error: Error): Promise<StackFrame[]> {\n  // @ts-ignore: parseErrorStack accepts nullable string after RN 0.64 but @types/react-native does not updated yet.\n  const parsedStack = parseErrorStack(error?.stack);\n  let symbolicatedStack: StackFrame[] | null;\n  try {\n    // @ts-ignore: symbolicateStackTrace has different real/Flow declaration\n    // than the one in DefinitelyTyped.\n    symbolicatedStack = (await symbolicateStackTrace(parsedStack))?.stack ?? null;\n  } catch {\n    return parsedStack;\n  }\n\n  // In this context an unsymbolicated stack is better than no stack\n  if (!symbolicatedStack) {\n    return parsedStack;\n  }\n\n  // Clean the stack trace\n  return symbolicatedStack.map(_removeProjectRoot);\n}\n\nfunction _formatStack(stack: StackFrame[]): string {\n  return stack\n    .map((frame) => {\n      let line = `${frame.file}:${frame.lineNumber}`;\n      if (frame.column != null) {\n        line += `:${frame.column}`;\n      }\n      line += ` in ${frame.methodName}`;\n      return line;\n    })\n    .join('\\n');\n}\n\nfunction _removeProjectRoot(frame: StackFrame): StackFrame {\n  let filename = frame.file;\n  if (filename == null) {\n    return frame;\n  }\n\n  const projectRoot = _getProjectRoot();\n  if (projectRoot == null) {\n    return frame;\n  }\n\n  if (filename.startsWith(projectRoot)) {\n    filename = filename.substring(projectRoot.length);\n    if (filename[0] === '/' || filename[0] === '\\\\') {\n      filename = filename.substring(1);\n    }\n    frame.file = filename;\n  }\n\n  return frame;\n}\n\n/**\n * Returns whether the development server that served this project supports logs with a stack trace.\n * Specifically, the version of Expo CLI that includes `projectRoot` in the manifest also accepts\n * payloads of the form:\n *\n * {\n *   includesStack: boolean, body: [{ message: string, stack: string }],\n * }\n */\nfunction _stackTraceLogsSupported(): boolean {\n  return !!(__DEV__ && _getProjectRoot());\n}\n\nfunction _isUnhandledPromiseRejection(data: unknown[], level: LogLevel): boolean {\n  return (\n    level === 'warn' &&\n    typeof data[0] === 'string' &&\n    /^Possible Unhandled Promise Rejection/.test(data[0] as string)\n  );\n}\n\nfunction _captureConsoleStackTrace(): Error {\n  try {\n    throw new Error();\n  } catch (error) {\n    let stackLines = error.stack.split('\\n');\n    const consoleMethodIndex = stackLines.findIndex((frame) =>\n      frame.includes(EXPO_CONSOLE_METHOD_NAME)\n    );\n    if (consoleMethodIndex !== -1) {\n      stackLines = stackLines.slice(consoleMethodIndex + 1);\n      error.stack = stackLines.join('\\n');\n    }\n    return error;\n  }\n}\n\nfunction _getProjectRoot(): string | null {\n  return Constants.expoGoConfig?.developer?.projectRoot ?? null;\n}\n\nexport default {\n  serializeLogDataAsync,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}