{"ast":null,"code":"'use strict';\n\nvar _require = require(\"./commands\"),\n  getCommands = _require.getCommands;\nvar _require2 = require(\"./events\"),\n  getEvents = _require2.getEvents;\nvar _require3 = require(\"./extends\"),\n  categorizeProps = _require3.categorizeProps;\nvar _require4 = require(\"./props\"),\n  getProps = _require4.getProps;\nvar _require5 = require(\"./componentsUtils.js\"),\n  getProperties = _require5.getProperties;\nvar _require6 = require(\"../../error-utils\"),\n  throwIfMoreThanOneCodegenNativecommands = _require6.throwIfMoreThanOneCodegenNativecommands;\nvar _require7 = require(\"../../parsers-commons\"),\n  createComponentConfig = _require7.createComponentConfig,\n  findNativeComponentType = _require7.findNativeComponentType,\n  getCommandOptions = _require7.getCommandOptions,\n  getOptions = _require7.getOptions;\nfunction findComponentConfig(ast, parser) {\n  var foundConfigs = [];\n  var defaultExports = ast.body.filter(function (node) {\n    return node.type === 'ExportDefaultDeclaration';\n  });\n  defaultExports.forEach(function (statement) {\n    return findNativeComponentType(statement, foundConfigs, parser);\n  });\n  if (foundConfigs.length === 0) {\n    throw new Error('Could not find component config for native component');\n  }\n  if (foundConfigs.length > 1) {\n    throw new Error('Only one component is supported per file');\n  }\n  var foundConfig = foundConfigs[0];\n  var namedExports = ast.body.filter(function (node) {\n    return node.type === 'ExportNamedDeclaration';\n  });\n  var commandsTypeNames = namedExports.map(function (statement) {\n    var callExpression;\n    var calleeName;\n    try {\n      callExpression = statement.declaration.declarations[0].init;\n      calleeName = callExpression.callee.name;\n    } catch (e) {\n      return;\n    }\n    if (calleeName !== 'codegenNativeCommands') {\n      return;\n    }\n    if (callExpression.arguments.length !== 1) {\n      throw new Error('codegenNativeCommands must be passed options including the supported commands');\n    }\n    var typeArgumentParam = callExpression.typeParameters.params[0];\n    if (typeArgumentParam.type !== 'TSTypeReference') {\n      throw new Error(\"codegenNativeCommands doesn't support inline definitions. Specify a file local type alias\");\n    }\n    return {\n      commandTypeName: typeArgumentParam.typeName.name,\n      commandOptionsExpression: callExpression.arguments[0]\n    };\n  }).filter(Boolean);\n  throwIfMoreThanOneCodegenNativecommands(commandsTypeNames);\n  return createComponentConfig(foundConfig, commandsTypeNames);\n}\nfunction getCommandProperties(commandTypeName, types, commandOptions) {\n  if (commandTypeName == null) {\n    return [];\n  }\n  var typeAlias = types[commandTypeName];\n  if (typeAlias.type !== 'TSInterfaceDeclaration') {\n    throw new Error(`The type argument for codegenNativeCommands must be an interface, received ${typeAlias.type}`);\n  }\n  var properties;\n  try {\n    properties = typeAlias.body.body;\n  } catch (e) {\n    throw new Error(`Failed to find type definition for \"${commandTypeName}\", please check that you have a valid codegen typescript file`);\n  }\n  var typeScriptPropertyNames = properties.map(function (property) {\n    return property && property.key && property.key.name;\n  }).filter(Boolean);\n  if (commandOptions == null || commandOptions.supportedCommands == null) {\n    throw new Error('codegenNativeCommands must be given an options object with supportedCommands array');\n  }\n  if (commandOptions.supportedCommands.length !== typeScriptPropertyNames.length || !commandOptions.supportedCommands.every(function (supportedCommand) {\n    return typeScriptPropertyNames.includes(supportedCommand);\n  })) {\n    throw new Error(`codegenNativeCommands expected the same supportedCommands specified in the ${commandTypeName} interface: ${typeScriptPropertyNames.join(', ')}`);\n  }\n  return properties;\n}\nfunction buildComponentSchema(ast, parser) {\n  var _findComponentConfig = findComponentConfig(ast, parser),\n    componentName = _findComponentConfig.componentName,\n    propsTypeName = _findComponentConfig.propsTypeName,\n    commandTypeName = _findComponentConfig.commandTypeName,\n    commandOptionsExpression = _findComponentConfig.commandOptionsExpression,\n    optionsExpression = _findComponentConfig.optionsExpression;\n  var types = parser.getTypes(ast);\n  var propProperties = getProperties(propsTypeName, types);\n  var commandOptions = getCommandOptions(commandOptionsExpression);\n  var commandProperties = getCommandProperties(commandTypeName, types, commandOptions);\n  var options = getOptions(optionsExpression);\n  var extendsProps = [];\n  var componentPropAsts = [];\n  var componentEventAsts = [];\n  categorizeProps(propProperties, types, extendsProps, componentPropAsts, componentEventAsts);\n  var props = getProps(componentPropAsts, types);\n  var events = getEvents(componentEventAsts, types);\n  var commands = getCommands(commandProperties, types);\n  return {\n    filename: componentName,\n    componentName: componentName,\n    options: options,\n    extendsProps: extendsProps,\n    events: events,\n    props: props,\n    commands: commands\n  };\n}\nmodule.exports = {\n  buildComponentSchema: buildComponentSchema\n};","map":{"version":3,"names":["_require","require","getCommands","_require2","getEvents","_require3","categorizeProps","_require4","getProps","_require5","getProperties","_require6","throwIfMoreThanOneCodegenNativecommands","_require7","createComponentConfig","findNativeComponentType","getCommandOptions","getOptions","findComponentConfig","ast","parser","foundConfigs","defaultExports","body","filter","node","type","forEach","statement","length","Error","foundConfig","namedExports","commandsTypeNames","map","callExpression","calleeName","declaration","declarations","init","callee","name","e","arguments","typeArgumentParam","typeParameters","params","commandTypeName","typeName","commandOptionsExpression","Boolean","getCommandProperties","types","commandOptions","typeAlias","properties","typeScriptPropertyNames","property","key","supportedCommands","every","supportedCommand","includes","join","buildComponentSchema","_findComponentConfig","componentName","propsTypeName","optionsExpression","getTypes","propProperties","commandProperties","options","extendsProps","componentPropAsts","componentEventAsts","props","events","commands","filename","module","exports"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native/codegen/lib/parsers/typescript/components/index.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\n'use strict';\n\nconst _require = require('./commands'),\n  getCommands = _require.getCommands;\nconst _require2 = require('./events'),\n  getEvents = _require2.getEvents;\nconst _require3 = require('./extends'),\n  categorizeProps = _require3.categorizeProps;\nconst _require4 = require('./props'),\n  getProps = _require4.getProps;\nconst _require5 = require('./componentsUtils.js'),\n  getProperties = _require5.getProperties;\nconst _require6 = require('../../error-utils'),\n  throwIfMoreThanOneCodegenNativecommands =\n    _require6.throwIfMoreThanOneCodegenNativecommands;\nconst _require7 = require('../../parsers-commons'),\n  createComponentConfig = _require7.createComponentConfig,\n  findNativeComponentType = _require7.findNativeComponentType,\n  getCommandOptions = _require7.getCommandOptions,\n  getOptions = _require7.getOptions;\n\n// $FlowFixMe[signature-verification-failure] TODO(T108222691): Use flow-types for @babel/parser\nfunction findComponentConfig(ast, parser) {\n  const foundConfigs = [];\n  const defaultExports = ast.body.filter(\n    node => node.type === 'ExportDefaultDeclaration',\n  );\n  defaultExports.forEach(statement =>\n    findNativeComponentType(statement, foundConfigs, parser),\n  );\n  if (foundConfigs.length === 0) {\n    throw new Error('Could not find component config for native component');\n  }\n  if (foundConfigs.length > 1) {\n    throw new Error('Only one component is supported per file');\n  }\n  const foundConfig = foundConfigs[0];\n  const namedExports = ast.body.filter(\n    node => node.type === 'ExportNamedDeclaration',\n  );\n  const commandsTypeNames = namedExports\n    .map(statement => {\n      let callExpression;\n      let calleeName;\n      try {\n        callExpression = statement.declaration.declarations[0].init;\n        calleeName = callExpression.callee.name;\n      } catch (e) {\n        return;\n      }\n      if (calleeName !== 'codegenNativeCommands') {\n        return;\n      }\n\n      // const statement.declaration.declarations[0].init\n      if (callExpression.arguments.length !== 1) {\n        throw new Error(\n          'codegenNativeCommands must be passed options including the supported commands',\n        );\n      }\n      const typeArgumentParam = callExpression.typeParameters.params[0];\n      if (typeArgumentParam.type !== 'TSTypeReference') {\n        throw new Error(\n          \"codegenNativeCommands doesn't support inline definitions. Specify a file local type alias\",\n        );\n      }\n      return {\n        commandTypeName: typeArgumentParam.typeName.name,\n        commandOptionsExpression: callExpression.arguments[0],\n      };\n    })\n    .filter(Boolean);\n  throwIfMoreThanOneCodegenNativecommands(commandsTypeNames);\n  return createComponentConfig(foundConfig, commandsTypeNames);\n}\nfunction getCommandProperties(\n  /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n   * LTI update could not be added via codemod */\n  commandTypeName,\n  types,\n  commandOptions,\n) {\n  if (commandTypeName == null) {\n    return [];\n  }\n  const typeAlias = types[commandTypeName];\n  if (typeAlias.type !== 'TSInterfaceDeclaration') {\n    throw new Error(\n      `The type argument for codegenNativeCommands must be an interface, received ${typeAlias.type}`,\n    );\n  }\n  let properties;\n  try {\n    properties = typeAlias.body.body;\n  } catch (e) {\n    throw new Error(\n      `Failed to find type definition for \"${commandTypeName}\", please check that you have a valid codegen typescript file`,\n    );\n  }\n  const typeScriptPropertyNames = properties\n    .map(property => property && property.key && property.key.name)\n    .filter(Boolean);\n  if (commandOptions == null || commandOptions.supportedCommands == null) {\n    throw new Error(\n      'codegenNativeCommands must be given an options object with supportedCommands array',\n    );\n  }\n  if (\n    commandOptions.supportedCommands.length !==\n      typeScriptPropertyNames.length ||\n    !commandOptions.supportedCommands.every(supportedCommand =>\n      typeScriptPropertyNames.includes(supportedCommand),\n    )\n  ) {\n    throw new Error(\n      `codegenNativeCommands expected the same supportedCommands specified in the ${commandTypeName} interface: ${typeScriptPropertyNames.join(\n        ', ',\n      )}`,\n    );\n  }\n  return properties;\n}\n\n// $FlowFixMe[unclear-type] TODO(T108222691): Use flow-types for @babel/parser\n\n// $FlowFixMe[signature-verification-failure] TODO(T108222691): Use flow-types for @babel/parser\nfunction buildComponentSchema(ast, parser) {\n  const _findComponentConfig = findComponentConfig(ast, parser),\n    componentName = _findComponentConfig.componentName,\n    propsTypeName = _findComponentConfig.propsTypeName,\n    commandTypeName = _findComponentConfig.commandTypeName,\n    commandOptionsExpression = _findComponentConfig.commandOptionsExpression,\n    optionsExpression = _findComponentConfig.optionsExpression;\n  const types = parser.getTypes(ast);\n  const propProperties = getProperties(propsTypeName, types);\n  const commandOptions = getCommandOptions(commandOptionsExpression);\n  const commandProperties = getCommandProperties(\n    commandTypeName,\n    types,\n    commandOptions,\n  );\n  const options = getOptions(optionsExpression);\n  const extendsProps = [];\n  const componentPropAsts = [];\n  const componentEventAsts = [];\n  categorizeProps(\n    propProperties,\n    types,\n    extendsProps,\n    componentPropAsts,\n    componentEventAsts,\n  );\n  const props = getProps(componentPropAsts, types);\n  const events = getEvents(componentEventAsts, types);\n  const commands = getCommands(commandProperties, types);\n  return {\n    filename: componentName,\n    componentName,\n    options,\n    extendsProps,\n    events,\n    props,\n    commands,\n  };\n}\nmodule.exports = {\n  buildComponentSchema,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}