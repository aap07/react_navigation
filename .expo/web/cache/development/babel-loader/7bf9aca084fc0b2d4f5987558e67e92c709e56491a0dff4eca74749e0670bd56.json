{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport { readFileSync as readFile, readdirSync as readdir, existsSync as exists } from 'fs';\nimport createDebug from 'debug';\nimport { sync as commandExists } from 'command-exists';\nimport rimraf from 'rimraf';\nimport { isMac, isLinux, isWindows, pathForDomain, domainsDir, rootCAKeyPath, rootCACertPath, VALID_DOMAIN, VALID_IP } from \"./constants\";\nimport currentPlatform from \"./platforms\";\nimport installCertificateAuthority, { ensureCACertReadable, uninstall } from \"./certificate-authority\";\nimport generateDomainCertificate from \"./certificates\";\nimport UI from \"./user-interface\";\nexport { uninstall };\nvar debug = createDebug('devcert');\nexport function certificateFor(_x) {\n  return _certificateFor.apply(this, arguments);\n}\nfunction _certificateFor() {\n  _certificateFor = _asyncToGenerator(function* (domain) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (VALID_IP.test(domain)) {\n      throw new Error('IP addresses are not supported currently');\n    }\n    if (!VALID_DOMAIN.test(domain)) {\n      throw new Error(`\"${domain}\" is not a valid domain name.`);\n    }\n    debug(`Certificate requested for ${domain}. Skipping certutil install: ${Boolean(options.skipCertutilInstall)}. Skipping hosts file: ${Boolean(options.skipHostsFile)}`);\n    if (options.ui) {\n      Object.assign(UI, options.ui);\n    }\n    if (!isMac && !isLinux && !isWindows) {\n      throw new Error(`Platform not supported: \"${process.platform}\"`);\n    }\n    if (!commandExists('openssl')) {\n      throw new Error('OpenSSL not found: OpenSSL is required to generate SSL certificates - make sure it is installed and available in your PATH');\n    }\n    var domainKeyPath = pathForDomain(domain, `private-key.key`);\n    var domainCertPath = pathForDomain(domain, `certificate.crt`);\n    if (!exists(rootCAKeyPath)) {\n      debug('Root CA is not installed yet, so it must be our first run. Installing root CA ...');\n      yield installCertificateAuthority(options);\n    } else if (options.getCaBuffer || options.getCaPath) {\n      debug('Root CA is not readable, but it probably is because an earlier version of devcert locked it. Trying to fix...');\n      yield ensureCACertReadable(options);\n    }\n    if (!exists(pathForDomain(domain, `certificate.crt`))) {\n      debug(`Can't find certificate file for ${domain}, so it must be the first request for ${domain}. Generating and caching ...`);\n      yield generateDomainCertificate(domain);\n    }\n    if (!options.skipHostsFile) {\n      yield currentPlatform.addDomainToHostFileIfMissing(domain);\n    }\n    debug(`Returning domain certificate`);\n    var ret = {\n      key: readFile(domainKeyPath),\n      cert: readFile(domainCertPath)\n    };\n    if (options.getCaBuffer) ret.ca = readFile(rootCACertPath);\n    if (options.getCaPath) ret.caPath = rootCACertPath;\n    return ret;\n  });\n  return _certificateFor.apply(this, arguments);\n}\nexport function hasCertificateFor(domain) {\n  return exists(pathForDomain(domain, `certificate.crt`));\n}\nexport function configuredDomains() {\n  return readdir(domainsDir);\n}\nexport function removeDomain(domain) {\n  return rimraf.sync(pathForDomain(domain));\n}","map":{"version":3,"names":["readFileSync","readFile","readdirSync","readdir","existsSync","exists","createDebug","sync","commandExists","rimraf","isMac","isLinux","isWindows","pathForDomain","domainsDir","rootCAKeyPath","rootCACertPath","VALID_DOMAIN","VALID_IP","currentPlatform","installCertificateAuthority","ensureCACertReadable","uninstall","generateDomainCertificate","UI","debug","certificateFor","_x","_certificateFor","apply","arguments","_asyncToGenerator","domain","options","length","undefined","test","Error","Boolean","skipCertutilInstall","skipHostsFile","ui","Object","assign","process","platform","domainKeyPath","domainCertPath","getCaBuffer","getCaPath","addDomainToHostFileIfMissing","ret","key","cert","ca","caPath","hasCertificateFor","configuredDomains","removeDomain"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@expo/devcert/src/index.ts"],"sourcesContent":["import { readFileSync as readFile, readdirSync as readdir, existsSync as exists } from 'fs';\nimport createDebug from 'debug';\nimport { sync as commandExists } from 'command-exists';\nimport rimraf from 'rimraf';\nimport {\n  isMac,\n  isLinux,\n  isWindows,\n  pathForDomain,\n  domainsDir,\n  rootCAKeyPath,\n  rootCACertPath,\n  VALID_DOMAIN,\n  VALID_IP\n} from './constants';\nimport currentPlatform from './platforms';\nimport installCertificateAuthority, { ensureCACertReadable, uninstall } from './certificate-authority';\nimport generateDomainCertificate from './certificates';\nimport UI, { UserInterface } from './user-interface';\nexport { uninstall };\n\nconst debug = createDebug('devcert');\n\nexport interface Options /* extends Partial<ICaBufferOpts & ICaPathOpts>  */{\n  /** Return the CA certificate data? */\n  getCaBuffer?: boolean;\n  /** Return the path to the CA certificate? */\n  getCaPath?: boolean;\n  /** If `certutil` is not installed already (for updating nss databases; e.g. firefox), do not attempt to install it */\n  skipCertutilInstall?: boolean,\n  /** Do not update your systems host file with the domain name of the certificate */\n  skipHostsFile?: boolean,\n  /** User interface hooks */\n  ui?: UserInterface\n}\n\ninterface ICaBuffer {\n  ca: Buffer;\n}\ninterface ICaPath {\n  caPath: string;\n}\ninterface IDomainData {\n  key: Buffer;\n  cert: Buffer;\n}\ntype IReturnCa<O extends Options> = O['getCaBuffer'] extends true ? ICaBuffer : false;\ntype IReturnCaPath<O extends Options> = O['getCaPath'] extends true ? ICaPath : false;\ntype IReturnData<O extends Options = {}> = (IDomainData) & (IReturnCa<O>) & (IReturnCaPath<O>);\n\n/**\n * Request an SSL certificate for the given app name signed by the devcert root\n * certificate authority. If devcert has previously generated a certificate for\n * that app name on this machine, it will reuse that certificate.\n *\n * If this is the first time devcert is being run on this machine, it will\n * generate and attempt to install a root certificate authority.\n *\n * Returns a promise that resolves with { key, cert }, where `key` and `cert`\n * are Buffers with the contents of the certificate private key and certificate\n * file, respectively\n * \n * If `options.getCaBuffer` is true, return value will include the ca certificate data\n * as { ca: Buffer }\n * \n * If `options.getCaPath` is true, return value will include the ca certificate path\n * as { caPath: string }\n */\nexport async function certificateFor<O extends Options>(domain: string, options: O = {} as O): Promise<IReturnData<O>> {\n  if (VALID_IP.test(domain)) {\n    throw new Error('IP addresses are not supported currently');\n  }\n  if (!VALID_DOMAIN.test(domain)) {\n    throw new Error(`\"${domain}\" is not a valid domain name.`);\n  }\n  debug(`Certificate requested for ${ domain }. Skipping certutil install: ${ Boolean(options.skipCertutilInstall) }. Skipping hosts file: ${ Boolean(options.skipHostsFile) }`);\n\n  if (options.ui) {\n    Object.assign(UI, options.ui);\n  }\n\n  if (!isMac && !isLinux && !isWindows) {\n    throw new Error(`Platform not supported: \"${ process.platform }\"`);\n  }\n\n  if (!commandExists('openssl')) {\n    throw new Error('OpenSSL not found: OpenSSL is required to generate SSL certificates - make sure it is installed and available in your PATH');\n  }\n\n  let domainKeyPath = pathForDomain(domain, `private-key.key`);\n  let domainCertPath = pathForDomain(domain, `certificate.crt`);\n\n  if (!exists(rootCAKeyPath)) {\n    debug('Root CA is not installed yet, so it must be our first run. Installing root CA ...');\n    await installCertificateAuthority(options);\n  } else if (options.getCaBuffer || options.getCaPath) {\n    debug('Root CA is not readable, but it probably is because an earlier version of devcert locked it. Trying to fix...');\n    await ensureCACertReadable(options);\n  }\n\n  if (!exists(pathForDomain(domain, `certificate.crt`))) {\n    debug(`Can't find certificate file for ${ domain }, so it must be the first request for ${ domain }. Generating and caching ...`);\n    await generateDomainCertificate(domain);\n  }\n\n  if (!options.skipHostsFile) {\n    await currentPlatform.addDomainToHostFileIfMissing(domain);\n  }\n\n  debug(`Returning domain certificate`);\n\n  const ret = {\n    key: readFile(domainKeyPath),\n    cert: readFile(domainCertPath)\n  } as IReturnData<O>;\n  if (options.getCaBuffer) (ret as ICaBuffer).ca = readFile(rootCACertPath);\n  if (options.getCaPath) (ret as ICaPath).caPath = rootCACertPath;\n\n  return ret;\n}\n\nexport function hasCertificateFor(domain: string) {\n  return exists(pathForDomain(domain, `certificate.crt`));\n}\n\nexport function configuredDomains() {\n  return readdir(domainsDir);\n}\n\nexport function removeDomain(domain: string) {\n  return rimraf.sync(pathForDomain(domain));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}