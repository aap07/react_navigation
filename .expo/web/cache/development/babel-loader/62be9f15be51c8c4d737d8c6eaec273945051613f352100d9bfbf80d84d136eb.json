{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.withStaticPlugin = void 0;\nfunction _assert() {\n  var data = _interopRequireDefault(require(\"assert\"));\n  _assert = function _assert() {\n    return data;\n  };\n  return data;\n}\nfunction _getenv() {\n  var data = require(\"getenv\");\n  _getenv = function _getenv() {\n    return data;\n  };\n  return data;\n}\nfunction _errors() {\n  var data = require(\"../utils/errors\");\n  _errors = function _errors() {\n    return data;\n  };\n  return data;\n}\nfunction _pluginResolver() {\n  var data = require(\"../utils/plugin-resolver\");\n  _pluginResolver = function _pluginResolver() {\n    return data;\n  };\n  return data;\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar EXPO_DEBUG = (0, _getenv().boolish)('EXPO_DEBUG', false);\nvar EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS = (0, _getenv().boolish)('EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS', false);\nvar EXPO_USE_UNVERSIONED_PLUGINS = (0, _getenv().boolish)('EXPO_USE_UNVERSIONED_PLUGINS', false);\nfunction isModuleMissingError(name, error) {\n  if (['MODULE_NOT_FOUND', 'PLUGIN_NOT_FOUND'].includes(error.code)) {\n    return true;\n  }\n  return error.message.includes(`Cannot find module '${name}'`);\n}\nfunction isUnexpectedTokenError(error) {\n  if (error instanceof SyntaxError || error instanceof _errors().PluginError && error.code === 'INVALID_PLUGIN_IMPORT') {\n    return !!error.message.match(/Unexpected token/) || !!error.message.match(/Cannot use import statement/);\n  }\n  return false;\n}\nvar withStaticPlugin = function withStaticPlugin(config, props) {\n  var _pluginProps;\n  var projectRoot = props.projectRoot;\n  if (!projectRoot) {\n    var _config$_internal;\n    projectRoot = (_config$_internal = config._internal) === null || _config$_internal === void 0 ? void 0 : _config$_internal.projectRoot;\n    (0, _pluginResolver().assertInternalProjectRoot)(projectRoot);\n  }\n  var _ref = (0, _pluginResolver().normalizeStaticPlugin)(props.plugin),\n    _ref2 = _slicedToArray(_ref, 2),\n    pluginResolve = _ref2[0],\n    pluginProps = _ref2[1];\n  (0, _assert().default)(!((_pluginProps = pluginProps) !== null && _pluginProps !== void 0 && _pluginProps._resolverError), `Plugin property '_resolverError' is a reserved property of \\`withStaticPlugin\\``);\n  var withPlugin;\n  if (typeof pluginResolve === 'function') {\n    withPlugin = pluginResolve;\n  } else if (typeof pluginResolve === 'string') {\n    try {\n      withPlugin = (0, _pluginResolver().resolveConfigPluginFunction)(projectRoot, pluginResolve);\n      if (EXPO_USE_UNVERSIONED_PLUGINS && !!withPlugin && !!props._isLegacyPlugin && !!props.fallback) {\n        console.log(`Force \"${pluginResolve}\" to unversioned plugin`);\n        withPlugin = props.fallback;\n      }\n    } catch (error) {\n      if (EXPO_DEBUG) {\n        if (EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS) {\n          console.log(`Error resolving plugin \"${pluginResolve}\"`);\n          console.log(error);\n          console.log();\n        } else {\n          var shouldMuteWarning = props._isLegacyPlugin && (isModuleMissingError(pluginResolve, error) || isUnexpectedTokenError(error));\n          if (!shouldMuteWarning) {\n            if (isModuleMissingError(pluginResolve, error)) {\n              console.log(`Could not find plugin \"${pluginResolve}\"`);\n            } else {\n              console.log(`Error resolving plugin \"${pluginResolve}\"`);\n              console.log(error);\n              console.log();\n            }\n          }\n        }\n      }\n      if (props.fallback) {\n        if (!pluginProps) pluginProps = {};\n        pluginProps._resolverError = error;\n        withPlugin = props.fallback;\n      } else {\n        throw error;\n      }\n    }\n  } else {\n    throw new (_errors().PluginError)(`Plugin is an unexpected type: ${typeof pluginResolve}`, 'INVALID_PLUGIN_TYPE');\n  }\n  config = withPlugin(config, pluginProps);\n  return config;\n};\nexports.withStaticPlugin = withStaticPlugin;","map":{"version":3,"names":["_assert","data","_interopRequireDefault","require","_getenv","_errors","_pluginResolver","obj","__esModule","default","EXPO_DEBUG","boolish","EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS","EXPO_USE_UNVERSIONED_PLUGINS","isModuleMissingError","name","error","includes","code","message","isUnexpectedTokenError","SyntaxError","PluginError","match","withStaticPlugin","config","props","_pluginProps","projectRoot","_config$_internal","_internal","assertInternalProjectRoot","_ref","normalizeStaticPlugin","plugin","_ref2","_slicedToArray","pluginResolve","pluginProps","_resolverError","withPlugin","resolveConfigPluginFunction","_isLegacyPlugin","fallback","console","log","shouldMuteWarning","exports"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\config-plugins\\src\\plugins\\withStaticPlugin.ts"],"sourcesContent":["import assert from 'assert';\nimport { boolish } from 'getenv';\n\nimport { ConfigPlugin, StaticPlugin } from '../Plugin.types';\nimport { PluginError } from '../utils/errors';\nimport {\n  assertInternalProjectRoot,\n  normalizeStaticPlugin,\n  resolveConfigPluginFunction,\n} from '../utils/plugin-resolver';\n\nconst EXPO_DEBUG = boolish('EXPO_DEBUG', false);\n\n// Show all error info related to plugin resolution.\nconst EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS = boolish('EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS', false);\n// Force using the fallback unversioned plugin instead of a local versioned copy,\n// this should only be used for testing the CLI.\nconst EXPO_USE_UNVERSIONED_PLUGINS = boolish('EXPO_USE_UNVERSIONED_PLUGINS', false);\n\nfunction isModuleMissingError(name: string, error: Error): boolean {\n  // @ts-ignore\n  if (['MODULE_NOT_FOUND', 'PLUGIN_NOT_FOUND'].includes(error.code)) {\n    return true;\n  }\n  return error.message.includes(`Cannot find module '${name}'`);\n}\n\nfunction isUnexpectedTokenError(error: Error): boolean {\n  if (\n    error instanceof SyntaxError ||\n    (error instanceof PluginError && error.code === 'INVALID_PLUGIN_IMPORT')\n  ) {\n    return (\n      // These are the most common errors that'll be thrown when a package isn't transpiled correctly.\n      !!error.message.match(/Unexpected token/) ||\n      !!error.message.match(/Cannot use import statement/)\n    );\n  }\n  return false;\n}\n\n/**\n * Resolves static module plugin and potentially falls back on a provided plugin if the module cannot be resolved\n *\n * @param config\n * @param fallback Plugin with `_resolverError` explaining why the module couldn't be used\n * @param projectRoot optional project root, fallback to _internal.projectRoot. Used for testing.\n * @param _isLegacyPlugin Used to suppress errors thrown by plugins that are applied automatically\n */\nexport const withStaticPlugin: ConfigPlugin<{\n  plugin: StaticPlugin | ConfigPlugin | string;\n  fallback?: ConfigPlugin<{ _resolverError: Error } & any>;\n  projectRoot?: string;\n  _isLegacyPlugin?: boolean;\n}> = (config, props) => {\n  let projectRoot = props.projectRoot;\n  if (!projectRoot) {\n    projectRoot = config._internal?.projectRoot;\n    assertInternalProjectRoot(projectRoot);\n  }\n\n  let [pluginResolve, pluginProps] = normalizeStaticPlugin(props.plugin);\n  // Ensure no one uses this property by accident.\n  assert(\n    !pluginProps?._resolverError,\n    `Plugin property '_resolverError' is a reserved property of \\`withStaticPlugin\\``\n  );\n\n  let withPlugin: ConfigPlugin<unknown>;\n\n  if (\n    // Function was provided, no need to resolve: [withPlugin, {}]\n    typeof pluginResolve === 'function'\n  ) {\n    withPlugin = pluginResolve;\n  } else if (typeof pluginResolve === 'string') {\n    try {\n      // Resolve and evaluate plugins.\n      withPlugin = resolveConfigPluginFunction(projectRoot, pluginResolve);\n\n      // Only force if the project has the versioned plugin, otherwise use default behavior.\n      // This helps see which plugins are being skipped.\n      if (\n        EXPO_USE_UNVERSIONED_PLUGINS &&\n        !!withPlugin &&\n        !!props._isLegacyPlugin &&\n        !!props.fallback\n      ) {\n        console.log(`Force \"${pluginResolve}\" to unversioned plugin`);\n        withPlugin = props.fallback;\n      }\n    } catch (error: any) {\n      if (EXPO_DEBUG) {\n        if (EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS) {\n          // Log the error in debug mode for plugins with fallbacks (like the Expo managed plugins).\n          console.log(`Error resolving plugin \"${pluginResolve}\"`);\n          console.log(error);\n          console.log();\n        } else {\n          const shouldMuteWarning =\n            props._isLegacyPlugin &&\n            (isModuleMissingError(pluginResolve, error) || isUnexpectedTokenError(error));\n          if (!shouldMuteWarning) {\n            if (isModuleMissingError(pluginResolve, error)) {\n              // Prevent causing log spew for basic resolution errors.\n              console.log(`Could not find plugin \"${pluginResolve}\"`);\n            } else {\n              // Log the error in debug mode for plugins with fallbacks (like the Expo managed plugins).\n              console.log(`Error resolving plugin \"${pluginResolve}\"`);\n              console.log(error);\n              console.log();\n            }\n          }\n        }\n      }\n      // TODO: Maybe allow for `PluginError`s to be thrown so external plugins can assert invalid options.\n\n      // If the static module failed to resolve, attempt to use a fallback.\n      // This enables support for built-in plugins with versioned variations living in other packages.\n      if (props.fallback) {\n        if (!pluginProps) pluginProps = {};\n        // Pass this to the fallback plugin for potential warnings about needing to install a versioned package.\n        pluginProps._resolverError = error;\n        withPlugin = props.fallback;\n      } else {\n        // If no fallback, throw the resolution error.\n        throw error;\n      }\n    }\n  } else {\n    throw new PluginError(\n      `Plugin is an unexpected type: ${typeof pluginResolve}`,\n      'INVALID_PLUGIN_TYPE'\n    );\n  }\n\n  // Execute the plugin.\n  config = withPlugin(config, pluginProps);\n  return config;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}