{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.downloadAppAsync = downloadAppAsync;\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _stream = require(\"stream\");\nvar _tempy = _interopRequireDefault(require(\"tempy\"));\nvar _util = require(\"util\");\nvar _client = require(\"../api/rest/client\");\nvar _dir = require(\"./dir\");\nvar _errors = require(\"./errors\");\nvar _tar = require(\"./tar\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar debug = require(\"debug\")(\"expo:utils:downloadAppAsync\");\nvar TIMER_DURATION = 30000;\nvar pipeline = (0, _util).promisify(_stream.Stream.pipeline);\nfunction downloadAsync(_x) {\n  return _downloadAsync.apply(this, arguments);\n}\nfunction _downloadAsync() {\n  _downloadAsync = _asyncToGenerator(function* (_ref) {\n    var url = _ref.url,\n      outputPath = _ref.outputPath,\n      cacheDirectory = _ref.cacheDirectory,\n      onProgress = _ref.onProgress;\n    var fetchInstance = _client.fetchAsync;\n    if (cacheDirectory) {\n      fetchInstance = (0, _client).createCachedFetch({\n        ttl: 1000 * 60 * 60 * 24 * 7,\n        cacheDirectory: cacheDirectory\n      });\n    }\n    debug(`Downloading ${url} to ${outputPath}`);\n    var res = yield fetchInstance(url, {\n      timeout: TIMER_DURATION,\n      onProgress: onProgress\n    });\n    if (!res.ok) {\n      throw new _errors.CommandError(\"FILE_DOWNLOAD\", `Unexpected response: ${res.statusText}. From url: ${url}`);\n    }\n    return pipeline(res.body, _fs.default.createWriteStream(outputPath));\n  });\n  return _downloadAsync.apply(this, arguments);\n}\nfunction downloadAppAsync(_x2) {\n  return _downloadAppAsync.apply(this, arguments);\n}\nfunction _downloadAppAsync() {\n  _downloadAppAsync = _asyncToGenerator(function* (_ref2) {\n    var url = _ref2.url,\n      outputPath = _ref2.outputPath,\n      _ref2$extract = _ref2.extract,\n      extract = _ref2$extract === void 0 ? false : _ref2$extract,\n      cacheDirectory = _ref2.cacheDirectory,\n      onProgress = _ref2.onProgress;\n    if (extract) {\n      var tmpPath = _tempy.default.file({\n        name: _path.default.basename(outputPath)\n      });\n      yield downloadAsync({\n        url: url,\n        outputPath: tmpPath,\n        cacheDirectory: cacheDirectory,\n        onProgress: onProgress\n      });\n      debug(`Extracting ${tmpPath} to ${outputPath}`);\n      yield (0, _dir).ensureDirectoryAsync(outputPath);\n      yield (0, _tar).extractAsync(tmpPath, outputPath);\n    } else {\n      yield (0, _dir).ensureDirectoryAsync(_path.default.dirname(outputPath));\n      yield downloadAsync({\n        url: url,\n        outputPath: outputPath,\n        cacheDirectory: cacheDirectory,\n        onProgress: onProgress\n      });\n    }\n  });\n  return _downloadAppAsync.apply(this, arguments);\n}","map":{"version":3,"names":["_asyncToGenerator","require","downloadAppAsync","_fs","_interopRequireDefault","_path","_stream","_tempy","_util","_client","_dir","_errors","_tar","debug","TIMER_DURATION","pipeline","promisify","Stream","downloadAsync","_x","_downloadAsync","apply","arguments","_ref","url","outputPath","cacheDirectory","onProgress","fetchInstance","fetchAsync","createCachedFetch","ttl","res","timeout","ok","CommandError","statusText","body","default","createWriteStream","_x2","_downloadAppAsync","_ref2","_ref2$extract","extract","tmpPath","file","name","basename","ensureDirectoryAsync","extractAsync","dirname"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\cli\\src\\utils\\downloadAppAsync.ts"],"sourcesContent":["import fs from 'fs';\nimport path from 'path';\nimport { Stream } from 'stream';\nimport temporary from 'tempy';\nimport { promisify } from 'util';\n\nimport { createCachedFetch, fetchAsync } from '../api/rest/client';\nimport { FetchLike, ProgressCallback } from '../api/rest/client.types';\nimport { ensureDirectoryAsync } from './dir';\nimport { CommandError } from './errors';\nimport { extractAsync } from './tar';\n\nconst debug = require('debug')('expo:utils:downloadAppAsync') as typeof console.log;\n\nconst TIMER_DURATION = 30000;\n\nconst pipeline = promisify(Stream.pipeline);\n\nasync function downloadAsync({\n  url,\n  outputPath,\n  cacheDirectory,\n  onProgress,\n}: {\n  url: string;\n  outputPath: string;\n  cacheDirectory?: string;\n  onProgress?: ProgressCallback;\n}) {\n  let fetchInstance: FetchLike = fetchAsync;\n  if (cacheDirectory) {\n    // Reconstruct the cached fetch since caching could be disabled.\n    fetchInstance = createCachedFetch({\n      // We'll use a 1 week cache for versions so older values get flushed out eventually.\n      ttl: 1000 * 60 * 60 * 24 * 7,\n      // Users can also nuke their `~/.expo` directory to clear the cache.\n      cacheDirectory,\n    });\n  }\n\n  debug(`Downloading ${url} to ${outputPath}`);\n  const res = await fetchInstance(url, {\n    timeout: TIMER_DURATION,\n    onProgress,\n  });\n  if (!res.ok) {\n    throw new CommandError(\n      'FILE_DOWNLOAD',\n      `Unexpected response: ${res.statusText}. From url: ${url}`\n    );\n  }\n  return pipeline(res.body, fs.createWriteStream(outputPath));\n}\n\nexport async function downloadAppAsync({\n  url,\n  outputPath,\n  extract = false,\n  cacheDirectory,\n  onProgress,\n}: {\n  url: string;\n  outputPath: string;\n  extract?: boolean;\n  cacheDirectory?: string;\n  onProgress?: ProgressCallback;\n}): Promise<void> {\n  if (extract) {\n    // For iOS we download the ipa to a file then pass that file into the extractor.\n    // In the future we should just pipe the `res.body -> tar.extract` directly.\n    // I tried this and it created some weird errors where observing the data stream\n    // would corrupt the file causing tar to fail with `TAR_BAD_ARCHIVE`.\n    const tmpPath = temporary.file({ name: path.basename(outputPath) });\n    await downloadAsync({ url, outputPath: tmpPath, cacheDirectory, onProgress });\n    debug(`Extracting ${tmpPath} to ${outputPath}`);\n    await ensureDirectoryAsync(outputPath);\n    await extractAsync(tmpPath, outputPath);\n  } else {\n    await ensureDirectoryAsync(path.dirname(outputPath));\n    await downloadAsync({ url, outputPath, cacheDirectory, onProgress });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}