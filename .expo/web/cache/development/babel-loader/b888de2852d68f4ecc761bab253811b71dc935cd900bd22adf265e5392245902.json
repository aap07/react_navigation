{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, 'string');\n  return typeof key === 'symbol' ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== 'object' || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || 'default');\n    if (typeof res !== 'object') return res;\n    throw new TypeError('@@toPrimitive must return a primitive value.');\n  }\n  return (hint === 'string' ? String : Number)(input);\n}\nvar _require = require(\"./modules\"),\n  typeScriptTranslateTypeAnnotation = _require.typeScriptTranslateTypeAnnotation;\nvar babelParser = require('@babel/parser');\nvar _require2 = require(\"../parsers-commons\"),\n  buildSchema = _require2.buildSchema;\nvar _require3 = require(\"../parsers-primitives\"),\n  Visitor = _require3.Visitor;\nvar _require4 = require(\"./components\"),\n  buildComponentSchema = _require4.buildComponentSchema;\nvar _require5 = require(\"../schema.js\"),\n  wrapComponentSchema = _require5.wrapComponentSchema;\nvar _require6 = require(\"../parsers-commons.js\"),\n  buildModuleSchema = _require6.buildModuleSchema;\nvar _require7 = require(\"./utils\"),\n  resolveTypeAnnotation = _require7.resolveTypeAnnotation;\nvar fs = require('fs');\nvar _require8 = require(\"../errors\"),\n  UnsupportedObjectPropertyTypeAnnotationParserError = _require8.UnsupportedObjectPropertyTypeAnnotationParserError;\nvar TypeScriptParser = function () {\n  function TypeScriptParser() {\n    _classCallCheck(this, TypeScriptParser);\n    _defineProperty(this, 'typeParameterInstantiation', 'TSTypeParameterInstantiation');\n  }\n  _createClass(TypeScriptParser, [{\n    key: \"isProperty\",\n    value: function isProperty(property) {\n      return property.type === 'TSPropertySignature';\n    }\n  }, {\n    key: \"getKeyName\",\n    value: function getKeyName(property, hasteModuleName) {\n      if (!this.isProperty(property)) {\n        throw new UnsupportedObjectPropertyTypeAnnotationParserError(hasteModuleName, property, property.type, this.language());\n      }\n      return property.key.name;\n    }\n  }, {\n    key: \"language\",\n    value: function language() {\n      return 'TypeScript';\n    }\n  }, {\n    key: \"nameForGenericTypeAnnotation\",\n    value: function nameForGenericTypeAnnotation(typeAnnotation) {\n      return typeAnnotation.typeName.name;\n    }\n  }, {\n    key: \"checkIfInvalidModule\",\n    value: function checkIfInvalidModule(typeArguments) {\n      return typeArguments.type !== 'TSTypeParameterInstantiation' || typeArguments.params.length !== 1 || typeArguments.params[0].type !== 'TSTypeReference' || typeArguments.params[0].typeName.name !== 'Spec';\n    }\n  }, {\n    key: \"remapUnionTypeAnnotationMemberNames\",\n    value: function remapUnionTypeAnnotationMemberNames(membersTypes) {\n      var remapLiteral = function remapLiteral(item) {\n        return item.literal ? item.literal.type.replace('NumericLiteral', 'NumberTypeAnnotation').replace('StringLiteral', 'StringTypeAnnotation') : 'ObjectTypeAnnotation';\n      };\n      return _toConsumableArray(new Set(membersTypes.map(remapLiteral)));\n    }\n  }, {\n    key: \"parseFile\",\n    value: function parseFile(filename) {\n      var contents = fs.readFileSync(filename, 'utf8');\n      return this.parseString(contents, filename);\n    }\n  }, {\n    key: \"parseString\",\n    value: function parseString(contents, filename) {\n      return buildSchema(contents, filename, wrapComponentSchema, buildComponentSchema, buildModuleSchema, Visitor, this, resolveTypeAnnotation, typeScriptTranslateTypeAnnotation);\n    }\n  }, {\n    key: \"parseModuleFixture\",\n    value: function parseModuleFixture(filename) {\n      var contents = fs.readFileSync(filename, 'utf8');\n      return this.parseString(contents, 'path/NativeSampleTurboModule.ts');\n    }\n  }, {\n    key: \"getAst\",\n    value: function getAst(contents) {\n      return babelParser.parse(contents, {\n        sourceType: 'module',\n        plugins: ['typescript']\n      }).program;\n    }\n  }, {\n    key: \"getFunctionTypeAnnotationParameters\",\n    value: function getFunctionTypeAnnotationParameters(functionTypeAnnotation) {\n      return functionTypeAnnotation.parameters;\n    }\n  }, {\n    key: \"getFunctionNameFromParameter\",\n    value: function getFunctionNameFromParameter(parameter) {\n      return parameter.typeAnnotation;\n    }\n  }, {\n    key: \"getParameterName\",\n    value: function getParameterName(parameter) {\n      return parameter.name;\n    }\n  }, {\n    key: \"getParameterTypeAnnotation\",\n    value: function getParameterTypeAnnotation(parameter) {\n      return parameter.typeAnnotation.typeAnnotation;\n    }\n  }, {\n    key: \"getFunctionTypeAnnotationReturnType\",\n    value: function getFunctionTypeAnnotationReturnType(functionTypeAnnotation) {\n      return functionTypeAnnotation.typeAnnotation.typeAnnotation;\n    }\n  }, {\n    key: \"parseEnumMembersType\",\n    value: function parseEnumMembersType(typeAnnotation) {\n      var _typeAnnotation$membe;\n      var enumInitializer = (_typeAnnotation$membe = typeAnnotation.members[0]) === null || _typeAnnotation$membe === void 0 ? void 0 : _typeAnnotation$membe.initializer;\n      var enumMembersType = !enumInitializer || enumInitializer.type === 'StringLiteral' ? 'StringTypeAnnotation' : enumInitializer.type === 'NumericLiteral' ? 'NumberTypeAnnotation' : null;\n      if (!enumMembersType) {\n        throw new Error('Enum values must be either blank, number, or string values.');\n      }\n      return enumMembersType;\n    }\n  }, {\n    key: \"validateEnumMembersSupported\",\n    value: function validateEnumMembersSupported(typeAnnotation, enumMembersType) {\n      if (!typeAnnotation.members || typeAnnotation.members.length === 0) {\n        throw new Error('Enums should have at least one member.');\n      }\n      var enumInitializerType = enumMembersType === 'StringTypeAnnotation' ? 'StringLiteral' : enumMembersType === 'NumberTypeAnnotation' ? 'NumericLiteral' : null;\n      typeAnnotation.members.forEach(function (member) {\n        var _member$initializer$t, _member$initializer;\n        if (((_member$initializer$t = (_member$initializer = member.initializer) === null || _member$initializer === void 0 ? void 0 : _member$initializer.type) !== null && _member$initializer$t !== void 0 ? _member$initializer$t : 'StringLiteral') !== enumInitializerType) {\n          throw new Error('Enum values can not be mixed. They all must be either blank, number, or string values.');\n        }\n      });\n    }\n  }, {\n    key: \"parseEnumMembers\",\n    value: function parseEnumMembers(typeAnnotation) {\n      return typeAnnotation.members.map(function (member) {\n        var _member$initializer$v, _member$initializer2;\n        return {\n          name: member.id.name,\n          value: (_member$initializer$v = (_member$initializer2 = member.initializer) === null || _member$initializer2 === void 0 ? void 0 : _member$initializer2.value) !== null && _member$initializer$v !== void 0 ? _member$initializer$v : member.id.name\n        };\n      });\n    }\n  }, {\n    key: \"isModuleInterface\",\n    value: function isModuleInterface(node) {\n      var _node$extends;\n      return node.type === 'TSInterfaceDeclaration' && ((_node$extends = node.extends) === null || _node$extends === void 0 ? void 0 : _node$extends.length) === 1 && node.extends[0].type === 'TSExpressionWithTypeArguments' && node.extends[0].expression.name === 'TurboModule';\n    }\n  }, {\n    key: \"extractAnnotatedElement\",\n    value: function extractAnnotatedElement(typeAnnotation, types) {\n      return types[typeAnnotation.typeParameters.params[0].typeName.name];\n    }\n  }, {\n    key: \"getTypes\",\n    value: function getTypes(ast) {\n      return ast.body.reduce(function (types, node) {\n        switch (node.type) {\n          case 'ExportNamedDeclaration':\n            {\n              if (node.declaration) {\n                switch (node.declaration.type) {\n                  case 'TSTypeAliasDeclaration':\n                  case 'TSInterfaceDeclaration':\n                  case 'TSEnumDeclaration':\n                    {\n                      types[node.declaration.id.name] = node.declaration;\n                      break;\n                    }\n                }\n              }\n              break;\n            }\n          case 'TSTypeAliasDeclaration':\n          case 'TSInterfaceDeclaration':\n          case 'TSEnumDeclaration':\n            {\n              types[node.id.name] = node;\n              break;\n            }\n        }\n        return types;\n      }, {});\n    }\n  }, {\n    key: \"callExpressionTypeParameters\",\n    value: function callExpressionTypeParameters(callExpression) {\n      return callExpression.typeParameters || null;\n    }\n  }, {\n    key: \"computePartialProperties\",\n    value: function computePartialProperties(properties, hasteModuleName, types, aliasMap, enumMap, tryParse, cxxOnly) {\n      var _this = this;\n      return properties.map(function (prop) {\n        return {\n          name: prop.key.name,\n          optional: true,\n          typeAnnotation: typeScriptTranslateTypeAnnotation(hasteModuleName, prop.typeAnnotation.typeAnnotation, types, aliasMap, enumMap, tryParse, cxxOnly, _this)\n        };\n      });\n    }\n  }, {\n    key: \"functionTypeAnnotation\",\n    value: function functionTypeAnnotation(propertyValueType) {\n      return propertyValueType === 'TSFunctionType' || propertyValueType === 'TSMethodSignature';\n    }\n  }, {\n    key: \"getTypeArgumentParamsFromDeclaration\",\n    value: function getTypeArgumentParamsFromDeclaration(declaration) {\n      return declaration.typeParameters.params;\n    }\n  }, {\n    key: \"getNativeComponentType\",\n    value: function getNativeComponentType(typeArgumentParams, funcArgumentParams) {\n      return {\n        propsTypeName: typeArgumentParams[0].typeName.name,\n        componentName: funcArgumentParams[0].value\n      };\n    }\n  }, {\n    key: \"getAnnotatedElementProperties\",\n    value: function getAnnotatedElementProperties(annotatedElement) {\n      return annotatedElement.typeAnnotation.members;\n    }\n  }]);\n  return TypeScriptParser;\n}();\nmodule.exports = {\n  TypeScriptParser: TypeScriptParser\n};","map":{"version":3,"names":["_toConsumableArray","require","_classCallCheck","_createClass","_defineProperty","obj","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","arg","_toPrimitive","String","input","hint","prim","Symbol","toPrimitive","undefined","res","call","TypeError","Number","_require","typeScriptTranslateTypeAnnotation","babelParser","_require2","buildSchema","_require3","Visitor","_require4","buildComponentSchema","_require5","wrapComponentSchema","_require6","buildModuleSchema","_require7","resolveTypeAnnotation","fs","_require8","UnsupportedObjectPropertyTypeAnnotationParserError","TypeScriptParser","isProperty","property","type","getKeyName","hasteModuleName","language","name","nameForGenericTypeAnnotation","typeAnnotation","typeName","checkIfInvalidModule","typeArguments","params","length","remapUnionTypeAnnotationMemberNames","membersTypes","remapLiteral","item","literal","replace","Set","map","parseFile","filename","contents","readFileSync","parseString","parseModuleFixture","getAst","parse","sourceType","plugins","program","getFunctionTypeAnnotationParameters","functionTypeAnnotation","parameters","getFunctionNameFromParameter","parameter","getParameterName","getParameterTypeAnnotation","getFunctionTypeAnnotationReturnType","parseEnumMembersType","_typeAnnotation$membe","enumInitializer","members","initializer","enumMembersType","Error","validateEnumMembersSupported","enumInitializerType","forEach","member","_member$initializer$t","_member$initializer","parseEnumMembers","_member$initializer$v","_member$initializer2","id","isModuleInterface","node","_node$extends","extends","expression","extractAnnotatedElement","types","typeParameters","getTypes","ast","body","reduce","declaration","callExpressionTypeParameters","callExpression","computePartialProperties","properties","aliasMap","enumMap","tryParse","cxxOnly","_this","prop","optional","propertyValueType","getTypeArgumentParamsFromDeclaration","getNativeComponentType","typeArgumentParams","funcArgumentParams","propsTypeName","componentName","getAnnotatedElementProperties","annotatedElement","module","exports"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native/codegen/lib/parsers/typescript/parser.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\n'use strict';\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true,\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, 'string');\n  return typeof key === 'symbol' ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== 'object' || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || 'default');\n    if (typeof res !== 'object') return res;\n    throw new TypeError('@@toPrimitive must return a primitive value.');\n  }\n  return (hint === 'string' ? String : Number)(input);\n}\nconst _require = require('./modules'),\n  typeScriptTranslateTypeAnnotation =\n    _require.typeScriptTranslateTypeAnnotation;\n\n// $FlowFixMe[untyped-import] Use flow-types for @babel/parser\nconst babelParser = require('@babel/parser');\nconst _require2 = require('../parsers-commons'),\n  buildSchema = _require2.buildSchema;\nconst _require3 = require('../parsers-primitives'),\n  Visitor = _require3.Visitor;\nconst _require4 = require('./components'),\n  buildComponentSchema = _require4.buildComponentSchema;\nconst _require5 = require('../schema.js'),\n  wrapComponentSchema = _require5.wrapComponentSchema;\nconst _require6 = require('../parsers-commons.js'),\n  buildModuleSchema = _require6.buildModuleSchema;\nconst _require7 = require('./utils'),\n  resolveTypeAnnotation = _require7.resolveTypeAnnotation;\nconst fs = require('fs');\nconst _require8 = require('../errors'),\n  UnsupportedObjectPropertyTypeAnnotationParserError =\n    _require8.UnsupportedObjectPropertyTypeAnnotationParserError;\nclass TypeScriptParser {\n  constructor() {\n    _defineProperty(\n      this,\n      'typeParameterInstantiation',\n      'TSTypeParameterInstantiation',\n    );\n  }\n  isProperty(property) {\n    return property.type === 'TSPropertySignature';\n  }\n  getKeyName(property, hasteModuleName) {\n    if (!this.isProperty(property)) {\n      throw new UnsupportedObjectPropertyTypeAnnotationParserError(\n        hasteModuleName,\n        property,\n        property.type,\n        this.language(),\n      );\n    }\n    return property.key.name;\n  }\n  language() {\n    return 'TypeScript';\n  }\n  nameForGenericTypeAnnotation(typeAnnotation) {\n    return typeAnnotation.typeName.name;\n  }\n  checkIfInvalidModule(typeArguments) {\n    return (\n      typeArguments.type !== 'TSTypeParameterInstantiation' ||\n      typeArguments.params.length !== 1 ||\n      typeArguments.params[0].type !== 'TSTypeReference' ||\n      typeArguments.params[0].typeName.name !== 'Spec'\n    );\n  }\n  remapUnionTypeAnnotationMemberNames(membersTypes) {\n    const remapLiteral = item => {\n      return item.literal\n        ? item.literal.type\n            .replace('NumericLiteral', 'NumberTypeAnnotation')\n            .replace('StringLiteral', 'StringTypeAnnotation')\n        : 'ObjectTypeAnnotation';\n    };\n    return [...new Set(membersTypes.map(remapLiteral))];\n  }\n  parseFile(filename) {\n    const contents = fs.readFileSync(filename, 'utf8');\n    return this.parseString(contents, filename);\n  }\n  parseString(contents, filename) {\n    return buildSchema(\n      contents,\n      filename,\n      wrapComponentSchema,\n      buildComponentSchema,\n      buildModuleSchema,\n      Visitor,\n      this,\n      resolveTypeAnnotation,\n      typeScriptTranslateTypeAnnotation,\n    );\n  }\n  parseModuleFixture(filename) {\n    const contents = fs.readFileSync(filename, 'utf8');\n    return this.parseString(contents, 'path/NativeSampleTurboModule.ts');\n  }\n  getAst(contents) {\n    return babelParser.parse(contents, {\n      sourceType: 'module',\n      plugins: ['typescript'],\n    }).program;\n  }\n  getFunctionTypeAnnotationParameters(functionTypeAnnotation) {\n    return functionTypeAnnotation.parameters;\n  }\n  getFunctionNameFromParameter(parameter) {\n    return parameter.typeAnnotation;\n  }\n  getParameterName(parameter) {\n    return parameter.name;\n  }\n  getParameterTypeAnnotation(parameter) {\n    return parameter.typeAnnotation.typeAnnotation;\n  }\n  getFunctionTypeAnnotationReturnType(functionTypeAnnotation) {\n    return functionTypeAnnotation.typeAnnotation.typeAnnotation;\n  }\n  parseEnumMembersType(typeAnnotation) {\n    var _typeAnnotation$membe;\n    const enumInitializer =\n      (_typeAnnotation$membe = typeAnnotation.members[0]) === null ||\n      _typeAnnotation$membe === void 0\n        ? void 0\n        : _typeAnnotation$membe.initializer;\n    const enumMembersType =\n      !enumInitializer || enumInitializer.type === 'StringLiteral'\n        ? 'StringTypeAnnotation'\n        : enumInitializer.type === 'NumericLiteral'\n        ? 'NumberTypeAnnotation'\n        : null;\n    if (!enumMembersType) {\n      throw new Error(\n        'Enum values must be either blank, number, or string values.',\n      );\n    }\n    return enumMembersType;\n  }\n  validateEnumMembersSupported(typeAnnotation, enumMembersType) {\n    if (!typeAnnotation.members || typeAnnotation.members.length === 0) {\n      throw new Error('Enums should have at least one member.');\n    }\n    const enumInitializerType =\n      enumMembersType === 'StringTypeAnnotation'\n        ? 'StringLiteral'\n        : enumMembersType === 'NumberTypeAnnotation'\n        ? 'NumericLiteral'\n        : null;\n    typeAnnotation.members.forEach(member => {\n      var _member$initializer$t, _member$initializer;\n      if (\n        ((_member$initializer$t =\n          (_member$initializer = member.initializer) === null ||\n          _member$initializer === void 0\n            ? void 0\n            : _member$initializer.type) !== null &&\n        _member$initializer$t !== void 0\n          ? _member$initializer$t\n          : 'StringLiteral') !== enumInitializerType\n      ) {\n        throw new Error(\n          'Enum values can not be mixed. They all must be either blank, number, or string values.',\n        );\n      }\n    });\n  }\n  parseEnumMembers(typeAnnotation) {\n    return typeAnnotation.members.map(member => {\n      var _member$initializer$v, _member$initializer2;\n      return {\n        name: member.id.name,\n        value:\n          (_member$initializer$v =\n            (_member$initializer2 = member.initializer) === null ||\n            _member$initializer2 === void 0\n              ? void 0\n              : _member$initializer2.value) !== null &&\n          _member$initializer$v !== void 0\n            ? _member$initializer$v\n            : member.id.name,\n      };\n    });\n  }\n  isModuleInterface(node) {\n    var _node$extends;\n    return (\n      node.type === 'TSInterfaceDeclaration' &&\n      ((_node$extends = node.extends) === null || _node$extends === void 0\n        ? void 0\n        : _node$extends.length) === 1 &&\n      node.extends[0].type === 'TSExpressionWithTypeArguments' &&\n      node.extends[0].expression.name === 'TurboModule'\n    );\n  }\n  extractAnnotatedElement(typeAnnotation, types) {\n    return types[typeAnnotation.typeParameters.params[0].typeName.name];\n  }\n\n  /**\n   * TODO(T108222691): Use flow-types for @babel/parser\n   */\n  getTypes(ast) {\n    return ast.body.reduce((types, node) => {\n      switch (node.type) {\n        case 'ExportNamedDeclaration': {\n          if (node.declaration) {\n            switch (node.declaration.type) {\n              case 'TSTypeAliasDeclaration':\n              case 'TSInterfaceDeclaration':\n              case 'TSEnumDeclaration': {\n                types[node.declaration.id.name] = node.declaration;\n                break;\n              }\n            }\n          }\n          break;\n        }\n        case 'TSTypeAliasDeclaration':\n        case 'TSInterfaceDeclaration':\n        case 'TSEnumDeclaration': {\n          types[node.id.name] = node;\n          break;\n        }\n      }\n      return types;\n    }, {});\n  }\n  callExpressionTypeParameters(callExpression) {\n    return callExpression.typeParameters || null;\n  }\n  computePartialProperties(\n    properties,\n    hasteModuleName,\n    types,\n    aliasMap,\n    enumMap,\n    tryParse,\n    cxxOnly,\n  ) {\n    return properties.map(prop => {\n      return {\n        name: prop.key.name,\n        optional: true,\n        typeAnnotation: typeScriptTranslateTypeAnnotation(\n          hasteModuleName,\n          prop.typeAnnotation.typeAnnotation,\n          types,\n          aliasMap,\n          enumMap,\n          tryParse,\n          cxxOnly,\n          this,\n        ),\n      };\n    });\n  }\n  functionTypeAnnotation(propertyValueType) {\n    return (\n      propertyValueType === 'TSFunctionType' ||\n      propertyValueType === 'TSMethodSignature'\n    );\n  }\n  getTypeArgumentParamsFromDeclaration(declaration) {\n    return declaration.typeParameters.params;\n  }\n\n  // This FlowFixMe is supposed to refer to typeArgumentParams and funcArgumentParams of generated AST.\n  getNativeComponentType(typeArgumentParams, funcArgumentParams) {\n    return {\n      propsTypeName: typeArgumentParams[0].typeName.name,\n      componentName: funcArgumentParams[0].value,\n    };\n  }\n  getAnnotatedElementProperties(annotatedElement) {\n    return annotatedElement.typeAnnotation.members;\n  }\n}\nmodule.exports = {\n  TypeScriptParser,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}