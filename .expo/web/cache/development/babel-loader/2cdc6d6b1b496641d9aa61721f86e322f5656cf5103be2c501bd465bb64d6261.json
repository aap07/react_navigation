{"ast":null,"code":"'use strict';\n\nvar _require = require(\"./componentsUtils\"),\n  flattenProperties = _require.flattenProperties;\nvar _require2 = require(\"../parseTopLevelType\"),\n  parseTopLevelType = _require2.parseTopLevelType;\nfunction getPropertyType(name, optionalProperty, annotation) {\n  var topLevelType = parseTopLevelType(annotation);\n  var typeAnnotation = topLevelType.type;\n  var optional = optionalProperty || topLevelType.optional;\n  var type = typeAnnotation.type === 'TSTypeReference' ? typeAnnotation.typeName.name : typeAnnotation.type;\n  switch (type) {\n    case 'TSBooleanKeyword':\n      return {\n        name: name,\n        optional: optional,\n        typeAnnotation: {\n          type: 'BooleanTypeAnnotation'\n        }\n      };\n    case 'TSStringKeyword':\n      return {\n        name: name,\n        optional: optional,\n        typeAnnotation: {\n          type: 'StringTypeAnnotation'\n        }\n      };\n    case 'Int32':\n      return {\n        name: name,\n        optional: optional,\n        typeAnnotation: {\n          type: 'Int32TypeAnnotation'\n        }\n      };\n    case 'Double':\n      return {\n        name: name,\n        optional: optional,\n        typeAnnotation: {\n          type: 'DoubleTypeAnnotation'\n        }\n      };\n    case 'Float':\n      return {\n        name: name,\n        optional: optional,\n        typeAnnotation: {\n          type: 'FloatTypeAnnotation'\n        }\n      };\n    case 'TSTypeLiteral':\n      return {\n        name: name,\n        optional: optional,\n        typeAnnotation: {\n          type: 'ObjectTypeAnnotation',\n          properties: typeAnnotation.members.map(buildPropertiesForEvent)\n        }\n      };\n    case 'TSUnionType':\n      return {\n        name: name,\n        optional: optional,\n        typeAnnotation: {\n          type: 'StringEnumTypeAnnotation',\n          options: typeAnnotation.types.map(function (option) {\n            return option.literal.value;\n          })\n        }\n      };\n    default:\n      type;\n      throw new Error(`Unable to determine event type for \"${name}\": ${type}`);\n  }\n}\nfunction findEventArgumentsAndType(typeAnnotation, types, bubblingType, paperName) {\n  if (typeAnnotation.type === 'TSInterfaceDeclaration') {\n    return {\n      argumentProps: flattenProperties([typeAnnotation], types),\n      paperTopLevelNameDeprecated: paperName,\n      bubblingType: bubblingType\n    };\n  }\n  if (typeAnnotation.type === 'TSTypeLiteral') {\n    return {\n      argumentProps: typeAnnotation.members,\n      paperTopLevelNameDeprecated: paperName,\n      bubblingType: bubblingType\n    };\n  }\n  if (!typeAnnotation.typeName) {\n    throw new Error(\"typeAnnotation of event doesn't have a name\");\n  }\n  var name = typeAnnotation.typeName.name;\n  if (name === 'Readonly') {\n    return findEventArgumentsAndType(typeAnnotation.typeParameters.params[0], types, bubblingType, paperName);\n  } else if (name === 'BubblingEventHandler' || name === 'DirectEventHandler') {\n    var eventType = name === 'BubblingEventHandler' ? 'bubble' : 'direct';\n    var paperTopLevelNameDeprecated = typeAnnotation.typeParameters.params.length > 1 ? typeAnnotation.typeParameters.params[1].literal.value : null;\n    switch (typeAnnotation.typeParameters.params[0].type) {\n      case 'TSNullKeyword':\n      case 'TSUndefinedKeyword':\n        return {\n          argumentProps: [],\n          bubblingType: eventType,\n          paperTopLevelNameDeprecated: paperTopLevelNameDeprecated\n        };\n      default:\n        return findEventArgumentsAndType(typeAnnotation.typeParameters.params[0], types, eventType, paperTopLevelNameDeprecated);\n    }\n  } else if (types[name]) {\n    var elementType = types[name];\n    if (elementType.type === 'TSTypeAliasDeclaration') {\n      elementType = elementType.typeAnnotation;\n    }\n    return findEventArgumentsAndType(elementType, types, bubblingType, paperName);\n  } else {\n    return {\n      argumentProps: null,\n      bubblingType: null,\n      paperTopLevelNameDeprecated: null\n    };\n  }\n}\nfunction buildPropertiesForEvent(property) {\n  var name = property.key.name;\n  var optional = property.optional || false;\n  var typeAnnotation = property.typeAnnotation.typeAnnotation;\n  return getPropertyType(name, optional, typeAnnotation);\n}\nfunction getEventArgument(argumentProps, name) {\n  return {\n    type: 'ObjectTypeAnnotation',\n    properties: argumentProps.map(buildPropertiesForEvent)\n  };\n}\nfunction buildEventSchema(types, property) {\n  var topLevelType = parseTopLevelType(property.typeAnnotation.typeAnnotation, types);\n  var name = property.key.name;\n  var typeAnnotation = topLevelType.type;\n  var optional = property.optional || topLevelType.optional;\n  var _findEventArgumentsAn = findEventArgumentsAndType(typeAnnotation, types),\n    argumentProps = _findEventArgumentsAn.argumentProps,\n    bubblingType = _findEventArgumentsAn.bubblingType,\n    paperTopLevelNameDeprecated = _findEventArgumentsAn.paperTopLevelNameDeprecated;\n  if (!argumentProps) {\n    throw new Error(`Unable to determine event arguments for \"${name}\"`);\n  } else if (!bubblingType) {\n    throw new Error(`Unable to determine event bubbling type for \"${name}\"`);\n  } else {\n    if (paperTopLevelNameDeprecated != null) {\n      return {\n        name: name,\n        optional: optional,\n        bubblingType: bubblingType,\n        paperTopLevelNameDeprecated: paperTopLevelNameDeprecated,\n        typeAnnotation: {\n          type: 'EventTypeAnnotation',\n          argument: getEventArgument(argumentProps, name)\n        }\n      };\n    }\n    return {\n      name: name,\n      optional: optional,\n      bubblingType: bubblingType,\n      typeAnnotation: {\n        type: 'EventTypeAnnotation',\n        argument: getEventArgument(argumentProps, name)\n      }\n    };\n  }\n}\nfunction getEvents(eventTypeAST, types) {\n  return eventTypeAST.map(function (property) {\n    return buildEventSchema(types, property);\n  });\n}\nmodule.exports = {\n  getEvents: getEvents\n};","map":{"version":3,"names":["_require","require","flattenProperties","_require2","parseTopLevelType","getPropertyType","name","optionalProperty","annotation","topLevelType","typeAnnotation","type","optional","typeName","properties","members","map","buildPropertiesForEvent","options","types","option","literal","value","Error","findEventArgumentsAndType","bubblingType","paperName","argumentProps","paperTopLevelNameDeprecated","typeParameters","params","eventType","length","elementType","property","key","getEventArgument","buildEventSchema","_findEventArgumentsAn","argument","getEvents","eventTypeAST","module","exports"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native/codegen/lib/parsers/typescript/components/events.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\n'use strict';\n\nconst _require = require('./componentsUtils'),\n  flattenProperties = _require.flattenProperties;\nconst _require2 = require('../parseTopLevelType'),\n  parseTopLevelType = _require2.parseTopLevelType;\nfunction getPropertyType(\n  /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n   * LTI update could not be added via codemod */\n  name,\n  optionalProperty,\n  /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n   * LTI update could not be added via codemod */\n  annotation,\n) {\n  const topLevelType = parseTopLevelType(annotation);\n  const typeAnnotation = topLevelType.type;\n  const optional = optionalProperty || topLevelType.optional;\n  const type =\n    typeAnnotation.type === 'TSTypeReference'\n      ? typeAnnotation.typeName.name\n      : typeAnnotation.type;\n  switch (type) {\n    case 'TSBooleanKeyword':\n      return {\n        name,\n        optional,\n        typeAnnotation: {\n          type: 'BooleanTypeAnnotation',\n        },\n      };\n    case 'TSStringKeyword':\n      return {\n        name,\n        optional,\n        typeAnnotation: {\n          type: 'StringTypeAnnotation',\n        },\n      };\n    case 'Int32':\n      return {\n        name,\n        optional,\n        typeAnnotation: {\n          type: 'Int32TypeAnnotation',\n        },\n      };\n    case 'Double':\n      return {\n        name,\n        optional,\n        typeAnnotation: {\n          type: 'DoubleTypeAnnotation',\n        },\n      };\n    case 'Float':\n      return {\n        name,\n        optional,\n        typeAnnotation: {\n          type: 'FloatTypeAnnotation',\n        },\n      };\n    case 'TSTypeLiteral':\n      return {\n        name,\n        optional,\n        typeAnnotation: {\n          type: 'ObjectTypeAnnotation',\n          properties: typeAnnotation.members.map(buildPropertiesForEvent),\n        },\n      };\n    case 'TSUnionType':\n      return {\n        name,\n        optional,\n        typeAnnotation: {\n          type: 'StringEnumTypeAnnotation',\n          options: typeAnnotation.types.map(option => option.literal.value),\n        },\n      };\n    default:\n      type;\n      throw new Error(`Unable to determine event type for \"${name}\": ${type}`);\n  }\n}\nfunction findEventArgumentsAndType(\n  typeAnnotation,\n  types,\n  bubblingType,\n  paperName,\n) {\n  if (typeAnnotation.type === 'TSInterfaceDeclaration') {\n    return {\n      argumentProps: flattenProperties([typeAnnotation], types),\n      paperTopLevelNameDeprecated: paperName,\n      bubblingType,\n    };\n  }\n  if (typeAnnotation.type === 'TSTypeLiteral') {\n    return {\n      argumentProps: typeAnnotation.members,\n      paperTopLevelNameDeprecated: paperName,\n      bubblingType,\n    };\n  }\n  if (!typeAnnotation.typeName) {\n    throw new Error(\"typeAnnotation of event doesn't have a name\");\n  }\n  const name = typeAnnotation.typeName.name;\n  if (name === 'Readonly') {\n    return findEventArgumentsAndType(\n      typeAnnotation.typeParameters.params[0],\n      types,\n      bubblingType,\n      paperName,\n    );\n  } else if (name === 'BubblingEventHandler' || name === 'DirectEventHandler') {\n    const eventType = name === 'BubblingEventHandler' ? 'bubble' : 'direct';\n    const paperTopLevelNameDeprecated =\n      typeAnnotation.typeParameters.params.length > 1\n        ? typeAnnotation.typeParameters.params[1].literal.value\n        : null;\n    switch (typeAnnotation.typeParameters.params[0].type) {\n      case 'TSNullKeyword':\n      case 'TSUndefinedKeyword':\n        return {\n          argumentProps: [],\n          bubblingType: eventType,\n          paperTopLevelNameDeprecated,\n        };\n      default:\n        return findEventArgumentsAndType(\n          typeAnnotation.typeParameters.params[0],\n          types,\n          eventType,\n          paperTopLevelNameDeprecated,\n        );\n    }\n  } else if (types[name]) {\n    let elementType = types[name];\n    if (elementType.type === 'TSTypeAliasDeclaration') {\n      elementType = elementType.typeAnnotation;\n    }\n    return findEventArgumentsAndType(\n      elementType,\n      types,\n      bubblingType,\n      paperName,\n    );\n  } else {\n    return {\n      argumentProps: null,\n      bubblingType: null,\n      paperTopLevelNameDeprecated: null,\n    };\n  }\n}\n\n/* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n * LTI update could not be added via codemod */\nfunction buildPropertiesForEvent(property) {\n  const name = property.key.name;\n  const optional = property.optional || false;\n  let typeAnnotation = property.typeAnnotation.typeAnnotation;\n  return getPropertyType(name, optional, typeAnnotation);\n}\n\n/* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n * LTI update could not be added via codemod */\nfunction getEventArgument(argumentProps, name) {\n  return {\n    type: 'ObjectTypeAnnotation',\n    properties: argumentProps.map(buildPropertiesForEvent),\n  };\n}\n\n// $FlowFixMe[unclear-type] TODO(T108222691): Use flow-types for @babel/parser\n\nfunction buildEventSchema(types, property) {\n  // unpack WithDefault, (T) or T|U\n  const topLevelType = parseTopLevelType(\n    property.typeAnnotation.typeAnnotation,\n    types,\n  );\n  const name = property.key.name;\n  const typeAnnotation = topLevelType.type;\n  const optional = property.optional || topLevelType.optional;\n  const _findEventArgumentsAn = findEventArgumentsAndType(\n      typeAnnotation,\n      types,\n    ),\n    argumentProps = _findEventArgumentsAn.argumentProps,\n    bubblingType = _findEventArgumentsAn.bubblingType,\n    paperTopLevelNameDeprecated =\n      _findEventArgumentsAn.paperTopLevelNameDeprecated;\n  if (!argumentProps) {\n    throw new Error(`Unable to determine event arguments for \"${name}\"`);\n  } else if (!bubblingType) {\n    throw new Error(`Unable to determine event bubbling type for \"${name}\"`);\n  } else {\n    if (paperTopLevelNameDeprecated != null) {\n      return {\n        name,\n        optional,\n        bubblingType,\n        paperTopLevelNameDeprecated,\n        typeAnnotation: {\n          type: 'EventTypeAnnotation',\n          argument: getEventArgument(argumentProps, name),\n        },\n      };\n    }\n    return {\n      name,\n      optional,\n      bubblingType,\n      typeAnnotation: {\n        type: 'EventTypeAnnotation',\n        argument: getEventArgument(argumentProps, name),\n      },\n    };\n  }\n}\nfunction getEvents(eventTypeAST, types) {\n  return eventTypeAST.map(property => buildEventSchema(types, property));\n}\nmodule.exports = {\n  getEvents,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}