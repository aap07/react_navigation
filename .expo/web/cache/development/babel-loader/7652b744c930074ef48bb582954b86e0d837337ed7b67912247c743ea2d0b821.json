{"ast":null,"code":"","map":{"version":3,"names":[],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@expo/cli/node_modules/type-fest/source/opaque.d.ts"],"sourcesContent":["/**\nCreate an opaque type, which hides its internal details from the public, and can only be created by being used explicitly.\n\nThe generic type parameter can be anything. It doesn't have to be an object.\n\n[Read more about opaque types.](https://codemix.com/opaque-types-in-javascript/)\n\nThere have been several discussions about adding this feature to TypeScript via the `opaque type` operator, similar to how Flow does it. Unfortunately, nothing has (yet) moved forward:\n\t- [Microsoft/TypeScript#15408](https://github.com/Microsoft/TypeScript/issues/15408)\n\t- [Microsoft/TypeScript#15807](https://github.com/Microsoft/TypeScript/issues/15807)\n\n@example\n```\nimport {Opaque} from 'type-fest';\n\ntype AccountNumber = Opaque<number, 'AccountNumber'>;\ntype AccountBalance = Opaque<number, 'AccountBalance'>;\n\n// The Token parameter allows the compiler to differentiate between types, whereas \"unknown\" will not. For example, consider the following structures:\ntype ThingOne = Opaque<string>;\ntype ThingTwo = Opaque<string>;\n\n// To the compiler, these types are allowed to be cast to each other as they have the same underlying type. They are both `string & { __opaque__: unknown }`.\n// To avoid this behaviour, you would instead pass the \"Token\" parameter, like so.\ntype NewThingOne = Opaque<string, 'ThingOne'>;\ntype NewThingTwo = Opaque<string, 'ThingTwo'>;\n\n// Now they're completely separate types, so the following will fail to compile.\nfunction createNewThingOne (): NewThingOne {\n\t// As you can see, casting from a string is still allowed. However, you may not cast NewThingOne to NewThingTwo, and vice versa.\n\treturn 'new thing one' as NewThingOne;\n}\n\n// This will fail to compile, as they are fundamentally different types.\nconst thingTwo = createNewThingOne() as NewThingTwo;\n\n// Here's another example of opaque typing.\nfunction createAccountNumber(): AccountNumber {\n\treturn 2 as AccountNumber;\n}\n\nfunction getMoneyForAccount(accountNumber: AccountNumber): AccountBalance {\n\treturn 4 as AccountBalance;\n}\n\n// This will compile successfully.\ngetMoneyForAccount(createAccountNumber());\n\n// But this won't, because it has to be explicitly passed as an `AccountNumber` type.\ngetMoneyForAccount(2);\n\n// You can use opaque values like they aren't opaque too.\nconst accountNumber = createAccountNumber();\n\n// This will not compile successfully.\nconst newAccountNumber = accountNumber + 2;\n\n// As a side note, you can (and should) use recursive types for your opaque types to make them stronger and hopefully easier to type.\ntype Person = {\n\tid: Opaque<number, Person>;\n\tname: string;\n};\n```\n*/\nexport type Opaque<Type, Token = unknown> = Type & {readonly __opaque__: Token};\n"],"mappings":""},"metadata":{},"sourceType":"script","externalDependencies":[]}