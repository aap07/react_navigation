{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar Scalar = require(\"../nodes/Scalar.js\");\nfunction resolveBlockScalar(scalar, strict, onError) {\n  var start = scalar.offset;\n  var header = parseBlockScalarHeader(scalar, strict, onError);\n  if (!header) return {\n    value: '',\n    type: null,\n    comment: '',\n    range: [start, start, start]\n  };\n  var type = header.mode === '>' ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;\n  var lines = scalar.source ? splitLines(scalar.source) : [];\n  var chompStart = lines.length;\n  for (var i = lines.length - 1; i >= 0; --i) {\n    var content = lines[i][1];\n    if (content === '' || content === '\\r') chompStart = i;else break;\n  }\n  if (chompStart === 0) {\n    var _value = header.chomp === '+' && lines.length > 0 ? '\\n'.repeat(Math.max(1, lines.length - 1)) : '';\n    var _end = start + header.length;\n    if (scalar.source) _end += scalar.source.length;\n    return {\n      value: _value,\n      type: type,\n      comment: header.comment,\n      range: [start, _end, _end]\n    };\n  }\n  var trimIndent = scalar.indent + header.indent;\n  var offset = scalar.offset + header.length;\n  var contentStart = 0;\n  for (var _i = 0; _i < chompStart; ++_i) {\n    var _lines$_i = _slicedToArray(lines[_i], 2),\n      indent = _lines$_i[0],\n      _content = _lines$_i[1];\n    if (_content === '' || _content === '\\r') {\n      if (header.indent === 0 && indent.length > trimIndent) trimIndent = indent.length;\n    } else {\n      if (indent.length < trimIndent) {\n        var message = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n        onError(offset + indent.length, 'MISSING_CHAR', message);\n      }\n      if (header.indent === 0) trimIndent = indent.length;\n      contentStart = _i;\n      break;\n    }\n    offset += indent.length + _content.length + 1;\n  }\n  for (var _i2 = lines.length - 1; _i2 >= chompStart; --_i2) {\n    if (lines[_i2][0].length > trimIndent) chompStart = _i2 + 1;\n  }\n  var value = '';\n  var sep = '';\n  var prevMoreIndented = false;\n  for (var _i3 = 0; _i3 < contentStart; ++_i3) value += lines[_i3][0].slice(trimIndent) + '\\n';\n  for (var _i4 = contentStart; _i4 < chompStart; ++_i4) {\n    var _lines$_i2 = _slicedToArray(lines[_i4], 2),\n      _indent = _lines$_i2[0],\n      _content2 = _lines$_i2[1];\n    offset += _indent.length + _content2.length + 1;\n    var crlf = _content2[_content2.length - 1] === '\\r';\n    if (crlf) _content2 = _content2.slice(0, -1);\n    if (_content2 && _indent.length < trimIndent) {\n      var src = header.indent ? 'explicit indentation indicator' : 'first line';\n      var _message = `Block scalar lines must not be less indented than their ${src}`;\n      onError(offset - _content2.length - (crlf ? 2 : 1), 'BAD_INDENT', _message);\n      _indent = '';\n    }\n    if (type === Scalar.Scalar.BLOCK_LITERAL) {\n      value += sep + _indent.slice(trimIndent) + _content2;\n      sep = '\\n';\n    } else if (_indent.length > trimIndent || _content2[0] === '\\t') {\n      if (sep === ' ') sep = '\\n';else if (!prevMoreIndented && sep === '\\n') sep = '\\n\\n';\n      value += sep + _indent.slice(trimIndent) + _content2;\n      sep = '\\n';\n      prevMoreIndented = true;\n    } else if (_content2 === '') {\n      if (sep === '\\n') value += '\\n';else sep = '\\n';\n    } else {\n      value += sep + _content2;\n      sep = ' ';\n      prevMoreIndented = false;\n    }\n  }\n  switch (header.chomp) {\n    case '-':\n      break;\n    case '+':\n      for (var _i5 = chompStart; _i5 < lines.length; ++_i5) value += '\\n' + lines[_i5][0].slice(trimIndent);\n      if (value[value.length - 1] !== '\\n') value += '\\n';\n      break;\n    default:\n      value += '\\n';\n  }\n  var end = start + header.length + scalar.source.length;\n  return {\n    value: value,\n    type: type,\n    comment: header.comment,\n    range: [start, end, end]\n  };\n}\nfunction parseBlockScalarHeader(_ref, strict, onError) {\n  var offset = _ref.offset,\n    props = _ref.props;\n  if (props[0].type !== 'block-scalar-header') {\n    onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');\n    return null;\n  }\n  var source = props[0].source;\n  var mode = source[0];\n  var indent = 0;\n  var chomp = '';\n  var error = -1;\n  for (var i = 1; i < source.length; ++i) {\n    var ch = source[i];\n    if (!chomp && (ch === '-' || ch === '+')) chomp = ch;else {\n      var n = Number(ch);\n      if (!indent && n) indent = n;else if (error === -1) error = offset + i;\n    }\n  }\n  if (error !== -1) onError(error, 'UNEXPECTED_TOKEN', `Block scalar header includes extra characters: ${source}`);\n  var hasSpace = false;\n  var comment = '';\n  var length = source.length;\n  for (var _i6 = 1; _i6 < props.length; ++_i6) {\n    var token = props[_i6];\n    switch (token.type) {\n      case 'space':\n        hasSpace = true;\n      case 'newline':\n        length += token.source.length;\n        break;\n      case 'comment':\n        if (strict && !hasSpace) {\n          var message = 'Comments must be separated from other tokens by white space characters';\n          onError(token, 'MISSING_CHAR', message);\n        }\n        length += token.source.length;\n        comment = token.source.substring(1);\n        break;\n      case 'error':\n        onError(token, 'UNEXPECTED_TOKEN', token.message);\n        length += token.source.length;\n        break;\n      default:\n        {\n          var _message2 = `Unexpected token in block scalar header: ${token.type}`;\n          onError(token, 'UNEXPECTED_TOKEN', _message2);\n          var ts = token.source;\n          if (ts && typeof ts === 'string') length += ts.length;\n        }\n    }\n  }\n  return {\n    mode: mode,\n    indent: indent,\n    chomp: chomp,\n    comment: comment,\n    length: length\n  };\n}\nfunction splitLines(source) {\n  var split = source.split(/\\n( *)/);\n  var first = split[0];\n  var m = first.match(/^( *)/);\n  var line0 = m != null && m[1] ? [m[1], first.slice(m[1].length)] : ['', first];\n  var lines = [line0];\n  for (var i = 1; i < split.length; i += 2) lines.push([split[i], split[i + 1]]);\n  return lines;\n}\nexports.resolveBlockScalar = resolveBlockScalar;","map":{"version":3,"names":["_slicedToArray","require","Scalar","resolveBlockScalar","scalar","strict","onError","start","offset","header","parseBlockScalarHeader","value","type","comment","range","mode","BLOCK_FOLDED","BLOCK_LITERAL","lines","source","splitLines","chompStart","length","i","content","chomp","repeat","Math","max","end","trimIndent","indent","contentStart","_lines$_i","message","sep","prevMoreIndented","slice","_lines$_i2","crlf","src","_ref","props","error","ch","n","Number","hasSpace","token","substring","ts","split","first","m","match","line0","push","exports"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native-community/cli-doctor/node_modules/yaml/dist/compose/resolve-block-scalar.js"],"sourcesContent":["'use strict';\n\nvar Scalar = require('../nodes/Scalar.js');\n\nfunction resolveBlockScalar(scalar, strict, onError) {\n    const start = scalar.offset;\n    const header = parseBlockScalarHeader(scalar, strict, onError);\n    if (!header)\n        return { value: '', type: null, comment: '', range: [start, start, start] };\n    const type = header.mode === '>' ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;\n    const lines = scalar.source ? splitLines(scalar.source) : [];\n    // determine the end of content & start of chomping\n    let chompStart = lines.length;\n    for (let i = lines.length - 1; i >= 0; --i) {\n        const content = lines[i][1];\n        if (content === '' || content === '\\r')\n            chompStart = i;\n        else\n            break;\n    }\n    // shortcut for empty contents\n    if (chompStart === 0) {\n        const value = header.chomp === '+' && lines.length > 0\n            ? '\\n'.repeat(Math.max(1, lines.length - 1))\n            : '';\n        let end = start + header.length;\n        if (scalar.source)\n            end += scalar.source.length;\n        return { value, type, comment: header.comment, range: [start, end, end] };\n    }\n    // find the indentation level to trim from start\n    let trimIndent = scalar.indent + header.indent;\n    let offset = scalar.offset + header.length;\n    let contentStart = 0;\n    for (let i = 0; i < chompStart; ++i) {\n        const [indent, content] = lines[i];\n        if (content === '' || content === '\\r') {\n            if (header.indent === 0 && indent.length > trimIndent)\n                trimIndent = indent.length;\n        }\n        else {\n            if (indent.length < trimIndent) {\n                const message = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n                onError(offset + indent.length, 'MISSING_CHAR', message);\n            }\n            if (header.indent === 0)\n                trimIndent = indent.length;\n            contentStart = i;\n            break;\n        }\n        offset += indent.length + content.length + 1;\n    }\n    // include trailing more-indented empty lines in content\n    for (let i = lines.length - 1; i >= chompStart; --i) {\n        if (lines[i][0].length > trimIndent)\n            chompStart = i + 1;\n    }\n    let value = '';\n    let sep = '';\n    let prevMoreIndented = false;\n    // leading whitespace is kept intact\n    for (let i = 0; i < contentStart; ++i)\n        value += lines[i][0].slice(trimIndent) + '\\n';\n    for (let i = contentStart; i < chompStart; ++i) {\n        let [indent, content] = lines[i];\n        offset += indent.length + content.length + 1;\n        const crlf = content[content.length - 1] === '\\r';\n        if (crlf)\n            content = content.slice(0, -1);\n        /* istanbul ignore if already caught in lexer */\n        if (content && indent.length < trimIndent) {\n            const src = header.indent\n                ? 'explicit indentation indicator'\n                : 'first line';\n            const message = `Block scalar lines must not be less indented than their ${src}`;\n            onError(offset - content.length - (crlf ? 2 : 1), 'BAD_INDENT', message);\n            indent = '';\n        }\n        if (type === Scalar.Scalar.BLOCK_LITERAL) {\n            value += sep + indent.slice(trimIndent) + content;\n            sep = '\\n';\n        }\n        else if (indent.length > trimIndent || content[0] === '\\t') {\n            // more-indented content within a folded block\n            if (sep === ' ')\n                sep = '\\n';\n            else if (!prevMoreIndented && sep === '\\n')\n                sep = '\\n\\n';\n            value += sep + indent.slice(trimIndent) + content;\n            sep = '\\n';\n            prevMoreIndented = true;\n        }\n        else if (content === '') {\n            // empty line\n            if (sep === '\\n')\n                value += '\\n';\n            else\n                sep = '\\n';\n        }\n        else {\n            value += sep + content;\n            sep = ' ';\n            prevMoreIndented = false;\n        }\n    }\n    switch (header.chomp) {\n        case '-':\n            break;\n        case '+':\n            for (let i = chompStart; i < lines.length; ++i)\n                value += '\\n' + lines[i][0].slice(trimIndent);\n            if (value[value.length - 1] !== '\\n')\n                value += '\\n';\n            break;\n        default:\n            value += '\\n';\n    }\n    const end = start + header.length + scalar.source.length;\n    return { value, type, comment: header.comment, range: [start, end, end] };\n}\nfunction parseBlockScalarHeader({ offset, props }, strict, onError) {\n    /* istanbul ignore if should not happen */\n    if (props[0].type !== 'block-scalar-header') {\n        onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');\n        return null;\n    }\n    const { source } = props[0];\n    const mode = source[0];\n    let indent = 0;\n    let chomp = '';\n    let error = -1;\n    for (let i = 1; i < source.length; ++i) {\n        const ch = source[i];\n        if (!chomp && (ch === '-' || ch === '+'))\n            chomp = ch;\n        else {\n            const n = Number(ch);\n            if (!indent && n)\n                indent = n;\n            else if (error === -1)\n                error = offset + i;\n        }\n    }\n    if (error !== -1)\n        onError(error, 'UNEXPECTED_TOKEN', `Block scalar header includes extra characters: ${source}`);\n    let hasSpace = false;\n    let comment = '';\n    let length = source.length;\n    for (let i = 1; i < props.length; ++i) {\n        const token = props[i];\n        switch (token.type) {\n            case 'space':\n                hasSpace = true;\n            // fallthrough\n            case 'newline':\n                length += token.source.length;\n                break;\n            case 'comment':\n                if (strict && !hasSpace) {\n                    const message = 'Comments must be separated from other tokens by white space characters';\n                    onError(token, 'MISSING_CHAR', message);\n                }\n                length += token.source.length;\n                comment = token.source.substring(1);\n                break;\n            case 'error':\n                onError(token, 'UNEXPECTED_TOKEN', token.message);\n                length += token.source.length;\n                break;\n            /* istanbul ignore next should not happen */\n            default: {\n                const message = `Unexpected token in block scalar header: ${token.type}`;\n                onError(token, 'UNEXPECTED_TOKEN', message);\n                const ts = token.source;\n                if (ts && typeof ts === 'string')\n                    length += ts.length;\n            }\n        }\n    }\n    return { mode, indent, chomp, comment, length };\n}\n/** @returns Array of lines split up as `[indent, content]` */\nfunction splitLines(source) {\n    const split = source.split(/\\n( *)/);\n    const first = split[0];\n    const m = first.match(/^( *)/);\n    const line0 = m?.[1]\n        ? [m[1], first.slice(m[1].length)]\n        : ['', first];\n    const lines = [line0];\n    for (let i = 1; i < split.length; i += 2)\n        lines.push([split[i], split[i + 1]]);\n    return lines;\n}\n\nexports.resolveBlockScalar = resolveBlockScalar;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}