{"ast":null,"code":"","map":{"version":3,"names":[],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@expo/devcert/dist/certificate-authority.d.ts"],"sourcesContent":["import { Options } from './index';\n/**\n * Install the once-per-machine trusted root CA. We'll use this CA to sign\n * per-app certs.\n */\nexport default function installCertificateAuthority(options?: Options): Promise<void>;\nexport declare function withCertificateAuthorityCredentials(cb: ({ caKeyPath, caCertPath }: {\n    caKeyPath: string;\n    caCertPath: string;\n}) => Promise<void> | void): Promise<void>;\n/**\n * Smoothly migrate the certificate storage from v1.0.x to >= v1.1.0.\n * In v1.1.0 there are new options for retrieving the CA cert directly,\n * to help third-party Node apps trust the root CA.\n *\n * If a v1.0.x cert already exists, then devcert has written it with\n * platform.writeProtectedFile(), so an unprivileged readFile cannot access it.\n * Pre-detect and remedy this; it should only happen once per installation.\n */\nexport declare function ensureCACertReadable(options?: Options): Promise<void>;\n/**\n * Remove as much of the devcert files and state as we can. This is necessary\n * when generating a new root certificate, and should be available to API\n * consumers as well.\n *\n * Not all of it will be removable. If certutil is not installed, we'll leave\n * Firefox alone. We try to remove files with maximum permissions, and if that\n * fails, we'll silently fail.\n *\n * It's also possible that the command to untrust will not work, and we'll\n * silently fail that as well; with no existing certificates anymore, the\n * security exposure there is minimal.\n */\nexport declare function uninstall(): void;\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}