{"ast":null,"code":"'use strict';\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError('Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.');\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === 'string') return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === 'Object' && o.constructor) n = o.constructor.name;\n  if (n === 'Map' || n === 'Set') return Array.from(o);\n  if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : 'undefined' != typeof Symbol && arr[Symbol.iterator] || arr['@@iterator'];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nvar _require = require(\"../Utils\"),\n  getSafePropertyName = _require.getSafePropertyName,\n  getNamespacedStructName = _require.getNamespacedStructName;\nvar _require2 = require(\"../../../Utils\"),\n  capitalize = _require2.capitalize;\nvar _require3 = require(\"../../../../parsers/parsers-commons\"),\n  unwrapNullable = _require3.unwrapNullable;\nvar StructTemplate = function StructTemplate(_ref) {\n  var hasteModuleName = _ref.hasteModuleName,\n    structName = _ref.structName,\n    structProperties = _ref.structProperties;\n  return `namespace JS {\n  namespace ${hasteModuleName} {\n    struct ${structName} {\n      ${structProperties}\n\n      ${structName}(NSDictionary *const v) : _v(v) {}\n    private:\n      NSDictionary *_v;\n    };\n  }\n}\n\n@interface RCTCxxConvert (${hasteModuleName}_${structName})\n+ (RCTManagedPointer *)JS_${hasteModuleName}_${structName}:(id)json;\n@end`;\n};\nvar MethodTemplate = function MethodTemplate(_ref2) {\n  var returnType = _ref2.returnType,\n    returnValue = _ref2.returnValue,\n    hasteModuleName = _ref2.hasteModuleName,\n    structName = _ref2.structName,\n    propertyName = _ref2.propertyName,\n    safePropertyName = _ref2.safePropertyName;\n  return `inline ${returnType}JS::${hasteModuleName}::${structName}::${safePropertyName}() const\n{\n  id const p = _v[@\"${propertyName}\"];\n  return ${returnValue};\n}`;\n};\nfunction toObjCType(hasteModuleName, nullableTypeAnnotation) {\n  var isOptional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var _unwrapNullable = unwrapNullable(nullableTypeAnnotation),\n    _unwrapNullable2 = _slicedToArray(_unwrapNullable, 2),\n    typeAnnotation = _unwrapNullable2[0],\n    nullable = _unwrapNullable2[1];\n  var isRequired = !nullable && !isOptional;\n  var wrapOptional = function wrapOptional(type) {\n    return isRequired ? type : `std::optional<${type}>`;\n  };\n  switch (typeAnnotation.type) {\n    case 'ReservedTypeAnnotation':\n      switch (typeAnnotation.name) {\n        case 'RootTag':\n          return wrapOptional('double');\n        default:\n          typeAnnotation.name;\n          throw new Error(`Unknown prop type, found: ${typeAnnotation.name}\"`);\n      }\n    case 'StringTypeAnnotation':\n      return 'NSString *';\n    case 'NumberTypeAnnotation':\n      return wrapOptional('double');\n    case 'FloatTypeAnnotation':\n      return wrapOptional('double');\n    case 'Int32TypeAnnotation':\n      return wrapOptional('double');\n    case 'DoubleTypeAnnotation':\n      return wrapOptional('double');\n    case 'BooleanTypeAnnotation':\n      return wrapOptional('bool');\n    case 'EnumDeclaration':\n      switch (typeAnnotation.memberType) {\n        case 'NumberTypeAnnotation':\n          return wrapOptional('double');\n        case 'StringTypeAnnotation':\n          return 'NSString *';\n        default:\n          throw new Error(`Couldn't convert enum into ObjC type: ${typeAnnotation.type}\"`);\n      }\n    case 'GenericObjectTypeAnnotation':\n      return isRequired ? 'id<NSObject> ' : 'id<NSObject> _Nullable';\n    case 'ArrayTypeAnnotation':\n      if (typeAnnotation.elementType == null) {\n        return isRequired ? 'id<NSObject> ' : 'id<NSObject> _Nullable';\n      }\n      return wrapOptional(`facebook::react::LazyVector<${toObjCType(hasteModuleName, typeAnnotation.elementType)}>`);\n    case 'TypeAliasTypeAnnotation':\n      var structName = capitalize(typeAnnotation.name);\n      var namespacedStructName = getNamespacedStructName(hasteModuleName, structName);\n      return wrapOptional(namespacedStructName);\n    default:\n      typeAnnotation.type;\n      throw new Error(`Couldn't convert into ObjC type: ${typeAnnotation.type}\"`);\n  }\n}\nfunction toObjCValue(hasteModuleName, nullableTypeAnnotation, value, depth) {\n  var isOptional = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var _unwrapNullable3 = unwrapNullable(nullableTypeAnnotation),\n    _unwrapNullable4 = _slicedToArray(_unwrapNullable3, 2),\n    typeAnnotation = _unwrapNullable4[0],\n    nullable = _unwrapNullable4[1];\n  var isRequired = !nullable && !isOptional;\n  var RCTBridgingTo = function RCTBridgingTo(type, arg) {\n    var args = [value, arg].filter(Boolean).join(', ');\n    return isRequired ? `RCTBridgingTo${type}(${args})` : `RCTBridgingToOptional${type}(${args})`;\n  };\n  switch (typeAnnotation.type) {\n    case 'ReservedTypeAnnotation':\n      switch (typeAnnotation.name) {\n        case 'RootTag':\n          return RCTBridgingTo('Double');\n        default:\n          typeAnnotation.name;\n          throw new Error(`Couldn't convert into ObjC type: ${typeAnnotation.type}\"`);\n      }\n    case 'StringTypeAnnotation':\n      return RCTBridgingTo('String');\n    case 'NumberTypeAnnotation':\n      return RCTBridgingTo('Double');\n    case 'FloatTypeAnnotation':\n      return RCTBridgingTo('Double');\n    case 'Int32TypeAnnotation':\n      return RCTBridgingTo('Double');\n    case 'DoubleTypeAnnotation':\n      return RCTBridgingTo('Double');\n    case 'BooleanTypeAnnotation':\n      return RCTBridgingTo('Bool');\n    case 'EnumDeclaration':\n      switch (typeAnnotation.memberType) {\n        case 'NumberTypeAnnotation':\n          return RCTBridgingTo('Double');\n        case 'StringTypeAnnotation':\n          return RCTBridgingTo('String');\n        default:\n          throw new Error(`Couldn't convert enum into ObjC value: ${typeAnnotation.type}\"`);\n      }\n    case 'GenericObjectTypeAnnotation':\n      return value;\n    case 'ArrayTypeAnnotation':\n      var elementType = typeAnnotation.elementType;\n      if (elementType == null) {\n        return value;\n      }\n      var localVarName = `itemValue_${depth}`;\n      var elementObjCType = toObjCType(hasteModuleName, elementType);\n      var elementObjCValue = toObjCValue(hasteModuleName, elementType, localVarName, depth + 1);\n      return RCTBridgingTo('Vec', `^${elementObjCType}(id ${localVarName}) { return ${elementObjCValue}; }`);\n    case 'TypeAliasTypeAnnotation':\n      var structName = capitalize(typeAnnotation.name);\n      var namespacedStructName = getNamespacedStructName(hasteModuleName, structName);\n      return !isRequired ? `(${value} == nil ? std::nullopt : std::make_optional(${namespacedStructName}(${value})))` : `${namespacedStructName}(${value})`;\n    default:\n      typeAnnotation.type;\n      throw new Error(`Couldn't convert into ObjC value: ${typeAnnotation.type}\"`);\n  }\n}\nfunction serializeRegularStruct(hasteModuleName, struct) {\n  var declaration = StructTemplate({\n    hasteModuleName: hasteModuleName,\n    structName: struct.name,\n    structProperties: struct.properties.map(function (property) {\n      var typeAnnotation = property.typeAnnotation,\n        optional = property.optional;\n      var safePropName = getSafePropertyName(property);\n      var returnType = toObjCType(hasteModuleName, typeAnnotation, optional);\n      var padding = ' '.repeat(returnType.endsWith('*') ? 0 : 1);\n      return `${returnType}${padding}${safePropName}() const;`;\n    }).join('\\n      ')\n  });\n  var methods = struct.properties.map(function (property) {\n    var typeAnnotation = property.typeAnnotation,\n      optional = property.optional,\n      propName = property.name;\n    var safePropertyName = getSafePropertyName(property);\n    var returnType = toObjCType(hasteModuleName, typeAnnotation, optional);\n    var returnValue = toObjCValue(hasteModuleName, typeAnnotation, 'p', 0, optional);\n    var padding = ' '.repeat(returnType.endsWith('*') ? 0 : 1);\n    return MethodTemplate({\n      hasteModuleName: hasteModuleName,\n      structName: struct.name,\n      returnType: returnType + padding,\n      returnValue: returnValue,\n      propertyName: propName,\n      safePropertyName: safePropertyName\n    });\n  }).join('\\n');\n  return {\n    methods: methods,\n    declaration: declaration\n  };\n}\nmodule.exports = {\n  serializeRegularStruct: serializeRegularStruct\n};","map":{"version":3,"names":["_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","len","length","arr2","_i","Symbol","iterator","_s","_e","_x","_r","_arr","_n","_d","next","done","push","value","err","return","isArray","_require","require","getSafePropertyName","getNamespacedStructName","_require2","capitalize","_require3","unwrapNullable","StructTemplate","_ref","hasteModuleName","structName","structProperties","MethodTemplate","_ref2","returnType","returnValue","propertyName","safePropertyName","toObjCType","nullableTypeAnnotation","isOptional","arguments","undefined","_unwrapNullable","_unwrapNullable2","typeAnnotation","nullable","isRequired","wrapOptional","type","Error","memberType","elementType","namespacedStructName","toObjCValue","depth","_unwrapNullable3","_unwrapNullable4","RCTBridgingTo","arg","args","filter","Boolean","join","localVarName","elementObjCType","elementObjCValue","serializeRegularStruct","struct","declaration","properties","map","property","optional","safePropName","padding","repeat","endsWith","methods","propName","module","exports"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native/codegen/lib/generators/modules/GenerateModuleObjCpp/header/serializeRegularStruct.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\n'use strict';\n\nfunction _slicedToArray(arr, i) {\n  return (\n    _arrayWithHoles(arr) ||\n    _iterableToArrayLimit(arr, i) ||\n    _unsupportedIterableToArray(arr, i) ||\n    _nonIterableRest()\n  );\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\n    'Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',\n  );\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === 'string') return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === 'Object' && o.constructor) n = o.constructor.name;\n  if (n === 'Map' || n === 'Set') return Array.from(o);\n  if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n    return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i =\n    null == arr\n      ? null\n      : ('undefined' != typeof Symbol && arr[Symbol.iterator]) ||\n        arr['@@iterator'];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (((_x = (_i = _i.call(arr)).next), 0 === i)) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else\n        for (\n          ;\n          !(_n = (_s = _x.call(_i)).done) &&\n          (_arr.push(_s.value), _arr.length !== i);\n          _n = !0\n        );\n    } catch (err) {\n      (_d = !0), (_e = err);\n    } finally {\n      try {\n        if (!_n && null != _i.return && ((_r = _i.return()), Object(_r) !== _r))\n          return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nconst _require = require('../Utils'),\n  getSafePropertyName = _require.getSafePropertyName,\n  getNamespacedStructName = _require.getNamespacedStructName;\nconst _require2 = require('../../../Utils'),\n  capitalize = _require2.capitalize;\nconst _require3 = require('../../../../parsers/parsers-commons'),\n  unwrapNullable = _require3.unwrapNullable;\nconst StructTemplate = ({\n  hasteModuleName,\n  structName,\n  structProperties,\n}) => `namespace JS {\n  namespace ${hasteModuleName} {\n    struct ${structName} {\n      ${structProperties}\n\n      ${structName}(NSDictionary *const v) : _v(v) {}\n    private:\n      NSDictionary *_v;\n    };\n  }\n}\n\n@interface RCTCxxConvert (${hasteModuleName}_${structName})\n+ (RCTManagedPointer *)JS_${hasteModuleName}_${structName}:(id)json;\n@end`;\nconst MethodTemplate = ({\n  returnType,\n  returnValue,\n  hasteModuleName,\n  structName,\n  propertyName,\n  safePropertyName,\n}) => `inline ${returnType}JS::${hasteModuleName}::${structName}::${safePropertyName}() const\n{\n  id const p = _v[@\"${propertyName}\"];\n  return ${returnValue};\n}`;\nfunction toObjCType(\n  hasteModuleName,\n  nullableTypeAnnotation,\n  isOptional = false,\n) {\n  const _unwrapNullable = unwrapNullable(nullableTypeAnnotation),\n    _unwrapNullable2 = _slicedToArray(_unwrapNullable, 2),\n    typeAnnotation = _unwrapNullable2[0],\n    nullable = _unwrapNullable2[1];\n  const isRequired = !nullable && !isOptional;\n  const wrapOptional = type => {\n    return isRequired ? type : `std::optional<${type}>`;\n  };\n  switch (typeAnnotation.type) {\n    case 'ReservedTypeAnnotation':\n      switch (typeAnnotation.name) {\n        case 'RootTag':\n          return wrapOptional('double');\n        default:\n          typeAnnotation.name;\n          throw new Error(`Unknown prop type, found: ${typeAnnotation.name}\"`);\n      }\n    case 'StringTypeAnnotation':\n      return 'NSString *';\n    case 'NumberTypeAnnotation':\n      return wrapOptional('double');\n    case 'FloatTypeAnnotation':\n      return wrapOptional('double');\n    case 'Int32TypeAnnotation':\n      return wrapOptional('double');\n    case 'DoubleTypeAnnotation':\n      return wrapOptional('double');\n    case 'BooleanTypeAnnotation':\n      return wrapOptional('bool');\n    case 'EnumDeclaration':\n      switch (typeAnnotation.memberType) {\n        case 'NumberTypeAnnotation':\n          return wrapOptional('double');\n        case 'StringTypeAnnotation':\n          return 'NSString *';\n        default:\n          throw new Error(\n            `Couldn't convert enum into ObjC type: ${typeAnnotation.type}\"`,\n          );\n      }\n    case 'GenericObjectTypeAnnotation':\n      return isRequired ? 'id<NSObject> ' : 'id<NSObject> _Nullable';\n    case 'ArrayTypeAnnotation':\n      if (typeAnnotation.elementType == null) {\n        return isRequired ? 'id<NSObject> ' : 'id<NSObject> _Nullable';\n      }\n      return wrapOptional(\n        `facebook::react::LazyVector<${toObjCType(\n          hasteModuleName,\n          typeAnnotation.elementType,\n        )}>`,\n      );\n    case 'TypeAliasTypeAnnotation':\n      const structName = capitalize(typeAnnotation.name);\n      const namespacedStructName = getNamespacedStructName(\n        hasteModuleName,\n        structName,\n      );\n      return wrapOptional(namespacedStructName);\n    default:\n      typeAnnotation.type;\n      throw new Error(\n        `Couldn't convert into ObjC type: ${typeAnnotation.type}\"`,\n      );\n  }\n}\nfunction toObjCValue(\n  hasteModuleName,\n  nullableTypeAnnotation,\n  value,\n  depth,\n  isOptional = false,\n) {\n  const _unwrapNullable3 = unwrapNullable(nullableTypeAnnotation),\n    _unwrapNullable4 = _slicedToArray(_unwrapNullable3, 2),\n    typeAnnotation = _unwrapNullable4[0],\n    nullable = _unwrapNullable4[1];\n  const isRequired = !nullable && !isOptional;\n  const RCTBridgingTo = (type, arg) => {\n    const args = [value, arg].filter(Boolean).join(', ');\n    return isRequired\n      ? `RCTBridgingTo${type}(${args})`\n      : `RCTBridgingToOptional${type}(${args})`;\n  };\n  switch (typeAnnotation.type) {\n    case 'ReservedTypeAnnotation':\n      switch (typeAnnotation.name) {\n        case 'RootTag':\n          return RCTBridgingTo('Double');\n        default:\n          typeAnnotation.name;\n          throw new Error(\n            `Couldn't convert into ObjC type: ${typeAnnotation.type}\"`,\n          );\n      }\n    case 'StringTypeAnnotation':\n      return RCTBridgingTo('String');\n    case 'NumberTypeAnnotation':\n      return RCTBridgingTo('Double');\n    case 'FloatTypeAnnotation':\n      return RCTBridgingTo('Double');\n    case 'Int32TypeAnnotation':\n      return RCTBridgingTo('Double');\n    case 'DoubleTypeAnnotation':\n      return RCTBridgingTo('Double');\n    case 'BooleanTypeAnnotation':\n      return RCTBridgingTo('Bool');\n    case 'EnumDeclaration':\n      switch (typeAnnotation.memberType) {\n        case 'NumberTypeAnnotation':\n          return RCTBridgingTo('Double');\n        case 'StringTypeAnnotation':\n          return RCTBridgingTo('String');\n        default:\n          throw new Error(\n            `Couldn't convert enum into ObjC value: ${typeAnnotation.type}\"`,\n          );\n      }\n    case 'GenericObjectTypeAnnotation':\n      return value;\n    case 'ArrayTypeAnnotation':\n      const elementType = typeAnnotation.elementType;\n      if (elementType == null) {\n        return value;\n      }\n      const localVarName = `itemValue_${depth}`;\n      const elementObjCType = toObjCType(hasteModuleName, elementType);\n      const elementObjCValue = toObjCValue(\n        hasteModuleName,\n        elementType,\n        localVarName,\n        depth + 1,\n      );\n      return RCTBridgingTo(\n        'Vec',\n        `^${elementObjCType}(id ${localVarName}) { return ${elementObjCValue}; }`,\n      );\n    case 'TypeAliasTypeAnnotation':\n      const structName = capitalize(typeAnnotation.name);\n      const namespacedStructName = getNamespacedStructName(\n        hasteModuleName,\n        structName,\n      );\n      return !isRequired\n        ? `(${value} == nil ? std::nullopt : std::make_optional(${namespacedStructName}(${value})))`\n        : `${namespacedStructName}(${value})`;\n    default:\n      typeAnnotation.type;\n      throw new Error(\n        `Couldn't convert into ObjC value: ${typeAnnotation.type}\"`,\n      );\n  }\n}\nfunction serializeRegularStruct(hasteModuleName, struct) {\n  const declaration = StructTemplate({\n    hasteModuleName: hasteModuleName,\n    structName: struct.name,\n    structProperties: struct.properties\n      .map(property => {\n        const typeAnnotation = property.typeAnnotation,\n          optional = property.optional;\n        const safePropName = getSafePropertyName(property);\n        const returnType = toObjCType(\n          hasteModuleName,\n          typeAnnotation,\n          optional,\n        );\n        const padding = ' '.repeat(returnType.endsWith('*') ? 0 : 1);\n        return `${returnType}${padding}${safePropName}() const;`;\n      })\n      .join('\\n      '),\n  });\n\n  // $FlowFixMe[missing-type-arg]\n  const methods = struct.properties\n    .map(property => {\n      const typeAnnotation = property.typeAnnotation,\n        optional = property.optional,\n        propName = property.name;\n      const safePropertyName = getSafePropertyName(property);\n      const returnType = toObjCType(hasteModuleName, typeAnnotation, optional);\n      const returnValue = toObjCValue(\n        hasteModuleName,\n        typeAnnotation,\n        'p',\n        0,\n        optional,\n      );\n      const padding = ' '.repeat(returnType.endsWith('*') ? 0 : 1);\n      return MethodTemplate({\n        hasteModuleName,\n        structName: struct.name,\n        returnType: returnType + padding,\n        returnValue: returnValue,\n        propertyName: propName,\n        safePropertyName,\n      });\n    })\n    .join('\\n');\n  return {\n    methods,\n    declaration,\n  };\n}\nmodule.exports = {\n  serializeRegularStruct,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}