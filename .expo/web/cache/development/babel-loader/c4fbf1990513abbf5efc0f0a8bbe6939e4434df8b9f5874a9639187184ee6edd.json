{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport Constants from 'expo-constants';\nimport { Platform } from 'expo-modules-core';\nimport { EventEmitter } from 'fbemitter';\nimport invariant from 'invariant';\nimport { v4 as uuidv4 } from 'uuid';\nimport getInstallationIdAsync from \"../environment/getInstallationIdAsync\";\nimport LogSerialization from \"./LogSerialization\";\nvar _sessionId = uuidv4();\nvar _logQueue = [];\nvar _transportEventEmitter = new EventEmitter();\nvar _logCounter = 0;\nvar _isSendingLogs = false;\nvar _completionPromise = null;\nvar _resolveCompletion2 = null;\nfunction enqueueRemoteLogAsync(_x, _x2, _x3) {\n  return _enqueueRemoteLogAsync.apply(this, arguments);\n}\nfunction _enqueueRemoteLogAsync() {\n  _enqueueRemoteLogAsync = _asyncToGenerator(function* (level, additionalFields, data) {\n    if (_isReactNativeWarning(data)) {\n      if (data.length === 0) {\n        throw new Error(`Warnings must include log arguments`);\n      }\n      var warning = data[0];\n      if (typeof warning !== 'string') {\n        throw new TypeError(`The log argument for a warning must be a string`);\n      }\n      var lines = warning.split('\\n');\n      if (lines.length > 1 && /^\\s+in /.test(lines[1])) {\n        data[0] = lines[0];\n      }\n    }\n    var _yield$LogSerializati = yield LogSerialization.serializeLogDataAsync(data, level),\n      body = _yield$LogSerializati.body,\n      includesStack = _yield$LogSerializati.includesStack;\n    _logQueue.push(_objectSpread({\n      count: _logCounter++,\n      level: level,\n      body: body,\n      includesStack: includesStack\n    }, additionalFields));\n    _sendRemoteLogsAsync().catch(function (error) {\n      setImmediate(function () {\n        throw error;\n      });\n    });\n  });\n  return _enqueueRemoteLogAsync.apply(this, arguments);\n}\nfunction _sendRemoteLogsAsync() {\n  return _sendRemoteLogsAsync2.apply(this, arguments);\n}\nfunction _sendRemoteLogsAsync2() {\n  _sendRemoteLogsAsync2 = _asyncToGenerator(function* () {\n    var _Constants$expoGoConf;\n    if (_isSendingLogs || !_logQueue.length) {\n      return;\n    }\n    var batch = _logQueue.splice(0);\n    var logUrl = (_Constants$expoGoConf = Constants.expoGoConfig) == null ? void 0 : _Constants$expoGoConf.logUrl;\n    if (typeof logUrl !== 'string') {\n      throw new Error('The Expo project manifest must specify `logUrl`');\n    }\n    _isSendingLogs = true;\n    try {\n      yield _sendNextLogBatchAsync(batch, logUrl);\n    } finally {\n      _isSendingLogs = false;\n    }\n    if (_logQueue.length) {\n      return _sendRemoteLogsAsync();\n    } else if (_resolveCompletion2) {\n      _resolveCompletion2();\n    }\n  });\n  return _sendRemoteLogsAsync2.apply(this, arguments);\n}\nfunction _sendNextLogBatchAsync(_x4, _x5) {\n  return _sendNextLogBatchAsync2.apply(this, arguments);\n}\nfunction _sendNextLogBatchAsync2() {\n  _sendNextLogBatchAsync2 = _asyncToGenerator(function* (batch, logUrl) {\n    var response;\n    var headers = {\n      'Content-Type': 'application/json',\n      Connection: 'keep-alive',\n      'Proxy-Connection': 'keep-alive',\n      Accept: 'application/json',\n      'Device-Id': yield getInstallationIdAsync(),\n      'Session-Id': _sessionId,\n      'Expo-Platform': Platform.OS\n    };\n    if (Constants.deviceName) {\n      headers['Device-Name'] = Constants.deviceName;\n    }\n    try {\n      response = yield fetch(logUrl, {\n        method: 'POST',\n        headers: headers,\n        body: JSON.stringify(batch)\n      });\n    } catch (error) {\n      _transportEventEmitter.emit('error', {\n        error: error\n      });\n      return;\n    }\n    var success = response.status >= 200 && response.status < 300;\n    if (!success) {\n      _transportEventEmitter.emit('error', {\n        error: new Error(`An HTTP error occurred when sending remote logs`),\n        response: response\n      });\n    }\n  });\n  return _sendNextLogBatchAsync2.apply(this, arguments);\n}\nfunction addTransportErrorListener(listener) {\n  return _transportEventEmitter.addListener('error', listener);\n}\nfunction _isReactNativeWarning(data) {\n  var message = data[0];\n  return data.length === 1 && typeof message === 'string' && message.startsWith('Warning: ');\n}\nexport default {\n  enqueueRemoteLogAsync: enqueueRemoteLogAsync,\n  addTransportErrorListener: addTransportErrorListener\n};\nexport function __waitForEmptyLogQueueAsync() {\n  if (_completionPromise) {\n    return _completionPromise;\n  }\n  if (!_isSendingLogs && !_logQueue.length) {\n    return Promise.resolve();\n  }\n  _completionPromise = new Promise(function (resolve) {\n    _resolveCompletion2 = function _resolveCompletion() {\n      invariant(!_isSendingLogs, `Must not be sending logs at completion`);\n      invariant(!_logQueue.length, `Log queue must be empty at completion`);\n      _completionPromise = null;\n      _resolveCompletion2 = null;\n      resolve();\n    };\n  });\n  return _completionPromise;\n}","map":{"version":3,"names":["Constants","Platform","EventEmitter","invariant","v4","uuidv4","getInstallationIdAsync","LogSerialization","_sessionId","_logQueue","_transportEventEmitter","_logCounter","_isSendingLogs","_completionPromise","_resolveCompletion","enqueueRemoteLogAsync","_x","_x2","_x3","_enqueueRemoteLogAsync","apply","arguments","_asyncToGenerator","level","additionalFields","data","_isReactNativeWarning","length","Error","warning","TypeError","lines","split","test","_yield$LogSerializati","serializeLogDataAsync","body","includesStack","push","_objectSpread","count","_sendRemoteLogsAsync","catch","error","setImmediate","_sendRemoteLogsAsync2","_Constants$expoGoConf","batch","splice","logUrl","expoGoConfig","_sendNextLogBatchAsync","_x4","_x5","_sendNextLogBatchAsync2","response","headers","Connection","Accept","OS","deviceName","fetch","method","JSON","stringify","emit","success","status","addTransportErrorListener","listener","addListener","message","startsWith","__waitForEmptyLogQueueAsync","Promise","resolve"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\expo\\src\\logs\\RemoteLogging.ts"],"sourcesContent":["import Constants from 'expo-constants';\nimport { Platform } from 'expo-modules-core';\nimport { EventEmitter, EventSubscription } from 'fbemitter';\nimport invariant from 'invariant';\nimport { v4 as uuidv4 } from 'uuid';\n\nimport getInstallationIdAsync from '../environment/getInstallationIdAsync';\nimport LogSerialization from './LogSerialization';\n\nexport type LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\ntype LogEntry = {\n  count: number;\n  level: LogLevel;\n  body: LogData[];\n  includesStack: boolean;\n  groupDepth?: number;\n} & LogEntryFields;\n\nexport type LogEntryFields = {\n  shouldHide?: boolean;\n  groupDepth?: number;\n  groupCollapsed?: boolean;\n};\n\nexport type LogData = string | LogErrorData;\nexport type LogErrorData = { message: string; stack: string };\n\ntype TransportErrorListener = (event: { error: Error; response?: Response }) => void;\n\nconst _sessionId = uuidv4();\nconst _logQueue: LogEntry[] = [];\nconst _transportEventEmitter = new EventEmitter();\n\nlet _logCounter = 0;\nlet _isSendingLogs = false;\nlet _completionPromise: Promise<void> | null = null;\nlet _resolveCompletion: (() => void) | null = null;\n\nasync function enqueueRemoteLogAsync(\n  level: LogLevel,\n  additionalFields: LogEntryFields,\n  data: unknown[]\n): Promise<void> {\n  if (_isReactNativeWarning(data)) {\n    // Remove the stack trace from the warning message since we'll capture our own\n    if (data.length === 0) {\n      throw new Error(`Warnings must include log arguments`);\n    }\n    const warning = data[0];\n    if (typeof warning !== 'string') {\n      throw new TypeError(`The log argument for a warning must be a string`);\n    }\n    const lines = warning.split('\\n');\n    if (lines.length > 1 && /^\\s+in /.test(lines[1])) {\n      data[0] = lines[0];\n    }\n  }\n\n  const { body, includesStack } = await LogSerialization.serializeLogDataAsync(data, level);\n\n  _logQueue.push({\n    count: _logCounter++,\n    level,\n    body,\n    includesStack,\n    ...additionalFields,\n  });\n\n  // Send the logs asynchronously (system errors are emitted with transport error events) and throw an uncaught error\n  _sendRemoteLogsAsync().catch((error) => {\n    setImmediate(() => {\n      throw error;\n    });\n  });\n}\n\nasync function _sendRemoteLogsAsync(): Promise<void> {\n  if (_isSendingLogs || !_logQueue.length) {\n    return;\n  }\n\n  // Our current transport policy is to send all of the pending log messages in one batch. If we opt\n  // for another policy (ex: throttling) this is where to to implement it.\n  const batch = _logQueue.splice(0);\n\n  const logUrl = Constants.expoGoConfig?.logUrl;\n  if (typeof logUrl !== 'string') {\n    throw new Error('The Expo project manifest must specify `logUrl`');\n  }\n\n  _isSendingLogs = true;\n  try {\n    await _sendNextLogBatchAsync(batch, logUrl);\n  } finally {\n    _isSendingLogs = false;\n  }\n\n  if (_logQueue.length) {\n    return _sendRemoteLogsAsync();\n  } else if (_resolveCompletion) {\n    _resolveCompletion();\n  }\n}\n\nasync function _sendNextLogBatchAsync(batch: LogEntry[], logUrl: string): Promise<void> {\n  let response;\n\n  const headers = {\n    'Content-Type': 'application/json',\n    Connection: 'keep-alive',\n    'Proxy-Connection': 'keep-alive',\n    Accept: 'application/json',\n    'Device-Id': await getInstallationIdAsync(),\n    'Session-Id': _sessionId,\n    'Expo-Platform': Platform.OS,\n  };\n  if (Constants.deviceName) {\n    headers['Device-Name'] = Constants.deviceName;\n  }\n  try {\n    response = await fetch(logUrl, {\n      method: 'POST',\n      headers,\n      body: JSON.stringify(batch),\n    });\n  } catch (error) {\n    _transportEventEmitter.emit('error', { error });\n    return;\n  }\n\n  const success = response.status >= 200 && response.status < 300;\n  if (!success) {\n    _transportEventEmitter.emit('error', {\n      error: new Error(`An HTTP error occurred when sending remote logs`),\n      response,\n    });\n  }\n}\n\nfunction addTransportErrorListener(listener: TransportErrorListener): EventSubscription {\n  return _transportEventEmitter.addListener('error', listener);\n}\n\nfunction _isReactNativeWarning(data: unknown[]): boolean {\n  // NOTE: RN does the same thing internally for YellowBox\n  const message = data[0];\n  return data.length === 1 && typeof message === 'string' && message.startsWith('Warning: ');\n}\n\nexport default {\n  enqueueRemoteLogAsync,\n  addTransportErrorListener,\n};\n\n/**\n * Returns a promise that resolves when all entries in the log queue have been sent. This method is\n * intended for testing only.\n */\nexport function __waitForEmptyLogQueueAsync(): Promise<void> {\n  if (_completionPromise) {\n    return _completionPromise;\n  }\n\n  if (!_isSendingLogs && !_logQueue.length) {\n    return Promise.resolve();\n  }\n\n  _completionPromise = new Promise((resolve) => {\n    _resolveCompletion = () => {\n      invariant(!_isSendingLogs, `Must not be sending logs at completion`);\n      invariant(!_logQueue.length, `Log queue must be empty at completion`);\n\n      _completionPromise = null;\n      _resolveCompletion = null;\n\n      resolve();\n    };\n  });\n  return _completionPromise;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}