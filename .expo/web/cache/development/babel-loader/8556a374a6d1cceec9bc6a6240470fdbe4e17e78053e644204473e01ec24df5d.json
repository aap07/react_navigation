{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evalConfig = evalConfig;\nexports.resolveConfigExport = resolveConfigExport;\nfunction _fs() {\n  var data = require(\"fs\");\n  _fs = function _fs() {\n    return data;\n  };\n  return data;\n}\nfunction _requireFromString() {\n  var data = _interopRequireDefault(require(\"require-from-string\"));\n  _requireFromString = function _requireFromString() {\n    return data;\n  };\n  return data;\n}\nfunction _sucrase() {\n  var data = require(\"sucrase\");\n  _sucrase = function _sucrase() {\n    return data;\n  };\n  return data;\n}\nfunction _Errors() {\n  var data = require(\"./Errors\");\n  _Errors = function _Errors() {\n    return data;\n  };\n  return data;\n}\nfunction _Serialize() {\n  var data = require(\"./Serialize\");\n  _Serialize = function _Serialize() {\n    return data;\n  };\n  return data;\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction evalConfig(configFile, request) {\n  var contents = (0, _fs().readFileSync)(configFile, 'utf8');\n  var result;\n  try {\n    var _ref = (0, _sucrase().transform)(contents, {\n        filePath: configFile,\n        transforms: ['typescript', 'imports']\n      }),\n      code = _ref.code;\n    result = (0, _requireFromString().default)(code, configFile);\n  } catch (error) {\n    var location = extractLocationFromSyntaxError(error);\n    if (location) {\n      var _require = require('@babel/code-frame'),\n        codeFrameColumns = _require.codeFrameColumns;\n      var codeFrame = codeFrameColumns(contents, {\n        start: error.loc\n      }, {\n        highlightCode: true\n      });\n      error.codeFrame = codeFrame;\n      error.message += `\\n${codeFrame}`;\n    } else {\n      var importantStack = extractImportantStackFromNodeError(error);\n      if (importantStack) {\n        error.message += `\\n${importantStack}`;\n      }\n    }\n    throw error;\n  }\n  return resolveConfigExport(result, configFile, request);\n}\nfunction extractLocationFromSyntaxError(error) {\n  if (error.loc) {\n    return error.loc;\n  }\n  if ('lineNumber' in error && 'columnNumber' in error) {\n    return {\n      line: error.lineNumber,\n      column: error.columnNumber\n    };\n  }\n  return null;\n}\nfunction extractImportantStackFromNodeError(error) {\n  if (isSyntaxError(error)) {\n    var _error$stack;\n    var traces = (_error$stack = error.stack) === null || _error$stack === void 0 ? void 0 : _error$stack.split('\\n').filter(function (line) {\n      return !line.startsWith('    at ');\n    });\n    if (!traces) return null;\n    if (traces[traces.length - 1].startsWith('SyntaxError:')) {\n      traces.pop();\n    }\n    return traces.join('\\n');\n  }\n  return null;\n}\nfunction isSyntaxError(error) {\n  return error instanceof SyntaxError || error.constructor.name === 'SyntaxError';\n}\nfunction resolveConfigExport(result, configFile, request) {\n  var _result;\n  if (result.default != null) {\n    result = result.default;\n  }\n  var exportedObjectType = typeof result;\n  if (typeof result === 'function') {\n    result = result(request);\n  }\n  if (result instanceof Promise) {\n    throw new (_Errors().ConfigError)(`Config file ${configFile} cannot return a Promise.`, 'INVALID_CONFIG');\n  }\n  if ((_result = result) !== null && _result !== void 0 && _result.expo) {\n    result = (0, _Serialize().serializeSkippingMods)(result.expo);\n  } else {\n    result = (0, _Serialize().serializeSkippingMods)(result);\n  }\n  return {\n    config: result,\n    exportedObjectType: exportedObjectType\n  };\n}","map":{"version":3,"names":["_fs","data","require","_requireFromString","_interopRequireDefault","_sucrase","_Errors","_Serialize","obj","__esModule","default","evalConfig","configFile","request","contents","readFileSync","result","_ref","transform","filePath","transforms","code","error","location","extractLocationFromSyntaxError","_require","codeFrameColumns","codeFrame","start","loc","highlightCode","message","importantStack","extractImportantStackFromNodeError","resolveConfigExport","line","lineNumber","column","columnNumber","isSyntaxError","_error$stack","traces","stack","split","filter","startsWith","length","pop","join","SyntaxError","constructor","name","_result","exportedObjectType","Promise","ConfigError","expo","serializeSkippingMods","config"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\config\\src\\evalConfig.ts"],"sourcesContent":["import { readFileSync } from 'fs';\nimport requireString from 'require-from-string';\nimport { transform } from 'sucrase';\n\nimport { AppJSONConfig, ConfigContext, ExpoConfig } from './Config.types';\nimport { ConfigError } from './Errors';\nimport { serializeSkippingMods } from './Serialize';\n\ntype RawDynamicConfig = AppJSONConfig | Partial<ExpoConfig> | null;\n\nexport type DynamicConfigResults = { config: RawDynamicConfig; exportedObjectType: string };\n\n/**\n * Transpile and evaluate the dynamic config object.\n * This method is shared between the standard reading method in getConfig, and the headless script.\n *\n * @param options configFile path to the dynamic app.config.*, request to send to the dynamic config if it exports a function.\n * @returns the serialized and evaluated config along with the exported object type (object or function).\n */\nexport function evalConfig(\n  configFile: string,\n  request: ConfigContext | null\n): DynamicConfigResults {\n  const contents = readFileSync(configFile, 'utf8');\n  let result: any;\n  try {\n    const { code } = transform(contents, {\n      filePath: configFile,\n      transforms: ['typescript', 'imports'],\n    });\n\n    result = requireString(code, configFile);\n  } catch (error: any) {\n    const location = extractLocationFromSyntaxError(error);\n\n    // Apply a code frame preview to the error if possible, sucrase doesn't do this by default.\n    if (location) {\n      const { codeFrameColumns } = require('@babel/code-frame');\n      const codeFrame = codeFrameColumns(contents, { start: error.loc }, { highlightCode: true });\n      error.codeFrame = codeFrame;\n      error.message += `\\n${codeFrame}`;\n    } else {\n      const importantStack = extractImportantStackFromNodeError(error);\n\n      if (importantStack) {\n        error.message += `\\n${importantStack}`;\n      }\n    }\n    throw error;\n  }\n  return resolveConfigExport(result, configFile, request);\n}\n\nfunction extractLocationFromSyntaxError(\n  error: Error | any\n): { line: number; column?: number } | null {\n  // sucrase provides the `loc` object\n  if (error.loc) {\n    return error.loc;\n  }\n\n  // `SyntaxError`s provide the `lineNumber` and `columnNumber` properties\n  if ('lineNumber' in error && 'columnNumber' in error) {\n    return { line: error.lineNumber, column: error.columnNumber };\n  }\n\n  return null;\n}\n\n// These kinda errors often come from syntax errors in files that were imported by the main file.\n// An example is a module that includes an import statement.\nfunction extractImportantStackFromNodeError(error: any): string | null {\n  if (isSyntaxError(error)) {\n    const traces = error.stack?.split('\\n').filter((line) => !line.startsWith('    at '));\n    if (!traces) return null;\n\n    // Remove redundant line\n    if (traces[traces.length - 1].startsWith('SyntaxError:')) {\n      traces.pop();\n    }\n    return traces.join('\\n');\n  }\n  return null;\n}\n\nfunction isSyntaxError(error: any): error is SyntaxError {\n  return error instanceof SyntaxError || error.constructor.name === 'SyntaxError';\n}\n\n/**\n * - Resolve the exported contents of an Expo config (be it default or module.exports)\n * - Assert no promise exports\n * - Return config type\n * - Serialize config\n *\n * @param result\n * @param configFile\n * @param request\n */\nexport function resolveConfigExport(\n  result: any,\n  configFile: string,\n  request: ConfigContext | null\n) {\n  if (result.default != null) {\n    result = result.default;\n  }\n  const exportedObjectType = typeof result;\n  if (typeof result === 'function') {\n    result = result(request);\n  }\n\n  if (result instanceof Promise) {\n    throw new ConfigError(`Config file ${configFile} cannot return a Promise.`, 'INVALID_CONFIG');\n  }\n\n  // If the expo object exists, ignore all other values.\n  if (result?.expo) {\n    result = serializeSkippingMods(result.expo);\n  } else {\n    result = serializeSkippingMods(result);\n  }\n\n  return { config: result, exportedObjectType };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}