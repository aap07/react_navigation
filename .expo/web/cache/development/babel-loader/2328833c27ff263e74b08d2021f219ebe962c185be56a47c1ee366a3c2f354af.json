{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.whichEmulator = whichEmulator;\nexports.listAvdsAsync = listAvdsAsync;\nexports.startDeviceAsync = startDeviceAsync;\nexports.EMULATOR_MAX_WAIT_TIMEOUT = void 0;\nvar _spawnAsync = _interopRequireDefault(require(\"@expo/spawn-async\"));\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\nvar _childProcess = require(\"child_process\");\nvar _os = _interopRequireDefault(require(\"os\"));\nvar Log = _interopRequireWildcard(require(\"../../../log\"));\nvar _errors = require(\"../../../utils/errors\");\nvar _exit = require(\"../../../utils/exit\");\nvar _adb = require(\"./adb\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nvar EMULATOR_MAX_WAIT_TIMEOUT = 60 * 1000 * 3;\nexports.EMULATOR_MAX_WAIT_TIMEOUT = EMULATOR_MAX_WAIT_TIMEOUT;\nfunction whichEmulator() {\n  if (process.env.ANDROID_HOME) {\n    return `${process.env.ANDROID_HOME}/emulator/emulator`;\n  }\n  return \"emulator\";\n}\nfunction listAvdsAsync() {\n  return _listAvdsAsync.apply(this, arguments);\n}\nfunction _listAvdsAsync() {\n  _listAvdsAsync = _asyncToGenerator(function* () {\n    try {\n      var _yield$default = yield (0, _spawnAsync).default(whichEmulator(), [\"-list-avds\"]),\n        stdout = _yield$default.stdout;\n      return stdout.split(_os.default.EOL).filter(Boolean).map(function (name) {\n        return {\n          name: name,\n          type: \"emulator\",\n          isBooted: false,\n          isAuthorized: true\n        };\n      });\n    } catch (_unused) {\n      return [];\n    }\n  });\n  return _listAvdsAsync.apply(this, arguments);\n}\nfunction startDeviceAsync(_x) {\n  return _startDeviceAsync.apply(this, arguments);\n}\nfunction _startDeviceAsync() {\n  _startDeviceAsync = _asyncToGenerator(function* (device) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$timeout = _ref.timeout,\n      timeout = _ref$timeout === void 0 ? EMULATOR_MAX_WAIT_TIMEOUT : _ref$timeout,\n      _ref$interval = _ref.interval,\n      interval = _ref$interval === void 0 ? 1000 : _ref$interval;\n    Log.log(`\\u203A Opening emulator ${_chalk.default.bold(device.name)}`);\n    var emulatorProcess = (0, _childProcess).spawn(whichEmulator(), [`@${device.name}`], {\n      stdio: \"ignore\",\n      detached: true\n    });\n    emulatorProcess.unref();\n    return new Promise(function (resolve, reject) {\n      var waitTimer = setInterval(_asyncToGenerator(function* () {\n        try {\n          var bootedDevices = yield (0, _adb).getAttachedDevicesAsync();\n          var connected = bootedDevices.find(function (_ref3) {\n            var name = _ref3.name;\n            return name === device.name;\n          });\n          if (connected) {\n            var isBooted = yield (0, _adb).isBootAnimationCompleteAsync(connected.pid);\n            if (isBooted) {\n              stopWaiting();\n              resolve(connected);\n            }\n          }\n        } catch (error) {\n          stopWaiting();\n          reject(error);\n        }\n      }), interval);\n      var maxTimer = setTimeout(function () {\n        var manualCommand = `${whichEmulator()} @${device.name}`;\n        stopWaitingAndReject(`It took too long to start the Android emulator: ${device.name}. You can try starting the emulator manually from the terminal with: ${manualCommand}`);\n      }, timeout);\n      var stopWaiting = function stopWaiting() {\n        clearTimeout(maxTimer);\n        clearInterval(waitTimer);\n        removeExitHook();\n      };\n      var stopWaitingAndReject = function stopWaitingAndReject(message) {\n        stopWaiting();\n        reject(new Error(message));\n      };\n      var removeExitHook = (0, _exit).installExitHooks(function (signal) {\n        stopWaiting();\n        emulatorProcess.kill(signal);\n        reject(new _errors.AbortCommandError());\n      });\n      emulatorProcess.on(\"error\", function (_ref4) {\n        var message = _ref4.message;\n        return stopWaitingAndReject(message);\n      });\n      emulatorProcess.on(\"exit\", function () {\n        var manualCommand = `${whichEmulator()} @${device.name}`;\n        stopWaitingAndReject(`The emulator (${device.name}) quit before it finished opening. You can try starting the emulator manually from the terminal with: ${manualCommand}`);\n      });\n    });\n  });\n  return _startDeviceAsync.apply(this, arguments);\n}","map":{"version":3,"names":["_asyncToGenerator","require","whichEmulator","listAvdsAsync","startDeviceAsync","_spawnAsync","_interopRequireDefault","_chalk","_childProcess","_os","Log","_interopRequireWildcard","_errors","_exit","_adb","EMULATOR_MAX_WAIT_TIMEOUT","process","env","ANDROID_HOME","_listAvdsAsync","apply","arguments","_yield$default","default","stdout","split","EOL","filter","Boolean","map","name","type","isBooted","isAuthorized","_unused","_x","_startDeviceAsync","device","_ref","length","undefined","_ref$timeout","timeout","_ref$interval","interval","log","bold","emulatorProcess","spawn","stdio","detached","unref","Promise","resolve","reject","waitTimer","setInterval","bootedDevices","getAttachedDevicesAsync","connected","find","_ref3","isBootAnimationCompleteAsync","pid","stopWaiting","error","maxTimer","setTimeout","manualCommand","stopWaitingAndReject","clearTimeout","clearInterval","removeExitHook","message","Error","installExitHooks","signal","kill","AbortCommandError","on","_ref4"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\cli\\src\\start\\platforms\\android\\emulator.ts"],"sourcesContent":["import spawnAsync from '@expo/spawn-async';\nimport chalk from 'chalk';\nimport { spawn } from 'child_process';\nimport os from 'os';\n\nimport * as Log from '../../../log';\nimport { AbortCommandError } from '../../../utils/errors';\nimport { installExitHooks } from '../../../utils/exit';\nimport { Device, getAttachedDevicesAsync, isBootAnimationCompleteAsync } from './adb';\n\nexport const EMULATOR_MAX_WAIT_TIMEOUT = 60 * 1000 * 3;\n\nexport function whichEmulator(): string {\n  // https://developer.android.com/studio/command-line/variables\n  // TODO: Add ANDROID_SDK_ROOT support as well https://github.com/expo/expo/pull/16516#discussion_r820037917\n  if (process.env.ANDROID_HOME) {\n    return `${process.env.ANDROID_HOME}/emulator/emulator`;\n  }\n  return 'emulator';\n}\n\n/** Returns a list of emulator names. */\nexport async function listAvdsAsync(): Promise<Device[]> {\n  try {\n    const { stdout } = await spawnAsync(whichEmulator(), ['-list-avds']);\n    return stdout\n      .split(os.EOL)\n      .filter(Boolean)\n      .map((name) => ({\n        name,\n        type: 'emulator',\n        // unsure from this\n        isBooted: false,\n        isAuthorized: true,\n      }));\n  } catch {\n    return [];\n  }\n}\n\n/** Start an Android device and wait until it is booted. */\nexport async function startDeviceAsync(\n  device: Pick<Device, 'name'>,\n  {\n    timeout = EMULATOR_MAX_WAIT_TIMEOUT,\n    interval = 1000,\n  }: {\n    /** Time in milliseconds to wait before asserting a timeout error. */\n    timeout?: number;\n    interval?: number;\n  } = {}\n): Promise<Device> {\n  Log.log(`\\u203A Opening emulator ${chalk.bold(device.name)}`);\n\n  // Start a process to open an emulator\n  const emulatorProcess = spawn(\n    whichEmulator(),\n    [\n      `@${device.name}`,\n      // disable animation for faster boot -- this might make it harder to detect if it mounted properly tho\n      //'-no-boot-anim'\n    ],\n    {\n      stdio: 'ignore',\n      detached: true,\n    }\n  );\n\n  emulatorProcess.unref();\n\n  return new Promise<Device>((resolve, reject) => {\n    const waitTimer = setInterval(async () => {\n      try {\n        const bootedDevices = await getAttachedDevicesAsync();\n        const connected = bootedDevices.find(({ name }) => name === device.name);\n        if (connected) {\n          const isBooted = await isBootAnimationCompleteAsync(connected.pid);\n          if (isBooted) {\n            stopWaiting();\n            resolve(connected);\n          }\n        }\n      } catch (error) {\n        stopWaiting();\n        reject(error);\n      }\n    }, interval);\n\n    // Reject command after timeout\n    const maxTimer = setTimeout(() => {\n      const manualCommand = `${whichEmulator()} @${device.name}`;\n      stopWaitingAndReject(\n        `It took too long to start the Android emulator: ${device.name}. You can try starting the emulator manually from the terminal with: ${manualCommand}`\n      );\n    }, timeout);\n\n    const stopWaiting = () => {\n      clearTimeout(maxTimer);\n      clearInterval(waitTimer);\n      removeExitHook();\n    };\n\n    const stopWaitingAndReject = (message: string) => {\n      stopWaiting();\n      reject(new Error(message));\n    };\n\n    const removeExitHook = installExitHooks((signal) => {\n      stopWaiting();\n      emulatorProcess.kill(signal);\n      reject(new AbortCommandError());\n    });\n\n    emulatorProcess.on('error', ({ message }) => stopWaitingAndReject(message));\n\n    emulatorProcess.on('exit', () => {\n      const manualCommand = `${whichEmulator()} @${device.name}`;\n      stopWaitingAndReject(\n        `The emulator (${device.name}) quit before it finished opening. You can try starting the emulator manually from the terminal with: ${manualCommand}`\n      );\n    });\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}