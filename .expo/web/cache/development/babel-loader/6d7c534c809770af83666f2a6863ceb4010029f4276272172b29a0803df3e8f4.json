{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nvar MapperRegistry = function () {\n  function MapperRegistry(module) {\n    _classCallCheck(this, MapperRegistry);\n    _defineProperty(this, \"sortedMappers\", []);\n    _defineProperty(this, \"mappers\", new Map());\n    _defineProperty(this, \"_module\", void 0);\n    _defineProperty(this, \"updatedSinceLastExecute\", false);\n    this._module = module;\n  }\n  _createClass(MapperRegistry, [{\n    key: \"startMapper\",\n    value: function startMapper(mapper) {\n      this.mappers.set(mapper.id, mapper);\n      this.updatedSinceLastExecute = true;\n      return mapper.id;\n    }\n  }, {\n    key: \"stopMapper\",\n    value: function stopMapper(id) {\n      this.mappers.delete(id);\n      this.updatedSinceLastExecute = true;\n    }\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      if (this.updatedSinceLastExecute) {\n        this.updateOrder();\n        this.updatedSinceLastExecute = false;\n      }\n      for (var i = 0, len = this.sortedMappers.length; i < len; ++i) {\n        var mapper = this.sortedMappers[i];\n        if (mapper.dirty) {\n          mapper.execute();\n        }\n      }\n    }\n  }, {\n    key: \"updateOrder\",\n    value: function updateOrder() {\n      var nodes = _toConsumableArray(this.mappers.values()).map(function (mapper) {\n        return new Node(mapper);\n      });\n      var mappersById = {};\n      this.mappers.forEach(function (mapper) {\n        mappersById[mapper.id] = mapper;\n      });\n      for (var i = 0, nodesLen = nodes.length; i < nodesLen; ++i) {\n        var node = nodes[i];\n        if (node.mapper.outputs.length === 0) {\n          continue;\n        }\n        for (var j = 0; j < nodesLen; ++j) {\n          var restNode = nodes[j];\n          if (i === j || restNode.mapper.inputs.length === 0) {\n            continue;\n          }\n          for (var outi = 0, outputsLen = node.mapper.outputs.length; outi < outputsLen; ++outi) {\n            for (var resti = 0, restLen = restNode.mapper.inputs.length; resti < restLen; ++resti) {\n              if (node.mapper.outputs[outi]._id === restNode.mapper.inputs[resti]._id) {\n                node.children.push(restNode);\n              }\n            }\n          }\n        }\n      }\n      var post = {};\n      var postCounter = 1;\n      var dfs = function dfs(node) {\n        var index = nodes.indexOf(node);\n        if (index === -1) {\n          return;\n        }\n        ++postCounter;\n        nodes.splice(index, 1);\n        if (node.children.length === 0 && nodes.length > 0) {\n          post[node.mapper.id] = postCounter++;\n          dfs(nodes[0]);\n          return;\n        }\n        for (var _i = 0, len = node.children.length; _i < len; ++_i) {\n          dfs(node.children[_i]);\n        }\n        post[node.mapper.id] = postCounter++;\n      };\n      while (nodes.length) dfs(nodes[0]);\n      var postArray = Object.keys(post).map(function (key) {\n        var num = parseInt(key);\n        return [num, post[num]];\n      });\n      postArray.sort(function (a, b) {\n        return b[1] - a[1];\n      });\n      this.sortedMappers = [];\n      for (var _i2 = 0, len = postArray.length; _i2 < len; ++_i2) {\n        var _postArray$_i = _slicedToArray(postArray[_i2], 1),\n          id = _postArray$_i[0];\n        this.sortedMappers.push(mappersById[id]);\n      }\n    }\n  }, {\n    key: \"needRunOnRender\",\n    get: function get() {\n      return this.updatedSinceLastExecute;\n    }\n  }]);\n  return MapperRegistry;\n}();\nexport { MapperRegistry as default };\nvar Node = _createClass(function Node(mapper) {\n  _classCallCheck(this, Node);\n  var children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  _defineProperty(this, \"mapper\", void 0);\n  _defineProperty(this, \"children\", void 0);\n  this.mapper = mapper;\n  this.children = children;\n});","map":{"version":3,"names":["MapperRegistry","module","_classCallCheck","_defineProperty","Map","_module","_createClass","key","value","startMapper","mapper","mappers","set","id","updatedSinceLastExecute","stopMapper","delete","execute","updateOrder","i","len","sortedMappers","length","dirty","nodes","_toConsumableArray","values","map","Node","mappersById","forEach","nodesLen","node","outputs","j","restNode","inputs","outi","outputsLen","resti","restLen","_id","children","push","post","postCounter","dfs","index","indexOf","splice","postArray","Object","keys","num","parseInt","sort","a","b","_postArray$_i","_slicedToArray","get","default","arguments","undefined"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\react-native-reanimated\\lib\\module\\reanimated2\\js-reanimated\\MapperRegistry.ts"],"sourcesContent":["import { JSReanimated } from './commonTypes';\nimport Mapper from './Mapper';\n\nexport default class MapperRegistry<T> {\n  sortedMappers: Mapper<T>[] = [];\n  mappers: Map<number, Mapper<T>> = new Map();\n  _module: JSReanimated;\n\n  updatedSinceLastExecute = false;\n\n  constructor(module: JSReanimated) {\n    this._module = module;\n  }\n\n  startMapper(mapper: Mapper<T>): number {\n    this.mappers.set(mapper.id, mapper);\n    this.updatedSinceLastExecute = true;\n    return mapper.id;\n  }\n\n  stopMapper(id: number): void {\n    this.mappers.delete(id);\n    this.updatedSinceLastExecute = true;\n  }\n\n  execute(): void {\n    if (this.updatedSinceLastExecute) {\n      this.updateOrder();\n      this.updatedSinceLastExecute = false;\n    }\n\n    for (let i = 0, len = this.sortedMappers.length; i < len; ++i) {\n      const mapper = this.sortedMappers[i];\n      if (mapper.dirty) {\n        mapper.execute();\n      }\n    }\n  }\n\n  updateOrder(): void {\n    const nodes = [...this.mappers.values()].map((mapper) => new Node(mapper));\n\n    const mappersById: Record<number, Mapper<T>> = {};\n    this.mappers.forEach((mapper) => {\n      mappersById[mapper.id] = mapper;\n    });\n\n    // create a graph from array of nodes\n    for (let i = 0, nodesLen = nodes.length; i < nodesLen; ++i) {\n      const node = nodes[i];\n      if (node.mapper.outputs.length === 0) {\n        continue;\n      }\n      for (let j = 0; j < nodesLen; ++j) {\n        const restNode = nodes[j];\n        if (i === j || restNode.mapper.inputs.length === 0) {\n          continue;\n        }\n        for (\n          let outi = 0, outputsLen = node.mapper.outputs.length;\n          outi < outputsLen;\n          ++outi\n        ) {\n          for (\n            let resti = 0, restLen = restNode.mapper.inputs.length;\n            resti < restLen;\n            ++resti\n          ) {\n            if (\n              node.mapper.outputs[outi]._id ===\n              restNode.mapper.inputs[resti]._id\n            ) {\n              node.children.push(restNode);\n            }\n          }\n        }\n      }\n    }\n\n    const post: Record<number, number> = {};\n    let postCounter = 1;\n    const dfs = (node: Node<T>) => {\n      const index = nodes.indexOf(node);\n      if (index === -1) {\n        // this node has already been handled\n        return;\n      }\n      ++postCounter;\n      nodes.splice(index, 1);\n      if (node.children.length === 0 && nodes.length > 0) {\n        post[node.mapper.id] = postCounter++;\n        dfs(nodes[0]);\n        return;\n      }\n      for (let i = 0, len = node.children.length; i < len; ++i) {\n        dfs(node.children[i]);\n      }\n      post[node.mapper.id] = postCounter++;\n    };\n\n    while (nodes.length) dfs(nodes[0]);\n\n    const postArray = Object.keys(post).map((key) => {\n      const num = parseInt(key);\n      return [num, post[num]];\n    });\n    postArray.sort((a, b) => {\n      return b[1] - a[1];\n    });\n\n    // clear sorted mappers\n    this.sortedMappers = [];\n\n    for (let i = 0, len = postArray.length; i < len; ++i) {\n      const [id] = postArray[i];\n      this.sortedMappers.push(mappersById[id]);\n    }\n  }\n\n  get needRunOnRender(): boolean {\n    return this.updatedSinceLastExecute;\n  }\n}\n\nclass Node<T> {\n  mapper: Mapper<T>;\n  children: Node<T>[];\n\n  constructor(mapper: Mapper<T>, children = []) {\n    this.mapper = mapper;\n    this.children = children;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}