{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport escapeStringRegexp from 'escape-string-regexp';\nexport default function extractPathFromURL(prefixes, url) {\n  for (var prefix of prefixes) {\n    var _ref;\n    var _prefix$match;\n    var protocol = (_ref = (_prefix$match = prefix.match(/^[^:]+:/)) === null || _prefix$match === void 0 ? void 0 : _prefix$match[0]) != null ? _ref : '';\n    var host = prefix.replace(new RegExp(`^${escapeStringRegexp(protocol)}`), '').replace(/\\/+/g, '/').replace(/^\\//, '');\n    var prefixRegex = new RegExp(`^${escapeStringRegexp(protocol)}(/)*${host.split('.').map(function (it) {\n      return it === '*' ? '[^/]+' : escapeStringRegexp(it);\n    }).join('\\\\.')}`);\n    var _url$split = url.split('?'),\n      _url$split2 = _slicedToArray(_url$split, 2),\n      originAndPath = _url$split2[0],\n      searchParams = _url$split2[1];\n    var normalizedURL = originAndPath.replace(/\\/+/g, '/').concat(searchParams ? `?${searchParams}` : '');\n    if (prefixRegex.test(normalizedURL)) {\n      return normalizedURL.replace(prefixRegex, '');\n    }\n  }\n  return undefined;\n}","map":{"version":3,"names":["escapeStringRegexp","extractPathFromURL","prefixes","url","prefix","_ref","_prefix$match","protocol","match","host","replace","RegExp","prefixRegex","split","map","it","join","_url$split","_url$split2","_slicedToArray","originAndPath","searchParams","normalizedURL","concat","test","undefined"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@react-navigation\\native\\src\\extractPathFromURL.tsx"],"sourcesContent":["import escapeStringRegexp from 'escape-string-regexp';\n\nexport default function extractPathFromURL(prefixes: string[], url: string) {\n  for (const prefix of prefixes) {\n    const protocol = prefix.match(/^[^:]+:/)?.[0] ?? '';\n    const host = prefix\n      .replace(new RegExp(`^${escapeStringRegexp(protocol)}`), '')\n      .replace(/\\/+/g, '/') // Replace multiple slash (//) with single ones\n      .replace(/^\\//, ''); // Remove extra leading slash\n\n    const prefixRegex = new RegExp(\n      `^${escapeStringRegexp(protocol)}(/)*${host\n        .split('.')\n        .map((it) => (it === '*' ? '[^/]+' : escapeStringRegexp(it)))\n        .join('\\\\.')}`\n    );\n\n    const [originAndPath, searchParams] = url.split('?');\n    const normalizedURL = originAndPath\n      .replace(/\\/+/g, '/')\n      .concat(searchParams ? `?${searchParams}` : '');\n\n    if (prefixRegex.test(normalizedURL)) {\n      return normalizedURL.replace(prefixRegex, '');\n    }\n  }\n\n  return undefined;\n}\n"],"mappings":";AAAA,OAAOA,kBAAkB,MAAM,sBAAsB;AAErD,eAAe,SAASC,kBAAkBA,CAACC,QAAkB,EAAEC,GAAW,EAAE;EAC1E,KAAK,IAAMC,MAAM,IAAIF,QAAQ,EAAE;IAAA,IAAAG,IAAA;IAAA,IAAAC,aAAA;IAC7B,IAAMC,QAAQ,IAAAF,IAAA,GAAG,CAAAC,aAAA,GAAAF,MAAM,CAACI,KAAK,CAAC,SAAS,CAAC,cAAAF,aAAA,uBAAvBA,aAAA,CAA0B,CAAC,CAAC,YAAAD,IAAA,GAAI,EAAE;IACnD,IAAMI,IAAI,GAAGL,MAAM,CAChBM,OAAO,CAAC,IAAIC,MAAM,CAAE,IAAGX,kBAAkB,CAACO,QAAQ,CAAE,EAAC,CAAC,EAAE,EAAE,CAAC,CAC3DG,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,CACpBA,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;IAErB,IAAME,WAAW,GAAG,IAAID,MAAM,CAC3B,IAAGX,kBAAkB,CAACO,QAAQ,CAAE,OAAME,IAAI,CACxCI,KAAK,CAAC,GAAG,CAAC,CACVC,GAAG,CAAE,UAAAC,EAAE;MAAA,OAAMA,EAAE,KAAK,GAAG,GAAG,OAAO,GAAGf,kBAAkB,CAACe,EAAE,CAAE;IAAA,EAAC,CAC5DC,IAAI,CAAC,KAAK,CAAE,EAAC,CACjB;IAED,IAAAC,UAAA,GAAsCd,GAAG,CAACU,KAAK,CAAC,GAAG,CAAC;MAAAK,WAAA,GAAAC,cAAA,CAAAF,UAAA;MAA7CG,aAAa,GAAAF,WAAA;MAAEG,YAAY,GAAAH,WAAA;IAClC,IAAMI,aAAa,GAAGF,aAAa,CAChCV,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,CACpBa,MAAM,CAACF,YAAY,GAAI,IAAGA,YAAa,EAAC,GAAG,EAAE,CAAC;IAEjD,IAAIT,WAAW,CAACY,IAAI,CAACF,aAAa,CAAC,EAAE;MACnC,OAAOA,aAAa,CAACZ,OAAO,CAACE,WAAW,EAAE,EAAE,CAAC;IAC/C;EACF;EAEA,OAAOa,SAAS;AAClB"},"metadata":{},"sourceType":"module","externalDependencies":[]}