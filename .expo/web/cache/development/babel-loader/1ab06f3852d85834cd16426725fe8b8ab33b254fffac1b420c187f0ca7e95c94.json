{"ast":null,"code":"function resolveProps(tokens, _ref) {\n  var _start;\n  var flow = _ref.flow,\n    indicator = _ref.indicator,\n    next = _ref.next,\n    offset = _ref.offset,\n    onError = _ref.onError,\n    startOnNewline = _ref.startOnNewline;\n  var spaceBefore = false;\n  var atNewline = startOnNewline;\n  var hasSpace = startOnNewline;\n  var comment = '';\n  var commentSep = '';\n  var hasNewline = false;\n  var hasNewlineAfterProp = false;\n  var reqSpace = false;\n  var anchor = null;\n  var tag = null;\n  var comma = null;\n  var found = null;\n  var start = null;\n  for (var token of tokens) {\n    if (reqSpace) {\n      if (token.type !== 'space' && token.type !== 'newline' && token.type !== 'comma') onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n      reqSpace = false;\n    }\n    switch (token.type) {\n      case 'space':\n        if (!flow && atNewline && indicator !== 'doc-start' && token.source[0] === '\\t') onError(token, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');\n        hasSpace = true;\n        break;\n      case 'comment':\n        {\n          if (!hasSpace) onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');\n          var cb = token.source.substring(1) || ' ';\n          if (!comment) comment = cb;else comment += commentSep + cb;\n          commentSep = '';\n          atNewline = false;\n          break;\n        }\n      case 'newline':\n        if (atNewline) {\n          if (comment) comment += token.source;else spaceBefore = true;\n        } else commentSep += token.source;\n        atNewline = true;\n        hasNewline = true;\n        if (anchor || tag) hasNewlineAfterProp = true;\n        hasSpace = true;\n        break;\n      case 'anchor':\n        if (anchor) onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');\n        if (token.source.endsWith(':')) onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);\n        anchor = token;\n        if (start === null) start = token.offset;\n        atNewline = false;\n        hasSpace = false;\n        reqSpace = true;\n        break;\n      case 'tag':\n        {\n          if (tag) onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');\n          tag = token;\n          if (start === null) start = token.offset;\n          atNewline = false;\n          hasSpace = false;\n          reqSpace = true;\n          break;\n        }\n      case indicator:\n        if (anchor || tag) onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);\n        if (found) onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.source} in ${flow != null ? flow : 'collection'}`);\n        found = token;\n        atNewline = false;\n        hasSpace = false;\n        break;\n      case 'comma':\n        if (flow) {\n          if (comma) onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);\n          comma = token;\n          atNewline = false;\n          hasSpace = false;\n          break;\n        }\n      default:\n        onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);\n        atNewline = false;\n        hasSpace = false;\n    }\n  }\n  var last = tokens[tokens.length - 1];\n  var end = last ? last.offset + last.source.length : offset;\n  if (reqSpace && next && next.type !== 'space' && next.type !== 'newline' && next.type !== 'comma' && (next.type !== 'scalar' || next.source !== '')) onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n  return {\n    comma: comma,\n    found: found,\n    spaceBefore: spaceBefore,\n    comment: comment,\n    hasNewline: hasNewline,\n    hasNewlineAfterProp: hasNewlineAfterProp,\n    anchor: anchor,\n    tag: tag,\n    end: end,\n    start: (_start = start) != null ? _start : end\n  };\n}\nexport { resolveProps };","map":{"version":3,"names":["resolveProps","tokens","_ref","_start","flow","indicator","next","offset","onError","startOnNewline","spaceBefore","atNewline","hasSpace","comment","commentSep","hasNewline","hasNewlineAfterProp","reqSpace","anchor","tag","comma","found","start","token","type","source","cb","substring","endsWith","length","last","end"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native-community/cli-doctor/node_modules/yaml/browser/dist/compose/resolve-props.js"],"sourcesContent":["function resolveProps(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {\n    let spaceBefore = false;\n    let atNewline = startOnNewline;\n    let hasSpace = startOnNewline;\n    let comment = '';\n    let commentSep = '';\n    let hasNewline = false;\n    let hasNewlineAfterProp = false;\n    let reqSpace = false;\n    let anchor = null;\n    let tag = null;\n    let comma = null;\n    let found = null;\n    let start = null;\n    for (const token of tokens) {\n        if (reqSpace) {\n            if (token.type !== 'space' &&\n                token.type !== 'newline' &&\n                token.type !== 'comma')\n                onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n            reqSpace = false;\n        }\n        switch (token.type) {\n            case 'space':\n                // At the doc level, tabs at line start may be parsed\n                // as leading white space rather than indentation.\n                // In a flow collection, only the parser handles indent.\n                if (!flow &&\n                    atNewline &&\n                    indicator !== 'doc-start' &&\n                    token.source[0] === '\\t')\n                    onError(token, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');\n                hasSpace = true;\n                break;\n            case 'comment': {\n                if (!hasSpace)\n                    onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');\n                const cb = token.source.substring(1) || ' ';\n                if (!comment)\n                    comment = cb;\n                else\n                    comment += commentSep + cb;\n                commentSep = '';\n                atNewline = false;\n                break;\n            }\n            case 'newline':\n                if (atNewline) {\n                    if (comment)\n                        comment += token.source;\n                    else\n                        spaceBefore = true;\n                }\n                else\n                    commentSep += token.source;\n                atNewline = true;\n                hasNewline = true;\n                if (anchor || tag)\n                    hasNewlineAfterProp = true;\n                hasSpace = true;\n                break;\n            case 'anchor':\n                if (anchor)\n                    onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');\n                if (token.source.endsWith(':'))\n                    onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);\n                anchor = token;\n                if (start === null)\n                    start = token.offset;\n                atNewline = false;\n                hasSpace = false;\n                reqSpace = true;\n                break;\n            case 'tag': {\n                if (tag)\n                    onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');\n                tag = token;\n                if (start === null)\n                    start = token.offset;\n                atNewline = false;\n                hasSpace = false;\n                reqSpace = true;\n                break;\n            }\n            case indicator:\n                // Could here handle preceding comments differently\n                if (anchor || tag)\n                    onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);\n                if (found)\n                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.source} in ${flow ?? 'collection'}`);\n                found = token;\n                atNewline = false;\n                hasSpace = false;\n                break;\n            case 'comma':\n                if (flow) {\n                    if (comma)\n                        onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);\n                    comma = token;\n                    atNewline = false;\n                    hasSpace = false;\n                    break;\n                }\n            // else fallthrough\n            default:\n                onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);\n                atNewline = false;\n                hasSpace = false;\n        }\n    }\n    const last = tokens[tokens.length - 1];\n    const end = last ? last.offset + last.source.length : offset;\n    if (reqSpace &&\n        next &&\n        next.type !== 'space' &&\n        next.type !== 'newline' &&\n        next.type !== 'comma' &&\n        (next.type !== 'scalar' || next.source !== ''))\n        onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n    return {\n        comma,\n        found,\n        spaceBefore,\n        comment,\n        hasNewline,\n        hasNewlineAfterProp,\n        anchor,\n        tag,\n        end,\n        start: start ?? end\n    };\n}\n\nexport { resolveProps };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}