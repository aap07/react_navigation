{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nvar _get = require(\"@babel/runtime/helpers/get\");\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MetroParser = void 0;\nvar Parser_1 = require(\"./Parser\");\nvar switchRegex_1 = require(\"./switchRegex\");\nvar MetroParser = function (_Parser_1$Parser) {\n  _inherits(MetroParser, _Parser_1$Parser);\n  var _super = _createSuper(MetroParser);\n  function MetroParser(formatter) {\n    var _this;\n    _classCallCheck(this, MetroParser);\n    _this = _super.call(this, formatter);\n    _this.formatter = formatter;\n    _this.isCollectingMetroError = false;\n    _this.metroError = [];\n    return _this;\n  }\n  _createClass(MetroParser, [{\n    key: \"parse\",\n    value: function parse(text) {\n      var results = this.checkMetroError(text);\n      if (results) {\n        return results;\n      }\n      return _get(_getPrototypeOf(MetroParser.prototype), \"parse\", this).call(this, text);\n    }\n  }, {\n    key: \"checkMetroError\",\n    value: function checkMetroError(text) {\n      var _this2 = this;\n      return switchRegex_1.switchRegex(text, [[/@build-script-error-begin/m, function () {\n        _this2.isCollectingMetroError = true;\n      }], [/@build-script-error-end/m, function () {\n        var results = _this2.metroError.join('\\n');\n        _this2.isCollectingMetroError = false;\n        _this2.metroError = [];\n        if ('formatMetroAssetCollectionError' in _this2.formatter) {\n          return _this2.formatter.formatMetroAssetCollectionError(results);\n        }\n        throw new Error('Current `@expo/xcpretty` formatter cannot handle Metro errors');\n      }], [null, function () {\n        if (_this2.isCollectingMetroError) {\n          var results = text;\n          if (!_this2.metroError.length) {\n            var match = text.match(/Error loading assets JSON from Metro.*steps correctly.((.|\\n)*)/m);\n            if (match && match[1]) {\n              results = match[1].trim();\n            }\n          }\n          _this2.metroError.push(results);\n        }\n      }]]);\n    }\n  }]);\n  return MetroParser;\n}(Parser_1.Parser);\nexports.MetroParser = MetroParser;","map":{"version":3,"names":["Parser_1","require","switchRegex_1","MetroParser","_Parser_1$Parser","_inherits","_super","_createSuper","formatter","_this","_classCallCheck","call","isCollectingMetroError","metroError","_createClass","key","value","parse","text","results","checkMetroError","_get","_getPrototypeOf","prototype","_this2","switchRegex","join","formatMetroAssetCollectionError","Error","length","match","trim","push","Parser","exports"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\xcpretty\\src\\MetroParser.ts"],"sourcesContent":["import { Formatter } from './Formatter';\nimport { Parser } from './Parser';\nimport { switchRegex } from './switchRegex';\n\nexport class MetroParser extends Parser {\n  private isCollectingMetroError = false;\n  private metroError: string[] = [];\n\n  constructor(public formatter: Formatter) {\n    super(formatter);\n  }\n\n  parse(text: string): void | string {\n    const results = this.checkMetroError(text);\n    if (results) {\n      return results;\n    }\n    return super.parse(text);\n  }\n\n  // Error for the build script wrapper in expo-updates that catches metro bundler errors.\n  // This can be repro'd by importing a file that doesn't exist, then building.\n  // Metro will fail to generate the JS bundle, and throw an error that should be caught here.\n  checkMetroError(text: string) {\n    // In expo-updates, we wrap the bundler script and add regex around the error message so we can present it nicely to the user.\n    return switchRegex(text, [\n      [\n        /@build-script-error-begin/m,\n        () => {\n          this.isCollectingMetroError = true;\n        },\n      ],\n      [\n        /@build-script-error-end/m,\n        () => {\n          const results = this.metroError.join('\\n');\n          // Reset the metro collection error array (should never need this).\n          this.isCollectingMetroError = false;\n          this.metroError = [];\n          if ('formatMetroAssetCollectionError' in this.formatter) {\n            return (this.formatter as any).formatMetroAssetCollectionError(results);\n          }\n          throw new Error('Current `@expo/xcpretty` formatter cannot handle Metro errors');\n        },\n      ],\n      [\n        null,\n        () => {\n          // Collect all the lines in the metro build error\n          if (this.isCollectingMetroError) {\n            let results = text;\n            if (!this.metroError.length) {\n              const match = text.match(\n                /Error loading assets JSON from Metro.*steps correctly.((.|\\n)*)/m\n              );\n              if (match && match[1]) {\n                results = match[1].trim();\n              }\n            }\n            this.metroError.push(results);\n          }\n        },\n      ],\n    ]);\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;AACA,IAAAA,QAAA,GAAAC,OAAA;AACA,IAAAC,aAAA,GAAAD,OAAA;AAA4C,IAE/BE,WAAY,aAAAC,gBAAA;EAAAC,SAAA,CAAAF,WAAA,EAAAC,gBAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,WAAA;EAIvB,SAAAA,YAAmBK,SAAoB;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAP,WAAA;IACrCM,KAAA,GAAAH,MAAA,CAAAK,IAAA,OAAMH,SAAS;IADEC,KAAA,CAAAD,SAAS,GAATA,SAAS;IAHpBC,KAAA,CAAAG,sBAAsB,GAAG,KAAK;IAC9BH,KAAA,CAAAI,UAAU,GAAa,EAAE;IAAC,OAAAJ,KAAA;EAIlC;EAACK,YAAA,CAAAX,WAAA;IAAAY,GAAA;IAAAC,KAAA,EAED,SAAAC,MAAMC,IAAY;MAChB,IAAMC,OAAO,GAAG,IAAI,CAACC,eAAe,CAACF,IAAI,CAAC;MAC1C,IAAIC,OAAO,EAAE;QACX,OAAOA,OAAO;;MAEhB,OAAAE,IAAA,CAAAC,eAAA,CAAAnB,WAAA,CAAAoB,SAAA,kBAAAZ,IAAA,OAAmBO,IAAI;IACzB;EAAC;IAAAH,GAAA;IAAAC,KAAA,EAKD,SAAAI,gBAAgBF,IAAY;MAAA,IAAAM,MAAA;MAE1B,OAAOtB,aAAA,CAAAuB,WAAW,CAACP,IAAI,EAAE,CACvB,CACE,4BAA4B,EAC5B,YAAK;QACHM,MAAI,CAACZ,sBAAsB,GAAG,IAAI;MACpC,CAAC,CACF,EACD,CACE,0BAA0B,EAC1B,YAAK;QACH,IAAMO,OAAO,GAAGK,MAAI,CAACX,UAAU,CAACa,IAAI,CAAC,IAAI,CAAC;QAE1CF,MAAI,CAACZ,sBAAsB,GAAG,KAAK;QACnCY,MAAI,CAACX,UAAU,GAAG,EAAE;QACpB,IAAI,iCAAiC,IAAIW,MAAI,CAAChB,SAAS,EAAE;UACvD,OAAQgB,MAAI,CAAChB,SAAiB,CAACmB,+BAA+B,CAACR,OAAO,CAAC;;QAEzE,MAAM,IAAIS,KAAK,CAAC,+DAA+D,CAAC;MAClF,CAAC,CACF,EACD,CACE,IAAI,EACJ,YAAK;QAEH,IAAIJ,MAAI,CAACZ,sBAAsB,EAAE;UAC/B,IAAIO,OAAO,GAAGD,IAAI;UAClB,IAAI,CAACM,MAAI,CAACX,UAAU,CAACgB,MAAM,EAAE;YAC3B,IAAMC,KAAK,GAAGZ,IAAI,CAACY,KAAK,CACtB,kEAAkE,CACnE;YACD,IAAIA,KAAK,IAAIA,KAAK,CAAC,CAAC,CAAC,EAAE;cACrBX,OAAO,GAAGW,KAAK,CAAC,CAAC,CAAC,CAACC,IAAI,EAAE;;;UAG7BP,MAAI,CAACX,UAAU,CAACmB,IAAI,CAACb,OAAO,CAAC;;MAEjC,CAAC,CACF,CACF,CAAC;IACJ;EAAC;EAAA,OAAAhB,WAAA;AAAA,EA5D8BH,QAAA,CAAAiC,MAAM;AAAvCC,OAAA,CAAA/B,WAAA,GAAAA,WAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}