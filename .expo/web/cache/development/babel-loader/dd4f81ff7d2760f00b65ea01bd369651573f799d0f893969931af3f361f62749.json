{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mergeGitIgnorePaths = mergeGitIgnorePaths;\nexports.removeGeneratedGitIgnoreContents = removeGeneratedGitIgnoreContents;\nexports.mergeGitIgnoreContents = mergeGitIgnoreContents;\nexports.upsertGitIgnoreContents = upsertGitIgnoreContents;\nexports.createGeneratedHeaderComment = createGeneratedHeaderComment;\nexports.getSanitizedGitIgnoreLines = getSanitizedGitIgnoreLines;\nexports.createGitIgnoreHash = createGitIgnoreHash;\nexports.removeFromGitIgnore = removeFromGitIgnore;\nexports.generatedFooterComment = void 0;\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _log = require(\"../log\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar generatedHeaderPrefix = `# @generated expo-cli`;\nvar generatedFooterComment = `# @end expo-cli`;\nexports.generatedFooterComment = generatedFooterComment;\nfunction mergeGitIgnorePaths(targetGitIgnorePath, sourceGitIgnorePath) {\n  if (!_fs.default.existsSync(targetGitIgnorePath)) {\n    return null;\n  }\n  if (!_fs.default.existsSync(sourceGitIgnorePath)) {\n    return null;\n  }\n  var targetGitIgnore = _fs.default.readFileSync(targetGitIgnorePath).toString();\n  var sourceGitIgnore = _fs.default.readFileSync(sourceGitIgnorePath).toString();\n  var merged = mergeGitIgnoreContents(targetGitIgnore, sourceGitIgnore);\n  if (merged.contents) {\n    _fs.default.writeFileSync(targetGitIgnorePath, merged.contents);\n  }\n  return merged;\n}\nfunction getGeneratedSectionIndexes(gitIgnore) {\n  var contents = gitIgnore.split(\"\\n\");\n  var start = contents.findIndex(function (line) {\n    return line.startsWith(generatedHeaderPrefix);\n  });\n  var end = contents.findIndex(function (line) {\n    return line.startsWith(generatedFooterComment);\n  });\n  return {\n    contents: contents,\n    start: start,\n    end: end\n  };\n}\nfunction removeGeneratedGitIgnoreContents(gitIgnore) {\n  var _getGeneratedSectionI = getGeneratedSectionIndexes(gitIgnore),\n    contents = _getGeneratedSectionI.contents,\n    start = _getGeneratedSectionI.start,\n    end = _getGeneratedSectionI.end;\n  if (start > -1 && end > -1 && start < end) {\n    contents.splice(start, end - start + 1);\n    return contents.join(\"\\n\");\n  }\n  return null;\n}\nfunction mergeGitIgnoreContents(targetGitIgnore, sourceGitIgnore) {\n  var header = createGeneratedHeaderComment(sourceGitIgnore);\n  if (!targetGitIgnore.includes(header)) {\n    var sanitizedTarget = removeGeneratedGitIgnoreContents(targetGitIgnore);\n    return {\n      contents: [sanitizedTarget != null ? sanitizedTarget : targetGitIgnore, header, `# The following patterns were generated by expo-cli`, ``, sourceGitIgnore, generatedFooterComment].join(\"\\n\"),\n      didMerge: true,\n      didClear: !!sanitizedTarget\n    };\n  }\n  return {\n    contents: targetGitIgnore,\n    didClear: false,\n    didMerge: false\n  };\n}\nfunction upsertGitIgnoreContents(targetGitIgnorePath, contents) {\n  var targetGitIgnore = _fs.default.readFileSync(targetGitIgnorePath, {\n    encoding: \"utf-8\",\n    flag: \"a+\"\n  });\n  if (targetGitIgnore.match(new RegExp(`^${contents}[\\\\n\\\\r\\\\s]*$`, \"m\"))) {\n    return null;\n  }\n  if (targetGitIgnore.includes(generatedHeaderPrefix)) {\n    var indexes = getGeneratedSectionIndexes(targetGitIgnore);\n    contents = `${indexes.contents.slice(indexes.start + 3, indexes.end).join(\"\\n\")}\\n${contents}`;\n  }\n  var merged = mergeGitIgnoreContents(targetGitIgnore, contents);\n  if (merged.contents) {\n    _fs.default.writeFileSync(targetGitIgnorePath, merged.contents);\n  }\n  return merged;\n}\nfunction createGeneratedHeaderComment(gitIgnore) {\n  var hashKey = createGitIgnoreHash(getSanitizedGitIgnoreLines(gitIgnore).join(\"\\n\"));\n  return `${generatedHeaderPrefix} ${hashKey}`;\n}\nfunction getSanitizedGitIgnoreLines(gitIgnore) {\n  return gitIgnore.split(\"\\n\").filter(function (v) {\n    var line = v.trim();\n    if (line.startsWith(\"#\")) {\n      return false;\n    }\n    return !!line;\n  }).sort();\n}\nfunction createGitIgnoreHash(gitIgnore) {\n  var hash = _crypto.default.createHash(\"sha1\").update(gitIgnore).digest(\"hex\");\n  return `sync-${hash}`;\n}\nfunction removeFromGitIgnore(targetGitIgnorePath, contents) {\n  try {\n    if (!_fs.default.existsSync(targetGitIgnorePath)) {\n      return;\n    }\n    var targetGitIgnore = _fs.default.readFileSync(targetGitIgnorePath, \"utf-8\");\n    if (!targetGitIgnore.includes(contents)) {\n      return null;\n    }\n    targetGitIgnore = targetGitIgnore.replace(`${contents}\\n`, \"\");\n    var indexes = getGeneratedSectionIndexes(targetGitIgnore);\n    if (indexes.start === indexes.end - 3) {\n      targetGitIgnore = targetGitIgnore.replace(new RegExp(`^${generatedHeaderPrefix}((.|\\n)*)${generatedFooterComment}$`, \"m\"), \"\");\n    }\n    return _fs.default.writeFileSync(targetGitIgnorePath, targetGitIgnore);\n  } catch (error) {\n    _log.Log.error(`Failed to read/write to .gitignore path: ${targetGitIgnorePath}`);\n    throw error;\n  }\n}","map":{"version":3,"names":["mergeGitIgnorePaths","removeGeneratedGitIgnoreContents","mergeGitIgnoreContents","upsertGitIgnoreContents","createGeneratedHeaderComment","getSanitizedGitIgnoreLines","createGitIgnoreHash","removeFromGitIgnore","_crypto","_interopRequireDefault","require","_fs","_log","generatedHeaderPrefix","generatedFooterComment","targetGitIgnorePath","sourceGitIgnorePath","default","existsSync","targetGitIgnore","readFileSync","toString","sourceGitIgnore","merged","contents","writeFileSync","getGeneratedSectionIndexes","gitIgnore","split","start","findIndex","line","startsWith","end","_getGeneratedSectionI","splice","join","header","includes","sanitizedTarget","didMerge","didClear","encoding","flag","match","RegExp","indexes","slice","hashKey","filter","v","trim","sort","hash","createHash","update","digest","replace","error","Log"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\cli\\src\\utils\\mergeGitIgnorePaths.ts"],"sourcesContent":["import crypto from 'crypto';\nimport fs from 'fs';\n\nimport { Log } from '../log';\n\ntype MergeResults = {\n  contents: string;\n  didClear: boolean;\n  didMerge: boolean;\n};\n\nconst generatedHeaderPrefix = `# @generated expo-cli`;\nexport const generatedFooterComment = `# @end expo-cli`;\n\n/**\n * Merge two gitignore files together and add a generated header.\n *\n * @param targetGitIgnorePath\n * @param sourceGitIgnorePath\n *\n * @returns `null` if one of the gitignore files doesn't exist. Otherwise, returns the merged contents.\n */\nexport function mergeGitIgnorePaths(\n  targetGitIgnorePath: string,\n  sourceGitIgnorePath: string\n): null | MergeResults {\n  if (!fs.existsSync(targetGitIgnorePath)) {\n    // No gitignore in the project already, no need to merge anything into anything. I guess they\n    // are not using git :O\n    return null;\n  }\n\n  if (!fs.existsSync(sourceGitIgnorePath)) {\n    // Maybe we don't have a gitignore in the template project\n    return null;\n  }\n\n  const targetGitIgnore = fs.readFileSync(targetGitIgnorePath).toString();\n  const sourceGitIgnore = fs.readFileSync(sourceGitIgnorePath).toString();\n  const merged = mergeGitIgnoreContents(targetGitIgnore, sourceGitIgnore);\n  // Only rewrite the file if it was modified.\n  if (merged.contents) {\n    fs.writeFileSync(targetGitIgnorePath, merged.contents);\n  }\n\n  return merged;\n}\n\n/**\n * Get line indexes for the generated section of a gitignore.\n *\n * @param gitIgnore\n */\nfunction getGeneratedSectionIndexes(gitIgnore: string): {\n  contents: string[];\n  start: number;\n  end: number;\n} {\n  const contents = gitIgnore.split('\\n');\n  const start = contents.findIndex((line) => line.startsWith(generatedHeaderPrefix));\n  const end = contents.findIndex((line) => line.startsWith(generatedFooterComment));\n\n  return { contents, start, end };\n}\n\n/**\n * Removes the generated section from a gitignore, returns null when nothing can be removed.\n * This sways heavily towards not removing lines unless it's certain that modifications were not made to the gitignore manually.\n *\n * @param gitIgnore\n */\nexport function removeGeneratedGitIgnoreContents(gitIgnore: string): string | null {\n  const { contents, start, end } = getGeneratedSectionIndexes(gitIgnore);\n  if (start > -1 && end > -1 && start < end) {\n    contents.splice(start, end - start + 1);\n    // TODO: We could in theory check that the contents we're removing match the hash used in the header,\n    // this would ensure that we don't accidentally remove lines that someone added or removed from the generated section.\n    return contents.join('\\n');\n  }\n  return null;\n}\n\n/**\n * Merge the contents of two gitignores together and add a generated header.\n *\n * @param targetGitIgnore contents of the existing gitignore\n * @param sourceGitIgnore contents of the extra gitignore\n */\nexport function mergeGitIgnoreContents(\n  targetGitIgnore: string,\n  sourceGitIgnore: string\n): MergeResults {\n  const header = createGeneratedHeaderComment(sourceGitIgnore);\n  if (!targetGitIgnore.includes(header)) {\n    // Ensure the old generated gitignore contents are removed.\n    const sanitizedTarget = removeGeneratedGitIgnoreContents(targetGitIgnore);\n    return {\n      contents: [\n        sanitizedTarget ?? targetGitIgnore,\n        header,\n        `# The following patterns were generated by expo-cli`,\n        ``,\n        sourceGitIgnore,\n        generatedFooterComment,\n      ].join('\\n'),\n      didMerge: true,\n      didClear: !!sanitizedTarget,\n    };\n  }\n  return { contents: targetGitIgnore, didClear: false, didMerge: false };\n}\n\n/**\n * Adds the contents into an existing gitignore \"generated by expo-cli section\"\n * If no section exists, it will be created (hence the name upsert)\n */\nexport function upsertGitIgnoreContents(\n  targetGitIgnorePath: string,\n  contents: string\n): MergeResults | null {\n  const targetGitIgnore = fs.readFileSync(targetGitIgnorePath, {\n    encoding: 'utf-8',\n    flag: 'a+',\n  });\n\n  if (targetGitIgnore.match(new RegExp(`^${contents}[\\\\n\\\\r\\\\s]*$`, 'm'))) {\n    return null;\n  }\n\n  // If there is an existing section, update it with the new content\n  if (targetGitIgnore.includes(generatedHeaderPrefix)) {\n    const indexes = getGeneratedSectionIndexes(targetGitIgnore);\n\n    contents = `${indexes.contents.slice(indexes.start + 3, indexes.end).join('\\n')}\\n${contents}`;\n  }\n\n  const merged = mergeGitIgnoreContents(targetGitIgnore, contents);\n\n  if (merged.contents) {\n    fs.writeFileSync(targetGitIgnorePath, merged.contents);\n  }\n  return merged;\n}\n\nexport function createGeneratedHeaderComment(gitIgnore: string): string {\n  const hashKey = createGitIgnoreHash(getSanitizedGitIgnoreLines(gitIgnore).join('\\n'));\n\n  return `${generatedHeaderPrefix} ${hashKey}`;\n}\n\n/**\n * Normalize the contents of a gitignore to ensure that minor changes like new lines or sort order don't cause a regeneration.\n */\nexport function getSanitizedGitIgnoreLines(gitIgnore: string): string[] {\n  // filter, trim, and sort the lines.\n  return gitIgnore\n    .split('\\n')\n    .filter((v) => {\n      const line = v.trim();\n      // Strip comments\n      if (line.startsWith('#')) {\n        return false;\n      }\n      return !!line;\n    })\n    .sort();\n}\n\nexport function createGitIgnoreHash(gitIgnore: string): string {\n  // this doesn't need to be secure, the shorter the better.\n  const hash = crypto.createHash('sha1').update(gitIgnore).digest('hex');\n  return `sync-${hash}`;\n}\n\nexport function removeFromGitIgnore(targetGitIgnorePath: string, contents: string) {\n  try {\n    if (!fs.existsSync(targetGitIgnorePath)) {\n      return;\n    }\n\n    let targetGitIgnore = fs.readFileSync(targetGitIgnorePath, 'utf-8');\n\n    if (!targetGitIgnore.includes(contents)) {\n      return null;\n    }\n\n    targetGitIgnore = targetGitIgnore.replace(`${contents}\\n`, '');\n\n    const indexes = getGeneratedSectionIndexes(targetGitIgnore);\n\n    if (indexes.start === indexes.end - 3) {\n      targetGitIgnore = targetGitIgnore.replace(\n        new RegExp(`^${generatedHeaderPrefix}((.|\\n)*)${generatedFooterComment}$`, 'm'),\n        ''\n      );\n    }\n\n    return fs.writeFileSync(targetGitIgnorePath, targetGitIgnore);\n  } catch (error) {\n    Log.error(`Failed to read/write to .gitignore path: ${targetGitIgnorePath}`);\n    throw error;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}