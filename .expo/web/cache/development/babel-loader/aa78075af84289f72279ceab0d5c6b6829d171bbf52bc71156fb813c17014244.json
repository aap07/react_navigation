{"ast":null,"code":"'use strict';\nvar invariant = require('invariant');\nfunction resolveTypeAnnotation(typeAnnotation, types) {\n  invariant(typeAnnotation != null, 'resolveTypeAnnotation(): typeAnnotation cannot be null');\n  var node = typeAnnotation;\n  var nullable = false;\n  var typeResolutionStatus = {\n    successful: false\n  };\n  for (;;) {\n    if (node.type === 'NullableTypeAnnotation') {\n      nullable = true;\n      node = node.typeAnnotation;\n      continue;\n    }\n    if (node.type !== 'GenericTypeAnnotation') {\n      break;\n    }\n    var resolvedTypeAnnotation = types[node.id.name];\n    if (resolvedTypeAnnotation == null) {\n      break;\n    }\n    switch (resolvedTypeAnnotation.type) {\n      case 'TypeAlias':\n        {\n          typeResolutionStatus = {\n            successful: true,\n            type: 'alias',\n            name: node.id.name\n          };\n          node = resolvedTypeAnnotation.right;\n          break;\n        }\n      case 'EnumDeclaration':\n        {\n          typeResolutionStatus = {\n            successful: true,\n            type: 'enum',\n            name: node.id.name\n          };\n          node = resolvedTypeAnnotation.body;\n          break;\n        }\n      default:\n        {\n          throw new TypeError(`A non GenericTypeAnnotation must be a type declaration ('TypeAlias') or enum ('EnumDeclaration'). Instead, got the unsupported ${resolvedTypeAnnotation.type}.`);\n        }\n    }\n  }\n  return {\n    nullable: nullable,\n    typeAnnotation: node,\n    typeResolutionStatus: typeResolutionStatus\n  };\n}\nfunction getValueFromTypes(value, types) {\n  if (value.type === 'GenericTypeAnnotation' && types[value.id.name]) {\n    return getValueFromTypes(types[value.id.name].right, types);\n  }\n  return value;\n}\nmodule.exports = {\n  getValueFromTypes: getValueFromTypes,\n  resolveTypeAnnotation: resolveTypeAnnotation\n};","map":{"version":3,"names":["invariant","require","resolveTypeAnnotation","typeAnnotation","types","node","nullable","typeResolutionStatus","successful","type","resolvedTypeAnnotation","id","name","right","body","TypeError","getValueFromTypes","value","module","exports"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native/codegen/lib/parsers/flow/utils.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\n'use strict';\n\n// $FlowFixMe[unclear-type] there's no flowtype for ASTs\n\nconst invariant = require('invariant');\nfunction resolveTypeAnnotation(\n  // TODO(T71778680): This is an Flow TypeAnnotation. Flow-type this\n  typeAnnotation,\n  types,\n) {\n  invariant(\n    typeAnnotation != null,\n    'resolveTypeAnnotation(): typeAnnotation cannot be null',\n  );\n  let node = typeAnnotation;\n  let nullable = false;\n  let typeResolutionStatus = {\n    successful: false,\n  };\n  for (;;) {\n    if (node.type === 'NullableTypeAnnotation') {\n      nullable = true;\n      node = node.typeAnnotation;\n      continue;\n    }\n    if (node.type !== 'GenericTypeAnnotation') {\n      break;\n    }\n    const resolvedTypeAnnotation = types[node.id.name];\n    if (resolvedTypeAnnotation == null) {\n      break;\n    }\n    switch (resolvedTypeAnnotation.type) {\n      case 'TypeAlias': {\n        typeResolutionStatus = {\n          successful: true,\n          type: 'alias',\n          name: node.id.name,\n        };\n        node = resolvedTypeAnnotation.right;\n        break;\n      }\n      case 'EnumDeclaration': {\n        typeResolutionStatus = {\n          successful: true,\n          type: 'enum',\n          name: node.id.name,\n        };\n        node = resolvedTypeAnnotation.body;\n        break;\n      }\n      default: {\n        throw new TypeError(\n          `A non GenericTypeAnnotation must be a type declaration ('TypeAlias') or enum ('EnumDeclaration'). Instead, got the unsupported ${resolvedTypeAnnotation.type}.`,\n        );\n      }\n    }\n  }\n  return {\n    nullable: nullable,\n    typeAnnotation: node,\n    typeResolutionStatus,\n  };\n}\nfunction getValueFromTypes(value, types) {\n  if (value.type === 'GenericTypeAnnotation' && types[value.id.name]) {\n    return getValueFromTypes(types[value.id.name].right, types);\n  }\n  return value;\n}\nmodule.exports = {\n  getValueFromTypes,\n  resolveTypeAnnotation,\n};\n"],"mappings":"AAUA,YAAY;AAIZ,IAAMA,SAAS,GAAGC,OAAO,CAAC,WAAW,CAAC;AACtC,SAASC,qBAAqBA,CAE5BC,cAAc,EACdC,KAAK,EACL;EACAJ,SAAS,CACPG,cAAc,IAAI,IAAI,EACtB,wDACF,CAAC;EACD,IAAIE,IAAI,GAAGF,cAAc;EACzB,IAAIG,QAAQ,GAAG,KAAK;EACpB,IAAIC,oBAAoB,GAAG;IACzBC,UAAU,EAAE;EACd,CAAC;EACD,SAAS;IACP,IAAIH,IAAI,CAACI,IAAI,KAAK,wBAAwB,EAAE;MAC1CH,QAAQ,GAAG,IAAI;MACfD,IAAI,GAAGA,IAAI,CAACF,cAAc;MAC1B;IACF;IACA,IAAIE,IAAI,CAACI,IAAI,KAAK,uBAAuB,EAAE;MACzC;IACF;IACA,IAAMC,sBAAsB,GAAGN,KAAK,CAACC,IAAI,CAACM,EAAE,CAACC,IAAI,CAAC;IAClD,IAAIF,sBAAsB,IAAI,IAAI,EAAE;MAClC;IACF;IACA,QAAQA,sBAAsB,CAACD,IAAI;MACjC,KAAK,WAAW;QAAE;UAChBF,oBAAoB,GAAG;YACrBC,UAAU,EAAE,IAAI;YAChBC,IAAI,EAAE,OAAO;YACbG,IAAI,EAAEP,IAAI,CAACM,EAAE,CAACC;UAChB,CAAC;UACDP,IAAI,GAAGK,sBAAsB,CAACG,KAAK;UACnC;QACF;MACA,KAAK,iBAAiB;QAAE;UACtBN,oBAAoB,GAAG;YACrBC,UAAU,EAAE,IAAI;YAChBC,IAAI,EAAE,MAAM;YACZG,IAAI,EAAEP,IAAI,CAACM,EAAE,CAACC;UAChB,CAAC;UACDP,IAAI,GAAGK,sBAAsB,CAACI,IAAI;UAClC;QACF;MACA;QAAS;UACP,MAAM,IAAIC,SAAS,CAChB,kIAAiIL,sBAAsB,CAACD,IAAK,GAChK,CAAC;QACH;IACF;EACF;EACA,OAAO;IACLH,QAAQ,EAAEA,QAAQ;IAClBH,cAAc,EAAEE,IAAI;IACpBE,oBAAoB,EAApBA;EACF,CAAC;AACH;AACA,SAASS,iBAAiBA,CAACC,KAAK,EAAEb,KAAK,EAAE;EACvC,IAAIa,KAAK,CAACR,IAAI,KAAK,uBAAuB,IAAIL,KAAK,CAACa,KAAK,CAACN,EAAE,CAACC,IAAI,CAAC,EAAE;IAClE,OAAOI,iBAAiB,CAACZ,KAAK,CAACa,KAAK,CAACN,EAAE,CAACC,IAAI,CAAC,CAACC,KAAK,EAAET,KAAK,CAAC;EAC7D;EACA,OAAOa,KAAK;AACd;AACAC,MAAM,CAACC,OAAO,GAAG;EACfH,iBAAiB,EAAjBA,iBAAiB;EACjBd,qBAAqB,EAArBA;AACF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}