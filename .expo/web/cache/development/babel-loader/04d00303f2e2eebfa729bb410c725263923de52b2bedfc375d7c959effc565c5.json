{"ast":null,"code":"","map":{"version":3,"names":[],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@expo/cli/node_modules/type-fest/source/union-to-intersection.d.ts"],"sourcesContent":["/**\nConvert a union type to an intersection type using [distributive conditional types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#distributive-conditional-types).\n\nInspired by [this Stack Overflow answer](https://stackoverflow.com/a/50375286/2172153).\n\n@example\n```\nimport {UnionToIntersection} from 'type-fest';\n\ntype Union = {the(): void} | {great(arg: string): void} | {escape: boolean};\n\ntype Intersection = UnionToIntersection<Union>;\n//=> {the(): void; great(arg: string): void; escape: boolean};\n```\n\nA more applicable example which could make its way into your library code follows.\n\n@example\n```\nimport {UnionToIntersection} from 'type-fest';\n\nclass CommandOne {\n\tcommands: {\n\t\ta1: () => undefined,\n\t\tb1: () => undefined,\n\t}\n}\n\nclass CommandTwo {\n\tcommands: {\n\t\ta2: (argA: string) => undefined,\n\t\tb2: (argB: string) => undefined,\n\t}\n}\n\nconst union = [new CommandOne(), new CommandTwo()].map(instance => instance.commands);\ntype Union = typeof union;\n//=> {a1(): void; b1(): void} | {a2(argA: string): void; b2(argB: string): void}\n\ntype Intersection = UnionToIntersection<Union>;\n//=> {a1(): void; b1(): void; a2(argA: string): void; b2(argB: string): void}\n```\n*/\nexport type UnionToIntersection<Union> = (\n\t// `extends unknown` is always going to be the case and is used to convert the\n\t// `Union` into a [distributive conditional\n\t// type](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#distributive-conditional-types).\n\tUnion extends unknown\n\t\t// The union type is used as the only argument to a function since the union\n\t\t// of function arguments is an intersection.\n\t\t? (distributedUnion: Union) => void\n\t\t// This won't happen.\n\t\t: never\n\t\t// Infer the `Intersection` type since TypeScript represents the positional\n\t\t// arguments of unions of functions as an intersection of the union.\n\t) extends ((mergedIntersection: infer Intersection) => void)\n\t\t? Intersection\n\t\t: never;\n"],"mappings":""},"metadata":{},"sourceType":"script","externalDependencies":[]}