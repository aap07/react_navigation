{"ast":null,"code":"export {};","map":{"version":3,"names":[],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native-community/cli-doctor/node_modules/yaml/dist/parse/parser.d.ts"],"sourcesContent":["import { Token } from './cst.js';\n/**\n * A YAML concrete syntax tree (CST) parser\n *\n * ```ts\n * const src: string = ...\n * for (const token of new Parser().parse(src)) {\n *   // token: Token\n * }\n * ```\n *\n * To use the parser with a user-provided lexer:\n *\n * ```ts\n * function* parse(source: string, lexer: Lexer) {\n *   const parser = new Parser()\n *   for (const lexeme of lexer.lex(source))\n *     yield* parser.next(lexeme)\n *   yield* parser.end()\n * }\n *\n * const src: string = ...\n * const lexer = new Lexer()\n * for (const token of parse(src, lexer)) {\n *   // token: Token\n * }\n * ```\n */\nexport declare class Parser {\n    private onNewLine?;\n    /** If true, space and sequence indicators count as indentation */\n    private atNewLine;\n    /** If true, next token is a scalar value */\n    private atScalar;\n    /** Current indentation level */\n    private indent;\n    /** Current offset since the start of parsing */\n    offset: number;\n    /** On the same line with a block map key */\n    private onKeyLine;\n    /** Top indicates the node that's currently being built */\n    stack: Token[];\n    /** The source of the current token, set in parse() */\n    private source;\n    /** The type of the current token, set in parse() */\n    private type;\n    /**\n     * @param onNewLine - If defined, called separately with the start position of\n     *   each new line (in `parse()`, including the start of input).\n     */\n    constructor(onNewLine?: (offset: number) => void);\n    /**\n     * Parse `source` as a YAML stream.\n     * If `incomplete`, a part of the last line may be left as a buffer for the next call.\n     *\n     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.\n     *\n     * @returns A generator of tokens representing each directive, document, and other structure.\n     */\n    parse(source: string, incomplete?: boolean): Generator<Token, void, unknown>;\n    /**\n     * Advance the parser by the `source` of one lexical token.\n     */\n    next(source: string): Generator<Token, void, unknown>;\n    private lexer;\n    /** Call at end of input to push out any remaining constructions */\n    end(): Generator<Token, void, unknown>;\n    private get sourceToken();\n    private step;\n    private peek;\n    private pop;\n    private stream;\n    private document;\n    private scalar;\n    private blockScalar;\n    private blockMap;\n    private blockSequence;\n    private flowCollection;\n    private flowScalar;\n    private startBlockValue;\n    private atIndentedComment;\n    private documentEnd;\n    private lineEnd;\n}\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}