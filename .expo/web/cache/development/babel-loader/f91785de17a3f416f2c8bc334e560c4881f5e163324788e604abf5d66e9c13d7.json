{"ast":null,"code":"'use strict';\n\nvar FOLD_FLOW = 'flow';\nvar FOLD_BLOCK = 'block';\nvar FOLD_QUOTED = 'quoted';\nfunction foldFlowLines(text, indent) {\n  var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'flow';\n  var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n    indentAtStart = _ref.indentAtStart,\n    _ref$lineWidth = _ref.lineWidth,\n    lineWidth = _ref$lineWidth === void 0 ? 80 : _ref$lineWidth,\n    _ref$minContentWidth = _ref.minContentWidth,\n    minContentWidth = _ref$minContentWidth === void 0 ? 20 : _ref$minContentWidth,\n    onFold = _ref.onFold,\n    onOverflow = _ref.onOverflow;\n  if (!lineWidth || lineWidth < 0) return text;\n  var endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n  if (text.length <= endStep) return text;\n  var folds = [];\n  var escapedFolds = {};\n  var end = lineWidth - indent.length;\n  if (typeof indentAtStart === 'number') {\n    if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);else end = lineWidth - indentAtStart;\n  }\n  var split = undefined;\n  var prev = undefined;\n  var overflow = false;\n  var i = -1;\n  var escStart = -1;\n  var escEnd = -1;\n  if (mode === FOLD_BLOCK) {\n    i = consumeMoreIndentedLines(text, i);\n    if (i !== -1) end = i + endStep;\n  }\n  for (var ch; ch = text[i += 1];) {\n    if (mode === FOLD_QUOTED && ch === '\\\\') {\n      escStart = i;\n      switch (text[i + 1]) {\n        case 'x':\n          i += 3;\n          break;\n        case 'u':\n          i += 5;\n          break;\n        case 'U':\n          i += 9;\n          break;\n        default:\n          i += 1;\n      }\n      escEnd = i;\n    }\n    if (ch === '\\n') {\n      if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);\n      end = i + endStep;\n      split = undefined;\n    } else {\n      if (ch === ' ' && prev && prev !== ' ' && prev !== '\\n' && prev !== '\\t') {\n        var next = text[i + 1];\n        if (next && next !== ' ' && next !== '\\n' && next !== '\\t') split = i;\n      }\n      if (i >= end) {\n        if (split) {\n          folds.push(split);\n          end = split + endStep;\n          split = undefined;\n        } else if (mode === FOLD_QUOTED) {\n          while (prev === ' ' || prev === '\\t') {\n            prev = ch;\n            ch = text[i += 1];\n            overflow = true;\n          }\n          var j = i > escEnd + 1 ? i - 2 : escStart - 1;\n          if (escapedFolds[j]) return text;\n          folds.push(j);\n          escapedFolds[j] = true;\n          end = j + endStep;\n          split = undefined;\n        } else {\n          overflow = true;\n        }\n      }\n    }\n    prev = ch;\n  }\n  if (overflow && onOverflow) onOverflow();\n  if (folds.length === 0) return text;\n  if (onFold) onFold();\n  var res = text.slice(0, folds[0]);\n  for (var _i = 0; _i < folds.length; ++_i) {\n    var fold = folds[_i];\n    var _end = folds[_i + 1] || text.length;\n    if (fold === 0) res = `\\n${indent}${text.slice(0, _end)}`;else {\n      if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\\\`;\n      res += `\\n${indent}${text.slice(fold + 1, _end)}`;\n    }\n  }\n  return res;\n}\nfunction consumeMoreIndentedLines(text, i) {\n  var ch = text[i + 1];\n  while (ch === ' ' || ch === '\\t') {\n    do {\n      ch = text[i += 1];\n    } while (ch && ch !== '\\n');\n    ch = text[i + 1];\n  }\n  return i;\n}\nexports.FOLD_BLOCK = FOLD_BLOCK;\nexports.FOLD_FLOW = FOLD_FLOW;\nexports.FOLD_QUOTED = FOLD_QUOTED;\nexports.foldFlowLines = foldFlowLines;","map":{"version":3,"names":["FOLD_FLOW","FOLD_BLOCK","FOLD_QUOTED","foldFlowLines","text","indent","mode","arguments","length","undefined","_ref","indentAtStart","_ref$lineWidth","lineWidth","_ref$minContentWidth","minContentWidth","onFold","onOverflow","endStep","Math","max","folds","escapedFolds","end","push","split","prev","overflow","i","escStart","escEnd","consumeMoreIndentedLines","ch","next","j","res","slice","fold","exports"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native-community/cli-doctor/node_modules/yaml/dist/stringify/foldFlowLines.js"],"sourcesContent":["'use strict';\n\nconst FOLD_FLOW = 'flow';\nconst FOLD_BLOCK = 'block';\nconst FOLD_QUOTED = 'quoted';\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n */\nfunction foldFlowLines(text, indent, mode = 'flow', { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {\n    if (!lineWidth || lineWidth < 0)\n        return text;\n    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n    if (text.length <= endStep)\n        return text;\n    const folds = [];\n    const escapedFolds = {};\n    let end = lineWidth - indent.length;\n    if (typeof indentAtStart === 'number') {\n        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))\n            folds.push(0);\n        else\n            end = lineWidth - indentAtStart;\n    }\n    let split = undefined;\n    let prev = undefined;\n    let overflow = false;\n    let i = -1;\n    let escStart = -1;\n    let escEnd = -1;\n    if (mode === FOLD_BLOCK) {\n        i = consumeMoreIndentedLines(text, i);\n        if (i !== -1)\n            end = i + endStep;\n    }\n    for (let ch; (ch = text[(i += 1)]);) {\n        if (mode === FOLD_QUOTED && ch === '\\\\') {\n            escStart = i;\n            switch (text[i + 1]) {\n                case 'x':\n                    i += 3;\n                    break;\n                case 'u':\n                    i += 5;\n                    break;\n                case 'U':\n                    i += 9;\n                    break;\n                default:\n                    i += 1;\n            }\n            escEnd = i;\n        }\n        if (ch === '\\n') {\n            if (mode === FOLD_BLOCK)\n                i = consumeMoreIndentedLines(text, i);\n            end = i + endStep;\n            split = undefined;\n        }\n        else {\n            if (ch === ' ' &&\n                prev &&\n                prev !== ' ' &&\n                prev !== '\\n' &&\n                prev !== '\\t') {\n                // space surrounded by non-space can be replaced with newline + indent\n                const next = text[i + 1];\n                if (next && next !== ' ' && next !== '\\n' && next !== '\\t')\n                    split = i;\n            }\n            if (i >= end) {\n                if (split) {\n                    folds.push(split);\n                    end = split + endStep;\n                    split = undefined;\n                }\n                else if (mode === FOLD_QUOTED) {\n                    // white-space collected at end may stretch past lineWidth\n                    while (prev === ' ' || prev === '\\t') {\n                        prev = ch;\n                        ch = text[(i += 1)];\n                        overflow = true;\n                    }\n                    // Account for newline escape, but don't break preceding escape\n                    const j = i > escEnd + 1 ? i - 2 : escStart - 1;\n                    // Bail out if lineWidth & minContentWidth are shorter than an escape string\n                    if (escapedFolds[j])\n                        return text;\n                    folds.push(j);\n                    escapedFolds[j] = true;\n                    end = j + endStep;\n                    split = undefined;\n                }\n                else {\n                    overflow = true;\n                }\n            }\n        }\n        prev = ch;\n    }\n    if (overflow && onOverflow)\n        onOverflow();\n    if (folds.length === 0)\n        return text;\n    if (onFold)\n        onFold();\n    let res = text.slice(0, folds[0]);\n    for (let i = 0; i < folds.length; ++i) {\n        const fold = folds[i];\n        const end = folds[i + 1] || text.length;\n        if (fold === 0)\n            res = `\\n${indent}${text.slice(0, end)}`;\n        else {\n            if (mode === FOLD_QUOTED && escapedFolds[fold])\n                res += `${text[fold]}\\\\`;\n            res += `\\n${indent}${text.slice(fold + 1, end)}`;\n        }\n    }\n    return res;\n}\n/**\n * Presumes `i + 1` is at the start of a line\n * @returns index of last newline in more-indented block\n */\nfunction consumeMoreIndentedLines(text, i) {\n    let ch = text[i + 1];\n    while (ch === ' ' || ch === '\\t') {\n        do {\n            ch = text[(i += 1)];\n        } while (ch && ch !== '\\n');\n        ch = text[i + 1];\n    }\n    return i;\n}\n\nexports.FOLD_BLOCK = FOLD_BLOCK;\nexports.FOLD_FLOW = FOLD_FLOW;\nexports.FOLD_QUOTED = FOLD_QUOTED;\nexports.foldFlowLines = foldFlowLines;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}