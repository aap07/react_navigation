{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getConnectedDevicesAsync = getConnectedDevicesAsync;\nexports.runOnDevice = runOnDevice;\nvar _debug = _interopRequireDefault(require(\"debug\"));\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _log = require(\"../../../log\");\nvar _xcodeDeveloperDiskImagePrerequisite = require(\"../../../start/doctor/apple/XcodeDeveloperDiskImagePrerequisite\");\nvar _xcrun = require(\"../../../start/platforms/ios/xcrun\");\nvar _delay = require(\"../../../utils/delay\");\nvar _errors = require(\"../../../utils/errors\");\nvar _exit = require(\"../../../utils/exit\");\nvar _clientManager = require(\"./ClientManager\");\nvar _lockdowndClient = require(\"./client/LockdowndClient\");\nvar _usbmuxdClient = require(\"./client/UsbmuxdClient\");\nvar _afcprotocol = require(\"./protocol/AFCProtocol\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar debug = (0, _debug).default(\"expo:apple-device\");\nfunction getConnectedDevicesAsync() {\n  return _getConnectedDevicesAsync.apply(this, arguments);\n}\nfunction _getConnectedDevicesAsync() {\n  _getConnectedDevicesAsync = _asyncToGenerator(function* () {\n    var client = new _usbmuxdClient.UsbmuxdClient(_usbmuxdClient.UsbmuxdClient.connectUsbmuxdSocket());\n    var devices = yield client.getDevices();\n    client.socket.end();\n    return Promise.all(devices.map(function () {\n      var _ref5 = _asyncToGenerator(function* (device) {\n        var socket = yield new _usbmuxdClient.UsbmuxdClient(_usbmuxdClient.UsbmuxdClient.connectUsbmuxdSocket()).connect(device, 62078);\n        var deviceValues = yield new _lockdowndClient.LockdowndClient(socket).getAllValues();\n        socket.end();\n        var _DeviceName, ref;\n        return {\n          name: (ref = (_DeviceName = deviceValues.DeviceName) != null ? _DeviceName : deviceValues.ProductType) != null ? ref : \"unknown iOS device\",\n          model: deviceValues.ProductType,\n          osVersion: deviceValues.ProductVersion,\n          deviceType: \"device\",\n          connectionType: device.Properties.ConnectionType,\n          udid: device.Properties.SerialNumber\n        };\n      });\n      return function (_x11) {\n        return _ref5.apply(this, arguments);\n      };\n    }()));\n  });\n  return _getConnectedDevicesAsync.apply(this, arguments);\n}\nfunction runOnDevice(_x) {\n  return _runOnDevice.apply(this, arguments);\n}\nfunction _runOnDevice() {\n  _runOnDevice = _asyncToGenerator(function* (_ref) {\n    var udid = _ref.udid,\n      appPath = _ref.appPath,\n      bundleId = _ref.bundleId,\n      waitForApp = _ref.waitForApp,\n      deltaPath = _ref.deltaPath,\n      onProgress = _ref.onProgress;\n    var clientManager = yield _clientManager.ClientManager.create(udid);\n    try {\n      yield mountDeveloperDiskImage(clientManager);\n      var packageName = _path.default.basename(appPath);\n      var destPackagePath = _path.default.join(\"PublicStaging\", packageName);\n      yield uploadApp(clientManager, {\n        appBinaryPath: appPath,\n        destinationPath: destPackagePath\n      });\n      var installer = yield clientManager.getInstallationProxyClient();\n      yield installer.installApp(destPackagePath, bundleId, {\n        ApplicationsType: \"Any\",\n        CFBundleIdentifier: bundleId,\n        CloseOnInvalidate: \"1\",\n        InvalidateOnDetach: \"1\",\n        IsUserInitiated: \"1\",\n        PreferWifi: \"0\",\n        PackageType: \"Developer\",\n        ShadowParentKey: deltaPath\n      }, onProgress);\n      var _yield$installer$look = yield installer.lookupApp([bundleId]),\n        appInfo = _yield$installer$look[bundleId];\n      if (appInfo) {\n        yield (0, _delay).delayAsync(200);\n        var debugServerClient = yield launchApp(clientManager, {\n          bundleId: bundleId,\n          appInfo: appInfo,\n          detach: !waitForApp\n        });\n        if (waitForApp && debugServerClient) {\n          (0, _exit).installExitHooks(_asyncToGenerator(function* () {\n            debugServerClient.halt();\n            yield (0, _delay).delayAsync(64);\n          }));\n          debug(`Waiting for app to close...\\n`);\n          var result = yield debugServerClient.continue();\n          if (result !== \"W00\") {\n            yield debugServerClient.kill();\n          }\n        }\n      } else {\n        _log.Log.warn(`App \"${bundleId}\" installed but couldn't be launched. Open on device manually.`);\n      }\n    } finally {\n      clientManager.end();\n    }\n  });\n  return _runOnDevice.apply(this, arguments);\n}\nfunction mountDeveloperDiskImage(_x2) {\n  return _mountDeveloperDiskImage.apply(this, arguments);\n}\nfunction _mountDeveloperDiskImage() {\n  _mountDeveloperDiskImage = _asyncToGenerator(function* (clientManager) {\n    var imageMounter = yield clientManager.getMobileImageMounterClient();\n    if (!(yield imageMounter.lookupImage()).ImageSignature) {\n      var version = yield (yield clientManager.getLockdowndClient()).getValue(\"ProductVersion\");\n      var developerDiskImagePath = yield _xcodeDeveloperDiskImagePrerequisite.XcodeDeveloperDiskImagePrerequisite.instance.assertAsync({\n        version: version\n      });\n      var developerDiskImageSig = _fs.default.readFileSync(`${developerDiskImagePath}.signature`);\n      yield imageMounter.uploadImage(developerDiskImagePath, developerDiskImageSig);\n      yield imageMounter.mountImage(developerDiskImagePath, developerDiskImageSig);\n    }\n  });\n  return _mountDeveloperDiskImage.apply(this, arguments);\n}\nfunction uploadApp(_x3, _x4) {\n  return _uploadApp.apply(this, arguments);\n}\nfunction _uploadApp() {\n  _uploadApp = _asyncToGenerator(function* (clientManager, _ref2) {\n    var appBinaryPath = _ref2.appBinaryPath,\n      destinationPath = _ref2.destinationPath;\n    var afcClient = yield clientManager.getAFCClient();\n    try {\n      yield afcClient.getFileInfo(\"PublicStaging\");\n    } catch (err) {\n      if (err instanceof _afcprotocol.AFCError && err.status === _afcprotocol.AFC_STATUS.OBJECT_NOT_FOUND) {\n        yield afcClient.makeDirectory(\"PublicStaging\");\n      } else {\n        throw err;\n      }\n    }\n    yield afcClient.uploadDirectory(appBinaryPath, destinationPath);\n  });\n  return _uploadApp.apply(this, arguments);\n}\nfunction launchAppWithUsbmux(_x5, _x6) {\n  return _launchAppWithUsbmux.apply(this, arguments);\n}\nfunction _launchAppWithUsbmux() {\n  _launchAppWithUsbmux = _asyncToGenerator(function* (clientManager, _ref3) {\n    var appInfo = _ref3.appInfo,\n      detach = _ref3.detach;\n    var tries = 0;\n    while (tries < 3) {\n      var debugServerClient = yield clientManager.getDebugserverClient();\n      yield debugServerClient.setMaxPacketSize(1024);\n      yield debugServerClient.setWorkingDir(appInfo.Container);\n      yield debugServerClient.launchApp(appInfo.Path, appInfo.CFBundleExecutable);\n      var result = yield debugServerClient.checkLaunchSuccess();\n      if (result === \"OK\") {\n        if (detach) {\n          var res = yield debugServerClient.sendCommand(\"D\", []);\n          debug(\"Disconnect from debug server request:\", res);\n          if (res !== \"OK\") {\n            console.warn(\"Something went wrong while attempting to disconnect from iOS debug server, you may need to reopen the app manually.\");\n          }\n        }\n        return debugServerClient;\n      } else if (result === \"EBusy\" || result === \"ENotFound\") {\n        debug(\"Device busy or app not found, trying to launch again in .5s...\");\n        tries++;\n        debugServerClient.socket.end();\n        yield (0, _delay).delayAsync(500);\n      } else {\n        throw new _errors.CommandError(`There was an error launching app: ${result}`);\n      }\n    }\n    throw new _errors.CommandError(\"Unable to launch app, number of tries exceeded\");\n  });\n  return _launchAppWithUsbmux.apply(this, arguments);\n}\nfunction launchAppWithDeviceCtl(_x7, _x8) {\n  return _launchAppWithDeviceCtl.apply(this, arguments);\n}\nfunction _launchAppWithDeviceCtl() {\n  _launchAppWithDeviceCtl = _asyncToGenerator(function* (deviceId, bundleId) {\n    yield (0, _xcrun).xcrunAsync([\"devicectl\", \"device\", \"process\", \"launch\", \"--device\", deviceId, bundleId]);\n  });\n  return _launchAppWithDeviceCtl.apply(this, arguments);\n}\nfunction launchApp(_x9, _x10) {\n  return _launchApp.apply(this, arguments);\n}\nfunction _launchApp() {\n  _launchApp = _asyncToGenerator(function* (clientManager, _ref4) {\n    var bundleId = _ref4.bundleId,\n      appInfo = _ref4.appInfo,\n      detach = _ref4.detach;\n    try {\n      return yield launchAppWithUsbmux(clientManager, {\n        appInfo: appInfo,\n        detach: detach\n      });\n    } catch (error) {\n      debug(\"Failed to launch app with Usbmuxd, falling back to xcrun...\", error);\n      var deviceId = clientManager.device.Properties.SerialNumber;\n      clientManager.end();\n      return yield launchAppWithDeviceCtl(deviceId, bundleId);\n    }\n  });\n  return _launchApp.apply(this, arguments);\n}","map":{"version":3,"names":["_asyncToGenerator","require","getConnectedDevicesAsync","runOnDevice","_debug","_interopRequireDefault","_fs","_path","_log","_xcodeDeveloperDiskImagePrerequisite","_xcrun","_delay","_errors","_exit","_clientManager","_lockdowndClient","_usbmuxdClient","_afcprotocol","debug","default","_getConnectedDevicesAsync","apply","arguments","client","UsbmuxdClient","connectUsbmuxdSocket","devices","getDevices","socket","end","Promise","all","map","_ref5","device","connect","deviceValues","LockdowndClient","getAllValues","_DeviceName","ref","name","DeviceName","ProductType","model","osVersion","ProductVersion","deviceType","connectionType","Properties","ConnectionType","udid","SerialNumber","_x11","_x","_runOnDevice","_ref","appPath","bundleId","waitForApp","deltaPath","onProgress","clientManager","ClientManager","create","mountDeveloperDiskImage","packageName","basename","destPackagePath","join","uploadApp","appBinaryPath","destinationPath","installer","getInstallationProxyClient","installApp","ApplicationsType","CFBundleIdentifier","CloseOnInvalidate","InvalidateOnDetach","IsUserInitiated","PreferWifi","PackageType","ShadowParentKey","_yield$installer$look","lookupApp","appInfo","delayAsync","debugServerClient","launchApp","detach","installExitHooks","halt","result","continue","kill","Log","warn","_x2","_mountDeveloperDiskImage","imageMounter","getMobileImageMounterClient","lookupImage","ImageSignature","version","getLockdowndClient","getValue","developerDiskImagePath","XcodeDeveloperDiskImagePrerequisite","instance","assertAsync","developerDiskImageSig","readFileSync","uploadImage","mountImage","_x3","_x4","_uploadApp","_ref2","afcClient","getAFCClient","getFileInfo","err","AFCError","status","AFC_STATUS","OBJECT_NOT_FOUND","makeDirectory","uploadDirectory","launchAppWithUsbmux","_x5","_x6","_launchAppWithUsbmux","_ref3","tries","getDebugserverClient","setMaxPacketSize","setWorkingDir","Container","Path","CFBundleExecutable","checkLaunchSuccess","res","sendCommand","console","CommandError","launchAppWithDeviceCtl","_x7","_x8","_launchAppWithDeviceCtl","deviceId","xcrunAsync","_x9","_x10","_launchApp","_ref4","error"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\cli\\src\\run\\ios\\appleDevice\\AppleDevice.ts"],"sourcesContent":["import Debug from 'debug';\nimport fs from 'fs';\nimport path from 'path';\n\nimport { Log } from '../../../log';\nimport { XcodeDeveloperDiskImagePrerequisite } from '../../../start/doctor/apple/XcodeDeveloperDiskImagePrerequisite';\nimport { xcrunAsync } from '../../../start/platforms/ios/xcrun';\nimport { delayAsync } from '../../../utils/delay';\nimport { CommandError } from '../../../utils/errors';\nimport { installExitHooks } from '../../../utils/exit';\nimport { ClientManager } from './ClientManager';\nimport { IPLookupResult, OnInstallProgressCallback } from './client/InstallationProxyClient';\nimport { LockdowndClient } from './client/LockdowndClient';\nimport { UsbmuxdClient } from './client/UsbmuxdClient';\nimport { AFC_STATUS, AFCError } from './protocol/AFCProtocol';\n\nconst debug = Debug('expo:apple-device');\n\n// NOTE(EvanBacon): I have a feeling this shape will change with new iOS versions (tested against iOS 15).\nexport interface ConnectedDevice {\n  /** @example `00008101-001964A22629003A` */\n  udid: string;\n  /** @example `Evan's phone` */\n  name: string;\n  /** @example `iPhone13,4` */\n  model: string;\n  /** @example `device` */\n  deviceType: 'device' | 'catalyst';\n  /** @example `USB` */\n  connectionType: 'USB' | 'Network';\n  /** @example `15.4.1` */\n  osVersion: string;\n}\n\n/** @returns a list of connected Apple devices. */\nexport async function getConnectedDevicesAsync(): Promise<ConnectedDevice[]> {\n  const client = new UsbmuxdClient(UsbmuxdClient.connectUsbmuxdSocket());\n  const devices = await client.getDevices();\n  client.socket.end();\n\n  return Promise.all(\n    devices.map(async (device): Promise<ConnectedDevice> => {\n      const socket = await new UsbmuxdClient(UsbmuxdClient.connectUsbmuxdSocket()).connect(\n        device,\n        62078\n      );\n      const deviceValues = await new LockdowndClient(socket).getAllValues();\n      socket.end();\n      // TODO(EvanBacon): Add support for osType (ipad, watchos, etc)\n      return {\n        // TODO(EvanBacon): Better name\n        name: deviceValues.DeviceName ?? deviceValues.ProductType ?? 'unknown iOS device',\n        model: deviceValues.ProductType,\n        osVersion: deviceValues.ProductVersion,\n        deviceType: 'device',\n        connectionType: device.Properties.ConnectionType,\n        udid: device.Properties.SerialNumber,\n      };\n    })\n  );\n}\n\n/** Install and run an Apple app binary on a connected Apple device. */\nexport async function runOnDevice({\n  udid,\n  appPath,\n  bundleId,\n  waitForApp,\n  deltaPath,\n  onProgress,\n}: {\n  /** Apple device UDID */\n  udid: string;\n  /** File path to the app binary (ipa) */\n  appPath: string;\n  /** Bundle identifier for the app at `appPath` */\n  bundleId: string;\n  /** Wait for the app to launch before returning */\n  waitForApp: boolean;\n  /** File path to the app deltas folder to use for faster subsequent installs */\n  deltaPath: string;\n  /** Callback to be called with progress updates */\n  onProgress: OnInstallProgressCallback;\n}) {\n  const clientManager = await ClientManager.create(udid);\n\n  try {\n    await mountDeveloperDiskImage(clientManager);\n\n    const packageName = path.basename(appPath);\n    const destPackagePath = path.join('PublicStaging', packageName);\n\n    await uploadApp(clientManager, { appBinaryPath: appPath, destinationPath: destPackagePath });\n\n    const installer = await clientManager.getInstallationProxyClient();\n    await installer.installApp(\n      destPackagePath,\n      bundleId,\n      {\n        // https://github.com/ios-control/ios-deploy/blob/0f2ffb1e564aa67a2dfca7cdf13de47ce489d835/src/ios-deploy/ios-deploy.m#L2491-L2508\n        ApplicationsType: 'Any',\n\n        CFBundleIdentifier: bundleId,\n        CloseOnInvalidate: '1',\n        InvalidateOnDetach: '1',\n        IsUserInitiated: '1',\n        // Disable checking for wifi devices, this is nominally faster.\n        PreferWifi: '0',\n        // Only info I could find on these:\n        // https://github.com/wwxxyx/Quectel_BG96/blob/310876f90fc1093a59e45e381160eddcc31697d0/Apple_Homekit/homekit_certification_tools/ATS%206/ATS%206/ATS.app/Contents/Frameworks/CaptureKit.framework/Versions/A/Resources/MobileDevice/MobileInstallation.h#L112-L121\n        PackageType: 'Developer',\n        ShadowParentKey: deltaPath,\n        // SkipUninstall: '1'\n      },\n      onProgress\n    );\n\n    const {\n      // TODO(EvanBacon): This can be undefined when querying App Clips.\n      [bundleId]: appInfo,\n    } = await installer.lookupApp([bundleId]);\n\n    if (appInfo) {\n      // launch fails with EBusy or ENotFound if you try to launch immediately after install\n      await delayAsync(200);\n      const debugServerClient = await launchApp(clientManager, {\n        bundleId,\n        appInfo,\n        detach: !waitForApp,\n      });\n\n      if (waitForApp && debugServerClient) {\n        installExitHooks(async () => {\n          // causes continue() to return\n          debugServerClient.halt();\n          // give continue() time to return response\n          await delayAsync(64);\n        });\n\n        debug(`Waiting for app to close...\\n`);\n        const result = await debugServerClient.continue();\n        // TODO: I have no idea what this packet means yet (successful close?)\n        // if not a close (ie, most likely due to halt from onBeforeExit), then kill the app\n        if (result !== 'W00') {\n          await debugServerClient.kill();\n        }\n      }\n    } else {\n      Log.warn(`App \"${bundleId}\" installed but couldn't be launched. Open on device manually.`);\n    }\n  } finally {\n    clientManager.end();\n  }\n}\n\n/** Mount the developer disk image for Xcode. */\nasync function mountDeveloperDiskImage(clientManager: ClientManager) {\n  const imageMounter = await clientManager.getMobileImageMounterClient();\n  // Check if already mounted. If not, mount.\n  if (!(await imageMounter.lookupImage()).ImageSignature) {\n    // verify DeveloperDiskImage exists (TODO: how does this work on Windows/Linux?)\n    // TODO: if windows/linux, download?\n    const version = await (await clientManager.getLockdowndClient()).getValue('ProductVersion');\n    const developerDiskImagePath = await XcodeDeveloperDiskImagePrerequisite.instance.assertAsync({\n      version,\n    });\n    const developerDiskImageSig = fs.readFileSync(`${developerDiskImagePath}.signature`);\n    await imageMounter.uploadImage(developerDiskImagePath, developerDiskImageSig);\n    await imageMounter.mountImage(developerDiskImagePath, developerDiskImageSig);\n  }\n}\n\nasync function uploadApp(\n  clientManager: ClientManager,\n  { appBinaryPath, destinationPath }: { appBinaryPath: string; destinationPath: string }\n) {\n  const afcClient = await clientManager.getAFCClient();\n  try {\n    await afcClient.getFileInfo('PublicStaging');\n  } catch (err: any) {\n    if (err instanceof AFCError && err.status === AFC_STATUS.OBJECT_NOT_FOUND) {\n      await afcClient.makeDirectory('PublicStaging');\n    } else {\n      throw err;\n    }\n  }\n  await afcClient.uploadDirectory(appBinaryPath, destinationPath);\n}\n\nasync function launchAppWithUsbmux(\n  clientManager: ClientManager,\n  { appInfo, detach }: { appInfo: IPLookupResult[string]; detach?: boolean }\n) {\n  let tries = 0;\n  while (tries < 3) {\n    const debugServerClient = await clientManager.getDebugserverClient();\n    await debugServerClient.setMaxPacketSize(1024);\n    await debugServerClient.setWorkingDir(appInfo.Container);\n    await debugServerClient.launchApp(appInfo.Path, appInfo.CFBundleExecutable);\n\n    const result = await debugServerClient.checkLaunchSuccess();\n    if (result === 'OK') {\n      if (detach) {\n        // https://github.com/libimobiledevice/libimobiledevice/blob/25059d4c7d75e03aab516af2929d7c6e6d4c17de/tools/idevicedebug.c#L455-L464\n        const res = await debugServerClient.sendCommand('D', []);\n        debug('Disconnect from debug server request:', res);\n        if (res !== 'OK') {\n          console.warn(\n            'Something went wrong while attempting to disconnect from iOS debug server, you may need to reopen the app manually.'\n          );\n        }\n      }\n\n      return debugServerClient;\n    } else if (result === 'EBusy' || result === 'ENotFound') {\n      debug('Device busy or app not found, trying to launch again in .5s...');\n      tries++;\n      debugServerClient.socket.end();\n      await delayAsync(500);\n    } else {\n      throw new CommandError(`There was an error launching app: ${result}`);\n    }\n  }\n  throw new CommandError('Unable to launch app, number of tries exceeded');\n}\n\nasync function launchAppWithDeviceCtl(deviceId: string, bundleId: string) {\n  await xcrunAsync(['devicectl', 'device', 'process', 'launch', '--device', deviceId, bundleId]);\n}\n\n/**\n * iOS 17 introduces a new protocol called RemoteXPC.\n * This is not yet implemented, so we fallback to devicectl.\n *\n * @see https://github.com/doronz88/pymobiledevice3/blob/master/misc/RemoteXPC.md#process-remoted\n */\nasync function launchApp(\n  clientManager: ClientManager,\n  {\n    bundleId,\n    appInfo,\n    detach,\n  }: { bundleId: string; appInfo: IPLookupResult[string]; detach?: boolean }\n) {\n  try {\n    return await launchAppWithUsbmux(clientManager, { appInfo, detach });\n  } catch (error) {\n    debug('Failed to launch app with Usbmuxd, falling back to xcrun...', error);\n\n    // Get the device UDID and close the connection, to allow `xcrun devicectl` to connect\n    const deviceId = clientManager.device.Properties.SerialNumber;\n    clientManager.end();\n\n    // Fallback to devicectl for iOS 17 support\n    return await launchAppWithDeviceCtl(deviceId, bundleId);\n  }\n}\n"],"mappings":"AAAA;;AAAA,IAAAA,iBAAA,GAAAC,OAAA;;;;QAmCsBC,wBAAwB,GAAxBA,wBAAwB;QA4BxBC,WAAW,GAAXA,WAAW;AA/Df,IAAAC,MAAO,GAAAC,sBAAA,CAAAJ,OAAA,CAAP,OAAO;AACV,IAAAK,GAAI,GAAAD,sBAAA,CAAAJ,OAAA,CAAJ,IAAI;AACF,IAAAM,KAAM,GAAAF,sBAAA,CAAAJ,OAAA,CAAN,MAAM;AAEH,IAAAO,IAAc,GAAAP,OAAA;AACkB,IAAAQ,oCAAiE,GAAAR,OAAA;AAC1F,IAAAS,MAAoC,GAAAT,OAAA;AACpC,IAAAU,MAAsB,GAAAV,OAAA;AACpB,IAAAW,OAAuB,GAAAX,OAAA;AACnB,IAAAY,KAAqB,GAAAZ,OAAA;AACxB,IAAAa,cAAiB,GAAAb,OAAA;AAEf,IAAAc,gBAA0B,GAAAd,OAAA;AAC5B,IAAAe,cAAwB,GAAAf,OAAA;AACjB,IAAAgB,YAAwB,GAAAhB,OAAA;;;;;;AAE7D,IAAMiB,KAAK,GAAG,IAAAd,MAAK,EAAqBe,OAArB,CAAC,mBAAmB,CAAC;AAAC,SAmBnBjB,wBAAwBA,CAAA;EAAA,OAAAkB,yBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAF,0BAAA;EAAAA,yBAAA,GAAApB,iBAAA,CAAvC,aAAsE;IAC3E,IAAMuB,MAAM,GAAG,IAAIP,cAAa,CAAAQ,aAAA,CAACR,cAAa,CAAAQ,aAAA,CAACC,oBAAoB,EAAE,CAAC;IACtE,IAAMC,OAAO,SAASH,MAAM,CAACI,UAAU,EAAE;IACzCJ,MAAM,CAACK,MAAM,CAACC,GAAG,EAAE;IAEnB,OAAOC,OAAO,CAACC,GAAG,CAChBL,OAAO,CAACM,GAAG;MAAA,IAAAC,KAAA,GAAAjC,iBAAA,CAAC,WAAOkC,MAAM,EAA+B;QACtD,IAAMN,MAAM,SAAS,IAAIZ,cAAa,CAAAQ,aAAA,CAACR,cAAa,CAAAQ,aAAA,CAACC,oBAAoB,EAAE,CAAC,CAACU,OAAO,CAClFD,MAAM,EACN,KAAK,CACN;QACD,IAAME,YAAY,SAAS,IAAIrB,gBAAe,CAAAsB,eAAA,CAACT,MAAM,CAAC,CAACU,YAAY,EAAE;QACrEV,MAAM,CAACC,GAAG,EAAE;YAIJU,WAAuB,EAAvBC,GAAmD;QAF3D,OAAO;UAELC,IAAI,EAAE,CAAAD,GAAmD,GAAnD,CAAAD,WAAuB,GAAvBH,YAAY,CAACM,UAAU,YAAvBH,WAAuB,GAAIH,YAAY,CAACO,WAAW,YAAnDH,GAAmD,GAAI,oBAAoB;UACjFI,KAAK,EAAER,YAAY,CAACO,WAAW;UAC/BE,SAAS,EAAET,YAAY,CAACU,cAAc;UACtCC,UAAU,EAAE,QAAQ;UACpBC,cAAc,EAAEd,MAAM,CAACe,UAAU,CAACC,cAAc;UAChDC,IAAI,EAAEjB,MAAM,CAACe,UAAU,CAACG;SACzB;OACF;MAAA,iBAAAC,IAAA;QAAA,OAAApB,KAAA,CAAAZ,KAAA,OAAAC,SAAA;MAAA;IAAA,IAAC,CACH;GACF;EAAA,OAAAF,yBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAGqBnB,WAAWA,CAAAmD,EAAA;EAAA,OAAAC,YAAA,CAAAlC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAiC,aAAA;EAAAA,YAAA,GAAAvD,iBAAA,CAA1B,WAAAwD,IAAA,EAoBJ;IAAA,IAnBDL,IAAI,GAAAK,IAAA,CAAJL,IAAI;MACJM,OAAO,GAAAD,IAAA,CAAPC,OAAO;MACPC,QAAQ,GAAAF,IAAA,CAARE,QAAQ;MACRC,UAAU,GAAAH,IAAA,CAAVG,UAAU;MACVC,SAAS,GAAAJ,IAAA,CAATI,SAAS;MACTC,UAAU,GAAAL,IAAA,CAAVK,UAAU;IAeV,IAAMC,aAAa,SAAShD,cAAa,CAAAiD,aAAA,CAACC,MAAM,CAACb,IAAI,CAAC;IAEtD,IAAI;MACF,MAAMc,uBAAuB,CAACH,aAAa,CAAC;MAE5C,IAAMI,WAAW,GAAG3D,KAAI,CAAAY,OAAA,CAACgD,QAAQ,CAACV,OAAO,CAAC;MAC1C,IAAMW,eAAe,GAAG7D,KAAI,CAAAY,OAAA,CAACkD,IAAI,CAAC,eAAe,EAAEH,WAAW,CAAC;MAE/D,MAAMI,SAAS,CAACR,aAAa,EAAE;QAAES,aAAa,EAAEd,OAAO;QAAEe,eAAe,EAAEJ;OAAiB,CAAC;MAE5F,IAAMK,SAAS,SAASX,aAAa,CAACY,0BAA0B,EAAE;MAClE,MAAMD,SAAS,CAACE,UAAU,CACxBP,eAAe,EACfV,QAAQ,EACR;QAEEkB,gBAAgB,EAAE,KAAK;QAEvBC,kBAAkB,EAAEnB,QAAQ;QAC5BoB,iBAAiB,EAAE,GAAG;QACtBC,kBAAkB,EAAE,GAAG;QACvBC,eAAe,EAAE,GAAG;QAEpBC,UAAU,EAAE,GAAG;QAGfC,WAAW,EAAE,WAAW;QACxBC,eAAe,EAAEvB;OAElB,EACDC,UAAU,CACX;MAED,IAAAuB,qBAAA,SAGUX,SAAS,CAACY,SAAS,CAAC,CAAC3B,QAAQ,CAAC,CAAC;QAD3B4B,OAAO,GAAAF,qBAAA,CAAlB1B,QAAQ;MAGX,IAAI4B,OAAO,EAAE;QAEX,MAAM,IAAA3E,MAAU,EAAK4E,UAAL,CAAC,GAAG,CAAC;QACrB,IAAMC,iBAAiB,SAASC,SAAS,CAAC3B,aAAa,EAAE;UACvDJ,QAAQ,EAARA,QAAQ;UACR4B,OAAO,EAAPA,OAAO;UACPI,MAAM,EAAE,CAAC/B;SACV,CAAC;QAEF,IAAIA,UAAU,IAAI6B,iBAAiB,EAAE;UACnC,IAAA3E,KAAgB,EAKd8E,gBALc,CAAA3F,iBAAA,CAAC,aAAY;YAE3BwF,iBAAiB,CAACI,IAAI,EAAE;YAExB,MAAM,IAAAjF,MAAU,EAAI4E,UAAJ,CAAC,EAAE,CAAC;WACrB,EAAC;UAEFrE,KAAK,CAAE,+BAA8B,CAAC;UACtC,IAAM2E,MAAM,SAASL,iBAAiB,CAACM,QAAQ,EAAE;UAGjD,IAAID,MAAM,KAAK,KAAK,EAAE;YACpB,MAAML,iBAAiB,CAACO,IAAI,EAAE;;;OAGnC,MAAM;QACLvF,IAAG,CAAAwF,GAAA,CAACC,IAAI,CAAE,QAAOvC,QAAS,gEAA+D,CAAC;;KAE7F,SAAS;MACRI,aAAa,CAACjC,GAAG,EAAE;;GAEtB;EAAA,OAAA0B,YAAA,CAAAlC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAGc2C,uBAAuBA,CAAAiC,GAAA;EAAA,OAAAC,wBAAA,CAAA9E,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAA6E,yBAAA;EAAAA,wBAAA,GAAAnG,iBAAA,CAAtC,WAAuC8D,aAA4B,EAAE;IACnE,IAAMsC,YAAY,SAAStC,aAAa,CAACuC,2BAA2B,EAAE;IAEtE,IAAI,CAAC,OAAOD,YAAY,CAACE,WAAW,EAAE,EAAEC,cAAc,EAAE;MAGtD,IAAMC,OAAO,SAAS,OAAO1C,aAAa,CAAC2C,kBAAkB,EAAE,EAAEC,QAAQ,CAAC,gBAAgB,CAAC;MAC3F,IAAMC,sBAAsB,SAASlG,oCAAmC,CAAAmG,mCAAA,CAACC,QAAQ,CAACC,WAAW,CAAC;QAC5FN,OAAO,EAAPA;OACD,CAAC;MACF,IAAMO,qBAAqB,GAAGzG,GAAE,CAAAa,OAAA,CAAC6F,YAAY,CAAE,GAAEL,sBAAuB,YAAW,CAAC;MACpF,MAAMP,YAAY,CAACa,WAAW,CAACN,sBAAsB,EAAEI,qBAAqB,CAAC;MAC7E,MAAMX,YAAY,CAACc,UAAU,CAACP,sBAAsB,EAAEI,qBAAqB,CAAC;;GAE/E;EAAA,OAAAZ,wBAAA,CAAA9E,KAAA,OAAAC,SAAA;AAAA;AAAA,SAEcgD,SAASA,CAAA6C,GAAA,EAAAC,GAAA;EAAA,OAAAC,UAAA,CAAAhG,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAA+F,WAAA;EAAAA,UAAA,GAAArH,iBAAA,CAAxB,WACE8D,aAA4B,EAAAwD,KAAA,EAE5B;IAAA,IADE/C,aAAa,GAAA+C,KAAA,CAAb/C,aAAa;MAAEC,eAAe,GAAA8C,KAAA,CAAf9C,eAAe;IAEhC,IAAM+C,SAAS,SAASzD,aAAa,CAAC0D,YAAY,EAAE;IACpD,IAAI;MACF,MAAMD,SAAS,CAACE,WAAW,CAAC,eAAe,CAAC;KAC7C,CAAC,OAAOC,GAAG,EAAO;MACjB,IAAIA,GAAG,YAAYzG,YAAQ,CAAA0G,QAAA,IAAID,GAAG,CAACE,MAAM,KAAK3G,YAAU,CAAA4G,UAAA,CAACC,gBAAgB,EAAE;QACzE,MAAMP,SAAS,CAACQ,aAAa,CAAC,eAAe,CAAC;OAC/C,MAAM;QACL,MAAML,GAAG;;;IAGb,MAAMH,SAAS,CAACS,eAAe,CAACzD,aAAa,EAAEC,eAAe,CAAC;GAChE;EAAA,OAAA6C,UAAA,CAAAhG,KAAA,OAAAC,SAAA;AAAA;AAAA,SAEc2G,mBAAmBA,CAAAC,GAAA,EAAAC,GAAA;EAAA,OAAAC,oBAAA,CAAA/G,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAA8G,qBAAA;EAAAA,oBAAA,GAAApI,iBAAA,CAAlC,WACE8D,aAA4B,EAAAuE,KAAA,EAE5B;IAAA,IADE/C,OAAO,GAAA+C,KAAA,CAAP/C,OAAO;MAAEI,MAAM,GAAA2C,KAAA,CAAN3C,MAAM;IAEjB,IAAI4C,KAAK,GAAG,CAAC;IACb,OAAOA,KAAK,GAAG,CAAC,EAAE;MAChB,IAAM9C,iBAAiB,SAAS1B,aAAa,CAACyE,oBAAoB,EAAE;MACpE,MAAM/C,iBAAiB,CAACgD,gBAAgB,CAAC,IAAI,CAAC;MAC9C,MAAMhD,iBAAiB,CAACiD,aAAa,CAACnD,OAAO,CAACoD,SAAS,CAAC;MACxD,MAAMlD,iBAAiB,CAACC,SAAS,CAACH,OAAO,CAACqD,IAAI,EAAErD,OAAO,CAACsD,kBAAkB,CAAC;MAE3E,IAAM/C,MAAM,SAASL,iBAAiB,CAACqD,kBAAkB,EAAE;MAC3D,IAAIhD,MAAM,KAAK,IAAI,EAAE;QACnB,IAAIH,MAAM,EAAE;UAEV,IAAMoD,GAAG,SAAStD,iBAAiB,CAACuD,WAAW,CAAC,GAAG,EAAE,EAAE,CAAC;UACxD7H,KAAK,CAAC,uCAAuC,EAAE4H,GAAG,CAAC;UACnD,IAAIA,GAAG,KAAK,IAAI,EAAE;YAChBE,OAAO,CAAC/C,IAAI,CACV,qHAAqH,CACtH;;;QAIL,OAAOT,iBAAiB;OACzB,MAAM,IAAIK,MAAM,KAAK,OAAO,IAAIA,MAAM,KAAK,WAAW,EAAE;QACvD3E,KAAK,CAAC,gEAAgE,CAAC;QACvEoH,KAAK,EAAE;QACP9C,iBAAiB,CAAC5D,MAAM,CAACC,GAAG,EAAE;QAC9B,MAAM,IAAAlB,MAAU,EAAK4E,UAAL,CAAC,GAAG,CAAC;OACtB,MAAM;QACL,MAAM,IAAI3E,OAAY,CAAAqI,YAAA,CAAE,qCAAoCpD,MAAO,EAAC,CAAC;;;IAGzE,MAAM,IAAIjF,OAAY,CAAAqI,YAAA,CAAC,gDAAgD,CAAC;GACzE;EAAA,OAAAb,oBAAA,CAAA/G,KAAA,OAAAC,SAAA;AAAA;AAAA,SAEc4H,sBAAsBA,CAAAC,GAAA,EAAAC,GAAA;EAAA,OAAAC,uBAAA,CAAAhI,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAA+H,wBAAA;EAAAA,uBAAA,GAAArJ,iBAAA,CAArC,WAAsCsJ,QAAgB,EAAE5F,QAAgB,EAAE;IACxE,MAAM,IAAAhD,MAAU,EAA8E6I,UAA9E,CAAC,CAAC,WAAW,EAAE,QAAQ,EAAE,SAAS,EAAE,QAAQ,EAAE,UAAU,EAAED,QAAQ,EAAE5F,QAAQ,CAAC,CAAC;GAC/F;EAAA,OAAA2F,uBAAA,CAAAhI,KAAA,OAAAC,SAAA;AAAA;AAAA,SAQcmE,SAASA,CAAA+D,GAAA,EAAAC,IAAA;EAAA,OAAAC,UAAA,CAAArI,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAoI,WAAA;EAAAA,UAAA,GAAA1J,iBAAA,CAAxB,WACE8D,aAA4B,EAAA6F,KAAA,EAM5B;IAAA,IAJEjG,QAAQ,GAAAiG,KAAA,CAARjG,QAAQ;MACR4B,OAAO,GAAAqE,KAAA,CAAPrE,OAAO;MACPI,MAAM,GAAAiE,KAAA,CAANjE,MAAM;IAGR,IAAI;MACF,aAAauC,mBAAmB,CAACnE,aAAa,EAAE;QAAEwB,OAAO,EAAPA,OAAO;QAAEI,MAAM,EAANA;OAAQ,CAAC;KACrE,CAAC,OAAOkE,KAAK,EAAE;MACd1I,KAAK,CAAC,6DAA6D,EAAE0I,KAAK,CAAC;MAG3E,IAAMN,QAAQ,GAAGxF,aAAa,CAAC5B,MAAM,CAACe,UAAU,CAACG,YAAY;MAC7DU,aAAa,CAACjC,GAAG,EAAE;MAGnB,aAAaqH,sBAAsB,CAACI,QAAQ,EAAE5F,QAAQ,CAAC;;GAE1D;EAAA,OAAAgG,UAAA,CAAArI,KAAA,OAAAC,SAAA;AAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}