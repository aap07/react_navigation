{"ast":null,"code":"import _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport { Component } from 'react';\nvar Swipeable = function (_Component) {\n  _inherits(Swipeable, _Component);\n  var _super = _createSuper(Swipeable);\n  function Swipeable() {\n    _classCallCheck(this, Swipeable);\n    return _super.apply(this, arguments);\n  }\n  return _createClass(Swipeable);\n}(Component);\nexport { Swipeable as default };\nexport {};","map":{"version":3,"names":["Component","Swipeable","_Component","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","default"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/react-native-gesture-handler/lib/typescript/components/Swipeable.d.ts"],"sourcesContent":["import * as React from 'react';\nimport { Component } from 'react';\nimport { Animated, StyleProp, ViewStyle } from 'react-native';\nimport { PanGestureHandlerProps } from '../handlers/PanGestureHandler';\ndeclare type SwipeableExcludes = Exclude<keyof PanGestureHandlerProps, 'onGestureEvent' | 'onHandlerStateChange'>;\ndeclare type AnimatedInterpolation = ReturnType<Animated.Value['interpolate']>;\nexport interface SwipeableProps extends Pick<PanGestureHandlerProps, SwipeableExcludes> {\n    /**\n     * Enables two-finger gestures on supported devices, for example iPads with\n     * trackpads. If not enabled the gesture will require click + drag, with\n     * `enableTrackpadTwoFingerGesture` swiping with two fingers will also trigger\n     * the gesture.\n     */\n    enableTrackpadTwoFingerGesture?: boolean;\n    /**\n     * Specifies how much the visual interaction will be delayed compared to the\n     * gesture distance. e.g. value of 1 will indicate that the swipeable panel\n     * should exactly follow the gesture, 2 means it is going to be two times\n     * \"slower\".\n     */\n    friction?: number;\n    /**\n     * Distance from the left edge at which released panel will animate to the\n     * open state (or the open panel will animate into the closed state). By\n     * default it's a half of the panel's width.\n     */\n    leftThreshold?: number;\n    /**\n     * Distance from the right edge at which released panel will animate to the\n     * open state (or the open panel will animate into the closed state). By\n     * default it's a half of the panel's width.\n     */\n    rightThreshold?: number;\n    /**\n     * Distance that the panel must be dragged from the left edge to be considered\n     * a swipe. The default value is 10.\n     */\n    dragOffsetFromLeftEdge?: number;\n    /**\n     * Distance that the panel must be dragged from the right edge to be considered\n     * a swipe. The default value is 10.\n     */\n    dragOffsetFromRightEdge?: number;\n    /**\n     * Value indicating if the swipeable panel can be pulled further than the left\n     * actions panel's width. It is set to true by default as long as the left\n     * panel render method is present.\n     */\n    overshootLeft?: boolean;\n    /**\n     * Value indicating if the swipeable panel can be pulled further than the\n     * right actions panel's width. It is set to true by default as long as the\n     * right panel render method is present.\n     */\n    overshootRight?: boolean;\n    /**\n     * Specifies how much the visual interaction will be delayed compared to the\n     * gesture distance at overshoot. Default value is 1, it mean no friction, for\n     * a native feel, try 8 or above.\n     */\n    overshootFriction?: number;\n    /**\n     * @deprecated Use `direction` argument of onSwipeableOpen()\n     *\n     * Called when left action panel gets open.\n     */\n    onSwipeableLeftOpen?: () => void;\n    /**\n     * @deprecated Use `direction` argument of onSwipeableOpen()\n     *\n     * Called when right action panel gets open.\n     */\n    onSwipeableRightOpen?: () => void;\n    /**\n     * Called when action panel gets open (either right or left).\n     */\n    onSwipeableOpen?: (direction: 'left' | 'right', swipeable: Swipeable) => void;\n    /**\n     * Called when action panel is closed.\n     */\n    onSwipeableClose?: (direction: 'left' | 'right', swipeable: Swipeable) => void;\n    /**\n     * @deprecated Use `direction` argument of onSwipeableWillOpen()\n     *\n     * Called when left action panel starts animating on open.\n     */\n    onSwipeableLeftWillOpen?: () => void;\n    /**\n     * @deprecated Use `direction` argument of onSwipeableWillOpen()\n     *\n     * Called when right action panel starts animating on open.\n     */\n    onSwipeableRightWillOpen?: () => void;\n    /**\n     * Called when action panel starts animating on open (either right or left).\n     */\n    onSwipeableWillOpen?: (direction: 'left' | 'right') => void;\n    /**\n     * Called when action panel starts animating on close.\n     */\n    onSwipeableWillClose?: (direction: 'left' | 'right') => void;\n    /**\n     *\n     * This map describes the values to use as inputRange for extra interpolation:\n     * AnimatedValue: [startValue, endValue]\n     *\n     * progressAnimatedValue: [0, 1] dragAnimatedValue: [0, +]\n     *\n     * To support `rtl` flexbox layouts use `flexDirection` styling.\n     * */\n    renderLeftActions?: (progressAnimatedValue: AnimatedInterpolation, dragAnimatedValue: AnimatedInterpolation, swipeable: Swipeable) => React.ReactNode;\n    /**\n     *\n     * This map describes the values to use as inputRange for extra interpolation:\n     * AnimatedValue: [startValue, endValue]\n     *\n     * progressAnimatedValue: [0, 1] dragAnimatedValue: [0, -]\n     *\n     * To support `rtl` flexbox layouts use `flexDirection` styling.\n     * */\n    renderRightActions?: (progressAnimatedValue: AnimatedInterpolation, dragAnimatedValue: AnimatedInterpolation, swipeable: Swipeable) => React.ReactNode;\n    useNativeAnimations?: boolean;\n    animationOptions?: Record<string, unknown>;\n    /**\n     * Style object for the container (`Animated.View`), for example to override\n     * `overflow: 'hidden'`.\n     */\n    containerStyle?: StyleProp<ViewStyle>;\n    /**\n     * Style object for the children container (`Animated.View`), for example to\n     * apply `flex: 1`\n     */\n    childrenContainerStyle?: StyleProp<ViewStyle>;\n}\ndeclare type SwipeableState = {\n    dragX: Animated.Value;\n    rowTranslation: Animated.Value;\n    rowState: number;\n    leftWidth?: number;\n    rightOffset?: number;\n    rowWidth?: number;\n};\nexport default class Swipeable extends Component<SwipeableProps, SwipeableState> {\n    static defaultProps: {\n        friction: number;\n        overshootFriction: number;\n        useNativeAnimations: boolean;\n    };\n    constructor(props: SwipeableProps);\n    shouldComponentUpdate(props: SwipeableProps, state: SwipeableState): boolean;\n    private onGestureEvent?;\n    private transX?;\n    private showLeftAction?;\n    private leftActionTranslate?;\n    private showRightAction?;\n    private rightActionTranslate?;\n    private updateAnimatedEvent;\n    private onTapHandlerStateChange;\n    private onHandlerStateChange;\n    private handleRelease;\n    private animateRow;\n    private onRowLayout;\n    private currentOffset;\n    close: () => void;\n    openLeft: () => void;\n    openRight: () => void;\n    reset: () => void;\n    render(): JSX.Element;\n}\nexport {};\n"],"mappings":";;;;;;;AACA,SAASA,SAAS,QAAQ,OAAO;AAAC,IA6IbC,SAAS,aAAAC,UAAA;EAAAC,SAAA,CAAAF,SAAA,EAAAC,UAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,SAAA;EAAA,SAAAA,UAAA;IAAAK,eAAA,OAAAL,SAAA;IAAA,OAAAG,MAAA,CAAAG,KAAA,OAAAC,SAAA;EAAA;EAAA,OAAAC,YAAA,CAAAR,SAAA;AAAA,EAASD,SAAS;AAAA,SAA3BC,SAAS,IAAAS,OAAA;AA2B9B"},"metadata":{},"sourceType":"module","externalDependencies":[]}