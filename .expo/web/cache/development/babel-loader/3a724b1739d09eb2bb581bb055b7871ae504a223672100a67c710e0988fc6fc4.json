{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nvar _assertThisInitialized = require(\"@babel/runtime/helpers/assertThisInitialized\");\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nvar EventEmitter = require('events');\nvar https = require('https');\nvar http = require('http');\nvar net = require('net');\nvar tls = require('tls');\nvar _require = require('crypto'),\n  randomBytes = _require.randomBytes,\n  createHash = _require.createHash;\nvar _require2 = require('stream'),\n  Duplex = _require2.Duplex,\n  Readable = _require2.Readable;\nvar _require3 = require('url'),\n  URL = _require3.URL;\nvar PerMessageDeflate = require(\"./permessage-deflate\");\nvar Receiver = require(\"./receiver\");\nvar Sender = require(\"./sender\");\nvar _require4 = require(\"./constants\"),\n  BINARY_TYPES = _require4.BINARY_TYPES,\n  EMPTY_BUFFER = _require4.EMPTY_BUFFER,\n  GUID = _require4.GUID,\n  kForOnEventAttribute = _require4.kForOnEventAttribute,\n  kListener = _require4.kListener,\n  kStatusCode = _require4.kStatusCode,\n  kWebSocket = _require4.kWebSocket,\n  NOOP = _require4.NOOP;\nvar _require5 = require(\"./event-target\"),\n  _require5$EventTarget = _require5.EventTarget,\n  addEventListener = _require5$EventTarget.addEventListener,\n  removeEventListener = _require5$EventTarget.removeEventListener;\nvar _require6 = require(\"./extension\"),\n  format = _require6.format,\n  parse = _require6.parse;\nvar _require7 = require(\"./buffer-util\"),\n  toBuffer = _require7.toBuffer;\nvar closeTimeout = 30 * 1000;\nvar kAborted = Symbol('kAborted');\nvar protocolVersions = [8, 13];\nvar readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nvar subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\nvar WebSocket = function (_EventEmitter) {\n  _inherits(WebSocket, _EventEmitter);\n  var _super = _createSuper(WebSocket);\n  function WebSocket(address, protocols, options) {\n    var _this;\n    _classCallCheck(this, WebSocket);\n    _this = _super.call(this);\n    _this._binaryType = BINARY_TYPES[0];\n    _this._closeCode = 1006;\n    _this._closeFrameReceived = false;\n    _this._closeFrameSent = false;\n    _this._closeMessage = EMPTY_BUFFER;\n    _this._closeTimer = null;\n    _this._extensions = {};\n    _this._paused = false;\n    _this._protocol = '';\n    _this._readyState = WebSocket.CONNECTING;\n    _this._receiver = null;\n    _this._sender = null;\n    _this._socket = null;\n    if (address !== null) {\n      _this._bufferedAmount = 0;\n      _this._isServer = false;\n      _this._redirects = 0;\n      if (protocols === undefined) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === 'object' && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n      initAsClient(_assertThisInitialized(_this), address, protocols, options);\n    } else {\n      _this._isServer = true;\n    }\n    return _this;\n  }\n  _createClass(WebSocket, [{\n    key: \"binaryType\",\n    get: function get() {\n      return this._binaryType;\n    },\n    set: function set(type) {\n      if (!BINARY_TYPES.includes(type)) return;\n      this._binaryType = type;\n      if (this._receiver) this._receiver._binaryType = type;\n    }\n  }, {\n    key: \"bufferedAmount\",\n    get: function get() {\n      if (!this._socket) return this._bufferedAmount;\n      return this._socket._writableState.length + this._sender._bufferedBytes;\n    }\n  }, {\n    key: \"extensions\",\n    get: function get() {\n      return Object.keys(this._extensions).join();\n    }\n  }, {\n    key: \"isPaused\",\n    get: function get() {\n      return this._paused;\n    }\n  }, {\n    key: \"onclose\",\n    get: function get() {\n      return null;\n    }\n  }, {\n    key: \"onerror\",\n    get: function get() {\n      return null;\n    }\n  }, {\n    key: \"onopen\",\n    get: function get() {\n      return null;\n    }\n  }, {\n    key: \"onmessage\",\n    get: function get() {\n      return null;\n    }\n  }, {\n    key: \"protocol\",\n    get: function get() {\n      return this._protocol;\n    }\n  }, {\n    key: \"readyState\",\n    get: function get() {\n      return this._readyState;\n    }\n  }, {\n    key: \"url\",\n    get: function get() {\n      return this._url;\n    }\n  }, {\n    key: \"setSocket\",\n    value: function setSocket(socket, head, options) {\n      var receiver = new Receiver({\n        binaryType: this.binaryType,\n        extensions: this._extensions,\n        isServer: this._isServer,\n        maxPayload: options.maxPayload,\n        skipUTF8Validation: options.skipUTF8Validation\n      });\n      this._sender = new Sender(socket, this._extensions, options.generateMask);\n      this._receiver = receiver;\n      this._socket = socket;\n      receiver[kWebSocket] = this;\n      socket[kWebSocket] = this;\n      receiver.on('conclude', receiverOnConclude);\n      receiver.on('drain', receiverOnDrain);\n      receiver.on('error', receiverOnError);\n      receiver.on('message', receiverOnMessage);\n      receiver.on('ping', receiverOnPing);\n      receiver.on('pong', receiverOnPong);\n      if (socket.setTimeout) socket.setTimeout(0);\n      if (socket.setNoDelay) socket.setNoDelay();\n      if (head.length > 0) socket.unshift(head);\n      socket.on('close', socketOnClose);\n      socket.on('data', socketOnData);\n      socket.on('end', socketOnEnd);\n      socket.on('error', socketOnError);\n      this._readyState = WebSocket.OPEN;\n      this.emit('open');\n    }\n  }, {\n    key: \"emitClose\",\n    value: function emitClose() {\n      if (!this._socket) {\n        this._readyState = WebSocket.CLOSED;\n        this.emit('close', this._closeCode, this._closeMessage);\n        return;\n      }\n      if (this._extensions[PerMessageDeflate.extensionName]) {\n        this._extensions[PerMessageDeflate.extensionName].cleanup();\n      }\n      this._receiver.removeAllListeners();\n      this._readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n    }\n  }, {\n    key: \"close\",\n    value: function close(code, data) {\n      var _this2 = this;\n      if (this.readyState === WebSocket.CLOSED) return;\n      if (this.readyState === WebSocket.CONNECTING) {\n        var msg = 'WebSocket was closed before the connection was established';\n        abortHandshake(this, this._req, msg);\n        return;\n      }\n      if (this.readyState === WebSocket.CLOSING) {\n        if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {\n          this._socket.end();\n        }\n        return;\n      }\n      this._readyState = WebSocket.CLOSING;\n      this._sender.close(code, data, !this._isServer, function (err) {\n        if (err) return;\n        _this2._closeFrameSent = true;\n        if (_this2._closeFrameReceived || _this2._receiver._writableState.errorEmitted) {\n          _this2._socket.end();\n        }\n      });\n      this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n        return;\n      }\n      this._paused = true;\n      this._socket.pause();\n    }\n  }, {\n    key: \"ping\",\n    value: function ping(data, mask, cb) {\n      if (this.readyState === WebSocket.CONNECTING) {\n        throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n      }\n      if (typeof data === 'function') {\n        cb = data;\n        data = mask = undefined;\n      } else if (typeof mask === 'function') {\n        cb = mask;\n        mask = undefined;\n      }\n      if (typeof data === 'number') data = data.toString();\n      if (this.readyState !== WebSocket.OPEN) {\n        sendAfterClose(this, data, cb);\n        return;\n      }\n      if (mask === undefined) mask = !this._isServer;\n      this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n    }\n  }, {\n    key: \"pong\",\n    value: function pong(data, mask, cb) {\n      if (this.readyState === WebSocket.CONNECTING) {\n        throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n      }\n      if (typeof data === 'function') {\n        cb = data;\n        data = mask = undefined;\n      } else if (typeof mask === 'function') {\n        cb = mask;\n        mask = undefined;\n      }\n      if (typeof data === 'number') data = data.toString();\n      if (this.readyState !== WebSocket.OPEN) {\n        sendAfterClose(this, data, cb);\n        return;\n      }\n      if (mask === undefined) mask = !this._isServer;\n      this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n        return;\n      }\n      this._paused = false;\n      if (!this._receiver._writableState.needDrain) this._socket.resume();\n    }\n  }, {\n    key: \"send\",\n    value: function send(data, options, cb) {\n      if (this.readyState === WebSocket.CONNECTING) {\n        throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n      }\n      if (typeof options === 'function') {\n        cb = options;\n        options = {};\n      }\n      if (typeof data === 'number') data = data.toString();\n      if (this.readyState !== WebSocket.OPEN) {\n        sendAfterClose(this, data, cb);\n        return;\n      }\n      var opts = _objectSpread({\n        binary: typeof data !== 'string',\n        mask: !this._isServer,\n        compress: true,\n        fin: true\n      }, options);\n      if (!this._extensions[PerMessageDeflate.extensionName]) {\n        opts.compress = false;\n      }\n      this._sender.send(data || EMPTY_BUFFER, opts, cb);\n    }\n  }, {\n    key: \"terminate\",\n    value: function terminate() {\n      if (this.readyState === WebSocket.CLOSED) return;\n      if (this.readyState === WebSocket.CONNECTING) {\n        var msg = 'WebSocket was closed before the connection was established';\n        abortHandshake(this, this._req, msg);\n        return;\n      }\n      if (this._socket) {\n        this._readyState = WebSocket.CLOSING;\n        this._socket.destroy();\n      }\n    }\n  }]);\n  return WebSocket;\n}(EventEmitter);\nObject.defineProperty(WebSocket, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\nObject.defineProperty(WebSocket, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\nObject.defineProperty(WebSocket, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\nObject.defineProperty(WebSocket, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n['binaryType', 'bufferedAmount', 'extensions', 'isPaused', 'protocol', 'readyState', 'url'].forEach(function (property) {\n  Object.defineProperty(WebSocket.prototype, property, {\n    enumerable: true\n  });\n});\n['open', 'error', 'close', 'message'].forEach(function (method) {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    enumerable: true,\n    get: function get() {\n      for (var listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) return listener[kListener];\n      }\n      return null;\n    },\n    set: function set(handler) {\n      for (var listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n      if (typeof handler !== 'function') return;\n      this.addEventListener(method, handler, _defineProperty({}, kForOnEventAttribute, true));\n    }\n  });\n});\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\nmodule.exports = WebSocket;\nfunction initAsClient(websocket, address, protocols, options) {\n  var opts = _objectSpread(_objectSpread({\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10\n  }, options), {}, {\n    createConnection: undefined,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: 'GET',\n    host: undefined,\n    path: undefined,\n    port: undefined\n  });\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(', ')})`);\n  }\n  var parsedUrl;\n  if (address instanceof URL) {\n    parsedUrl = address;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n  }\n  if (parsedUrl.protocol === 'http:') {\n    parsedUrl.protocol = 'ws:';\n  } else if (parsedUrl.protocol === 'https:') {\n    parsedUrl.protocol = 'wss:';\n  }\n  websocket._url = parsedUrl.href;\n  var isSecure = parsedUrl.protocol === 'wss:';\n  var isIpcUrl = parsedUrl.protocol === 'ws+unix:';\n  var invalidUrlMessage;\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {\n    invalidUrlMessage = 'The URL\\'s protocol must be one of \"ws:\", \"wss:\", ' + '\"http:\", \"https\", or \"ws+unix:\"';\n  } else if (isIpcUrl && !parsedUrl.pathname) {\n    invalidUrlMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidUrlMessage = 'The URL contains a fragment identifier';\n  }\n  if (invalidUrlMessage) {\n    var err = new SyntaxError(invalidUrlMessage);\n    if (websocket._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket, err);\n      return;\n    }\n  }\n  var defaultPort = isSecure ? 443 : 80;\n  var key = randomBytes(16).toString('base64');\n  var request = isSecure ? https.request : http.request;\n  var protocolSet = new Set();\n  var perMessageDeflate;\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[') ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;\n  opts.headers = _objectSpread(_objectSpread({}, opts.headers), {}, {\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket'\n  });\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);\n    opts.headers['Sec-WebSocket-Extensions'] = format(_defineProperty({}, PerMessageDeflate.extensionName, perMessageDeflate.offer()));\n  }\n  if (protocols.length) {\n    for (var protocol of protocols) {\n      if (typeof protocol !== 'string' || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {\n        throw new SyntaxError('An invalid or duplicated subprotocol was specified');\n      }\n      protocolSet.add(protocol);\n    }\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n  if (isIpcUrl) {\n    var parts = opts.path.split(':');\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n  var req;\n  if (opts.followRedirects) {\n    if (websocket._redirects === 0) {\n      websocket._originalIpc = isIpcUrl;\n      websocket._originalSecure = isSecure;\n      websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;\n      var headers = options && options.headers;\n      options = _objectSpread(_objectSpread({}, options), {}, {\n        headers: {}\n      });\n      if (headers) {\n        for (var _ref of Object.entries(headers)) {\n          var _ref2 = _slicedToArray(_ref, 2);\n          var _key = _ref2[0];\n          var value = _ref2[1];\n          options.headers[_key.toLowerCase()] = value;\n        }\n      }\n    } else if (websocket.listenerCount('redirect') === 0) {\n      var isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;\n      if (!isSameHost || websocket._originalSecure && !isSecure) {\n        delete opts.headers.authorization;\n        delete opts.headers.cookie;\n        if (!isSameHost) delete opts.headers.host;\n        opts.auth = undefined;\n      }\n    }\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization = 'Basic ' + Buffer.from(opts.auth).toString('base64');\n    }\n    req = websocket._req = request(opts);\n    if (websocket._redirects) {\n      websocket.emit('redirect', websocket.url, req);\n    }\n  } else {\n    req = websocket._req = request(opts);\n  }\n  if (opts.timeout) {\n    req.on('timeout', function () {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n  req.on('error', function (err) {\n    if (req === null || req[kAborted]) return;\n    req = websocket._req = null;\n    emitErrorAndClose(websocket, err);\n  });\n  req.on('response', function (res) {\n    var location = res.headers.location;\n    var statusCode = res.statusCode;\n    if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n      req.abort();\n      var addr;\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        var _err = new SyntaxError(`Invalid URL: ${location}`);\n        emitErrorAndClose(websocket, _err);\n        return;\n      }\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);\n    }\n  });\n  req.on('upgrade', function (res, socket, head) {\n    websocket.emit('upgrade', res);\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n    req = websocket._req = null;\n    if (res.headers.upgrade.toLowerCase() !== 'websocket') {\n      abortHandshake(websocket, socket, 'Invalid Upgrade header');\n      return;\n    }\n    var digest = createHash('sha1').update(key + GUID).digest('base64');\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n    var serverProt = res.headers['sec-websocket-protocol'];\n    var protError;\n    if (serverProt !== undefined) {\n      if (!protocolSet.size) {\n        protError = 'Server sent a subprotocol but none was requested';\n      } else if (!protocolSet.has(serverProt)) {\n        protError = 'Server sent an invalid subprotocol';\n      }\n    } else if (protocolSet.size) {\n      protError = 'Server sent no subprotocol';\n    }\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n    if (serverProt) websocket._protocol = serverProt;\n    var secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n    if (secWebSocketExtensions !== undefined) {\n      if (!perMessageDeflate) {\n        var message = 'Server sent a Sec-WebSocket-Extensions header but no extension ' + 'was requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n      var extensions;\n      try {\n        extensions = parse(secWebSocketExtensions);\n      } catch (err) {\n        var _message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, _message);\n        return;\n      }\n      var extensionNames = Object.keys(extensions);\n      if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {\n        var _message2 = 'Server indicated an extension that was not requested';\n        abortHandshake(websocket, socket, _message2);\n        return;\n      }\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        var _message3 = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, _message3);\n        return;\n      }\n      websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n    }\n    websocket.setSocket(socket, head, {\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n  if (opts.finishRequest) {\n    opts.finishRequest(req, websocket);\n  } else {\n    req.end();\n  }\n}\nfunction emitErrorAndClose(websocket, err) {\n  websocket._readyState = WebSocket.CLOSING;\n  websocket.emit('error', err);\n  websocket.emitClose();\n}\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\nfunction tlsConnect(options) {\n  options.path = undefined;\n  if (!options.servername && options.servername !== '') {\n    options.servername = net.isIP(options.host) ? '' : options.host;\n  }\n  return tls.connect(options);\n}\nfunction abortHandshake(websocket, stream, message) {\n  websocket._readyState = WebSocket.CLOSING;\n  var err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n  if (stream.setHeader) {\n    stream[kAborted] = true;\n    stream.abort();\n    if (stream.socket && !stream.socket.destroyed) {\n      stream.socket.destroy();\n    }\n    process.nextTick(emitErrorAndClose, websocket, err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    var length = toBuffer(data).length;\n    if (websocket._socket) websocket._sender._bufferedBytes += length;else websocket._bufferedAmount += length;\n  }\n  if (cb) {\n    var err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);\n    process.nextTick(cb, err);\n  }\n}\nfunction receiverOnConclude(code, reason) {\n  var websocket = this[kWebSocket];\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n  if (websocket._socket[kWebSocket] === undefined) return;\n  websocket._socket.removeListener('data', socketOnData);\n  process.nextTick(resume, websocket._socket);\n  if (code === 1005) websocket.close();else websocket.close(code, reason);\n}\nfunction receiverOnDrain() {\n  var websocket = this[kWebSocket];\n  if (!websocket.isPaused) websocket._socket.resume();\n}\nfunction receiverOnError(err) {\n  var websocket = this[kWebSocket];\n  if (websocket._socket[kWebSocket] !== undefined) {\n    websocket._socket.removeListener('data', socketOnData);\n    process.nextTick(resume, websocket._socket);\n    websocket.close(err[kStatusCode]);\n  }\n  websocket.emit('error', err);\n}\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket].emit('message', data, isBinary);\n}\nfunction receiverOnPing(data) {\n  var websocket = this[kWebSocket];\n  websocket.pong(data, !websocket._isServer, NOOP);\n  websocket.emit('ping', data);\n}\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\nfunction resume(stream) {\n  stream.resume();\n}\nfunction socketOnClose() {\n  var websocket = this[kWebSocket];\n  this.removeListener('close', socketOnClose);\n  this.removeListener('data', socketOnData);\n  this.removeListener('end', socketOnEnd);\n  websocket._readyState = WebSocket.CLOSING;\n  var chunk;\n  if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {\n    websocket._receiver.write(chunk);\n  }\n  websocket._receiver.end();\n  this[kWebSocket] = undefined;\n  clearTimeout(websocket._closeTimer);\n  if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\nfunction socketOnEnd() {\n  var websocket = this[kWebSocket];\n  websocket._readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\nfunction socketOnError() {\n  var websocket = this[kWebSocket];\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n  if (websocket) {\n    websocket._readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}","map":{"version":3,"names":["_slicedToArray","require","_defineProperty","_classCallCheck","_createClass","_assertThisInitialized","_inherits","_possibleConstructorReturn","_getPrototypeOf","ownKeys","e","r","t","Object","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","length","forEach","getOwnPropertyDescriptors","defineProperties","defineProperty","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","constructor","Reflect","construct","sham","Proxy","Boolean","prototype","valueOf","call","EventEmitter","https","http","net","tls","_require","randomBytes","createHash","_require2","Duplex","Readable","_require3","URL","PerMessageDeflate","Receiver","Sender","_require4","BINARY_TYPES","EMPTY_BUFFER","GUID","kForOnEventAttribute","kListener","kStatusCode","kWebSocket","NOOP","_require5","_require5$EventTarget","EventTarget","addEventListener","removeEventListener","_require6","format","parse","_require7","toBuffer","closeTimeout","kAborted","Symbol","protocolVersions","readyStates","subprotocolRegex","WebSocket","_EventEmitter","_super","address","protocols","options","_this","_binaryType","_closeCode","_closeFrameReceived","_closeFrameSent","_closeMessage","_closeTimer","_extensions","_paused","_protocol","_readyState","CONNECTING","_receiver","_sender","_socket","_bufferedAmount","_isServer","_redirects","undefined","Array","isArray","initAsClient","key","get","set","type","includes","_writableState","_bufferedBytes","join","_url","value","setSocket","socket","head","receiver","binaryType","extensions","isServer","maxPayload","skipUTF8Validation","generateMask","on","receiverOnConclude","receiverOnDrain","receiverOnError","receiverOnMessage","receiverOnPing","receiverOnPong","setTimeout","setNoDelay","unshift","socketOnClose","socketOnData","socketOnEnd","socketOnError","OPEN","emit","emitClose","CLOSED","extensionName","cleanup","removeAllListeners","close","code","data","_this2","readyState","msg","abortHandshake","_req","CLOSING","errorEmitted","end","err","destroy","bind","pause","ping","mask","cb","Error","toString","sendAfterClose","pong","resume","needDrain","send","opts","binary","compress","fin","terminate","indexOf","property","method","listener","listeners","handler","removeListener","module","exports","websocket","protocolVersion","perMessageDeflate","followRedirects","maxRedirects","createConnection","socketPath","hostname","protocol","timeout","host","path","port","RangeError","parsedUrl","SyntaxError","href","isSecure","isIpcUrl","invalidUrlMessage","pathname","hash","emitErrorAndClose","defaultPort","request","protocolSet","Set","tlsConnect","netConnect","startsWith","slice","headers","Connection","Upgrade","search","handshakeTimeout","offer","test","has","add","origin","Origin","username","password","auth","parts","split","req","_originalIpc","_originalSecure","_originalHostOrSocketPath","_ref","entries","_ref2","toLowerCase","listenerCount","isSameHost","authorization","cookie","Buffer","from","url","res","location","statusCode","abort","addr","upgrade","digest","update","serverProt","protError","size","secWebSocketExtensions","message","extensionNames","accept","finishRequest","connect","servername","isIP","stream","captureStackTrace","setHeader","destroyed","process","nextTick","once","reason","isPaused","receiverOnFinish","isBinary","chunk","_readableState","endEmitted","read","write","clearTimeout","finished"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@expo/cli/node_modules/ws/lib/websocket.js"],"sourcesContent":["/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex|Readable$\" }] */\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst https = require('https');\nconst http = require('http');\nconst net = require('net');\nconst tls = require('tls');\nconst { randomBytes, createHash } = require('crypto');\nconst { Duplex, Readable } = require('stream');\nconst { URL } = require('url');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst Receiver = require('./receiver');\nconst Sender = require('./sender');\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kForOnEventAttribute,\n  kListener,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = require('./constants');\nconst {\n  EventTarget: { addEventListener, removeEventListener }\n} = require('./event-target');\nconst { format, parse } = require('./extension');\nconst { toBuffer } = require('./buffer-util');\n\nconst closeTimeout = 30 * 1000;\nconst kAborted = Symbol('kAborted');\nconst protocolVersions = [8, 13];\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = EMPTY_BUFFER;\n    this._closeTimer = null;\n    this._extensions = {};\n    this._paused = false;\n    this._protocol = '';\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (protocols === undefined) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === 'object' && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._isServer = true;\n    }\n  }\n\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get isPaused() {\n    return this._paused;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onclose() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onerror() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onopen() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onmessage() {\n    return null;\n  }\n\n  /**\n   * @type {String}\n   */\n  get protocol() {\n    return this._protocol;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get readyState() {\n    return this._readyState;\n  }\n\n  /**\n   * @type {String}\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */\n  setSocket(socket, head, options) {\n    const receiver = new Receiver({\n      binaryType: this.binaryType,\n      extensions: this._extensions,\n      isServer: this._isServer,\n      maxPayload: options.maxPayload,\n      skipUTF8Validation: options.skipUTF8Validation\n    });\n\n    this._sender = new Sender(socket, this._extensions, options.generateMask);\n    this._receiver = receiver;\n    this._socket = socket;\n\n    receiver[kWebSocket] = this;\n    socket[kWebSocket] = this;\n\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n\n    //\n    // These methods may not be available if `socket` is just a `Duplex`.\n    //\n    if (socket.setTimeout) socket.setTimeout(0);\n    if (socket.setNoDelay) socket.setNoDelay();\n\n    if (head.length > 0) socket.unshift(head);\n\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n\n    this._readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n    this._readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      abortHandshake(this, this._req, msg);\n      return;\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (\n        this._closeFrameSent &&\n        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)\n      ) {\n        this._socket.end();\n      }\n\n      return;\n    }\n\n    this._readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n\n      if (\n        this._closeFrameReceived ||\n        this._receiver._writableState.errorEmitted\n      ) {\n        this._socket.end();\n      }\n    });\n\n    //\n    // Specify a timeout for the closing handshake to complete.\n    //\n    this._closeTimer = setTimeout(\n      this._socket.destroy.bind(this._socket),\n      closeTimeout\n    );\n  }\n\n  /**\n   * Pause the socket.\n   *\n   * @public\n   */\n  pause() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = true;\n    this._socket.pause();\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Resume the socket.\n   *\n   * @public\n   */\n  resume() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = false;\n    if (!this._receiver._writableState.needDrain) this._socket.resume();\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      abortHandshake(this, this._req, msg);\n      return;\n    }\n\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n[\n  'binaryType',\n  'bufferedAmount',\n  'extensions',\n  'isPaused',\n  'protocol',\n  'readyState',\n  'url'\n].forEach((property) => {\n  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    enumerable: true,\n    get() {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) return listener[kListener];\n      }\n\n      return null;\n    },\n    set(handler) {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n\n      if (typeof handler !== 'function') return;\n\n      this.addEventListener(method, handler, {\n        [kForOnEventAttribute]: true\n      });\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {Array} protocols The subprotocols\n * @param {Object} [options] Connection options\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Function} [options.generateMask] The function used to generate the\n *     masking key\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n *     not to skip UTF-8 validation for text and close messages\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    createConnection: undefined,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: 'GET',\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\n        `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  let parsedUrl;\n\n  if (address instanceof URL) {\n    parsedUrl = address;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n  }\n\n  if (parsedUrl.protocol === 'http:') {\n    parsedUrl.protocol = 'ws:';\n  } else if (parsedUrl.protocol === 'https:') {\n    parsedUrl.protocol = 'wss:';\n  }\n\n  websocket._url = parsedUrl.href;\n\n  const isSecure = parsedUrl.protocol === 'wss:';\n  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';\n  let invalidUrlMessage;\n\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {\n    invalidUrlMessage =\n      'The URL\\'s protocol must be one of \"ws:\", \"wss:\", ' +\n      '\"http:\", \"https\", or \"ws+unix:\"';\n  } else if (isIpcUrl && !parsedUrl.pathname) {\n    invalidUrlMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidUrlMessage = 'The URL contains a fragment identifier';\n  }\n\n  if (invalidUrlMessage) {\n    const err = new SyntaxError(invalidUrlMessage);\n\n    if (websocket._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket, err);\n      return;\n    }\n  }\n\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const request = isSecure ? https.request : http.request;\n  const protocolSet = new Set();\n  let perMessageDeflate;\n\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[')\n    ? parsedUrl.hostname.slice(1, -1)\n    : parsedUrl.hostname;\n  opts.headers = {\n    ...opts.headers,\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket'\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n      false,\n      opts.maxPayload\n    );\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols.length) {\n    for (const protocol of protocols) {\n      if (\n        typeof protocol !== 'string' ||\n        !subprotocolRegex.test(protocol) ||\n        protocolSet.has(protocol)\n      ) {\n        throw new SyntaxError(\n          'An invalid or duplicated subprotocol was specified'\n        );\n      }\n\n      protocolSet.add(protocol);\n    }\n\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isIpcUrl) {\n    const parts = opts.path.split(':');\n\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  let req;\n\n  if (opts.followRedirects) {\n    if (websocket._redirects === 0) {\n      websocket._originalIpc = isIpcUrl;\n      websocket._originalSecure = isSecure;\n      websocket._originalHostOrSocketPath = isIpcUrl\n        ? opts.socketPath\n        : parsedUrl.host;\n\n      const headers = options && options.headers;\n\n      //\n      // Shallow copy the user provided options so that headers can be changed\n      // without mutating the original object.\n      //\n      options = { ...options, headers: {} };\n\n      if (headers) {\n        for (const [key, value] of Object.entries(headers)) {\n          options.headers[key.toLowerCase()] = value;\n        }\n      }\n    } else if (websocket.listenerCount('redirect') === 0) {\n      const isSameHost = isIpcUrl\n        ? websocket._originalIpc\n          ? opts.socketPath === websocket._originalHostOrSocketPath\n          : false\n        : websocket._originalIpc\n        ? false\n        : parsedUrl.host === websocket._originalHostOrSocketPath;\n\n      if (!isSameHost || (websocket._originalSecure && !isSecure)) {\n        //\n        // Match curl 7.77.0 behavior and drop the following headers. These\n        // headers are also dropped when following a redirect to a subdomain.\n        //\n        delete opts.headers.authorization;\n        delete opts.headers.cookie;\n\n        if (!isSameHost) delete opts.headers.host;\n\n        opts.auth = undefined;\n      }\n    }\n\n    //\n    // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n    // If the `Authorization` header is set, then there is nothing to do as it\n    // will take precedence.\n    //\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization =\n        'Basic ' + Buffer.from(opts.auth).toString('base64');\n    }\n\n    req = websocket._req = request(opts);\n\n    if (websocket._redirects) {\n      //\n      // Unlike what is done for the `'upgrade'` event, no early exit is\n      // triggered here if the user calls `websocket.close()` or\n      // `websocket.terminate()` from a listener of the `'redirect'` event. This\n      // is because the user can also call `request.destroy()` with an error\n      // before calling `websocket.close()` or `websocket.terminate()` and this\n      // would result in an error being emitted on the `request` object with no\n      // `'error'` event listeners attached.\n      //\n      websocket.emit('redirect', websocket.url, req);\n    }\n  } else {\n    req = websocket._req = request(opts);\n  }\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', (err) => {\n    if (req === null || req[kAborted]) return;\n\n    req = websocket._req = null;\n    emitErrorAndClose(websocket, err);\n  });\n\n  req.on('response', (res) => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (\n      location &&\n      opts.followRedirects &&\n      statusCode >= 300 &&\n      statusCode < 400\n    ) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n\n      let addr;\n\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        const err = new SyntaxError(`Invalid URL: ${location}`);\n        emitErrorAndClose(websocket, err);\n        return;\n      }\n\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(\n        websocket,\n        req,\n        `Unexpected server response: ${res.statusCode}`\n      );\n    }\n  });\n\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the\n    // `'upgrade'` event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n\n    req = websocket._req = null;\n\n    if (res.headers.upgrade.toLowerCase() !== 'websocket') {\n      abortHandshake(websocket, socket, 'Invalid Upgrade header');\n      return;\n    }\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    let protError;\n\n    if (serverProt !== undefined) {\n      if (!protocolSet.size) {\n        protError = 'Server sent a subprotocol but none was requested';\n      } else if (!protocolSet.has(serverProt)) {\n        protError = 'Server sent an invalid subprotocol';\n      }\n    } else if (protocolSet.size) {\n      protError = 'Server sent no subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket._protocol = serverProt;\n\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n\n    if (secWebSocketExtensions !== undefined) {\n      if (!perMessageDeflate) {\n        const message =\n          'Server sent a Sec-WebSocket-Extensions header but no extension ' +\n          'was requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      let extensions;\n\n      try {\n        extensions = parse(secWebSocketExtensions);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      const extensionNames = Object.keys(extensions);\n\n      if (\n        extensionNames.length !== 1 ||\n        extensionNames[0] !== PerMessageDeflate.extensionName\n      ) {\n        const message = 'Server indicated an extension that was not requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      websocket._extensions[PerMessageDeflate.extensionName] =\n        perMessageDeflate;\n    }\n\n    websocket.setSocket(socket, head, {\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n\n  if (opts.finishRequest) {\n    opts.finishRequest(req, websocket);\n  } else {\n    req.end();\n  }\n}\n\n/**\n * Emit the `'error'` and `'close'` events.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */\nfunction emitErrorAndClose(websocket, err) {\n  websocket._readyState = WebSocket.CLOSING;\n  websocket.emit('error', err);\n  websocket.emitClose();\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n\n  if (!options.servername && options.servername !== '') {\n    options.servername = net.isIP(options.host) ? '' : options.host;\n  }\n\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket._readyState = WebSocket.CLOSING;\n\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream[kAborted] = true;\n    stream.abort();\n\n    if (stream.socket && !stream.socket.destroyed) {\n      //\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n      // called after the request completed. See\n      // https://github.com/websockets/ws/issues/1869.\n      //\n      stream.socket.destroy();\n    }\n\n    process.nextTick(emitErrorAndClose, websocket, err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = toBuffer(data).length;\n\n    //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n    if (websocket._socket) websocket._sender._bufferedBytes += length;\n    else websocket._bufferedAmount += length;\n  }\n\n  if (cb) {\n    const err = new Error(\n      `WebSocket is not open: readyState ${websocket.readyState} ` +\n        `(${readyStates[websocket.readyState]})`\n    );\n    process.nextTick(cb, err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {Buffer} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n\n  if (websocket._socket[kWebSocket] === undefined) return;\n\n  websocket._socket.removeListener('data', socketOnData);\n  process.nextTick(resume, websocket._socket);\n\n  if (code === 1005) websocket.close();\n  else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  const websocket = this[kWebSocket];\n\n  if (!websocket.isPaused) websocket._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._socket[kWebSocket] !== undefined) {\n    websocket._socket.removeListener('data', socketOnData);\n\n    //\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n    // https://github.com/websockets/ws/issues/1940.\n    //\n    process.nextTick(resume, websocket._socket);\n\n    websocket.close(err[kStatusCode]);\n  }\n\n  websocket.emit('error', err);\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n * @param {Boolean} isBinary Specifies whether the message is binary or not\n * @private\n */\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket].emit('message', data, isBinary);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n\n  websocket.pong(data, !websocket._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */\nfunction resume(stream) {\n  stream.resume();\n}\n\n/**\n * The listener of the socket `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('close', socketOnClose);\n  this.removeListener('data', socketOnData);\n  this.removeListener('end', socketOnEnd);\n\n  websocket._readyState = WebSocket.CLOSING;\n\n  let chunk;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk.\n  //\n  if (\n    !this._readableState.endEmitted &&\n    !websocket._closeFrameReceived &&\n    !websocket._receiver._writableState.errorEmitted &&\n    (chunk = websocket._socket.read()) !== null\n  ) {\n    websocket._receiver.write(chunk);\n  }\n\n  websocket._receiver.end();\n\n  this[kWebSocket] = undefined;\n\n  clearTimeout(websocket._closeTimer);\n\n  if (\n    websocket._receiver._writableState.finished ||\n    websocket._receiver._writableState.errorEmitted\n  ) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the socket `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the socket `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n\n  websocket._readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the socket `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  if (websocket) {\n    websocket._readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}