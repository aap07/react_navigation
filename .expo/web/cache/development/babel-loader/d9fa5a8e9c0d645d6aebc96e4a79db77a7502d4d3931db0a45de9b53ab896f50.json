{"ast":null,"code":"export {};","map":{"version":3,"names":[],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/react-native-gesture-handler/lib/typescript/handlers/gestures/gesture.d.ts"],"sourcesContent":["import { FlingGestureHandlerEventPayload } from '../FlingGestureHandler';\nimport { ForceTouchGestureHandlerEventPayload } from '../ForceTouchGestureHandler';\nimport { HitSlop, CommonGestureConfig, GestureTouchEvent, GestureStateChangeEvent, GestureUpdateEvent } from '../gestureHandlerCommon';\nimport { GestureStateManagerType } from './gestureStateManager';\nimport { LongPressGestureHandlerEventPayload } from '../LongPressGestureHandler';\nimport { PanGestureHandlerEventPayload } from '../PanGestureHandler';\nimport { PinchGestureHandlerEventPayload } from '../PinchGestureHandler';\nimport { RotationGestureHandlerEventPayload } from '../RotationGestureHandler';\nimport { TapGestureHandlerEventPayload } from '../TapGestureHandler';\nimport { NativeViewGestureHandlerPayload } from '../NativeViewGestureHandler';\nexport declare type GestureType = BaseGesture<Record<string, unknown>> | BaseGesture<Record<string, never>> | BaseGesture<TapGestureHandlerEventPayload> | BaseGesture<PanGestureHandlerEventPayload> | BaseGesture<LongPressGestureHandlerEventPayload> | BaseGesture<RotationGestureHandlerEventPayload> | BaseGesture<PinchGestureHandlerEventPayload> | BaseGesture<FlingGestureHandlerEventPayload> | BaseGesture<ForceTouchGestureHandlerEventPayload> | BaseGesture<NativeViewGestureHandlerPayload>;\nexport declare type GestureRef = number | GestureType | React.RefObject<GestureType | undefined> | React.RefObject<React.ComponentType | undefined>;\nexport interface BaseGestureConfig extends CommonGestureConfig, Record<string, unknown> {\n    ref?: React.MutableRefObject<GestureType | undefined>;\n    requireToFail?: GestureRef[];\n    simultaneousWith?: GestureRef[];\n    needsPointerData?: boolean;\n    manualActivation?: boolean;\n    runOnJS?: boolean;\n    testId?: string;\n    cancelsTouchesInView?: boolean;\n}\ndeclare type TouchEventHandlerType = (event: GestureTouchEvent, stateManager: GestureStateManagerType) => void;\nexport declare type HandlerCallbacks<EventPayloadT extends Record<string, unknown>> = {\n    gestureId: number;\n    handlerTag: number;\n    onBegin?: (event: GestureStateChangeEvent<EventPayloadT>) => void;\n    onStart?: (event: GestureStateChangeEvent<EventPayloadT>) => void;\n    onEnd?: (event: GestureStateChangeEvent<EventPayloadT>, success: boolean) => void;\n    onFinalize?: (event: GestureStateChangeEvent<EventPayloadT>, success: boolean) => void;\n    onUpdate?: (event: GestureUpdateEvent<EventPayloadT>) => void;\n    onChange?: (event: any) => void;\n    onTouchesDown?: TouchEventHandlerType;\n    onTouchesMove?: TouchEventHandlerType;\n    onTouchesUp?: TouchEventHandlerType;\n    onTouchesCancelled?: TouchEventHandlerType;\n    changeEventCalculator?: (current: GestureUpdateEvent<Record<string, unknown>>, previous?: GestureUpdateEvent<Record<string, unknown>>) => GestureUpdateEvent<Record<string, unknown>>;\n    isWorklet: boolean[];\n};\nexport declare const CALLBACK_TYPE: {\n    readonly UNDEFINED: 0;\n    readonly BEGAN: 1;\n    readonly START: 2;\n    readonly UPDATE: 3;\n    readonly CHANGE: 4;\n    readonly END: 5;\n    readonly FINALIZE: 6;\n    readonly TOUCHES_DOWN: 7;\n    readonly TOUCHES_MOVE: 8;\n    readonly TOUCHES_UP: 9;\n    readonly TOUCHES_CANCELLED: 10;\n};\nexport declare type CALLBACK_TYPE = typeof CALLBACK_TYPE[keyof typeof CALLBACK_TYPE];\nexport declare abstract class Gesture {\n    /**\n     * Return array of gestures, providing the same interface for creating and updating\n     * handlers, no matter which object was used to create gesture instance.\n     */\n    abstract toGestureArray(): GestureType[];\n    /**\n     * Assign handlerTag to the gesture instance and set ref.current (if a ref is set)\n     */\n    abstract initialize(): void;\n    /**\n     * Make sure that values of properties defining relations are arrays. Do any necessary\n     * preprocessing required to configure relations between handlers. Called just before\n     * updating the handler on the native side.\n     */\n    abstract prepare(): void;\n}\nexport declare abstract class BaseGesture<EventPayloadT extends Record<string, unknown>> extends Gesture {\n    private gestureId;\n    handlerTag: number;\n    handlerName: string;\n    config: BaseGestureConfig;\n    handlers: HandlerCallbacks<EventPayloadT>;\n    constructor();\n    private addDependency;\n    withRef(ref: React.MutableRefObject<GestureType | undefined>): this;\n    protected isWorklet(callback: Function): boolean;\n    onBegin(callback: (event: GestureStateChangeEvent<EventPayloadT>) => void): this;\n    onStart(callback: (event: GestureStateChangeEvent<EventPayloadT>) => void): this;\n    onEnd(callback: (event: GestureStateChangeEvent<EventPayloadT>, success: boolean) => void): this;\n    onFinalize(callback: (event: GestureStateChangeEvent<EventPayloadT>, success: boolean) => void): this;\n    onTouchesDown(callback: TouchEventHandlerType): this;\n    onTouchesMove(callback: TouchEventHandlerType): this;\n    onTouchesUp(callback: TouchEventHandlerType): this;\n    onTouchesCancelled(callback: TouchEventHandlerType): this;\n    enabled(enabled: boolean): this;\n    shouldCancelWhenOutside(value: boolean): this;\n    hitSlop(hitSlop: HitSlop): this;\n    runOnJS(runOnJS: boolean): this;\n    simultaneousWithExternalGesture(...gestures: Exclude<GestureRef, number>[]): this;\n    requireExternalGestureToFail(...gestures: Exclude<GestureRef, number>[]): this;\n    withTestId(id: string): this;\n    cancelsTouchesInView(value: boolean): this;\n    initialize(): void;\n    toGestureArray(): GestureType[];\n    prepare(): void;\n    get shouldUseReanimated(): boolean;\n}\nexport declare abstract class ContinousBaseGesture<EventPayloadT extends Record<string, unknown>, EventChangePayloadT extends Record<string, unknown>> extends BaseGesture<EventPayloadT> {\n    onUpdate(callback: (event: GestureUpdateEvent<EventPayloadT>) => void): this;\n    onChange(callback: (event: GestureUpdateEvent<EventPayloadT & EventChangePayloadT>) => void): this;\n    manualActivation(manualActivation: boolean): this;\n}\nexport {};\n"],"mappings":"AA0GA"},"metadata":{},"sourceType":"module","externalDependencies":[]}