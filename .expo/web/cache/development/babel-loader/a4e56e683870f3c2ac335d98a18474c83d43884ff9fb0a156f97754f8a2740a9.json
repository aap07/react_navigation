{"ast":null,"code":"import { Composer } from \"./compose/composer.js\";\nimport { Document } from \"./doc/Document.js\";\nimport { prettifyError, YAMLParseError } from \"./errors.js\";\nimport { warn } from \"./log.js\";\nimport { LineCounter } from \"./parse/line-counter.js\";\nimport { Parser } from \"./parse/parser.js\";\nfunction parseOptions(options) {\n  var prettyErrors = options.prettyErrors !== false;\n  var lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;\n  return {\n    lineCounter: lineCounter,\n    prettyErrors: prettyErrors\n  };\n}\nfunction parseAllDocuments(source) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _parseOptions = parseOptions(options),\n    lineCounter = _parseOptions.lineCounter,\n    prettyErrors = _parseOptions.prettyErrors;\n  var parser = new Parser(lineCounter == null ? void 0 : lineCounter.addNewLine);\n  var composer = new Composer(options);\n  var docs = Array.from(composer.compose(parser.parse(source)));\n  if (prettyErrors && lineCounter) for (var doc of docs) {\n    doc.errors.forEach(prettifyError(source, lineCounter));\n    doc.warnings.forEach(prettifyError(source, lineCounter));\n  }\n  if (docs.length > 0) return docs;\n  return Object.assign([], {\n    empty: true\n  }, composer.streamInfo());\n}\nfunction parseDocument(source) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _parseOptions2 = parseOptions(options),\n    lineCounter = _parseOptions2.lineCounter,\n    prettyErrors = _parseOptions2.prettyErrors;\n  var parser = new Parser(lineCounter == null ? void 0 : lineCounter.addNewLine);\n  var composer = new Composer(options);\n  var doc = null;\n  for (var _doc of composer.compose(parser.parse(source), true, source.length)) {\n    if (!doc) doc = _doc;else if (doc.options.logLevel !== 'silent') {\n      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));\n      break;\n    }\n  }\n  if (prettyErrors && lineCounter) {\n    doc.errors.forEach(prettifyError(source, lineCounter));\n    doc.warnings.forEach(prettifyError(source, lineCounter));\n  }\n  return doc;\n}\nfunction parse(src, reviver, options) {\n  var _reviver = undefined;\n  if (typeof reviver === 'function') {\n    _reviver = reviver;\n  } else if (options === undefined && reviver && typeof reviver === 'object') {\n    options = reviver;\n  }\n  var doc = parseDocument(src, options);\n  if (!doc) return null;\n  doc.warnings.forEach(function (warning) {\n    return warn(doc.options.logLevel, warning);\n  });\n  if (doc.errors.length > 0) {\n    if (doc.options.logLevel !== 'silent') throw doc.errors[0];else doc.errors = [];\n  }\n  return doc.toJS(Object.assign({\n    reviver: _reviver\n  }, options));\n}\nfunction stringify(value, replacer, options) {\n  var _replacer = null;\n  if (typeof replacer === 'function' || Array.isArray(replacer)) {\n    _replacer = replacer;\n  } else if (options === undefined && replacer) {\n    options = replacer;\n  }\n  if (typeof options === 'string') options = options.length;\n  if (typeof options === 'number') {\n    var indent = Math.round(options);\n    options = indent < 1 ? undefined : indent > 8 ? {\n      indent: 8\n    } : {\n      indent: indent\n    };\n  }\n  if (value === undefined) {\n    var _ref2, _options;\n    var _ref = (_ref2 = (_options = options) != null ? _options : replacer) != null ? _ref2 : {},\n      keepUndefined = _ref.keepUndefined;\n    if (!keepUndefined) return undefined;\n  }\n  return new Document(value, _replacer, options).toString(options);\n}\nexport { parse, parseAllDocuments, parseDocument, stringify };","map":{"version":3,"names":["Composer","Document","prettifyError","YAMLParseError","warn","LineCounter","Parser","parseOptions","options","prettyErrors","lineCounter","parseAllDocuments","source","arguments","length","undefined","_parseOptions","parser","addNewLine","composer","docs","Array","from","compose","parse","doc","errors","forEach","warnings","Object","assign","empty","streamInfo","parseDocument","_parseOptions2","_doc","logLevel","push","range","slice","src","reviver","_reviver","warning","toJS","stringify","value","replacer","_replacer","isArray","indent","Math","round","_ref2","_options","_ref","keepUndefined","toString"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native-community/cli-doctor/node_modules/yaml/browser/dist/public-api.js"],"sourcesContent":["import { Composer } from './compose/composer.js';\nimport { Document } from './doc/Document.js';\nimport { prettifyError, YAMLParseError } from './errors.js';\nimport { warn } from './log.js';\nimport { LineCounter } from './parse/line-counter.js';\nimport { Parser } from './parse/parser.js';\n\nfunction parseOptions(options) {\n    const prettyErrors = options.prettyErrors !== false;\n    const lineCounter = options.lineCounter || (prettyErrors && new LineCounter()) || null;\n    return { lineCounter, prettyErrors };\n}\n/**\n * Parse the input as a stream of YAML documents.\n *\n * Documents should be separated from each other by `...` or `---` marker lines.\n *\n * @returns If an empty `docs` array is returned, it will be of type\n *   EmptyStream and contain additional stream information. In\n *   TypeScript, you should use `'empty' in docs` as a type guard for it.\n */\nfunction parseAllDocuments(source, options = {}) {\n    const { lineCounter, prettyErrors } = parseOptions(options);\n    const parser = new Parser(lineCounter?.addNewLine);\n    const composer = new Composer(options);\n    const docs = Array.from(composer.compose(parser.parse(source)));\n    if (prettyErrors && lineCounter)\n        for (const doc of docs) {\n            doc.errors.forEach(prettifyError(source, lineCounter));\n            doc.warnings.forEach(prettifyError(source, lineCounter));\n        }\n    if (docs.length > 0)\n        return docs;\n    return Object.assign([], { empty: true }, composer.streamInfo());\n}\n/** Parse an input string into a single YAML.Document */\nfunction parseDocument(source, options = {}) {\n    const { lineCounter, prettyErrors } = parseOptions(options);\n    const parser = new Parser(lineCounter?.addNewLine);\n    const composer = new Composer(options);\n    // `doc` is always set by compose.end(true) at the very latest\n    let doc = null;\n    for (const _doc of composer.compose(parser.parse(source), true, source.length)) {\n        if (!doc)\n            doc = _doc;\n        else if (doc.options.logLevel !== 'silent') {\n            doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));\n            break;\n        }\n    }\n    if (prettyErrors && lineCounter) {\n        doc.errors.forEach(prettifyError(source, lineCounter));\n        doc.warnings.forEach(prettifyError(source, lineCounter));\n    }\n    return doc;\n}\nfunction parse(src, reviver, options) {\n    let _reviver = undefined;\n    if (typeof reviver === 'function') {\n        _reviver = reviver;\n    }\n    else if (options === undefined && reviver && typeof reviver === 'object') {\n        options = reviver;\n    }\n    const doc = parseDocument(src, options);\n    if (!doc)\n        return null;\n    doc.warnings.forEach(warning => warn(doc.options.logLevel, warning));\n    if (doc.errors.length > 0) {\n        if (doc.options.logLevel !== 'silent')\n            throw doc.errors[0];\n        else\n            doc.errors = [];\n    }\n    return doc.toJS(Object.assign({ reviver: _reviver }, options));\n}\nfunction stringify(value, replacer, options) {\n    let _replacer = null;\n    if (typeof replacer === 'function' || Array.isArray(replacer)) {\n        _replacer = replacer;\n    }\n    else if (options === undefined && replacer) {\n        options = replacer;\n    }\n    if (typeof options === 'string')\n        options = options.length;\n    if (typeof options === 'number') {\n        const indent = Math.round(options);\n        options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };\n    }\n    if (value === undefined) {\n        const { keepUndefined } = options ?? replacer ?? {};\n        if (!keepUndefined)\n            return undefined;\n    }\n    return new Document(value, _replacer, options).toString(options);\n}\n\nexport { parse, parseAllDocuments, parseDocument, stringify };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}