{"ast":null,"code":"export {};","map":{"version":3,"names":[],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/react-native-gesture-handler/lib/typescript/web_hammer/GestureHandler.d.ts"],"sourcesContent":["import { findNodeHandle } from 'react-native';\nimport { State } from '../State';\nimport { EventMap } from './constants';\nexport declare type HammerInputExt = Omit<HammerInput, 'destroy' | 'handler' | 'init'>;\nexport declare type Config = Partial<{\n    enabled: boolean;\n    minPointers: number;\n    maxPointers: number;\n    minDist: number;\n    minDistSq: number;\n    minVelocity: number;\n    minVelocitySq: number;\n    maxDist: number;\n    maxDistSq: number;\n    failOffsetXStart: number;\n    failOffsetYStart: number;\n    failOffsetXEnd: number;\n    failOffsetYEnd: number;\n    activeOffsetXStart: number;\n    activeOffsetXEnd: number;\n    activeOffsetYStart: number;\n    activeOffsetYEnd: number;\n    waitFor: any[] | null;\n    simultaneousHandlers: any[] | null;\n}>;\ndeclare abstract class GestureHandler {\n    handlerTag: any;\n    isGestureRunning: boolean;\n    view: number | null;\n    protected hasCustomActivationCriteria: boolean;\n    protected hasGestureFailed: boolean;\n    protected hammer: HammerManager | null;\n    protected initialRotation: number | null;\n    protected __initialX: any;\n    protected __initialY: any;\n    protected config: Config;\n    protected previousState: State;\n    private pendingGestures;\n    private oldState;\n    private lastSentState;\n    private gestureInstance;\n    private _stillWaiting;\n    private propsRef;\n    private ref;\n    abstract get name(): string;\n    get id(): string;\n    get isNative(): boolean;\n    get isDiscrete(): boolean;\n    get shouldEnableGestureOnSetup(): boolean;\n    constructor();\n    getConfig(): Partial<{\n        enabled: boolean;\n        minPointers: number;\n        maxPointers: number;\n        minDist: number;\n        minDistSq: number;\n        minVelocity: number;\n        minVelocitySq: number;\n        maxDist: number;\n        maxDistSq: number;\n        failOffsetXStart: number;\n        failOffsetYStart: number;\n        failOffsetXEnd: number;\n        failOffsetYEnd: number;\n        activeOffsetXStart: number;\n        activeOffsetXEnd: number;\n        activeOffsetYStart: number;\n        activeOffsetYEnd: number;\n        waitFor: any[] | null;\n        simultaneousHandlers: any[] | null;\n    }>;\n    onWaitingEnded(_gesture: this): void;\n    removePendingGesture(id: string): void;\n    addPendingGesture(gesture: this): void;\n    isGestureEnabledForEvent(_config: any, _recognizer: any, _event: any): {\n        failed?: boolean;\n        success?: boolean;\n    };\n    get NativeGestureClass(): RecognizerStatic;\n    updateHasCustomActivationCriteria(_config: Config): boolean;\n    clearSelfAsPending: () => void;\n    updateGestureConfig({ enabled, ...props }: {\n        [x: string]: any;\n        enabled?: boolean | undefined;\n    }): Partial<{\n        enabled: boolean;\n        minPointers: number;\n        maxPointers: number;\n        minDist: number;\n        minDistSq: number;\n        minVelocity: number;\n        minVelocitySq: number;\n        maxDist: number;\n        maxDistSq: number;\n        failOffsetXStart: number;\n        failOffsetYStart: number;\n        failOffsetXEnd: number;\n        failOffsetYEnd: number;\n        activeOffsetXStart: number;\n        activeOffsetXEnd: number;\n        activeOffsetYStart: number;\n        activeOffsetYEnd: number;\n        waitFor: any[] | null;\n        simultaneousHandlers: any[] | null;\n    }>;\n    destroy: () => void;\n    isPointInView: ({ x, y }: {\n        x: number;\n        y: number;\n    }) => boolean;\n    getState(type: keyof typeof EventMap): State;\n    transformEventData(event: HammerInputExt): {\n        nativeEvent: {\n            handlerTag: any;\n            target: any;\n            oldState: State | undefined;\n            numberOfPointers: number;\n            state: State;\n            pointerInside: boolean;\n        };\n        timeStamp: number;\n    };\n    transformNativeEvent(_event: HammerInputExt): {};\n    sendEvent: (nativeEvent: HammerInputExt) => void;\n    cancelPendingGestures(event: HammerInputExt): void;\n    notifyPendingGestures(): void;\n    onGestureEnded(event: HammerInputExt): void;\n    forceInvalidate(event: HammerInputExt): void;\n    cancelEvent(event: HammerInputExt): void;\n    onRawEvent({ isFirst }: HammerInputExt): void;\n    shouldUseTouchEvents(config: Config): boolean;\n    setView(ref: Parameters<typeof findNodeHandle>['0'], propsRef: any): void;\n    setupEvents(): void;\n    onStart({ deltaX, deltaY, rotation }: HammerInputExt): void;\n    onGestureActivated(ev: HammerInputExt): void;\n    onSuccess(): void;\n    _getPendingGestures(): any[];\n    getHammerConfig(): {\n        pointers: number | undefined;\n    };\n    sync: () => void;\n    simulateCancelEvent(_inputData: any): void;\n    ensureConfig(config: Config): Required<Config>;\n}\nexport default GestureHandler;\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}