{"ast":null,"code":"'use strict';\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError('Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.');\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === 'string') return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === 'Object' && o.constructor) n = o.constructor.name;\n  if (n === 'Map' || n === 'Set') return Array.from(o);\n  if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : 'undefined' != typeof Symbol && arr[Symbol.iterator] || arr['@@iterator'];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nvar _require = require(\"../Utils\"),\n  getSafePropertyName = _require.getSafePropertyName,\n  getNamespacedStructName = _require.getNamespacedStructName;\nvar _require2 = require(\"../../../Utils\"),\n  capitalize = _require2.capitalize;\nvar _require3 = require(\"../../../../parsers/parsers-commons\"),\n  unwrapNullable = _require3.unwrapNullable;\nvar StructTemplate = function StructTemplate(_ref) {\n  var hasteModuleName = _ref.hasteModuleName,\n    structName = _ref.structName,\n    builderInputProps = _ref.builderInputProps;\n  return `namespace JS {\n  namespace ${hasteModuleName} {\n    struct ${structName} {\n\n      struct Builder {\n        struct Input {\n          ${builderInputProps}\n        };\n\n        /** Initialize with a set of values */\n        Builder(const Input i);\n        /** Initialize with an existing ${structName} */\n        Builder(${structName} i);\n        /** Builds the object. Generally used only by the infrastructure. */\n        NSDictionary *buildUnsafeRawValue() const { return _factory(); };\n      private:\n        NSDictionary *(^_factory)(void);\n      };\n\n      static ${structName} fromUnsafeRawValue(NSDictionary *const v) { return {v}; }\n      NSDictionary *unsafeRawValue() const { return _v; }\n    private:\n      ${structName}(NSDictionary *const v) : _v(v) {}\n      NSDictionary *_v;\n    };\n  }\n}`;\n};\nvar MethodTemplate = function MethodTemplate(_ref2) {\n  var hasteModuleName = _ref2.hasteModuleName,\n    structName = _ref2.structName,\n    properties = _ref2.properties;\n  return `inline JS::${hasteModuleName}::${structName}::Builder::Builder(const Input i) : _factory(^{\n  NSMutableDictionary *d = [NSMutableDictionary new];\n${properties}\n  return d;\n}) {}\ninline JS::${hasteModuleName}::${structName}::Builder::Builder(${structName} i) : _factory(^{\n  return i.unsafeRawValue();\n}) {}`;\n};\nfunction toObjCType(hasteModuleName, nullableTypeAnnotation) {\n  var isOptional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var _unwrapNullable = unwrapNullable(nullableTypeAnnotation),\n    _unwrapNullable2 = _slicedToArray(_unwrapNullable, 2),\n    typeAnnotation = _unwrapNullable2[0],\n    nullable = _unwrapNullable2[1];\n  var isRequired = !nullable && !isOptional;\n  var wrapOptional = function wrapOptional(type) {\n    return isRequired ? type : `std::optional<${type}>`;\n  };\n  switch (typeAnnotation.type) {\n    case 'ReservedTypeAnnotation':\n      switch (typeAnnotation.name) {\n        case 'RootTag':\n          return wrapOptional('double');\n        default:\n          typeAnnotation.name;\n          throw new Error(`Unknown prop type, found: ${typeAnnotation.name}\"`);\n      }\n    case 'StringTypeAnnotation':\n      return 'NSString *';\n    case 'NumberTypeAnnotation':\n      return wrapOptional('double');\n    case 'FloatTypeAnnotation':\n      return wrapOptional('double');\n    case 'Int32TypeAnnotation':\n      return wrapOptional('double');\n    case 'DoubleTypeAnnotation':\n      return wrapOptional('double');\n    case 'BooleanTypeAnnotation':\n      return wrapOptional('bool');\n    case 'EnumDeclaration':\n      switch (typeAnnotation.memberType) {\n        case 'NumberTypeAnnotation':\n          return wrapOptional('double');\n        case 'StringTypeAnnotation':\n          return 'NSString *';\n        default:\n          throw new Error(`Couldn't convert enum into ObjC type: ${typeAnnotation.type}\"`);\n      }\n    case 'GenericObjectTypeAnnotation':\n      return isRequired ? 'id<NSObject> ' : 'id<NSObject> _Nullable ';\n    case 'ArrayTypeAnnotation':\n      if (typeAnnotation.elementType == null) {\n        return isRequired ? 'id<NSObject> ' : 'id<NSObject> _Nullable ';\n      }\n      return wrapOptional(`std::vector<${toObjCType(hasteModuleName, typeAnnotation.elementType)}>`);\n    case 'TypeAliasTypeAnnotation':\n      var structName = capitalize(typeAnnotation.name);\n      var namespacedStructName = getNamespacedStructName(hasteModuleName, structName);\n      return wrapOptional(`${namespacedStructName}::Builder`);\n    default:\n      typeAnnotation.type;\n      throw new Error(`Couldn't convert into ObjC type: ${typeAnnotation.type}\"`);\n  }\n}\nfunction toObjCValue(hasteModuleName, nullableTypeAnnotation, value, depth) {\n  var isOptional = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var _unwrapNullable3 = unwrapNullable(nullableTypeAnnotation),\n    _unwrapNullable4 = _slicedToArray(_unwrapNullable3, 2),\n    typeAnnotation = _unwrapNullable4[0],\n    nullable = _unwrapNullable4[1];\n  var isRequired = !nullable && !isOptional;\n  function wrapPrimitive(type) {\n    return !isRequired ? `${value}.has_value() ? @((${type})${value}.value()) : nil` : `@(${value})`;\n  }\n  switch (typeAnnotation.type) {\n    case 'ReservedTypeAnnotation':\n      switch (typeAnnotation.name) {\n        case 'RootTag':\n          return wrapPrimitive('double');\n        default:\n          typeAnnotation.name;\n          throw new Error(`Couldn't convert into ObjC type: ${typeAnnotation.type}\"`);\n      }\n    case 'StringTypeAnnotation':\n      return value;\n    case 'NumberTypeAnnotation':\n      return wrapPrimitive('double');\n    case 'FloatTypeAnnotation':\n      return wrapPrimitive('double');\n    case 'Int32TypeAnnotation':\n      return wrapPrimitive('double');\n    case 'DoubleTypeAnnotation':\n      return wrapPrimitive('double');\n    case 'BooleanTypeAnnotation':\n      return wrapPrimitive('BOOL');\n    case 'EnumDeclaration':\n      switch (typeAnnotation.memberType) {\n        case 'NumberTypeAnnotation':\n          return wrapPrimitive('double');\n        case 'StringTypeAnnotation':\n          return value;\n        default:\n          throw new Error(`Couldn't convert enum into ObjC value: ${typeAnnotation.type}\"`);\n      }\n    case 'GenericObjectTypeAnnotation':\n      return value;\n    case 'ArrayTypeAnnotation':\n      var elementType = typeAnnotation.elementType;\n      if (elementType == null) {\n        return value;\n      }\n      var localVarName = `el${'_'.repeat(depth + 1)}`;\n      var elementObjCType = toObjCType(hasteModuleName, elementType);\n      var elementObjCValue = toObjCValue(hasteModuleName, elementType, localVarName, depth + 1);\n      var RCTConvertVecToArray = function RCTConvertVecToArray(transformer) {\n        return `RCTConvert${!isRequired ? 'Optional' : ''}VecToArray(${value}, ${transformer})`;\n      };\n      return RCTConvertVecToArray(`^id(${elementObjCType} ${localVarName}) { return ${elementObjCValue}; }`);\n    case 'TypeAliasTypeAnnotation':\n      return !isRequired ? `${value}.has_value() ? ${value}.value().buildUnsafeRawValue() : nil` : `${value}.buildUnsafeRawValue()`;\n    default:\n      typeAnnotation.type;\n      throw new Error(`Couldn't convert into ObjC value: ${typeAnnotation.type}\"`);\n  }\n}\nfunction serializeConstantsStruct(hasteModuleName, struct) {\n  var declaration = StructTemplate({\n    hasteModuleName: hasteModuleName,\n    structName: struct.name,\n    builderInputProps: struct.properties.map(function (property) {\n      var typeAnnotation = property.typeAnnotation,\n        optional = property.optional;\n      var safePropName = getSafePropertyName(property);\n      var objCType = toObjCType(hasteModuleName, typeAnnotation, optional);\n      if (!optional) {\n        return `RCTRequired<${objCType}> ${safePropName};`;\n      }\n      var space = ' '.repeat(objCType.endsWith('*') ? 0 : 1);\n      return `${objCType}${space}${safePropName};`;\n    }).join('\\n          ')\n  });\n  var methods = MethodTemplate({\n    hasteModuleName: hasteModuleName,\n    structName: struct.name,\n    properties: struct.properties.map(function (property) {\n      var typeAnnotation = property.typeAnnotation,\n        optional = property.optional,\n        propName = property.name;\n      var safePropName = getSafePropertyName(property);\n      var objCValue = toObjCValue(hasteModuleName, typeAnnotation, safePropName, 0, optional);\n      var varDecl = `auto ${safePropName} = i.${safePropName}`;\n      if (!optional) {\n        varDecl += '.get()';\n      }\n      var assignment = `d[@\"${propName}\"] = ` + objCValue;\n      return `  ${varDecl};\\n  ${assignment};`;\n    }).join('\\n')\n  });\n  return {\n    declaration: declaration,\n    methods: methods\n  };\n}\nmodule.exports = {\n  serializeConstantsStruct: serializeConstantsStruct\n};","map":{"version":3,"names":["_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","len","length","arr2","_i","Symbol","iterator","_s","_e","_x","_r","_arr","_n","_d","next","done","push","value","err","return","isArray","_require","require","getSafePropertyName","getNamespacedStructName","_require2","capitalize","_require3","unwrapNullable","StructTemplate","_ref","hasteModuleName","structName","builderInputProps","MethodTemplate","_ref2","properties","toObjCType","nullableTypeAnnotation","isOptional","arguments","undefined","_unwrapNullable","_unwrapNullable2","typeAnnotation","nullable","isRequired","wrapOptional","type","Error","memberType","elementType","namespacedStructName","toObjCValue","depth","_unwrapNullable3","_unwrapNullable4","wrapPrimitive","localVarName","repeat","elementObjCType","elementObjCValue","RCTConvertVecToArray","transformer","serializeConstantsStruct","struct","declaration","map","property","optional","safePropName","objCType","space","endsWith","join","methods","propName","objCValue","varDecl","assignment","module","exports"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native/codegen/lib/generators/modules/GenerateModuleObjCpp/header/serializeConstantsStruct.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\n'use strict';\n\nfunction _slicedToArray(arr, i) {\n  return (\n    _arrayWithHoles(arr) ||\n    _iterableToArrayLimit(arr, i) ||\n    _unsupportedIterableToArray(arr, i) ||\n    _nonIterableRest()\n  );\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\n    'Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',\n  );\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === 'string') return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === 'Object' && o.constructor) n = o.constructor.name;\n  if (n === 'Map' || n === 'Set') return Array.from(o);\n  if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n    return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i =\n    null == arr\n      ? null\n      : ('undefined' != typeof Symbol && arr[Symbol.iterator]) ||\n        arr['@@iterator'];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (((_x = (_i = _i.call(arr)).next), 0 === i)) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else\n        for (\n          ;\n          !(_n = (_s = _x.call(_i)).done) &&\n          (_arr.push(_s.value), _arr.length !== i);\n          _n = !0\n        );\n    } catch (err) {\n      (_d = !0), (_e = err);\n    } finally {\n      try {\n        if (!_n && null != _i.return && ((_r = _i.return()), Object(_r) !== _r))\n          return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nconst _require = require('../Utils'),\n  getSafePropertyName = _require.getSafePropertyName,\n  getNamespacedStructName = _require.getNamespacedStructName;\nconst _require2 = require('../../../Utils'),\n  capitalize = _require2.capitalize;\nconst _require3 = require('../../../../parsers/parsers-commons'),\n  unwrapNullable = _require3.unwrapNullable;\nconst StructTemplate = ({\n  hasteModuleName,\n  structName,\n  builderInputProps,\n}) => `namespace JS {\n  namespace ${hasteModuleName} {\n    struct ${structName} {\n\n      struct Builder {\n        struct Input {\n          ${builderInputProps}\n        };\n\n        /** Initialize with a set of values */\n        Builder(const Input i);\n        /** Initialize with an existing ${structName} */\n        Builder(${structName} i);\n        /** Builds the object. Generally used only by the infrastructure. */\n        NSDictionary *buildUnsafeRawValue() const { return _factory(); };\n      private:\n        NSDictionary *(^_factory)(void);\n      };\n\n      static ${structName} fromUnsafeRawValue(NSDictionary *const v) { return {v}; }\n      NSDictionary *unsafeRawValue() const { return _v; }\n    private:\n      ${structName}(NSDictionary *const v) : _v(v) {}\n      NSDictionary *_v;\n    };\n  }\n}`;\nconst MethodTemplate = ({\n  hasteModuleName,\n  structName,\n  properties,\n}) => `inline JS::${hasteModuleName}::${structName}::Builder::Builder(const Input i) : _factory(^{\n  NSMutableDictionary *d = [NSMutableDictionary new];\n${properties}\n  return d;\n}) {}\ninline JS::${hasteModuleName}::${structName}::Builder::Builder(${structName} i) : _factory(^{\n  return i.unsafeRawValue();\n}) {}`;\nfunction toObjCType(\n  hasteModuleName,\n  nullableTypeAnnotation,\n  isOptional = false,\n) {\n  const _unwrapNullable = unwrapNullable(nullableTypeAnnotation),\n    _unwrapNullable2 = _slicedToArray(_unwrapNullable, 2),\n    typeAnnotation = _unwrapNullable2[0],\n    nullable = _unwrapNullable2[1];\n  const isRequired = !nullable && !isOptional;\n  const wrapOptional = type => {\n    return isRequired ? type : `std::optional<${type}>`;\n  };\n  switch (typeAnnotation.type) {\n    case 'ReservedTypeAnnotation':\n      switch (typeAnnotation.name) {\n        case 'RootTag':\n          return wrapOptional('double');\n        default:\n          typeAnnotation.name;\n          throw new Error(`Unknown prop type, found: ${typeAnnotation.name}\"`);\n      }\n    case 'StringTypeAnnotation':\n      return 'NSString *';\n    case 'NumberTypeAnnotation':\n      return wrapOptional('double');\n    case 'FloatTypeAnnotation':\n      return wrapOptional('double');\n    case 'Int32TypeAnnotation':\n      return wrapOptional('double');\n    case 'DoubleTypeAnnotation':\n      return wrapOptional('double');\n    case 'BooleanTypeAnnotation':\n      return wrapOptional('bool');\n    case 'EnumDeclaration':\n      switch (typeAnnotation.memberType) {\n        case 'NumberTypeAnnotation':\n          return wrapOptional('double');\n        case 'StringTypeAnnotation':\n          return 'NSString *';\n        default:\n          throw new Error(\n            `Couldn't convert enum into ObjC type: ${typeAnnotation.type}\"`,\n          );\n      }\n    case 'GenericObjectTypeAnnotation':\n      return isRequired ? 'id<NSObject> ' : 'id<NSObject> _Nullable ';\n    case 'ArrayTypeAnnotation':\n      if (typeAnnotation.elementType == null) {\n        return isRequired ? 'id<NSObject> ' : 'id<NSObject> _Nullable ';\n      }\n      return wrapOptional(\n        `std::vector<${toObjCType(\n          hasteModuleName,\n          typeAnnotation.elementType,\n        )}>`,\n      );\n    case 'TypeAliasTypeAnnotation':\n      const structName = capitalize(typeAnnotation.name);\n      const namespacedStructName = getNamespacedStructName(\n        hasteModuleName,\n        structName,\n      );\n      return wrapOptional(`${namespacedStructName}::Builder`);\n    default:\n      typeAnnotation.type;\n      throw new Error(\n        `Couldn't convert into ObjC type: ${typeAnnotation.type}\"`,\n      );\n  }\n}\nfunction toObjCValue(\n  hasteModuleName,\n  nullableTypeAnnotation,\n  value,\n  depth,\n  isOptional = false,\n) {\n  const _unwrapNullable3 = unwrapNullable(nullableTypeAnnotation),\n    _unwrapNullable4 = _slicedToArray(_unwrapNullable3, 2),\n    typeAnnotation = _unwrapNullable4[0],\n    nullable = _unwrapNullable4[1];\n  const isRequired = !nullable && !isOptional;\n  function wrapPrimitive(type) {\n    return !isRequired\n      ? `${value}.has_value() ? @((${type})${value}.value()) : nil`\n      : `@(${value})`;\n  }\n  switch (typeAnnotation.type) {\n    case 'ReservedTypeAnnotation':\n      switch (typeAnnotation.name) {\n        case 'RootTag':\n          return wrapPrimitive('double');\n        default:\n          typeAnnotation.name;\n          throw new Error(\n            `Couldn't convert into ObjC type: ${typeAnnotation.type}\"`,\n          );\n      }\n    case 'StringTypeAnnotation':\n      return value;\n    case 'NumberTypeAnnotation':\n      return wrapPrimitive('double');\n    case 'FloatTypeAnnotation':\n      return wrapPrimitive('double');\n    case 'Int32TypeAnnotation':\n      return wrapPrimitive('double');\n    case 'DoubleTypeAnnotation':\n      return wrapPrimitive('double');\n    case 'BooleanTypeAnnotation':\n      return wrapPrimitive('BOOL');\n    case 'EnumDeclaration':\n      switch (typeAnnotation.memberType) {\n        case 'NumberTypeAnnotation':\n          return wrapPrimitive('double');\n        case 'StringTypeAnnotation':\n          return value;\n        default:\n          throw new Error(\n            `Couldn't convert enum into ObjC value: ${typeAnnotation.type}\"`,\n          );\n      }\n    case 'GenericObjectTypeAnnotation':\n      return value;\n    case 'ArrayTypeAnnotation':\n      const elementType = typeAnnotation.elementType;\n      if (elementType == null) {\n        return value;\n      }\n      const localVarName = `el${'_'.repeat(depth + 1)}`;\n      const elementObjCType = toObjCType(hasteModuleName, elementType);\n      const elementObjCValue = toObjCValue(\n        hasteModuleName,\n        elementType,\n        localVarName,\n        depth + 1,\n      );\n      const RCTConvertVecToArray = transformer => {\n        return `RCTConvert${\n          !isRequired ? 'Optional' : ''\n        }VecToArray(${value}, ${transformer})`;\n      };\n      return RCTConvertVecToArray(\n        `^id(${elementObjCType} ${localVarName}) { return ${elementObjCValue}; }`,\n      );\n    case 'TypeAliasTypeAnnotation':\n      return !isRequired\n        ? `${value}.has_value() ? ${value}.value().buildUnsafeRawValue() : nil`\n        : `${value}.buildUnsafeRawValue()`;\n    default:\n      typeAnnotation.type;\n      throw new Error(\n        `Couldn't convert into ObjC value: ${typeAnnotation.type}\"`,\n      );\n  }\n}\nfunction serializeConstantsStruct(hasteModuleName, struct) {\n  const declaration = StructTemplate({\n    hasteModuleName,\n    structName: struct.name,\n    builderInputProps: struct.properties\n      .map(property => {\n        const typeAnnotation = property.typeAnnotation,\n          optional = property.optional;\n        const safePropName = getSafePropertyName(property);\n        const objCType = toObjCType(hasteModuleName, typeAnnotation, optional);\n        if (!optional) {\n          return `RCTRequired<${objCType}> ${safePropName};`;\n        }\n        const space = ' '.repeat(objCType.endsWith('*') ? 0 : 1);\n        return `${objCType}${space}${safePropName};`;\n      })\n      .join('\\n          '),\n  });\n  const methods = MethodTemplate({\n    hasteModuleName,\n    structName: struct.name,\n    properties: struct.properties\n      .map(property => {\n        const typeAnnotation = property.typeAnnotation,\n          optional = property.optional,\n          propName = property.name;\n        const safePropName = getSafePropertyName(property);\n        const objCValue = toObjCValue(\n          hasteModuleName,\n          typeAnnotation,\n          safePropName,\n          0,\n          optional,\n        );\n        let varDecl = `auto ${safePropName} = i.${safePropName}`;\n        if (!optional) {\n          varDecl += '.get()';\n        }\n        const assignment = `d[@\"${propName}\"] = ` + objCValue;\n        return `  ${varDecl};\\n  ${assignment};`;\n      })\n      .join('\\n'),\n  });\n  return {\n    declaration,\n    methods,\n  };\n}\nmodule.exports = {\n  serializeConstantsStruct,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}