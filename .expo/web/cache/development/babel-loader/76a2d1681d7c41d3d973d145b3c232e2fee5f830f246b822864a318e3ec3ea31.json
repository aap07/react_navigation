{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _spawnAsync = _interopRequireDefault(require(\"@expo/spawn-async\"));\nvar _childProcess = require(\"child_process\");\nvar _log = require(\"../../../log\");\nvar _errors = require(\"../../../utils/errors\");\nvar _exit = require(\"../../../utils/exit\");\nvar _androidSdk = require(\"./AndroidSdk\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar debug = require(\"debug\")(\"expo:start:platforms:android:adbServer\");\nvar BEGINNING_OF_ADB_ERROR_MESSAGE = \"error: \";\nvar ADBServer = function () {\n  function ADBServer() {\n    _classCallCheck(this, ADBServer);\n    this.isRunning = false;\n    this.removeExitHook = function () {};\n  }\n  _createClass(ADBServer, [{\n    key: \"getAdbExecutablePath\",\n    value: function getAdbExecutablePath() {\n      try {\n        var sdkRoot = (0, _androidSdk).assertSdkRoot();\n        if (sdkRoot) {\n          return `${sdkRoot}/platform-tools/adb`;\n        }\n      } catch (error) {\n        _log.Log.warn(error.message);\n      }\n      _log.Log.debug(\"Failed to resolve the Android SDK path, falling back to global adb executable\");\n      return \"adb\";\n    }\n  }, {\n    key: \"startAsync\",\n    value: function () {\n      var _startAsync = _asyncToGenerator(function* () {\n        var _this = this;\n        if (this.isRunning) {\n          return false;\n        }\n        this.removeExitHook = (0, _exit).installExitHooks(function () {\n          if (_this.isRunning) {\n            _this.stopAsync();\n          }\n        });\n        var adb = this.getAdbExecutablePath();\n        var result = yield this.resolveAdbPromise((0, _spawnAsync).default(adb, [\"start-server\"]));\n        var lines = result.stderr.trim().split(/\\r?\\n/);\n        var isStarted = lines.includes(\"* daemon started successfully\");\n        this.isRunning = isStarted;\n        return isStarted;\n      });\n      function startAsync() {\n        return _startAsync.apply(this, arguments);\n      }\n      return startAsync;\n    }()\n  }, {\n    key: \"stopAsync\",\n    value: function () {\n      var _stopAsync = _asyncToGenerator(function* () {\n        debug(\"Stopping ADB server\");\n        if (!this.isRunning) {\n          debug(\"ADB server is not running\");\n          return false;\n        }\n        this.removeExitHook();\n        try {\n          yield this.runAsync([\"kill-server\"]);\n          return true;\n        } catch (error) {\n          _log.Log.error(\"Failed to stop ADB server: \" + error.message);\n          return false;\n        } finally {\n          debug(\"Stopped ADB server\");\n          this.isRunning = false;\n        }\n      });\n      function stopAsync() {\n        return _stopAsync.apply(this, arguments);\n      }\n      return stopAsync;\n    }()\n  }, {\n    key: \"runAsync\",\n    value: function () {\n      var _runAsync = _asyncToGenerator(function* (args) {\n        var adb = this.getAdbExecutablePath();\n        yield this.startAsync();\n        debug([adb].concat(_toConsumableArray(args)).join(\" \"));\n        var result = yield this.resolveAdbPromise((0, _spawnAsync).default(adb, args));\n        return result.output.join(\"\\n\");\n      });\n      function runAsync(_x) {\n        return _runAsync.apply(this, arguments);\n      }\n      return runAsync;\n    }()\n  }, {\n    key: \"getFileOutputAsync\",\n    value: function () {\n      var _getFileOutputAsync = _asyncToGenerator(function* (args) {\n        var adb = this.getAdbExecutablePath();\n        yield this.startAsync();\n        var results = yield this.resolveAdbPromise((0, _childProcess).execFileSync(adb, args, {\n          encoding: \"latin1\",\n          stdio: \"pipe\"\n        }));\n        debug(\"[ADB] File output:\\n\", results);\n        return results;\n      });\n      function getFileOutputAsync(_x2) {\n        return _getFileOutputAsync.apply(this, arguments);\n      }\n      return getFileOutputAsync;\n    }()\n  }, {\n    key: \"resolveAdbPromise\",\n    value: function () {\n      var _resolveAdbPromise = _asyncToGenerator(function* (promise) {\n        try {\n          return yield promise;\n        } catch (error) {\n          if (error.signal === \"SIGINT\") {\n            throw new _errors.AbortCommandError();\n          }\n          var errorMessage = (error.stderr || error.stdout || error.message).trim();\n          if (errorMessage.startsWith(BEGINNING_OF_ADB_ERROR_MESSAGE)) {\n            errorMessage = errorMessage.substring(BEGINNING_OF_ADB_ERROR_MESSAGE.length);\n          }\n          error.message = errorMessage;\n          throw error;\n        }\n      });\n      function resolveAdbPromise(_x3) {\n        return _resolveAdbPromise.apply(this, arguments);\n      }\n      return resolveAdbPromise;\n    }()\n  }]);\n  return ADBServer;\n}();\nexports.ADBServer = ADBServer;","map":{"version":3,"names":["_toConsumableArray","require","_asyncToGenerator","_classCallCheck","_createClass","_spawnAsync","_interopRequireDefault","_childProcess","_log","_errors","_exit","_androidSdk","debug","BEGINNING_OF_ADB_ERROR_MESSAGE","ADBServer","isRunning","removeExitHook","key","value","getAdbExecutablePath","sdkRoot","assertSdkRoot","error","Log","warn","message","_startAsync","_this","installExitHooks","stopAsync","adb","result","resolveAdbPromise","default","lines","stderr","trim","split","isStarted","includes","startAsync","apply","arguments","_stopAsync","runAsync","_runAsync","args","concat","join","output","_x","_getFileOutputAsync","results","execFileSync","encoding","stdio","getFileOutputAsync","_x2","_resolveAdbPromise","promise","signal","AbortCommandError","errorMessage","stdout","startsWith","substring","length","_x3"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\cli\\src\\start\\platforms\\android\\ADBServer.ts"],"sourcesContent":["import spawnAsync from '@expo/spawn-async';\nimport { execFileSync } from 'child_process';\n\nimport { Log } from '../../../log';\nimport { AbortCommandError } from '../../../utils/errors';\nimport { installExitHooks } from '../../../utils/exit';\nimport { assertSdkRoot } from './AndroidSdk';\n\nconst debug = require('debug')('expo:start:platforms:android:adbServer') as typeof console.log;\n\nconst BEGINNING_OF_ADB_ERROR_MESSAGE = 'error: ';\n\n// This is a tricky class since it controls a system state (side-effects).\n// A more ideal solution would be to implement ADB in JS.\n// The main reason this is a class is to control the flow of testing.\n\nexport class ADBServer {\n  isRunning: boolean = false;\n  removeExitHook: () => void = () => {};\n\n  /** Returns the command line reference to ADB. */\n  getAdbExecutablePath(): string {\n    try {\n      const sdkRoot = assertSdkRoot();\n      if (sdkRoot) {\n        return `${sdkRoot}/platform-tools/adb`;\n      }\n    } catch (error: any) {\n      Log.warn(error.message);\n    }\n\n    Log.debug('Failed to resolve the Android SDK path, falling back to global adb executable');\n    return 'adb';\n  }\n\n  /** Start the ADB server. */\n  async startAsync(): Promise<boolean> {\n    if (this.isRunning) {\n      return false;\n    }\n    // clean up\n    this.removeExitHook = installExitHooks(() => {\n      if (this.isRunning) {\n        this.stopAsync();\n      }\n    });\n    const adb = this.getAdbExecutablePath();\n    const result = await this.resolveAdbPromise(spawnAsync(adb, ['start-server']));\n    const lines = result.stderr.trim().split(/\\r?\\n/);\n    const isStarted = lines.includes('* daemon started successfully');\n    this.isRunning = isStarted;\n    return isStarted;\n  }\n\n  /** Kill the ADB server. */\n  async stopAsync(): Promise<boolean> {\n    debug('Stopping ADB server');\n\n    if (!this.isRunning) {\n      debug('ADB server is not running');\n      return false;\n    }\n    this.removeExitHook();\n    try {\n      await this.runAsync(['kill-server']);\n      return true;\n    } catch (error: any) {\n      Log.error('Failed to stop ADB server: ' + error.message);\n      return false;\n    } finally {\n      debug('Stopped ADB server');\n      this.isRunning = false;\n    }\n  }\n\n  /** Execute an ADB command with given args. */\n  async runAsync(args: string[]): Promise<string> {\n    // TODO: Add a global package that installs adb to the path.\n    const adb = this.getAdbExecutablePath();\n\n    await this.startAsync();\n\n    debug([adb, ...args].join(' '));\n    const result = await this.resolveAdbPromise(spawnAsync(adb, args));\n    return result.output.join('\\n');\n  }\n\n  /** Get ADB file output. Useful for reading device state/settings. */\n  async getFileOutputAsync(args: string[]): Promise<string> {\n    // TODO: Add a global package that installs adb to the path.\n    const adb = this.getAdbExecutablePath();\n\n    await this.startAsync();\n\n    const results = await this.resolveAdbPromise(\n      execFileSync(adb, args, {\n        encoding: 'latin1',\n        stdio: 'pipe',\n      })\n    );\n    debug('[ADB] File output:\\n', results);\n    return results;\n  }\n\n  /** Formats error info. */\n  async resolveAdbPromise<T>(promise: T | Promise<T>): Promise<T> {\n    try {\n      return await promise;\n    } catch (error: any) {\n      // User pressed ctrl+c to cancel the process...\n      if (error.signal === 'SIGINT') {\n        throw new AbortCommandError();\n      }\n      // TODO: Support heap corruption for adb 29 (process exits with code -1073740940) (windows and linux)\n      let errorMessage = (error.stderr || error.stdout || error.message).trim();\n      if (errorMessage.startsWith(BEGINNING_OF_ADB_ERROR_MESSAGE)) {\n        errorMessage = errorMessage.substring(BEGINNING_OF_ADB_ERROR_MESSAGE.length);\n      }\n      error.message = errorMessage;\n      throw error;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}