{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __commonJS = function __commonJS(cb, mod) {\n  return function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {\n      exports: {}\n    }).exports, mod), mod.exports;\n  };\n};\nvar require_commonObjects = __commonJS({\n  \"lib/commonObjects.js\": function libCommonObjectsJs(exports2) {\n    \"use strict\";\n\n    Object.defineProperty(exports2, \"__esModule\", {\n      value: true\n    });\n    exports2.globals = void 0;\n    exports2.globals = new Set([\"this\", \"console\", \"performance\", \"Date\", \"Array\", \"ArrayBuffer\", \"Int8Array\", \"Int16Array\", \"Int32Array\", \"Uint8Array\", \"Uint8ClampedArray\", \"Uint16Array\", \"Uint32Array\", \"Float32Array\", \"Float64Array\", \"HermesInternal\", \"JSON\", \"Math\", \"Number\", \"Object\", \"String\", \"Symbol\", \"undefined\", \"null\", \"UIManager\", \"requestAnimationFrame\", \"setImmediate\", \"queueMicrotask\", \"_WORKLET\", \"arguments\", \"Boolean\", \"parseInt\", \"parseFloat\", \"Map\", \"WeakMap\", \"Proxy\", \"WeakRef\", \"Set\", \"_log\", \"_scheduleOnJS\", \"_makeShareableClone\", \"_updateDataSynchronously\", \"eval\", \"_updatePropsPaper\", \"_updatePropsFabric\", \"_removeShadowNodeFromRegistry\", \"RegExp\", \"Error\", \"__ErrorUtils\", \"global\", \"_measure\", \"_scrollTo\", \"_dispatchCommand\", \"_setGestureState\", \"isNaN\", \"LayoutAnimationRepository\", \"_notifyAboutProgress\", \"_notifyAboutEnd\", \"_runOnUIQueue\"]);\n  }\n});\nvar require_utils = __commonJS({\n  \"lib/utils.js\": function libUtilsJs(exports2) {\n    \"use strict\";\n\n    Object.defineProperty(exports2, \"__esModule\", {\n      value: true\n    });\n    exports2.isRelease = void 0;\n    function isRelease() {\n      return process.env.BABEL_ENV && [\"production\", \"release\"].includes(process.env.BABEL_ENV);\n    }\n    exports2.isRelease = isRelease;\n  }\n});\nvar require_buildWorkletString = __commonJS({\n  \"lib/buildWorkletString.js\": function libBuildWorkletStringJs(exports2) {\n    \"use strict\";\n\n    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function (o, m, k, k2) {\n      if (k2 === void 0) k2 = k;\n      var desc = Object.getOwnPropertyDescriptor(m, k);\n      if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n          enumerable: true,\n          get: function get() {\n            return m[k];\n          }\n        };\n      }\n      Object.defineProperty(o, k2, desc);\n    } : function (o, m, k, k2) {\n      if (k2 === void 0) k2 = k;\n      o[k2] = m[k];\n    });\n    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function (o, v) {\n      Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n      });\n    } : function (o, v) {\n      o[\"default\"] = v;\n    });\n    var __importStar = exports2 && exports2.__importStar || function (mod) {\n      if (mod && mod.__esModule) return mod;\n      var result = {};\n      if (mod != null) {\n        for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n      }\n      __setModuleDefault(result, mod);\n      return result;\n    };\n    var __importDefault = exports2 && exports2.__importDefault || function (mod) {\n      return mod && mod.__esModule ? mod : {\n        \"default\": mod\n      };\n    };\n    Object.defineProperty(exports2, \"__esModule\", {\n      value: true\n    });\n    exports2.buildWorkletString = void 0;\n    var core_1 = require(\"@babel/core\");\n    var generator_1 = __importDefault(require(\"@babel/generator\"));\n    var types_1 = require(\"@babel/types\");\n    var fs = __importStar(require(\"fs\"));\n    var convertSourceMap = __importStar(require(\"convert-source-map\"));\n    var assert_1 = require(\"assert\");\n    var utils_1 = require_utils();\n    function buildWorkletString(fun, closureVariables, name, inputMap) {\n      var draftExpression = fun.program.body.find(function (obj) {\n        return (0, types_1.isFunctionDeclaration)(obj);\n      }) || fun.program.body.find(function (obj) {\n        return (0, types_1.isExpressionStatement)(obj);\n      }) || void 0;\n      (0, assert_1.strict)(draftExpression, \"'draftExpression' is undefined\");\n      var expression = (0, types_1.isFunctionDeclaration)(draftExpression) ? draftExpression : draftExpression.expression;\n      (0, assert_1.strict)(\"params\" in expression, \"'params' property is undefined in 'expression'\");\n      (0, assert_1.strict)((0, types_1.isBlockStatement)(expression.body), \"'expression.body' is not a 'BlockStatement'\");\n      var workletFunction = (0, types_1.functionExpression)((0, types_1.identifier)(name), expression.params, expression.body);\n      var code = (0, generator_1.default)(workletFunction).code;\n      (0, assert_1.strict)(inputMap, \"'inputMap' is undefined\");\n      var includeSourceMap = shouldGenerateSourceMap();\n      if (includeSourceMap) {\n        inputMap.sourcesContent = [];\n        for (var sourceFile of inputMap.sources) {\n          inputMap.sourcesContent.push(fs.readFileSync(sourceFile).toString(\"utf-8\"));\n        }\n      }\n      var transformed = (0, core_1.transformSync)(code, {\n        plugins: [prependClosureVariablesIfNecessary(closureVariables)],\n        compact: !includeSourceMap,\n        sourceMaps: includeSourceMap,\n        inputSourceMap: inputMap,\n        ast: false,\n        babelrc: false,\n        configFile: false,\n        comments: false\n      });\n      (0, assert_1.strict)(transformed, \"'transformed' is null\");\n      var sourceMap;\n      if (includeSourceMap) {\n        sourceMap = convertSourceMap.fromObject(transformed.map).toObject();\n        delete sourceMap.sourcesContent;\n      }\n      return [transformed.code, JSON.stringify(sourceMap)];\n    }\n    exports2.buildWorkletString = buildWorkletString;\n    function shouldGenerateSourceMap() {\n      if ((0, utils_1.isRelease)()) {\n        return false;\n      }\n      if (process.env.REANIMATED_JEST_DISABLE_SOURCEMAP === \"jest\") {\n        return false;\n      }\n      return true;\n    }\n    function prependClosure(path, closureVariables, closureDeclaration) {\n      if (closureVariables.length === 0 || !(0, types_1.isProgram)(path.parent)) {\n        return;\n      }\n      if (!(0, types_1.isExpression)(path.node.body)) {\n        path.node.body.body.unshift(closureDeclaration);\n      }\n    }\n    function prependRecursiveDeclaration(path) {\n      var _a;\n      if ((0, types_1.isProgram)(path.parent) && !(0, types_1.isArrowFunctionExpression)(path.node) && !(0, types_1.isObjectMethod)(path.node) && path.node.id && path.scope.parent) {\n        var hasRecursiveCalls = ((_a = path.scope.parent.bindings[path.node.id.name]) === null || _a === void 0 ? void 0 : _a.references) > 0;\n        if (hasRecursiveCalls) {\n          path.node.body.body.unshift((0, types_1.variableDeclaration)(\"const\", [(0, types_1.variableDeclarator)((0, types_1.identifier)(path.node.id.name), (0, types_1.memberExpression)((0, types_1.thisExpression)(), (0, types_1.identifier)(\"_recur\")))]));\n        }\n      }\n    }\n    function prependClosureVariablesIfNecessary(closureVariables) {\n      var closureDeclaration = (0, types_1.variableDeclaration)(\"const\", [(0, types_1.variableDeclarator)((0, types_1.objectPattern)(closureVariables.map(function (variable) {\n        return (0, types_1.objectProperty)((0, types_1.identifier)(variable.name), (0, types_1.identifier)(variable.name), false, true);\n      })), (0, types_1.memberExpression)((0, types_1.thisExpression)(), (0, types_1.identifier)(\"_closure\")))]);\n      return {\n        visitor: {\n          \"FunctionDeclaration|FunctionExpression|ArrowFunctionExpression|ObjectMethod\": function FunctionDeclarationFunctionExpressionArrowFunctionExpressionObjectMethod(path) {\n            prependClosure(path, closureVariables, closureDeclaration);\n            prependRecursiveDeclaration(path);\n          }\n        }\n      };\n    }\n  }\n});\nvar require_makeWorklet = __commonJS({\n  \"lib/makeWorklet.js\": function libMakeWorkletJs(exports2) {\n    \"use strict\";\n\n    var __importDefault = exports2 && exports2.__importDefault || function (mod) {\n      return mod && mod.__esModule ? mod : {\n        \"default\": mod\n      };\n    };\n    Object.defineProperty(exports2, \"__esModule\", {\n      value: true\n    });\n    exports2.makeWorklet = void 0;\n    var core_1 = require(\"@babel/core\");\n    var generator_1 = __importDefault(require(\"@babel/generator\"));\n    var types_1 = require(\"@babel/types\");\n    var utils_1 = require_utils();\n    var assert_1 = require(\"assert\");\n    var commonObjects_12 = require_commonObjects();\n    var path_1 = require(\"path\");\n    var buildWorkletString_1 = require_buildWorkletString();\n    var version = require(\"../../package.json\").version;\n    function makeWorklet(fun, state) {\n      var functionName = makeWorkletName(fun);\n      fun.traverse({\n        DirectiveLiteral: function DirectiveLiteral(path) {\n          if (path.node.value === \"worklet\" && path.getFunctionParent() === fun) {\n            path.parentPath.remove();\n          }\n        }\n      });\n      (0, assert_1.strict)(state.file.opts.filename, \"'state.file.opts.filename' is undefined\");\n      var codeObject = (0, generator_1.default)(fun.node, {\n        sourceMaps: true,\n        sourceFileName: state.file.opts.filename\n      });\n      codeObject.code = \"(\" + ((0, types_1.isObjectMethod)(fun) ? \"function \" : \"\") + codeObject.code + \"\\n)\";\n      var transformed = (0, core_1.transformSync)(codeObject.code, {\n        filename: state.file.opts.filename,\n        presets: [\"@babel/preset-typescript\"],\n        plugins: [\"@babel/plugin-transform-shorthand-properties\", \"@babel/plugin-transform-arrow-functions\", \"@babel/plugin-proposal-optional-chaining\", \"@babel/plugin-proposal-nullish-coalescing-operator\", [\"@babel/plugin-transform-template-literals\", {\n          loose: true\n        }]],\n        ast: true,\n        babelrc: false,\n        configFile: false,\n        inputSourceMap: codeObject.map\n      });\n      (0, assert_1.strict)(transformed, \"'transformed' is undefined\");\n      (0, assert_1.strict)(transformed.ast, \"'transformed.ast' is undefined\");\n      var variables = makeArrayFromCapturedBindings(transformed.ast, fun);\n      var privateFunctionId = (0, types_1.identifier)(\"_f\");\n      var clone = (0, types_1.cloneNode)(fun.node);\n      var funExpression = (0, types_1.isBlockStatement)(clone.body) ? (0, types_1.functionExpression)(null, clone.params, clone.body) : clone;\n      var _ref = (0, buildWorkletString_1.buildWorkletString)(transformed.ast, variables, functionName, transformed.map),\n        _ref2 = _slicedToArray(_ref, 2),\n        funString = _ref2[0],\n        sourceMapString = _ref2[1];\n      (0, assert_1.strict)(funString, \"'funString' is undefined\");\n      var workletHash = hash(funString);\n      var location = state.file.opts.filename;\n      if (state.opts.relativeSourceLocation) {\n        location = (0, path_1.relative)(state.cwd, location);\n      }\n      var lineOffset = 1;\n      if (variables.length > 0) {\n        lineOffset -= variables.length + 2;\n      }\n      var pathForStringDefinitions = fun.parentPath.isProgram() ? fun : fun.findParent(function (path) {\n        return (0, types_1.isProgram)(path.parentPath);\n      });\n      (0, assert_1.strict)(pathForStringDefinitions, \"'pathForStringDefinitions' is null\");\n      (0, assert_1.strict)(pathForStringDefinitions.parentPath, \"'pathForStringDefinitions.parentPath' is null\");\n      var initDataId = pathForStringDefinitions.parentPath.scope.generateUidIdentifier(`worklet_${workletHash}_init_data`);\n      var initDataObjectExpression = (0, types_1.objectExpression)([(0, types_1.objectProperty)((0, types_1.identifier)(\"code\"), (0, types_1.stringLiteral)(funString)), (0, types_1.objectProperty)((0, types_1.identifier)(\"location\"), (0, types_1.stringLiteral)(location))]);\n      if (sourceMapString) {\n        initDataObjectExpression.properties.push((0, types_1.objectProperty)((0, types_1.identifier)(\"sourceMap\"), (0, types_1.stringLiteral)(sourceMapString)));\n      }\n      pathForStringDefinitions.insertBefore((0, types_1.variableDeclaration)(\"const\", [(0, types_1.variableDeclarator)(initDataId, initDataObjectExpression)]));\n      (0, assert_1.strict)(!(0, types_1.isFunctionDeclaration)(funExpression), \"'funExpression' is a 'FunctionDeclaration'\");\n      (0, assert_1.strict)(!(0, types_1.isObjectMethod)(funExpression), \"'funExpression' is an 'ObjectMethod'\");\n      var statements = [(0, types_1.variableDeclaration)(\"const\", [(0, types_1.variableDeclarator)(privateFunctionId, funExpression)]), (0, types_1.expressionStatement)((0, types_1.assignmentExpression)(\"=\", (0, types_1.memberExpression)(privateFunctionId, (0, types_1.identifier)(\"_closure\"), false), (0, types_1.objectExpression)(variables.map(function (variable) {\n        return (0, types_1.objectProperty)((0, types_1.identifier)(variable.name), variable, false, true);\n      })))), (0, types_1.expressionStatement)((0, types_1.assignmentExpression)(\"=\", (0, types_1.memberExpression)(privateFunctionId, (0, types_1.identifier)(\"__initData\"), false), initDataId)), (0, types_1.expressionStatement)((0, types_1.assignmentExpression)(\"=\", (0, types_1.memberExpression)(privateFunctionId, (0, types_1.identifier)(\"__workletHash\"), false), (0, types_1.numericLiteral)(workletHash)))];\n      if (!(0, utils_1.isRelease)()) {\n        statements.unshift((0, types_1.variableDeclaration)(\"const\", [(0, types_1.variableDeclarator)((0, types_1.identifier)(\"_e\"), (0, types_1.arrayExpression)([(0, types_1.newExpression)((0, types_1.memberExpression)((0, types_1.identifier)(\"global\"), (0, types_1.identifier)(\"Error\")), []), (0, types_1.numericLiteral)(lineOffset), (0, types_1.numericLiteral)(-27)]))]));\n        statements.push((0, types_1.expressionStatement)((0, types_1.assignmentExpression)(\"=\", (0, types_1.memberExpression)(privateFunctionId, (0, types_1.identifier)(\"__stackDetails\"), false), (0, types_1.identifier)(\"_e\"))));\n        if (shouldInjectVersion()) {\n          statements.push((0, types_1.expressionStatement)((0, types_1.assignmentExpression)(\"=\", (0, types_1.memberExpression)(privateFunctionId, (0, types_1.identifier)(\"__version\"), false), (0, types_1.stringLiteral)(version))));\n        }\n      }\n      statements.push((0, types_1.returnStatement)(privateFunctionId));\n      var newFun = (0, types_1.functionExpression)(void 0, [], (0, types_1.blockStatement)(statements));\n      return newFun;\n    }\n    exports2.makeWorklet = makeWorklet;\n    function shouldInjectVersion() {\n      if ((0, utils_1.isRelease)()) {\n        return false;\n      }\n      if (process.env.REANIMATED_JEST_DISABLE_VERSION === \"jest\") {\n        return false;\n      }\n      return true;\n    }\n    function hash(str) {\n      var i = str.length;\n      var hash1 = 5381;\n      var hash2 = 52711;\n      while (i--) {\n        var char = str.charCodeAt(i);\n        hash1 = hash1 * 33 ^ char;\n        hash2 = hash2 * 33 ^ char;\n      }\n      return (hash1 >>> 0) * 4096 + (hash2 >>> 0);\n    }\n    function makeWorkletName(fun) {\n      if ((0, types_1.isObjectMethod)(fun.node) && \"name\" in fun.node.key) {\n        return fun.node.key.name;\n      }\n      if ((0, types_1.isFunctionDeclaration)(fun.node) && fun.node.id) {\n        return fun.node.id.name;\n      }\n      if ((0, types_1.isFunctionExpression)(fun.node) && (0, types_1.isIdentifier)(fun.node.id)) {\n        return fun.node.id.name;\n      }\n      return \"anonymous\";\n    }\n    function makeArrayFromCapturedBindings(ast, fun) {\n      var closure = new Map();\n      (0, core_1.traverse)(ast, {\n        Identifier: function Identifier(path) {\n          if (!path.isReferencedIdentifier()) {\n            return;\n          }\n          var name = path.node.name;\n          if (commonObjects_12.globals.has(name)) {\n            return;\n          }\n          if (\"id\" in fun.node && fun.node.id && fun.node.id.name === name) {\n            return;\n          }\n          var parentNode = path.parent;\n          if ((0, types_1.isMemberExpression)(parentNode) && parentNode.property === path.node && !parentNode.computed) {\n            return;\n          }\n          if ((0, types_1.isObjectProperty)(parentNode) && (0, types_1.isObjectExpression)(path.parentPath.parent) && path.node !== parentNode.value) {\n            return;\n          }\n          var currentScope = path.scope;\n          while (currentScope != null) {\n            if (currentScope.bindings[name] != null) {\n              return;\n            }\n            currentScope = currentScope.parent;\n          }\n          closure.set(name, path.node);\n        }\n      });\n      return Array.from(closure.values());\n    }\n  }\n});\nvar require_processWorkletObjectMethod = __commonJS({\n  \"lib/processWorkletObjectMethod.js\": function libProcessWorkletObjectMethodJs(exports2) {\n    \"use strict\";\n\n    Object.defineProperty(exports2, \"__esModule\", {\n      value: true\n    });\n    exports2.processWorkletObjectMethod = void 0;\n    var types_1 = require(\"@babel/types\");\n    var makeWorklet_1 = require_makeWorklet();\n    function processWorkletObjectMethod(path, state) {\n      if (!(0, types_1.isFunctionParent)(path)) {\n        return;\n      }\n      var newFun = (0, makeWorklet_1.makeWorklet)(path, state);\n      var replacement = (0, types_1.objectProperty)((0, types_1.identifier)((0, types_1.isIdentifier)(path.node.key) ? path.node.key.name : \"\"), (0, types_1.callExpression)(newFun, []));\n      path.replaceWith(replacement);\n    }\n    exports2.processWorkletObjectMethod = processWorkletObjectMethod;\n  }\n});\nvar require_processIfWorkletFunction = __commonJS({\n  \"lib/processIfWorkletFunction.js\": function libProcessIfWorkletFunctionJs(exports2) {\n    \"use strict\";\n\n    Object.defineProperty(exports2, \"__esModule\", {\n      value: true\n    });\n    exports2.processIfWorkletFunction = void 0;\n    var types_1 = require(\"@babel/types\");\n    var makeWorklet_1 = require_makeWorklet();\n    function processIfWorkletFunction(path, state) {\n      if (path.isFunctionDeclaration() || path.isFunctionExpression() || path.isArrowFunctionExpression()) {\n        processWorkletFunction(path, state);\n      }\n    }\n    exports2.processIfWorkletFunction = processIfWorkletFunction;\n    function processWorkletFunction(path, state) {\n      var newFun = (0, makeWorklet_1.makeWorklet)(path, state);\n      var replacement = (0, types_1.callExpression)(newFun, []);\n      var needDeclaration = (0, types_1.isScopable)(path.parent) || (0, types_1.isExportNamedDeclaration)(path.parent);\n      path.replaceWith(\"id\" in path.node && path.node.id && needDeclaration ? (0, types_1.variableDeclaration)(\"const\", [(0, types_1.variableDeclarator)(path.node.id, replacement)]) : replacement);\n    }\n  }\n});\nvar require_processForCalleesWorklets = __commonJS({\n  \"lib/processForCalleesWorklets.js\": function libProcessForCalleesWorkletsJs(exports2) {\n    \"use strict\";\n\n    Object.defineProperty(exports2, \"__esModule\", {\n      value: true\n    });\n    exports2.processForCalleesWorklets = void 0;\n    var types_1 = require(\"@babel/types\");\n    var processWorkletObjectMethod_1 = require_processWorkletObjectMethod();\n    var processIfWorkletFunction_1 = require_processIfWorkletFunction();\n    var assert_1 = require(\"assert\");\n    var functionArgsToWorkletize = new Map([[\"useFrameCallback\", [0]], [\"useAnimatedStyle\", [0]], [\"useAnimatedProps\", [0]], [\"createAnimatedPropAdapter\", [0]], [\"useDerivedValue\", [0]], [\"useAnimatedScrollHandler\", [0]], [\"useAnimatedReaction\", [0, 1]], [\"useWorkletCallback\", [0]], [\"withTiming\", [2]], [\"withSpring\", [2]], [\"withDecay\", [1]], [\"withRepeat\", [3]], [\"runOnUI\", [0]]]);\n    var objectHooks = new Set([\"useAnimatedGestureHandler\", \"useAnimatedScrollHandler\"]);\n    function processForCalleesWorklets(path, state) {\n      var callee = (0, types_1.isSequenceExpression)(path.node.callee) ? path.node.callee.expressions[path.node.callee.expressions.length - 1] : path.node.callee;\n      var name = \"name\" in callee ? callee.name : \"property\" in callee && \"name\" in callee.property ? callee.property.name : void 0;\n      if (name === void 0) {\n        return;\n      }\n      if (objectHooks.has(name)) {\n        var workletToProcess = path.get(\"arguments.0\");\n        (0, assert_1.strict)(!Array.isArray(workletToProcess), \"'workletToProcess' is an array'\");\n        if (workletToProcess.isObjectExpression()) {\n          processObjectHook(workletToProcess, state);\n        } else if (name === \"useAnimatedScrollHandler\") {\n          (0, processIfWorkletFunction_1.processIfWorkletFunction)(workletToProcess, state);\n        }\n      } else {\n        var indices = functionArgsToWorkletize.get(name);\n        if (indices === void 0) {\n          return;\n        }\n        processArguments(path, indices, state);\n      }\n    }\n    exports2.processForCalleesWorklets = processForCalleesWorklets;\n    function processObjectHook(path, state) {\n      var properties = path.get(\"properties\");\n      for (var property of properties) {\n        if (property.isObjectMethod()) {\n          (0, processWorkletObjectMethod_1.processWorkletObjectMethod)(property, state);\n        } else if (property.isObjectProperty()) {\n          var value = property.get(\"value\");\n          (0, processIfWorkletFunction_1.processIfWorkletFunction)(value, state);\n        } else {\n          throw new Error(`'${property.type}' as to-be workletized arguments is not supported for object hooks`);\n        }\n      }\n    }\n    function processArguments(path, indices, state) {\n      var argumentsArray = path.get(\"arguments\");\n      indices.forEach(function (index) {\n        var argumentToWorkletize = argumentsArray[index];\n        if (!argumentToWorkletize) {\n          return;\n        }\n        (0, processIfWorkletFunction_1.processIfWorkletFunction)(argumentToWorkletize, state);\n      });\n    }\n  }\n});\nvar require_processIfWorkletNode = __commonJS({\n  \"lib/processIfWorkletNode.js\": function libProcessIfWorkletNodeJs(exports2) {\n    \"use strict\";\n\n    Object.defineProperty(exports2, \"__esModule\", {\n      value: true\n    });\n    exports2.processIfWorkletNode = void 0;\n    var types_1 = require(\"@babel/types\");\n    var processIfWorkletFunction_1 = require_processIfWorkletFunction();\n    function processIfWorkletNode(fun, state) {\n      fun.traverse({\n        DirectiveLiteral: function DirectiveLiteral(path) {\n          var value = path.node.value;\n          if (value === \"worklet\" && path.getFunctionParent() === fun && (0, types_1.isBlockStatement)(fun.node.body)) {\n            var directives = fun.node.body.directives;\n            if (directives && directives.length > 0 && directives.some(function (directive) {\n              return (0, types_1.isDirectiveLiteral)(directive.value) && directive.value.value === \"worklet\";\n            })) {\n              (0, processIfWorkletFunction_1.processIfWorkletFunction)(fun, state);\n            }\n          }\n        }\n      });\n    }\n    exports2.processIfWorkletNode = processIfWorkletNode;\n  }\n});\nvar require_processIfGestureHandlerEventCallbackFunctionNode = __commonJS({\n  \"lib/processIfGestureHandlerEventCallbackFunctionNode.js\": function libProcessIfGestureHandlerEventCallbackFunctionNodeJs(exports2) {\n    \"use strict\";\n\n    Object.defineProperty(exports2, \"__esModule\", {\n      value: true\n    });\n    exports2.processIfGestureHandlerEventCallbackFunctionNode = void 0;\n    var types_1 = require(\"@babel/types\");\n    var processIfWorkletFunction_1 = require_processIfWorkletFunction();\n    var gestureHandlerGestureObjects = new Set([\"Tap\", \"Pan\", \"Pinch\", \"Rotation\", \"Fling\", \"LongPress\", \"ForceTouch\", \"Native\", \"Manual\", \"Race\", \"Simultaneous\", \"Exclusive\"]);\n    var gestureHandlerBuilderMethods = new Set([\"onBegin\", \"onStart\", \"onEnd\", \"onFinalize\", \"onUpdate\", \"onChange\", \"onTouchesDown\", \"onTouchesMove\", \"onTouchesUp\", \"onTouchesCancelled\"]);\n    function processIfGestureHandlerEventCallbackFunctionNode(path, state) {\n      if ((0, types_1.isCallExpression)(path.parent) && (0, types_1.isExpression)(path.parent.callee) && isGestureObjectEventCallbackMethod(path.parent.callee)) {\n        (0, processIfWorkletFunction_1.processIfWorkletFunction)(path, state);\n      }\n    }\n    exports2.processIfGestureHandlerEventCallbackFunctionNode = processIfGestureHandlerEventCallbackFunctionNode;\n    function isGestureObjectEventCallbackMethod(exp) {\n      return (0, types_1.isMemberExpression)(exp) && (0, types_1.isIdentifier)(exp.property) && gestureHandlerBuilderMethods.has(exp.property.name) && containsGestureObject(exp.object);\n    }\n    function containsGestureObject(exp) {\n      if (isGestureObject(exp)) {\n        return true;\n      }\n      if ((0, types_1.isCallExpression)(exp) && (0, types_1.isMemberExpression)(exp.callee) && containsGestureObject(exp.callee.object)) {\n        return true;\n      }\n      return false;\n    }\n    function isGestureObject(exp) {\n      return (0, types_1.isCallExpression)(exp) && (0, types_1.isMemberExpression)(exp.callee) && (0, types_1.isIdentifier)(exp.callee.object) && exp.callee.object.name === \"Gesture\" && (0, types_1.isIdentifier)(exp.callee.property) && gestureHandlerGestureObjects.has(exp.callee.property.name);\n    }\n  }\n});\nvar require_processInlineStylesWarning = __commonJS({\n  \"lib/processInlineStylesWarning.js\": function libProcessInlineStylesWarningJs(exports2) {\n    \"use strict\";\n\n    Object.defineProperty(exports2, \"__esModule\", {\n      value: true\n    });\n    exports2.processInlineStylesWarning = void 0;\n    var types_1 = require(\"@babel/types\");\n    var utils_1 = require_utils();\n    var assert_1 = require(\"assert\");\n    function generateInlineStylesWarning(path) {\n      return (0, types_1.callExpression)((0, types_1.arrowFunctionExpression)([], (0, types_1.blockStatement)([(0, types_1.expressionStatement)((0, types_1.callExpression)((0, types_1.memberExpression)((0, types_1.identifier)(\"console\"), (0, types_1.identifier)(\"warn\")), [(0, types_1.callExpression)((0, types_1.memberExpression)((0, types_1.callExpression)((0, types_1.identifier)(\"require\"), [(0, types_1.stringLiteral)(\"react-native-reanimated\")]), (0, types_1.identifier)(\"getUseOfValueInStyleWarning\")), [])])), (0, types_1.returnStatement)(path.node)])), []);\n    }\n    function processPropertyValueForInlineStylesWarning(path) {\n      if (path.isMemberExpression() && (0, types_1.isIdentifier)(path.node.property)) {\n        if (path.node.property.name === \"value\") {\n          path.replaceWith(generateInlineStylesWarning(path));\n        }\n      }\n    }\n    function processTransformPropertyForInlineStylesWarning(path) {\n      if ((0, types_1.isArrayExpression)(path.node)) {\n        var elements = path.get(\"elements\");\n        (0, assert_1.strict)(Array.isArray(elements), \"'elements' should be an array\");\n        for (var element of elements) {\n          if (element.isObjectExpression()) {\n            processStyleObjectForInlineStylesWarning(element);\n          }\n        }\n      }\n    }\n    function processStyleObjectForInlineStylesWarning(path) {\n      var properties = path.get(\"properties\");\n      for (var property of properties) {\n        if (property.isObjectProperty()) {\n          var value = property.get(\"value\");\n          if ((0, types_1.isIdentifier)(property.node.key) && property.node.key.name === \"transform\") {\n            processTransformPropertyForInlineStylesWarning(value);\n          } else {\n            processPropertyValueForInlineStylesWarning(value);\n          }\n        }\n      }\n    }\n    function processInlineStylesWarning(path, state) {\n      if ((0, utils_1.isRelease)()) {\n        return;\n      }\n      if (state.opts.disableInlineStylesWarning) {\n        return;\n      }\n      if (path.node.name.name !== \"style\") {\n        return;\n      }\n      if (!(0, types_1.isJSXExpressionContainer)(path.node.value)) {\n        return;\n      }\n      var expression = path.get(\"value\").get(\"expression\");\n      (0, assert_1.strict)(!Array.isArray(expression), \"'expression' should not be an array\");\n      if (expression.isArrayExpression()) {\n        var elements = expression.get(\"elements\");\n        (0, assert_1.strict)(Array.isArray(elements), \"'elements' should be an array\");\n        for (var element of elements) {\n          if (element.isObjectExpression()) {\n            processStyleObjectForInlineStylesWarning(element);\n          }\n        }\n      } else if (expression.isObjectExpression()) {\n        processStyleObjectForInlineStylesWarning(expression);\n      }\n    }\n    exports2.processInlineStylesWarning = processInlineStylesWarning;\n  }\n});\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar commonObjects_1 = require_commonObjects();\nvar processForCalleesWorklets_1 = require_processForCalleesWorklets();\nvar processIfWorkletNode_1 = require_processIfWorkletNode();\nvar processIfGestureHandlerEventCallbackFunctionNode_1 = require_processIfGestureHandlerEventCallbackFunctionNode();\nvar processInlineStylesWarning_1 = require_processInlineStylesWarning();\nmodule.exports = function () {\n  return {\n    pre: function pre() {\n      if (this.opts != null && Array.isArray(this.opts.globals)) {\n        this.opts.globals.forEach(function (name) {\n          commonObjects_1.globals.add(name);\n        });\n      }\n    },\n    visitor: {\n      CallExpression: {\n        enter: function enter(path, state) {\n          (0, processForCalleesWorklets_1.processForCalleesWorklets)(path, state);\n        }\n      },\n      \"FunctionDeclaration|FunctionExpression|ArrowFunctionExpression\": {\n        enter: function enter(path, state) {\n          (0, processIfWorkletNode_1.processIfWorkletNode)(path, state);\n          (0, processIfGestureHandlerEventCallbackFunctionNode_1.processIfGestureHandlerEventCallbackFunctionNode)(path, state);\n        }\n      },\n      JSXAttribute: {\n        enter: function enter(path, state) {\n          (0, processInlineStylesWarning_1.processInlineStylesWarning)(path, state);\n        }\n      }\n    }\n  };\n};","map":{"version":3,"names":["exports2","globals","Set","isRelease","process","env","BABEL_ENV","includes","core_1","require","generator_1","__importDefault","types_1","fs","__importStar","convertSourceMap","assert_1","utils_1","require_utils","buildWorkletString","fun","closureVariables","name","inputMap","draftExpression","program","body","find","obj","isFunctionDeclaration","isExpressionStatement","strict","expression","isBlockStatement","workletFunction","functionExpression","identifier","params","code","default","includeSourceMap","shouldGenerateSourceMap","sourcesContent","sourceFile","sources","push","readFileSync","toString","transformed","transformSync","plugins","prependClosureVariablesIfNecessary","compact","sourceMaps","inputSourceMap","ast","babelrc","configFile","comments","sourceMap","fromObject","map","toObject","JSON","stringify","REANIMATED_JEST_DISABLE_SOURCEMAP","prependClosure","path","closureDeclaration","length","isProgram","parent","isExpression","node","unshift","prependRecursiveDeclaration","isArrowFunctionExpression","isObjectMethod","id","scope","hasRecursiveCalls","_a","bindings","references","variableDeclaration","variableDeclarator","memberExpression","thisExpression","objectPattern","variable","objectProperty","visitor","FunctionDeclarationFunctionExpressionArrowFunctionExpressionObjectMethod","commonObjects_12","require_commonObjects","path_1","buildWorkletString_1","require_buildWorkletString","version","makeWorklet","state","functionName","makeWorkletName","traverse","DirectiveLiteral","value","getFunctionParent","parentPath","remove","file","opts","filename","codeObject","sourceFileName","presets","loose","variables","makeArrayFromCapturedBindings","privateFunctionId","clone","cloneNode","funExpression","_ref","_ref2","_slicedToArray","funString","sourceMapString","workletHash","hash","location","relativeSourceLocation","relative","cwd","lineOffset","pathForStringDefinitions","findParent","initDataId","generateUidIdentifier","initDataObjectExpression","objectExpression","stringLiteral","properties","insertBefore","statements","expressionStatement","assignmentExpression","numericLiteral","arrayExpression","newExpression","shouldInjectVersion","returnStatement","newFun","blockStatement","REANIMATED_JEST_DISABLE_VERSION","str","i","hash1","hash2","char","charCodeAt","key","isFunctionExpression","isIdentifier","closure","Map","Identifier","isReferencedIdentifier","has","parentNode","isMemberExpression","property","computed","isObjectProperty","isObjectExpression","currentScope","set","Array","from","values","makeWorklet_1","require_makeWorklet","processWorkletObjectMethod","isFunctionParent","replacement","callExpression","replaceWith","processIfWorkletFunction","processWorkletFunction","needDeclaration","isScopable","isExportNamedDeclaration","processWorkletObjectMethod_1","require_processWorkletObjectMethod","processIfWorkletFunction_1","require_processIfWorkletFunction","functionArgsToWorkletize","objectHooks","processForCalleesWorklets","callee","isSequenceExpression","expressions","workletToProcess","get","isArray","processObjectHook","indices","processArguments","Error","type","argumentsArray","forEach","index","argumentToWorkletize","processIfWorkletNode","directives","some","directive","isDirectiveLiteral","gestureHandlerGestureObjects","gestureHandlerBuilderMethods","processIfGestureHandlerEventCallbackFunctionNode","isCallExpression","isGestureObjectEventCallbackMethod","exp","containsGestureObject","object","isGestureObject","generateInlineStylesWarning","arrowFunctionExpression","processPropertyValueForInlineStylesWarning","processTransformPropertyForInlineStylesWarning","isArrayExpression","elements","element","processStyleObjectForInlineStylesWarning","processInlineStylesWarning","disableInlineStylesWarning","isJSXExpressionContainer","commonObjects_1","processForCalleesWorklets_1","require_processForCalleesWorklets","processIfWorkletNode_1","require_processIfWorkletNode","processIfGestureHandlerEventCallbackFunctionNode_1","require_processIfGestureHandlerEventCallbackFunctionNode","processInlineStylesWarning_1","require_processInlineStylesWarning","module","exports","pre","add","CallExpression","enter","JSXAttribute"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\react-native-reanimated\\plugin\\src\\commonObjects.ts","C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\react-native-reanimated\\plugin\\src\\utils.ts","C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\react-native-reanimated\\plugin\\src\\buildWorkletString.ts","C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\react-native-reanimated\\plugin\\src\\makeWorklet.ts","C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\react-native-reanimated\\plugin\\src\\processWorkletObjectMethod.ts","C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\react-native-reanimated\\plugin\\src\\processIfWorkletFunction.ts","C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\react-native-reanimated\\plugin\\src\\processForCalleesWorklets.ts","C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\react-native-reanimated\\plugin\\src\\processIfWorkletNode.ts","C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\react-native-reanimated\\plugin\\src\\processIfGestureHandlerEventCallbackFunctionNode.ts","C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\react-native-reanimated\\plugin\\src\\processInlineStylesWarning.ts","C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\react-native-reanimated\\plugin\\src\\plugin.ts"],"sourcesContent":["export const globals = new Set([\n  'this',\n  'console',\n  'performance',\n  'Date',\n  'Array',\n  'ArrayBuffer',\n  'Int8Array',\n  'Int16Array',\n  'Int32Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Uint16Array',\n  'Uint32Array',\n  'Float32Array',\n  'Float64Array',\n  'HermesInternal',\n  'JSON',\n  'Math',\n  'Number',\n  'Object',\n  'String',\n  'Symbol',\n  'undefined',\n  'null',\n  'UIManager',\n  'requestAnimationFrame',\n  'setImmediate',\n  'queueMicrotask',\n  '_WORKLET',\n  'arguments',\n  'Boolean',\n  'parseInt',\n  'parseFloat',\n  'Map',\n  'WeakMap',\n  'Proxy',\n  'WeakRef',\n  'Set',\n  '_log',\n  '_scheduleOnJS',\n  '_makeShareableClone',\n  '_updateDataSynchronously',\n  'eval',\n  '_updatePropsPaper',\n  '_updatePropsFabric',\n  '_removeShadowNodeFromRegistry',\n  'RegExp',\n  'Error',\n  '__ErrorUtils',\n  'global',\n  '_measure',\n  '_scrollTo',\n  '_dispatchCommand',\n  '_setGestureState',\n  'isNaN',\n  'LayoutAnimationRepository',\n  '_notifyAboutProgress',\n  '_notifyAboutEnd',\n  '_runOnUIQueue',\n]);\n","export function isRelease() {\n  return (\n    process.env.BABEL_ENV &&\n    ['production', 'release'].includes(process.env.BABEL_ENV)\n  );\n}\n","import {\n  BabelFileResult,\n  NodePath,\n  transformSync,\n  PluginItem,\n} from '@babel/core';\nimport generate from '@babel/generator';\nimport {\n  ObjectMethod,\n  isObjectMethod,\n  FunctionDeclaration,\n  FunctionExpression,\n  ArrowFunctionExpression,\n  identifier,\n  Identifier,\n  objectProperty,\n  isArrowFunctionExpression,\n  variableDeclaration,\n  variableDeclarator,\n  isBlockStatement,\n  functionExpression,\n  isFunctionDeclaration,\n  VariableDeclaration,\n  ExpressionStatement,\n  isProgram,\n  memberExpression,\n  File as BabelFile,\n  objectPattern,\n  thisExpression,\n  isExpression,\n  isExpressionStatement,\n} from '@babel/types';\nimport * as fs from 'fs';\nimport * as convertSourceMap from 'convert-source-map';\nimport { strict as assert } from 'assert';\nimport { isRelease } from './utils';\n\nexport function buildWorkletString(\n  fun: BabelFile,\n  closureVariables: Array<Identifier>,\n  name: string,\n  inputMap: BabelFileResult['map']\n): Array<string | null | undefined> {\n  const draftExpression = (fun.program.body.find((obj) =>\n    isFunctionDeclaration(obj)\n  ) ||\n    fun.program.body.find((obj) => isExpressionStatement(obj)) ||\n    undefined) as FunctionDeclaration | ExpressionStatement | undefined;\n\n  assert(draftExpression, \"'draftExpression' is undefined\");\n\n  const expression = isFunctionDeclaration(draftExpression)\n    ? draftExpression\n    : draftExpression.expression;\n\n  assert(\n    'params' in expression,\n    \"'params' property is undefined in 'expression'\"\n  );\n  assert(\n    isBlockStatement(expression.body),\n    \"'expression.body' is not a 'BlockStatement'\"\n  );\n\n  const workletFunction = functionExpression(\n    identifier(name),\n    expression.params,\n    expression.body\n  );\n\n  const code = generate(workletFunction).code;\n\n  assert(inputMap, \"'inputMap' is undefined\");\n\n  const includeSourceMap = shouldGenerateSourceMap();\n\n  if (includeSourceMap) {\n    // Clear contents array (should be empty anyways)\n    inputMap.sourcesContent = [];\n    // Include source contents in source map, because Flipper/iframe is not\n    // allowed to read files from disk.\n    for (const sourceFile of inputMap.sources) {\n      inputMap.sourcesContent.push(\n        fs.readFileSync(sourceFile).toString('utf-8')\n      );\n    }\n  }\n\n  const transformed = transformSync(code, {\n    plugins: [prependClosureVariablesIfNecessary(closureVariables)],\n    compact: !includeSourceMap,\n    sourceMaps: includeSourceMap,\n    inputSourceMap: inputMap,\n    ast: false,\n    babelrc: false,\n    configFile: false,\n    comments: false,\n  });\n\n  assert(transformed, \"'transformed' is null\");\n\n  let sourceMap;\n  if (includeSourceMap) {\n    sourceMap = convertSourceMap.fromObject(transformed.map).toObject();\n    // sourcesContent field contains a full source code of the file which contains the worklet\n    // and is not needed by the source map interpreter in order to symbolicate a stack trace.\n    // Therefore, we remove it to reduce the bandwith and avoid sending it potentially multiple times\n    // in files that contain multiple worklets. Along with sourcesContent.\n    delete sourceMap.sourcesContent;\n  }\n\n  return [transformed.code, JSON.stringify(sourceMap)];\n}\n\nfunction shouldGenerateSourceMap() {\n  if (isRelease()) {\n    return false;\n  }\n\n  // We want to detect this, so we can disable source maps (because they break\n  // snapshot tests with jest).\n  if (process.env.REANIMATED_JEST_DISABLE_SOURCEMAP === 'jest') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction prependClosure(\n  path: NodePath<\n    | FunctionDeclaration\n    | FunctionExpression\n    | ArrowFunctionExpression\n    | ObjectMethod\n  >,\n  closureVariables: Array<Identifier>,\n  closureDeclaration: VariableDeclaration\n) {\n  if (closureVariables.length === 0 || !isProgram(path.parent)) {\n    return;\n  }\n\n  if (!isExpression(path.node.body)) {\n    path.node.body.body.unshift(closureDeclaration);\n  }\n}\n\nfunction prependRecursiveDeclaration(\n  path: NodePath<\n    | FunctionDeclaration\n    | FunctionExpression\n    | ArrowFunctionExpression\n    | ObjectMethod\n  >\n) {\n  if (\n    isProgram(path.parent) &&\n    !isArrowFunctionExpression(path.node) &&\n    !isObjectMethod(path.node) &&\n    path.node.id &&\n    path.scope.parent\n  ) {\n    const hasRecursiveCalls =\n      path.scope.parent.bindings[path.node.id.name]?.references > 0;\n    if (hasRecursiveCalls) {\n      path.node.body.body.unshift(\n        variableDeclaration('const', [\n          variableDeclarator(\n            identifier(path.node.id.name),\n            memberExpression(thisExpression(), identifier('_recur'))\n          ),\n        ])\n      );\n    }\n  }\n}\n\nfunction prependClosureVariablesIfNecessary(\n  closureVariables: Array<Identifier>\n): PluginItem {\n  const closureDeclaration = variableDeclaration('const', [\n    variableDeclarator(\n      objectPattern(\n        closureVariables.map((variable) =>\n          objectProperty(\n            identifier(variable.name),\n            identifier(variable.name),\n            false,\n            true\n          )\n        )\n      ),\n      memberExpression(thisExpression(), identifier('_closure'))\n    ),\n  ]);\n\n  return {\n    visitor: {\n      'FunctionDeclaration|FunctionExpression|ArrowFunctionExpression|ObjectMethod':\n        (\n          path: NodePath<\n            | FunctionDeclaration\n            | FunctionExpression\n            | ArrowFunctionExpression\n            | ObjectMethod\n          >\n        ) => {\n          prependClosure(path, closureVariables, closureDeclaration);\n          prependRecursiveDeclaration(path);\n        },\n    },\n  };\n}\n","import { NodePath, transformSync, traverse } from '@babel/core';\nimport generate from '@babel/generator';\nimport {\n  ObjectMethod,\n  isObjectMethod,\n  FunctionDeclaration,\n  FunctionExpression,\n  ArrowFunctionExpression,\n  identifier,\n  Identifier,\n  objectProperty,\n  variableDeclaration,\n  variableDeclarator,\n  cloneNode,\n  isBlockStatement,\n  functionExpression,\n  objectExpression,\n  stringLiteral,\n  isFunctionDeclaration,\n  VariableDeclaration,\n  ExpressionStatement,\n  ReturnStatement,\n  isProgram,\n  isObjectProperty,\n  isMemberExpression,\n  isObjectExpression,\n  expressionStatement,\n  assignmentExpression,\n  memberExpression,\n  numericLiteral,\n  arrayExpression,\n  newExpression,\n  returnStatement,\n  blockStatement,\n  isFunctionExpression,\n  isIdentifier,\n  File as BabelFile,\n} from '@babel/types';\nimport { ReanimatedPluginPass } from './types';\nimport { isRelease } from './utils';\nimport { strict as assert } from 'assert';\nimport { globals } from './commonObjects';\nimport { relative } from 'path';\nimport { buildWorkletString } from './buildWorkletString';\n\nconst version = require('../../package.json').version;\n\nexport function makeWorklet(\n  fun: NodePath<\n    | FunctionDeclaration\n    | FunctionExpression\n    | ObjectMethod\n    | ArrowFunctionExpression\n  >,\n  state: ReanimatedPluginPass\n): FunctionExpression {\n  // Returns a new FunctionExpression which is a workletized version of provided\n  // FunctionDeclaration, FunctionExpression, ArrowFunctionExpression or ObjectMethod.\n\n  const functionName = makeWorkletName(fun);\n\n  // remove 'worklet'; directive before generating string\n  fun.traverse({\n    DirectiveLiteral(path) {\n      if (path.node.value === 'worklet' && path.getFunctionParent() === fun) {\n        path.parentPath.remove();\n      }\n    },\n  });\n\n  // We use copy because some of the plugins don't update bindings and\n  // some even break them\n  assert(state.file.opts.filename, \"'state.file.opts.filename' is undefined\");\n\n  const codeObject = generate(fun.node, {\n    sourceMaps: true,\n    sourceFileName: state.file.opts.filename,\n  });\n\n  // We need to add a newline at the end, because there could potentially be a\n  // comment after the function that gets included here, and then the closing\n  // bracket would become part of the comment thus resulting in an error, since\n  // there is a missing closing bracket.\n  codeObject.code =\n    '(' + (isObjectMethod(fun) ? 'function ' : '') + codeObject.code + '\\n)';\n\n  const transformed = transformSync(codeObject.code, {\n    filename: state.file.opts.filename,\n    presets: ['@babel/preset-typescript'],\n    plugins: [\n      '@babel/plugin-transform-shorthand-properties',\n      '@babel/plugin-transform-arrow-functions',\n      '@babel/plugin-proposal-optional-chaining',\n      '@babel/plugin-proposal-nullish-coalescing-operator',\n      ['@babel/plugin-transform-template-literals', { loose: true }],\n    ],\n    ast: true,\n    babelrc: false,\n    configFile: false,\n    inputSourceMap: codeObject.map,\n  });\n\n  assert(transformed, \"'transformed' is undefined\");\n  assert(transformed.ast, \"'transformed.ast' is undefined\");\n\n  const variables = makeArrayFromCapturedBindings(transformed.ast, fun);\n\n  const privateFunctionId = identifier('_f');\n  const clone = cloneNode(fun.node);\n  const funExpression = isBlockStatement(clone.body)\n    ? functionExpression(null, clone.params, clone.body)\n    : clone;\n\n  const [funString, sourceMapString] = buildWorkletString(\n    transformed.ast,\n    variables,\n    functionName,\n    transformed.map\n  );\n  assert(funString, \"'funString' is undefined\");\n  const workletHash = hash(funString);\n\n  let location = state.file.opts.filename;\n  if (state.opts.relativeSourceLocation) {\n    location = relative(state.cwd, location);\n  }\n\n  let lineOffset = 1;\n  if (variables.length > 0) {\n    // When worklet captures some variables, we append closure destructing at\n    // the beginning of the function body. This effectively results in line\n    // numbers shifting by the number of captured variables (size of the\n    // closure) + 2 (for the opening and closing brackets of the destruct\n    // statement)\n    lineOffset -= variables.length + 2;\n  }\n\n  const pathForStringDefinitions = fun.parentPath.isProgram()\n    ? fun\n    : fun.findParent((path) => isProgram(path.parentPath));\n  assert(pathForStringDefinitions, \"'pathForStringDefinitions' is null\");\n  assert(\n    pathForStringDefinitions.parentPath,\n    \"'pathForStringDefinitions.parentPath' is null\"\n  );\n\n  const initDataId =\n    pathForStringDefinitions.parentPath.scope.generateUidIdentifier(\n      `worklet_${workletHash}_init_data`\n    );\n\n  const initDataObjectExpression = objectExpression([\n    objectProperty(identifier('code'), stringLiteral(funString)),\n    objectProperty(identifier('location'), stringLiteral(location)),\n  ]);\n\n  if (sourceMapString) {\n    initDataObjectExpression.properties.push(\n      objectProperty(identifier('sourceMap'), stringLiteral(sourceMapString))\n    );\n  }\n\n  pathForStringDefinitions.insertBefore(\n    variableDeclaration('const', [\n      variableDeclarator(initDataId, initDataObjectExpression),\n    ])\n  );\n\n  assert(\n    !isFunctionDeclaration(funExpression),\n    \"'funExpression' is a 'FunctionDeclaration'\"\n  );\n  assert(\n    !isObjectMethod(funExpression),\n    \"'funExpression' is an 'ObjectMethod'\"\n  );\n\n  const statements: Array<\n    VariableDeclaration | ExpressionStatement | ReturnStatement\n  > = [\n    variableDeclaration('const', [\n      variableDeclarator(privateFunctionId, funExpression),\n    ]),\n    expressionStatement(\n      assignmentExpression(\n        '=',\n        memberExpression(privateFunctionId, identifier('_closure'), false),\n        objectExpression(\n          variables.map((variable) =>\n            objectProperty(identifier(variable.name), variable, false, true)\n          )\n        )\n      )\n    ),\n    expressionStatement(\n      assignmentExpression(\n        '=',\n        memberExpression(privateFunctionId, identifier('__initData'), false),\n        initDataId\n      )\n    ),\n    expressionStatement(\n      assignmentExpression(\n        '=',\n        memberExpression(privateFunctionId, identifier('__workletHash'), false),\n        numericLiteral(workletHash)\n      )\n    ),\n  ];\n\n  if (!isRelease()) {\n    statements.unshift(\n      variableDeclaration('const', [\n        variableDeclarator(\n          identifier('_e'),\n          arrayExpression([\n            newExpression(\n              memberExpression(identifier('global'), identifier('Error')),\n              []\n            ),\n            numericLiteral(lineOffset),\n            numericLiteral(-27), // the placement of opening bracket after Exception in line that defined '_e' variable\n          ])\n        ),\n      ])\n    );\n    statements.push(\n      expressionStatement(\n        assignmentExpression(\n          '=',\n          memberExpression(\n            privateFunctionId,\n            identifier('__stackDetails'),\n            false\n          ),\n          identifier('_e')\n        )\n      )\n    );\n    if (shouldInjectVersion()) {\n      statements.push(\n        expressionStatement(\n          assignmentExpression(\n            '=',\n            memberExpression(privateFunctionId, identifier('__version'), false),\n            stringLiteral(version)\n          )\n        )\n      );\n    }\n  }\n\n  statements.push(returnStatement(privateFunctionId));\n\n  const newFun = functionExpression(undefined, [], blockStatement(statements));\n\n  return newFun;\n}\n\nfunction shouldInjectVersion() {\n  // We don't inject version in release since cache is reset there anyway\n  if (isRelease()) {\n    return false;\n  }\n\n  // We don't want to pollute tests with current version number so we disable it\n  // for all tests (except one)\n  if (process.env.REANIMATED_JEST_DISABLE_VERSION === 'jest') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction hash(str: string) {\n  let i = str.length;\n  let hash1 = 5381;\n  let hash2 = 52711;\n\n  while (i--) {\n    const char = str.charCodeAt(i);\n    // eslint-disable-next-line no-bitwise\n    hash1 = (hash1 * 33) ^ char;\n    // eslint-disable-next-line no-bitwise\n    hash2 = (hash2 * 33) ^ char;\n  }\n\n  // eslint-disable-next-line no-bitwise\n  return (hash1 >>> 0) * 4096 + (hash2 >>> 0);\n}\n\nfunction makeWorkletName(\n  fun: NodePath<\n    | FunctionDeclaration\n    | FunctionExpression\n    | ObjectMethod\n    | ArrowFunctionExpression\n  >\n) {\n  if (isObjectMethod(fun.node) && 'name' in fun.node.key) {\n    return fun.node.key.name;\n  }\n  if (isFunctionDeclaration(fun.node) && fun.node.id) {\n    return fun.node.id.name;\n  }\n  if (isFunctionExpression(fun.node) && isIdentifier(fun.node.id)) {\n    return fun.node.id.name;\n  }\n  return 'anonymous'; // fallback for ArrowFunctionExpression and unnamed FunctionExpression\n}\n\nfunction makeArrayFromCapturedBindings(\n  ast: BabelFile,\n  fun: NodePath<\n    | FunctionDeclaration\n    | FunctionExpression\n    | ObjectMethod\n    | ArrowFunctionExpression\n  >\n) {\n  const closure = new Map<string, Identifier>();\n\n  // this traversal looks for variables to capture\n  traverse(ast, {\n    Identifier(path) {\n      // we only capture variables that were declared outside of the scope\n      if (!path.isReferencedIdentifier()) {\n        return;\n      }\n      const name = path.node.name;\n      // if the function is named and was added to globals we don't want to add it to closure\n      // hence we check if identifier has that name\n      if (globals.has(name)) {\n        return;\n      }\n      if (\n        'id' in fun.node &&\n        fun.node.id &&\n        fun.node.id.name === name // we don't want to capture function's own name\n      ) {\n        return;\n      }\n\n      const parentNode = path.parent;\n\n      if (\n        isMemberExpression(parentNode) &&\n        parentNode.property === path.node &&\n        !parentNode.computed\n      ) {\n        return;\n      }\n\n      if (\n        isObjectProperty(parentNode) &&\n        isObjectExpression(path.parentPath.parent) &&\n        path.node !== parentNode.value\n      ) {\n        return;\n      }\n\n      let currentScope = path.scope;\n\n      while (currentScope != null) {\n        if (currentScope.bindings[name] != null) {\n          return;\n        }\n        currentScope = currentScope.parent;\n      }\n      closure.set(name, path.node);\n    },\n  });\n\n  return Array.from(closure.values());\n}\n","import { NodePath } from '@babel/core';\nimport {\n  ObjectMethod,\n  identifier,\n  isIdentifier,\n  isFunctionParent,\n  objectProperty,\n  callExpression,\n} from '@babel/types';\nimport { ReanimatedPluginPass } from './types';\nimport { makeWorklet } from './makeWorklet';\n\nexport function processWorkletObjectMethod(\n  path: NodePath<ObjectMethod>,\n  state: ReanimatedPluginPass\n) {\n  // Replaces ObjectMethod with a workletized version of itself.\n\n  if (!isFunctionParent(path)) {\n    return;\n  }\n\n  const newFun = makeWorklet(path, state);\n\n  const replacement = objectProperty(\n    identifier(isIdentifier(path.node.key) ? path.node.key.name : ''),\n    callExpression(newFun, [])\n  );\n\n  path.replaceWith(replacement);\n}\n","import { NodePath, Node } from '@babel/core';\nimport {\n  FunctionDeclaration,\n  FunctionExpression,\n  ArrowFunctionExpression,\n  callExpression,\n  isScopable,\n  isExportNamedDeclaration,\n  variableDeclaration,\n  variableDeclarator,\n} from '@babel/types';\nimport { ReanimatedPluginPass } from './types';\nimport { makeWorklet } from './makeWorklet';\n\n// Replaces FunctionDeclaration, FunctionExpression or ArrowFunctionExpression\n// with a workletized version of itself.\n\nexport function processIfWorkletFunction(\n  path: NodePath<Node>,\n  state: ReanimatedPluginPass\n) {\n  if (\n    path.isFunctionDeclaration() ||\n    path.isFunctionExpression() ||\n    path.isArrowFunctionExpression()\n  ) {\n    processWorkletFunction(path, state);\n  }\n}\n\nfunction processWorkletFunction(\n  path: NodePath<\n    FunctionDeclaration | FunctionExpression | ArrowFunctionExpression\n  >,\n  state: ReanimatedPluginPass\n) {\n  const newFun = makeWorklet(path, state);\n\n  const replacement = callExpression(newFun, []);\n\n  // we check if function needs to be assigned to variable declaration.\n  // This is needed if function definition directly in a scope. Some other ways\n  // where function definition can be used is for example with variable declaration:\n  // const ggg = function foo() { }\n  // ^ in such a case we don't need to define variable for the function\n  const needDeclaration =\n    isScopable(path.parent) || isExportNamedDeclaration(path.parent);\n  path.replaceWith(\n    'id' in path.node && path.node.id && needDeclaration\n      ? variableDeclaration('const', [\n          variableDeclarator(path.node.id, replacement),\n        ])\n      : replacement\n  );\n}\n","import { NodePath } from '@babel/core';\nimport {\n  CallExpression,\n  isSequenceExpression,\n  ObjectExpression,\n} from '@babel/types';\nimport { ReanimatedPluginPass } from './types';\nimport { processWorkletObjectMethod } from './processWorkletObjectMethod';\nimport { processIfWorkletFunction } from './processIfWorkletFunction';\nimport { strict as assert } from 'assert';\n\nconst functionArgsToWorkletize = new Map([\n  ['useFrameCallback', [0]],\n  ['useAnimatedStyle', [0]],\n  ['useAnimatedProps', [0]],\n  ['createAnimatedPropAdapter', [0]],\n  ['useDerivedValue', [0]],\n  ['useAnimatedScrollHandler', [0]],\n  ['useAnimatedReaction', [0, 1]],\n  ['useWorkletCallback', [0]],\n  // animations' callbacks\n  ['withTiming', [2]],\n  ['withSpring', [2]],\n  ['withDecay', [1]],\n  ['withRepeat', [3]],\n  // scheduling functions\n  ['runOnUI', [0]],\n]);\n\nconst objectHooks = new Set([\n  'useAnimatedGestureHandler',\n  'useAnimatedScrollHandler',\n]);\n\nexport function processForCalleesWorklets(\n  path: NodePath<CallExpression>,\n  state: ReanimatedPluginPass\n) {\n  const callee = isSequenceExpression(path.node.callee)\n    ? path.node.callee.expressions[path.node.callee.expressions.length - 1]\n    : path.node.callee;\n\n  // We are looking for objects we know we should workletize\n  // hence if object is not named, we return.\n  const name =\n    'name' in callee\n      ? callee.name\n      : 'property' in callee && 'name' in callee.property\n      ? callee.property.name\n      : undefined;\n  if (name === undefined) {\n    return;\n  }\n\n  if (objectHooks.has(name)) {\n    const workletToProcess = path.get('arguments.0');\n    assert(!Array.isArray(workletToProcess), \"'workletToProcess' is an array'\");\n    if (workletToProcess.isObjectExpression()) {\n      processObjectHook(workletToProcess, state);\n      // useAnimatedScrollHandler can take a function as an argument instead of an ObjectExpression\n      // but useAnimatedGestureHandler can't\n    } else if (name === 'useAnimatedScrollHandler') {\n      processIfWorkletFunction(workletToProcess, state);\n    }\n  } else {\n    const indices = functionArgsToWorkletize.get(name);\n    if (indices === undefined) {\n      return;\n    }\n    processArguments(path, indices, state);\n  }\n}\n\nfunction processObjectHook(\n  path: NodePath<ObjectExpression>,\n  state: ReanimatedPluginPass\n) {\n  const properties = path.get('properties');\n  for (const property of properties) {\n    if (property.isObjectMethod()) {\n      processWorkletObjectMethod(property, state);\n    } else if (property.isObjectProperty()) {\n      const value = property.get('value');\n      processIfWorkletFunction(value, state);\n    } else {\n      throw new Error(\n        `'${property.type}' as to-be workletized arguments is not supported for object hooks`\n      );\n    }\n  }\n}\n\nfunction processArguments(\n  path: NodePath<CallExpression>,\n  indices: number[],\n  state: ReanimatedPluginPass\n) {\n  const argumentsArray = path.get('arguments');\n  indices.forEach((index) => {\n    const argumentToWorkletize = argumentsArray[index];\n    if (!argumentToWorkletize) {\n      // workletizable argument doesn't always have to be specified\n      return;\n    }\n    processIfWorkletFunction(argumentToWorkletize, state);\n  });\n}\n","import { NodePath } from '@babel/core';\nimport {\n  FunctionDeclaration,\n  FunctionExpression,\n  ArrowFunctionExpression,\n  isBlockStatement,\n  isDirectiveLiteral,\n} from '@babel/types';\nimport { processIfWorkletFunction } from './processIfWorkletFunction';\nimport { ReanimatedPluginPass } from './types';\n\nexport function processIfWorkletNode(\n  fun: NodePath<\n    FunctionDeclaration | FunctionExpression | ArrowFunctionExpression\n  >,\n  state: ReanimatedPluginPass\n) {\n  fun.traverse({\n    DirectiveLiteral(path) {\n      const value = path.node.value;\n      if (\n        value === 'worklet' &&\n        path.getFunctionParent() === fun &&\n        isBlockStatement(fun.node.body)\n      ) {\n        // make sure \"worklet\" is listed among directives for the fun\n        // this is necessary as because of some bug, babel will attempt to\n        // process replaced function if it is nested inside another function\n        const directives = fun.node.body.directives;\n        if (\n          directives &&\n          directives.length > 0 &&\n          directives.some(\n            (directive) =>\n              isDirectiveLiteral(directive.value) &&\n              directive.value.value === 'worklet'\n          )\n        ) {\n          processIfWorkletFunction(fun, state);\n        }\n      }\n    },\n  });\n}\n","import { NodePath } from '@babel/core';\nimport {\n  FunctionDeclaration,\n  FunctionExpression,\n  ArrowFunctionExpression,\n  isIdentifier,\n  isCallExpression,\n  Expression,\n  isMemberExpression,\n  isExpression,\n} from '@babel/types';\nimport { processIfWorkletFunction } from './processIfWorkletFunction';\nimport { ReanimatedPluginPass } from './types';\n\nconst gestureHandlerGestureObjects = new Set([\n  // from https://github.com/software-mansion/react-native-gesture-handler/blob/new-api/src/handlers/gestures/gestureObjects.ts\n  'Tap',\n  'Pan',\n  'Pinch',\n  'Rotation',\n  'Fling',\n  'LongPress',\n  'ForceTouch',\n  'Native',\n  'Manual',\n  'Race',\n  'Simultaneous',\n  'Exclusive',\n]);\n\nconst gestureHandlerBuilderMethods = new Set([\n  'onBegin',\n  'onStart',\n  'onEnd',\n  'onFinalize',\n  'onUpdate',\n  'onChange',\n  'onTouchesDown',\n  'onTouchesMove',\n  'onTouchesUp',\n  'onTouchesCancelled',\n]);\n\n// Auto-workletizes React Native Gesture Handler callback functions.\n// Detects `Gesture.Tap().onEnd(<fun>)` or similar, but skips `something.onEnd(<fun>)`.\n// Supports method chaining as well, e.g. `Gesture.Tap().onStart(<fun1>).onUpdate(<fun2>).onEnd(<fun3>)`.\n\n// Example #1: `Gesture.Tap().onEnd(<fun>)`\n/*\n  CallExpression(\n    callee: MemberExpression(\n      object: CallExpression(\n        callee: MemberExpression(\n          object: Identifier('Gesture')\n          property: Identifier('Tap')\n        )\n      )\n      property: Identifier('onEnd')\n    )\n    arguments: [fun]\n  )\n  */\n\n// Example #2: `Gesture.Tap().onStart(<fun1>).onUpdate(<fun2>).onEnd(<fun3>)`\n/*\n  CallExpression(\n    callee: MemberExpression(\n      object: CallExpression(\n        callee: MemberExpression(\n          object: CallExpression(\n            callee: MemberExpression(\n              object: CallExpression(\n                callee: MemberExpression(\n                  object: Identifier('Gesture')\n                  property: Identifier('Tap')\n                )\n              )\n              property: Identifier('onStart')\n            )\n            arguments: [fun1]\n          )\n          property: Identifier('onUpdate')\n        )\n        arguments: [fun2]\n      )\n      property: Identifier('onEnd')\n    )\n    arguments: [fun3]\n  )\n  */\nexport function processIfGestureHandlerEventCallbackFunctionNode(\n  path: NodePath<\n    FunctionDeclaration | FunctionExpression | ArrowFunctionExpression\n  >,\n  state: ReanimatedPluginPass\n) {\n  if (\n    isCallExpression(path.parent) &&\n    isExpression(path.parent.callee) &&\n    isGestureObjectEventCallbackMethod(path.parent.callee)\n  ) {\n    processIfWorkletFunction(path, state);\n  }\n}\n\nfunction isGestureObjectEventCallbackMethod(exp: Expression) {\n  // Checks if node matches the pattern `Gesture.Foo()[*].onBar`\n  // where `[*]` represents any number of method calls.\n  return (\n    isMemberExpression(exp) &&\n    isIdentifier(exp.property) &&\n    gestureHandlerBuilderMethods.has(exp.property.name) &&\n    containsGestureObject(exp.object)\n  );\n}\n\nfunction containsGestureObject(exp: Expression) {\n  // Checks if node matches the pattern `Gesture.Foo()[*]`\n  // where `[*]` represents any number of chained method calls, like `.something(42)`.\n\n  // direct call\n  if (isGestureObject(exp)) {\n    return true;\n  }\n\n  // method chaining\n  if (\n    isCallExpression(exp) &&\n    isMemberExpression(exp.callee) &&\n    containsGestureObject(exp.callee.object)\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isGestureObject(exp: Expression) {\n  // Checks if node matches `Gesture.Tap()` or similar.\n  /*\n  node: CallExpression(\n    callee: MemberExpression(\n      object: Identifier('Gesture')\n      property: Identifier('Tap')\n    )\n  )\n  */\n  return (\n    isCallExpression(exp) &&\n    isMemberExpression(exp.callee) &&\n    isIdentifier(exp.callee.object) &&\n    exp.callee.object.name === 'Gesture' &&\n    isIdentifier(exp.callee.property) &&\n    gestureHandlerGestureObjects.has(exp.callee.property.name)\n  );\n}\n","import { NodePath } from '@babel/core';\nimport {\n  MemberExpression,\n  callExpression,\n  arrowFunctionExpression,\n  isArrayExpression,\n  ObjectExpression,\n  JSXAttribute,\n  isJSXExpressionContainer,\n  identifier,\n  stringLiteral,\n  expressionStatement,\n  memberExpression,\n  returnStatement,\n  blockStatement,\n  ObjectProperty,\n  isIdentifier,\n} from '@babel/types';\nimport { isRelease } from './utils';\nimport { ReanimatedPluginPass } from './types';\nimport { strict as assert } from 'assert';\n\nfunction generateInlineStylesWarning(path: NodePath<MemberExpression>) {\n  // replaces `sharedvalue.value` with `(()=>{console.warn(require('react-native-reanimated').getUseOfValueInStyleWarning());return sharedvalue.value;})()`\n  return callExpression(\n    arrowFunctionExpression(\n      [],\n      blockStatement([\n        expressionStatement(\n          callExpression(\n            memberExpression(identifier('console'), identifier('warn')),\n            [\n              callExpression(\n                memberExpression(\n                  callExpression(identifier('require'), [\n                    stringLiteral('react-native-reanimated'),\n                  ]),\n                  identifier('getUseOfValueInStyleWarning')\n                ),\n                []\n              ),\n            ]\n          )\n        ),\n        returnStatement(path.node),\n      ])\n    ),\n    []\n  );\n}\n\nfunction processPropertyValueForInlineStylesWarning(\n  path: NodePath<ObjectProperty['value']>\n) {\n  // if it's something like object.value then raise a warning\n  if (path.isMemberExpression() && isIdentifier(path.node.property)) {\n    if (path.node.property.name === 'value') {\n      path.replaceWith(generateInlineStylesWarning(path));\n    }\n  }\n}\n\nfunction processTransformPropertyForInlineStylesWarning(\n  path: NodePath<ObjectProperty['value']>\n) {\n  if (isArrayExpression(path.node)) {\n    const elements = path.get('elements');\n    assert(Array.isArray(elements), \"'elements' should be an array\");\n    for (const element of elements) {\n      if (element.isObjectExpression()) {\n        processStyleObjectForInlineStylesWarning(element);\n      }\n    }\n  }\n}\n\nfunction processStyleObjectForInlineStylesWarning(\n  path: NodePath<ObjectExpression>\n) {\n  const properties = path.get('properties');\n  for (const property of properties) {\n    if (property.isObjectProperty()) {\n      const value = property.get('value');\n      if (\n        isIdentifier(property.node.key) &&\n        property.node.key.name === 'transform'\n      ) {\n        processTransformPropertyForInlineStylesWarning(value);\n      } else {\n        processPropertyValueForInlineStylesWarning(value);\n      }\n    }\n  }\n}\n\nexport function processInlineStylesWarning(\n  path: NodePath<JSXAttribute>,\n  state: ReanimatedPluginPass\n) {\n  if (isRelease()) {\n    return;\n  }\n  if (state.opts.disableInlineStylesWarning) {\n    return;\n  }\n  if (path.node.name.name !== 'style') {\n    return;\n  }\n  if (!isJSXExpressionContainer(path.node.value)) {\n    return;\n  }\n\n  const expression = path.get('value').get('expression');\n  // style={[{...}, {...}]}\n  assert(!Array.isArray(expression), \"'expression' should not be an array\");\n  if (expression.isArrayExpression()) {\n    const elements = expression.get('elements');\n    assert(Array.isArray(elements), \"'elements' should be an array\");\n    for (const element of elements) {\n      if (element.isObjectExpression()) {\n        processStyleObjectForInlineStylesWarning(element);\n      }\n    }\n  }\n  // style={{...}}\n  else if (expression.isObjectExpression()) {\n    processStyleObjectForInlineStylesWarning(expression);\n  }\n}\n","import { PluginItem, NodePath } from '@babel/core';\nimport { globals } from './commonObjects';\nimport {\n  CallExpression,\n  FunctionDeclaration,\n  FunctionExpression,\n  ArrowFunctionExpression,\n} from '@babel/types';\nimport { processForCalleesWorklets } from './processForCalleesWorklets';\nimport { ReanimatedPluginPass } from './types';\nimport { processIfWorkletNode } from './processIfWorkletNode';\nimport { processIfGestureHandlerEventCallbackFunctionNode } from './processIfGestureHandlerEventCallbackFunctionNode';\nimport { processInlineStylesWarning } from './processInlineStylesWarning';\n\nmodule.exports = function (): PluginItem {\n  return {\n    pre() {\n      // allows adding custom globals such as host-functions\n      if (this.opts != null && Array.isArray(this.opts.globals)) {\n        this.opts.globals.forEach((name: string) => {\n          globals.add(name);\n        });\n      }\n    },\n    visitor: {\n      CallExpression: {\n        enter(path: NodePath<CallExpression>, state: ReanimatedPluginPass) {\n          processForCalleesWorklets(path, state);\n        },\n      },\n      'FunctionDeclaration|FunctionExpression|ArrowFunctionExpression': {\n        enter(\n          path: NodePath<\n            FunctionDeclaration | FunctionExpression | ArrowFunctionExpression\n          >,\n          state: ReanimatedPluginPass\n        ) {\n          processIfWorkletNode(path, state);\n          processIfGestureHandlerEventCallbackFunctionNode(path, state);\n        },\n      },\n      JSXAttribute: {\n        enter(path, state) {\n          processInlineStylesWarning(path, state);\n        },\n      },\n    },\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}