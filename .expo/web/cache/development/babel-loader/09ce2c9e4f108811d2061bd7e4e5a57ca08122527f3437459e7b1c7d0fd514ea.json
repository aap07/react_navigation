{"ast":null,"code":"'use strict';\n\nfunction getValueFromTypes(value, types) {\n  switch (value.type) {\n    case 'TSTypeReference':\n      if (types[value.typeName.name]) {\n        return getValueFromTypes(types[value.typeName.name], types);\n      } else {\n        return value;\n      }\n    case 'TSTypeAliasDeclaration':\n      return getValueFromTypes(value.typeAnnotation, types);\n    default:\n      return value;\n  }\n}\nfunction isNull(t) {\n  return t.type === 'TSNullKeyword' || t.type === 'TSUndefinedKeyword';\n}\nfunction isNullOrVoid(t) {\n  return isNull(t) || t.type === 'TSVoidKeyword';\n}\nfunction couldBeNumericLiteral(type) {\n  return type === 'Literal' || type === 'NumericLiteral';\n}\nfunction couldBeSimpleLiteral(type) {\n  return couldBeNumericLiteral(type) || type === 'StringLiteral' || type === 'BooleanLiteral';\n}\nfunction evaluateLiteral(literalNode) {\n  var valueType = literalNode.type;\n  if (valueType === 'TSLiteralType') {\n    var literal = literalNode.literal;\n    if (couldBeSimpleLiteral(literal.type)) {\n      if (typeof literal.value === 'string' || typeof literal.value === 'number' || typeof literal.value === 'boolean') {\n        return literal.value;\n      }\n    } else if (literal.type === 'UnaryExpression' && literal.operator === '-' && couldBeNumericLiteral(literal.argument.type) && typeof literal.argument.value === 'number') {\n      return -literal.argument.value;\n    }\n  } else if (isNull(literalNode)) {\n    return null;\n  }\n  throw new Error('The default value in WithDefault must be string, number, boolean or null .');\n}\nfunction handleUnionAndParen(type, result, knownTypes) {\n  switch (type.type) {\n    case 'TSParenthesizedType':\n      {\n        handleUnionAndParen(type.typeAnnotation, result, knownTypes);\n        break;\n      }\n    case 'TSUnionType':\n      {\n        for (var t of type.types) {\n          if (isNullOrVoid(t)) {\n            result.optional = true;\n          }\n        }\n        for (var _t of type.types) {\n          if (!isNullOrVoid(_t)) {\n            handleUnionAndParen(_t, result, knownTypes);\n          }\n        }\n        break;\n      }\n    case 'TSTypeReference':\n      if (type.typeName.name === 'Readonly') {\n        handleUnionAndParen(type.typeParameters.params[0], result, knownTypes);\n      } else if (type.typeName.name === 'WithDefault') {\n        if (result.optional) {\n          throw new Error('WithDefault<> is optional and does not need to be marked as optional. Please remove the union of undefined and/or null');\n        }\n        if (type.typeParameters.params.length !== 2) {\n          throw new Error('WithDefault requires two parameters: type and default value.');\n        }\n        if (result.defaultValue !== undefined) {\n          throw new Error('Multiple WithDefault is not allowed nested or in a union type.');\n        }\n        result.optional = true;\n        result.defaultValue = evaluateLiteral(type.typeParameters.params[1]);\n        handleUnionAndParen(type.typeParameters.params[0], result, knownTypes);\n      } else if (!knownTypes) {\n        result.unions.push(type);\n      } else {\n        var resolvedType = getValueFromTypes(type, knownTypes);\n        if (resolvedType.type === 'TSTypeReference' && resolvedType.typeName.name === type.typeName.name) {\n          result.unions.push(type);\n        } else {\n          handleUnionAndParen(resolvedType, result, knownTypes);\n        }\n      }\n      break;\n    default:\n      result.unions.push(type);\n  }\n}\nfunction parseTopLevelType(type, knownTypes) {\n  var result = {\n    unions: [],\n    optional: false\n  };\n  handleUnionAndParen(type, result, knownTypes);\n  if (result.unions.length === 0) {\n    throw new Error('Union type could not be just null or undefined.');\n  } else if (result.unions.length === 1) {\n    return {\n      type: result.unions[0],\n      optional: result.optional,\n      defaultValue: result.defaultValue\n    };\n  } else {\n    return {\n      type: {\n        type: 'TSUnionType',\n        types: result.unions\n      },\n      optional: result.optional,\n      defaultValue: result.defaultValue\n    };\n  }\n}\nfunction handleIntersectionAndParen(type, result, knownTypes) {\n  switch (type.type) {\n    case 'TSParenthesizedType':\n      {\n        handleIntersectionAndParen(type.typeAnnotation, result, knownTypes);\n        break;\n      }\n    case 'TSIntersectionType':\n      {\n        for (var t of type.types) {\n          handleIntersectionAndParen(t, result, knownTypes);\n        }\n        break;\n      }\n    case 'TSTypeReference':\n      if (type.typeName.name === 'Readonly') {\n        handleIntersectionAndParen(type.typeParameters.params[0], result, knownTypes);\n      } else if (type.typeName.name === 'WithDefault') {\n        throw new Error('WithDefault<> is now allowed in intersection types.');\n      } else if (!knownTypes) {\n        result.push(type);\n      } else {\n        var resolvedType = getValueFromTypes(type, knownTypes);\n        if (resolvedType.type === 'TSTypeReference' && resolvedType.typeName.name === type.typeName.name) {\n          result.push(type);\n        } else {\n          handleIntersectionAndParen(resolvedType, result, knownTypes);\n        }\n      }\n      break;\n    default:\n      result.push(type);\n  }\n}\nfunction flattenIntersectionType(type, knownTypes) {\n  var result = [];\n  handleIntersectionAndParen(type, result, knownTypes);\n  return result;\n}\nmodule.exports = {\n  parseTopLevelType: parseTopLevelType,\n  flattenIntersectionType: flattenIntersectionType\n};","map":{"version":3,"names":["getValueFromTypes","value","types","type","typeName","name","typeAnnotation","isNull","t","isNullOrVoid","couldBeNumericLiteral","couldBeSimpleLiteral","evaluateLiteral","literalNode","valueType","literal","operator","argument","Error","handleUnionAndParen","result","knownTypes","optional","typeParameters","params","length","defaultValue","undefined","unions","push","resolvedType","parseTopLevelType","handleIntersectionAndParen","flattenIntersectionType","module","exports"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native/codegen/lib/parsers/typescript/parseTopLevelType.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\n'use strict';\n\nfunction getValueFromTypes(value, types) {\n  switch (value.type) {\n    case 'TSTypeReference':\n      if (types[value.typeName.name]) {\n        return getValueFromTypes(types[value.typeName.name], types);\n      } else {\n        return value;\n      }\n    case 'TSTypeAliasDeclaration':\n      return getValueFromTypes(value.typeAnnotation, types);\n    default:\n      return value;\n  }\n}\nfunction isNull(t) {\n  return t.type === 'TSNullKeyword' || t.type === 'TSUndefinedKeyword';\n}\nfunction isNullOrVoid(t) {\n  return isNull(t) || t.type === 'TSVoidKeyword';\n}\nfunction couldBeNumericLiteral(type) {\n  return type === 'Literal' || type === 'NumericLiteral';\n}\nfunction couldBeSimpleLiteral(type) {\n  return (\n    couldBeNumericLiteral(type) ||\n    type === 'StringLiteral' ||\n    type === 'BooleanLiteral'\n  );\n}\nfunction evaluateLiteral(literalNode) {\n  const valueType = literalNode.type;\n  if (valueType === 'TSLiteralType') {\n    const literal = literalNode.literal;\n    if (couldBeSimpleLiteral(literal.type)) {\n      if (\n        typeof literal.value === 'string' ||\n        typeof literal.value === 'number' ||\n        typeof literal.value === 'boolean'\n      ) {\n        return literal.value;\n      }\n    } else if (\n      literal.type === 'UnaryExpression' &&\n      literal.operator === '-' &&\n      couldBeNumericLiteral(literal.argument.type) &&\n      typeof literal.argument.value === 'number'\n    ) {\n      return -literal.argument.value;\n    }\n  } else if (isNull(literalNode)) {\n    return null;\n  }\n  throw new Error(\n    'The default value in WithDefault must be string, number, boolean or null .',\n  );\n}\nfunction handleUnionAndParen(type, result, knownTypes) {\n  switch (type.type) {\n    case 'TSParenthesizedType': {\n      handleUnionAndParen(type.typeAnnotation, result, knownTypes);\n      break;\n    }\n    case 'TSUnionType': {\n      // the order is important\n      // result.optional must be set first\n      for (const t of type.types) {\n        if (isNullOrVoid(t)) {\n          result.optional = true;\n        }\n      }\n      for (const t of type.types) {\n        if (!isNullOrVoid(t)) {\n          handleUnionAndParen(t, result, knownTypes);\n        }\n      }\n      break;\n    }\n    case 'TSTypeReference':\n      if (type.typeName.name === 'Readonly') {\n        handleUnionAndParen(type.typeParameters.params[0], result, knownTypes);\n      } else if (type.typeName.name === 'WithDefault') {\n        if (result.optional) {\n          throw new Error(\n            'WithDefault<> is optional and does not need to be marked as optional. Please remove the union of undefined and/or null',\n          );\n        }\n        if (type.typeParameters.params.length !== 2) {\n          throw new Error(\n            'WithDefault requires two parameters: type and default value.',\n          );\n        }\n        if (result.defaultValue !== undefined) {\n          throw new Error(\n            'Multiple WithDefault is not allowed nested or in a union type.',\n          );\n        }\n        result.optional = true;\n        result.defaultValue = evaluateLiteral(type.typeParameters.params[1]);\n        handleUnionAndParen(type.typeParameters.params[0], result, knownTypes);\n      } else if (!knownTypes) {\n        result.unions.push(type);\n      } else {\n        const resolvedType = getValueFromTypes(type, knownTypes);\n        if (\n          resolvedType.type === 'TSTypeReference' &&\n          resolvedType.typeName.name === type.typeName.name\n        ) {\n          result.unions.push(type);\n        } else {\n          handleUnionAndParen(resolvedType, result, knownTypes);\n        }\n      }\n      break;\n    default:\n      result.unions.push(type);\n  }\n}\nfunction parseTopLevelType(type, knownTypes) {\n  let result = {\n    unions: [],\n    optional: false,\n  };\n  handleUnionAndParen(type, result, knownTypes);\n  if (result.unions.length === 0) {\n    throw new Error('Union type could not be just null or undefined.');\n  } else if (result.unions.length === 1) {\n    return {\n      type: result.unions[0],\n      optional: result.optional,\n      defaultValue: result.defaultValue,\n    };\n  } else {\n    return {\n      type: {\n        type: 'TSUnionType',\n        types: result.unions,\n      },\n      optional: result.optional,\n      defaultValue: result.defaultValue,\n    };\n  }\n}\nfunction handleIntersectionAndParen(type, result, knownTypes) {\n  switch (type.type) {\n    case 'TSParenthesizedType': {\n      handleIntersectionAndParen(type.typeAnnotation, result, knownTypes);\n      break;\n    }\n    case 'TSIntersectionType': {\n      for (const t of type.types) {\n        handleIntersectionAndParen(t, result, knownTypes);\n      }\n      break;\n    }\n    case 'TSTypeReference':\n      if (type.typeName.name === 'Readonly') {\n        handleIntersectionAndParen(\n          type.typeParameters.params[0],\n          result,\n          knownTypes,\n        );\n      } else if (type.typeName.name === 'WithDefault') {\n        throw new Error('WithDefault<> is now allowed in intersection types.');\n      } else if (!knownTypes) {\n        result.push(type);\n      } else {\n        const resolvedType = getValueFromTypes(type, knownTypes);\n        if (\n          resolvedType.type === 'TSTypeReference' &&\n          resolvedType.typeName.name === type.typeName.name\n        ) {\n          result.push(type);\n        } else {\n          handleIntersectionAndParen(resolvedType, result, knownTypes);\n        }\n      }\n      break;\n    default:\n      result.push(type);\n  }\n}\nfunction flattenIntersectionType(type, knownTypes) {\n  const result = [];\n  handleIntersectionAndParen(type, result, knownTypes);\n  return result;\n}\nmodule.exports = {\n  parseTopLevelType,\n  flattenIntersectionType,\n};\n"],"mappings":"AAUA,YAAY;;AAEZ,SAASA,iBAAiBA,CAACC,KAAK,EAAEC,KAAK,EAAE;EACvC,QAAQD,KAAK,CAACE,IAAI;IAChB,KAAK,iBAAiB;MACpB,IAAID,KAAK,CAACD,KAAK,CAACG,QAAQ,CAACC,IAAI,CAAC,EAAE;QAC9B,OAAOL,iBAAiB,CAACE,KAAK,CAACD,KAAK,CAACG,QAAQ,CAACC,IAAI,CAAC,EAAEH,KAAK,CAAC;MAC7D,CAAC,MAAM;QACL,OAAOD,KAAK;MACd;IACF,KAAK,wBAAwB;MAC3B,OAAOD,iBAAiB,CAACC,KAAK,CAACK,cAAc,EAAEJ,KAAK,CAAC;IACvD;MACE,OAAOD,KAAK;EAChB;AACF;AACA,SAASM,MAAMA,CAACC,CAAC,EAAE;EACjB,OAAOA,CAAC,CAACL,IAAI,KAAK,eAAe,IAAIK,CAAC,CAACL,IAAI,KAAK,oBAAoB;AACtE;AACA,SAASM,YAAYA,CAACD,CAAC,EAAE;EACvB,OAAOD,MAAM,CAACC,CAAC,CAAC,IAAIA,CAAC,CAACL,IAAI,KAAK,eAAe;AAChD;AACA,SAASO,qBAAqBA,CAACP,IAAI,EAAE;EACnC,OAAOA,IAAI,KAAK,SAAS,IAAIA,IAAI,KAAK,gBAAgB;AACxD;AACA,SAASQ,oBAAoBA,CAACR,IAAI,EAAE;EAClC,OACEO,qBAAqB,CAACP,IAAI,CAAC,IAC3BA,IAAI,KAAK,eAAe,IACxBA,IAAI,KAAK,gBAAgB;AAE7B;AACA,SAASS,eAAeA,CAACC,WAAW,EAAE;EACpC,IAAMC,SAAS,GAAGD,WAAW,CAACV,IAAI;EAClC,IAAIW,SAAS,KAAK,eAAe,EAAE;IACjC,IAAMC,OAAO,GAAGF,WAAW,CAACE,OAAO;IACnC,IAAIJ,oBAAoB,CAACI,OAAO,CAACZ,IAAI,CAAC,EAAE;MACtC,IACE,OAAOY,OAAO,CAACd,KAAK,KAAK,QAAQ,IACjC,OAAOc,OAAO,CAACd,KAAK,KAAK,QAAQ,IACjC,OAAOc,OAAO,CAACd,KAAK,KAAK,SAAS,EAClC;QACA,OAAOc,OAAO,CAACd,KAAK;MACtB;IACF,CAAC,MAAM,IACLc,OAAO,CAACZ,IAAI,KAAK,iBAAiB,IAClCY,OAAO,CAACC,QAAQ,KAAK,GAAG,IACxBN,qBAAqB,CAACK,OAAO,CAACE,QAAQ,CAACd,IAAI,CAAC,IAC5C,OAAOY,OAAO,CAACE,QAAQ,CAAChB,KAAK,KAAK,QAAQ,EAC1C;MACA,OAAO,CAACc,OAAO,CAACE,QAAQ,CAAChB,KAAK;IAChC;EACF,CAAC,MAAM,IAAIM,MAAM,CAACM,WAAW,CAAC,EAAE;IAC9B,OAAO,IAAI;EACb;EACA,MAAM,IAAIK,KAAK,CACb,4EACF,CAAC;AACH;AACA,SAASC,mBAAmBA,CAAChB,IAAI,EAAEiB,MAAM,EAAEC,UAAU,EAAE;EACrD,QAAQlB,IAAI,CAACA,IAAI;IACf,KAAK,qBAAqB;MAAE;QAC1BgB,mBAAmB,CAAChB,IAAI,CAACG,cAAc,EAAEc,MAAM,EAAEC,UAAU,CAAC;QAC5D;MACF;IACA,KAAK,aAAa;MAAE;QAGlB,KAAK,IAAMb,CAAC,IAAIL,IAAI,CAACD,KAAK,EAAE;UAC1B,IAAIO,YAAY,CAACD,CAAC,CAAC,EAAE;YACnBY,MAAM,CAACE,QAAQ,GAAG,IAAI;UACxB;QACF;QACA,KAAK,IAAMd,EAAC,IAAIL,IAAI,CAACD,KAAK,EAAE;UAC1B,IAAI,CAACO,YAAY,CAACD,EAAC,CAAC,EAAE;YACpBW,mBAAmB,CAACX,EAAC,EAAEY,MAAM,EAAEC,UAAU,CAAC;UAC5C;QACF;QACA;MACF;IACA,KAAK,iBAAiB;MACpB,IAAIlB,IAAI,CAACC,QAAQ,CAACC,IAAI,KAAK,UAAU,EAAE;QACrCc,mBAAmB,CAAChB,IAAI,CAACoB,cAAc,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEJ,MAAM,EAAEC,UAAU,CAAC;MACxE,CAAC,MAAM,IAAIlB,IAAI,CAACC,QAAQ,CAACC,IAAI,KAAK,aAAa,EAAE;QAC/C,IAAIe,MAAM,CAACE,QAAQ,EAAE;UACnB,MAAM,IAAIJ,KAAK,CACb,wHACF,CAAC;QACH;QACA,IAAIf,IAAI,CAACoB,cAAc,CAACC,MAAM,CAACC,MAAM,KAAK,CAAC,EAAE;UAC3C,MAAM,IAAIP,KAAK,CACb,8DACF,CAAC;QACH;QACA,IAAIE,MAAM,CAACM,YAAY,KAAKC,SAAS,EAAE;UACrC,MAAM,IAAIT,KAAK,CACb,gEACF,CAAC;QACH;QACAE,MAAM,CAACE,QAAQ,GAAG,IAAI;QACtBF,MAAM,CAACM,YAAY,GAAGd,eAAe,CAACT,IAAI,CAACoB,cAAc,CAACC,MAAM,CAAC,CAAC,CAAC,CAAC;QACpEL,mBAAmB,CAAChB,IAAI,CAACoB,cAAc,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEJ,MAAM,EAAEC,UAAU,CAAC;MACxE,CAAC,MAAM,IAAI,CAACA,UAAU,EAAE;QACtBD,MAAM,CAACQ,MAAM,CAACC,IAAI,CAAC1B,IAAI,CAAC;MAC1B,CAAC,MAAM;QACL,IAAM2B,YAAY,GAAG9B,iBAAiB,CAACG,IAAI,EAAEkB,UAAU,CAAC;QACxD,IACES,YAAY,CAAC3B,IAAI,KAAK,iBAAiB,IACvC2B,YAAY,CAAC1B,QAAQ,CAACC,IAAI,KAAKF,IAAI,CAACC,QAAQ,CAACC,IAAI,EACjD;UACAe,MAAM,CAACQ,MAAM,CAACC,IAAI,CAAC1B,IAAI,CAAC;QAC1B,CAAC,MAAM;UACLgB,mBAAmB,CAACW,YAAY,EAAEV,MAAM,EAAEC,UAAU,CAAC;QACvD;MACF;MACA;IACF;MACED,MAAM,CAACQ,MAAM,CAACC,IAAI,CAAC1B,IAAI,CAAC;EAC5B;AACF;AACA,SAAS4B,iBAAiBA,CAAC5B,IAAI,EAAEkB,UAAU,EAAE;EAC3C,IAAID,MAAM,GAAG;IACXQ,MAAM,EAAE,EAAE;IACVN,QAAQ,EAAE;EACZ,CAAC;EACDH,mBAAmB,CAAChB,IAAI,EAAEiB,MAAM,EAAEC,UAAU,CAAC;EAC7C,IAAID,MAAM,CAACQ,MAAM,CAACH,MAAM,KAAK,CAAC,EAAE;IAC9B,MAAM,IAAIP,KAAK,CAAC,iDAAiD,CAAC;EACpE,CAAC,MAAM,IAAIE,MAAM,CAACQ,MAAM,CAACH,MAAM,KAAK,CAAC,EAAE;IACrC,OAAO;MACLtB,IAAI,EAAEiB,MAAM,CAACQ,MAAM,CAAC,CAAC,CAAC;MACtBN,QAAQ,EAAEF,MAAM,CAACE,QAAQ;MACzBI,YAAY,EAAEN,MAAM,CAACM;IACvB,CAAC;EACH,CAAC,MAAM;IACL,OAAO;MACLvB,IAAI,EAAE;QACJA,IAAI,EAAE,aAAa;QACnBD,KAAK,EAAEkB,MAAM,CAACQ;MAChB,CAAC;MACDN,QAAQ,EAAEF,MAAM,CAACE,QAAQ;MACzBI,YAAY,EAAEN,MAAM,CAACM;IACvB,CAAC;EACH;AACF;AACA,SAASM,0BAA0BA,CAAC7B,IAAI,EAAEiB,MAAM,EAAEC,UAAU,EAAE;EAC5D,QAAQlB,IAAI,CAACA,IAAI;IACf,KAAK,qBAAqB;MAAE;QAC1B6B,0BAA0B,CAAC7B,IAAI,CAACG,cAAc,EAAEc,MAAM,EAAEC,UAAU,CAAC;QACnE;MACF;IACA,KAAK,oBAAoB;MAAE;QACzB,KAAK,IAAMb,CAAC,IAAIL,IAAI,CAACD,KAAK,EAAE;UAC1B8B,0BAA0B,CAACxB,CAAC,EAAEY,MAAM,EAAEC,UAAU,CAAC;QACnD;QACA;MACF;IACA,KAAK,iBAAiB;MACpB,IAAIlB,IAAI,CAACC,QAAQ,CAACC,IAAI,KAAK,UAAU,EAAE;QACrC2B,0BAA0B,CACxB7B,IAAI,CAACoB,cAAc,CAACC,MAAM,CAAC,CAAC,CAAC,EAC7BJ,MAAM,EACNC,UACF,CAAC;MACH,CAAC,MAAM,IAAIlB,IAAI,CAACC,QAAQ,CAACC,IAAI,KAAK,aAAa,EAAE;QAC/C,MAAM,IAAIa,KAAK,CAAC,qDAAqD,CAAC;MACxE,CAAC,MAAM,IAAI,CAACG,UAAU,EAAE;QACtBD,MAAM,CAACS,IAAI,CAAC1B,IAAI,CAAC;MACnB,CAAC,MAAM;QACL,IAAM2B,YAAY,GAAG9B,iBAAiB,CAACG,IAAI,EAAEkB,UAAU,CAAC;QACxD,IACES,YAAY,CAAC3B,IAAI,KAAK,iBAAiB,IACvC2B,YAAY,CAAC1B,QAAQ,CAACC,IAAI,KAAKF,IAAI,CAACC,QAAQ,CAACC,IAAI,EACjD;UACAe,MAAM,CAACS,IAAI,CAAC1B,IAAI,CAAC;QACnB,CAAC,MAAM;UACL6B,0BAA0B,CAACF,YAAY,EAAEV,MAAM,EAAEC,UAAU,CAAC;QAC9D;MACF;MACA;IACF;MACED,MAAM,CAACS,IAAI,CAAC1B,IAAI,CAAC;EACrB;AACF;AACA,SAAS8B,uBAAuBA,CAAC9B,IAAI,EAAEkB,UAAU,EAAE;EACjD,IAAMD,MAAM,GAAG,EAAE;EACjBY,0BAA0B,CAAC7B,IAAI,EAAEiB,MAAM,EAAEC,UAAU,CAAC;EACpD,OAAOD,MAAM;AACf;AACAc,MAAM,CAACC,OAAO,GAAG;EACfJ,iBAAiB,EAAjBA,iBAAiB;EACjBE,uBAAuB,EAAvBA;AACF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}