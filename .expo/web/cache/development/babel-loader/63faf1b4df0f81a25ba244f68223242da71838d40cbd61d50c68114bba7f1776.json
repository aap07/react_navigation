{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ensureSimulatorOpenAsync = ensureSimulatorOpenAsync;\nvar osascript = _interopRequireWildcard(require(\"@expo/osascript\"));\nvar _assert = _interopRequireDefault(require(\"assert\"));\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\nvar _fs = _interopRequireDefault(require(\"fs\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _delay = require(\"../../../utils/delay\");\nvar _errors = require(\"../../../utils/errors\");\nvar _plist = require(\"../../../utils/plist\");\nvar _url = require(\"../../../utils/url\");\nvar _deviceManager = require(\"../DeviceManager\");\nvar _expoGoInstaller = require(\"../ExpoGoInstaller\");\nvar _assertSystemRequirements = require(\"./assertSystemRequirements\");\nvar _ensureSimulatorAppRunning = require(\"./ensureSimulatorAppRunning\");\nvar _getBestSimulator = require(\"./getBestSimulator\");\nvar _promptAppleDevice = require(\"./promptAppleDevice\");\nvar SimControl = _interopRequireWildcard(require(\"./simctl\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nvar debug = require(\"debug\")(\"expo:start:platforms:ios:AppleDeviceManager\");\nvar EXPO_GO_BUNDLE_IDENTIFIER = \"host.exp.Exponent\";\nfunction ensureSimulatorOpenAsync() {\n  return _ensureSimulatorOpenAsync.apply(this, arguments);\n}\nfunction _ensureSimulatorOpenAsync() {\n  _ensureSimulatorOpenAsync = _asyncToGenerator(function* () {\n    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      udid = _ref2.udid,\n      osType = _ref2.osType;\n    var tryAgain = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (!udid) {\n      var simulatorOpenedByApp = yield (0, _getBestSimulator).getBestBootedSimulatorAsync({\n        osType: osType\n      });\n      if (simulatorOpenedByApp) {\n        return simulatorOpenedByApp;\n      }\n      var bestUdid = yield (0, _getBestSimulator).getBestUnbootedSimulatorAsync({\n        osType: osType\n      });\n      if (!bestUdid) {\n        throw new _errors.CommandError(\"No simulators found.\");\n      }\n      udid = bestUdid;\n    }\n    var bootedDevice = yield (0, _delay).waitForActionAsync({\n      action: function action() {\n        (0, _assert).default(udid);\n        return SimControl.bootAsync({\n          udid: udid\n        });\n      }\n    });\n    if (!bootedDevice) {\n      if (tryAgain) {\n        return yield ensureSimulatorOpenAsync({\n          udid: udid,\n          osType: osType\n        }, false);\n      }\n      throw new _errors.CommandError(\"SIMULATOR_TIMEOUT\", `Simulator didn't boot fast enough. Try opening Simulator first, then running your app.`);\n    }\n    return bootedDevice;\n  });\n  return _ensureSimulatorOpenAsync.apply(this, arguments);\n}\nvar AppleDeviceManager = function (_deviceManager$Device) {\n  _inherits(AppleDeviceManager, _deviceManager$Device);\n  var _super = _createSuper(AppleDeviceManager);\n  function AppleDeviceManager() {\n    _classCallCheck(this, AppleDeviceManager);\n    return _super.apply(this, arguments);\n  }\n  _createClass(AppleDeviceManager, [{\n    key: \"name\",\n    get: function get() {\n      return this.device.name;\n    }\n  }, {\n    key: \"identifier\",\n    get: function get() {\n      return this.device.udid;\n    }\n  }, {\n    key: \"getAppVersionAsync\",\n    value: function () {\n      var _getAppVersionAsync = _asyncToGenerator(function* (appId) {\n        return yield SimControl.getInfoPlistValueAsync(this.device, {\n          appId: appId,\n          key: \"CFBundleShortVersionString\"\n        });\n      });\n      function getAppVersionAsync(_x) {\n        return _getAppVersionAsync.apply(this, arguments);\n      }\n      return getAppVersionAsync;\n    }()\n  }, {\n    key: \"startAsync\",\n    value: function () {\n      var _startAsync = _asyncToGenerator(function* () {\n        return ensureSimulatorOpenAsync({\n          osType: this.device.osType,\n          udid: this.device.udid\n        });\n      });\n      function startAsync() {\n        return _startAsync.apply(this, arguments);\n      }\n      return startAsync;\n    }()\n  }, {\n    key: \"launchApplicationIdAsync\",\n    value: function () {\n      var _launchApplicationIdAsync = _asyncToGenerator(function* (appId) {\n        try {\n          var result = yield SimControl.openAppIdAsync(this.device, {\n            appId: appId\n          });\n          if (result.status === 0) {\n            yield this.activateWindowAsync();\n          } else {\n            throw new _errors.CommandError(result.stderr);\n          }\n        } catch (error) {\n          var errorMessage = `Couldn't open iOS app with ID \"${appId}\" on device \"${this.name}\".`;\n          if (error instanceof _errors.CommandError && error.code === \"APP_NOT_INSTALLED\") {\n            if (appId === EXPO_GO_BUNDLE_IDENTIFIER) {\n              errorMessage = `Couldn't open Expo Go app on device \"${this.name}\". Please install.`;\n            } else {\n              errorMessage += `\\nThe app might not be installed, try installing it with: ${_chalk.default.bold(`npx expo run:ios -d ${this.device.udid}`)}`;\n            }\n          }\n          if (error.stderr) {\n            errorMessage += _chalk.default.gray(`\\n${error.stderr}`);\n          } else if (error.message) {\n            errorMessage += _chalk.default.gray(`\\n${error.message}`);\n          }\n          throw new _errors.CommandError(errorMessage);\n        }\n      });\n      function launchApplicationIdAsync(_x2) {\n        return _launchApplicationIdAsync.apply(this, arguments);\n      }\n      return launchApplicationIdAsync;\n    }()\n  }, {\n    key: \"installAppAsync\",\n    value: function () {\n      var _installAppAsync = _asyncToGenerator(function* (filePath) {\n        yield SimControl.installAsync(this.device, {\n          filePath: filePath\n        });\n        yield this.waitForAppInstalledAsync(yield this.getApplicationIdFromBundle(filePath));\n      });\n      function installAppAsync(_x3) {\n        return _installAppAsync.apply(this, arguments);\n      }\n      return installAppAsync;\n    }()\n  }, {\n    key: \"getApplicationIdFromBundle\",\n    value: function () {\n      var _getApplicationIdFromBundle = _asyncToGenerator(function* (filePath) {\n        debug(\"getApplicationIdFromBundle:\", filePath);\n        var builtInfoPlistPath = _path.default.join(filePath, \"Info.plist\");\n        if (_fs.default.existsSync(builtInfoPlistPath)) {\n          var _yield$parsePlistAsyn = yield (0, _plist).parsePlistAsync(builtInfoPlistPath),\n            CFBundleIdentifier = _yield$parsePlistAsyn.CFBundleIdentifier;\n          debug(\"getApplicationIdFromBundle: using built Info.plist\", CFBundleIdentifier);\n          return CFBundleIdentifier;\n        }\n        debug(\"getApplicationIdFromBundle: no Info.plist found\");\n        return EXPO_GO_BUNDLE_IDENTIFIER;\n      });\n      function getApplicationIdFromBundle(_x4) {\n        return _getApplicationIdFromBundle.apply(this, arguments);\n      }\n      return getApplicationIdFromBundle;\n    }()\n  }, {\n    key: \"waitForAppInstalledAsync\",\n    value: function () {\n      var _waitForAppInstalledAsync = _asyncToGenerator(function* (applicationId) {\n        while (true) {\n          if (yield this.isAppInstalledAsync(applicationId)) {\n            return true;\n          }\n          yield (0, _delay).delayAsync(100);\n        }\n      });\n      function waitForAppInstalledAsync(_x5) {\n        return _waitForAppInstalledAsync.apply(this, arguments);\n      }\n      return waitForAppInstalledAsync;\n    }()\n  }, {\n    key: \"uninstallAppAsync\",\n    value: function () {\n      var _uninstallAppAsync = _asyncToGenerator(function* (appId) {\n        yield SimControl.uninstallAsync(this.device, {\n          appId: appId\n        });\n      });\n      function uninstallAppAsync(_x6) {\n        return _uninstallAppAsync.apply(this, arguments);\n      }\n      return uninstallAppAsync;\n    }()\n  }, {\n    key: \"isAppInstalledAsync\",\n    value: function () {\n      var _isAppInstalledAsync = _asyncToGenerator(function* (appId) {\n        return !!(yield SimControl.getContainerPathAsync(this.device, {\n          appId: appId\n        }));\n      });\n      function isAppInstalledAsync(_x7) {\n        return _isAppInstalledAsync.apply(this, arguments);\n      }\n      return isAppInstalledAsync;\n    }()\n  }, {\n    key: \"openUrlAsync\",\n    value: function () {\n      var _openUrlAsync = _asyncToGenerator(function* (url) {\n        if (!(0, _url).validateUrl(url, {\n          requireProtocol: true\n        })) {\n          return yield this.launchApplicationIdAsync(url);\n        }\n        try {\n          yield SimControl.openUrlAsync(this.device, {\n            url: url\n          });\n        } catch (error) {\n          if (error.status === 194) {\n            throw new _errors.CommandError(\"APP_NOT_INSTALLED\", `Device ${this.device.name} (${this.device.udid}) has no app to handle the URI: ${url}`);\n          }\n          throw error;\n        }\n      });\n      function openUrlAsync(_x8) {\n        return _openUrlAsync.apply(this, arguments);\n      }\n      return openUrlAsync;\n    }()\n  }, {\n    key: \"activateWindowAsync\",\n    value: function () {\n      var _activateWindowAsync = _asyncToGenerator(function* () {\n        yield (0, _ensureSimulatorAppRunning).ensureSimulatorAppRunningAsync(this.device);\n        yield osascript.execAsync(`tell application \"Simulator\" to activate`);\n      });\n      function activateWindowAsync() {\n        return _activateWindowAsync.apply(this, arguments);\n      }\n      return activateWindowAsync;\n    }()\n  }, {\n    key: \"ensureExpoGoAsync\",\n    value: function () {\n      var _ensureExpoGoAsync = _asyncToGenerator(function* (sdkVersion) {\n        var installer = new _expoGoInstaller.ExpoGoInstaller(\"ios\", EXPO_GO_BUNDLE_IDENTIFIER, sdkVersion);\n        return installer.ensureAsync(this);\n      });\n      function ensureExpoGoAsync(_x9) {\n        return _ensureExpoGoAsync.apply(this, arguments);\n      }\n      return ensureExpoGoAsync;\n    }()\n  }], [{\n    key: \"resolveAsync\",\n    value: function () {\n      var _resolveAsync = _asyncToGenerator(function* () {\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          device = _ref.device,\n          shouldPrompt = _ref.shouldPrompt;\n        if (shouldPrompt) {\n          var devices = yield (0, _getBestSimulator).getSelectableSimulatorsAsync(device);\n          device = yield (0, _promptAppleDevice).promptAppleDeviceAsync(devices, device == null ? void 0 : device.osType);\n        }\n        var booted = yield ensureSimulatorOpenAsync(device);\n        return new AppleDeviceManager(booted);\n      });\n      function resolveAsync() {\n        return _resolveAsync.apply(this, arguments);\n      }\n      return resolveAsync;\n    }()\n  }]);\n  return AppleDeviceManager;\n}(_deviceManager.DeviceManager);\nAppleDeviceManager.assertSystemRequirementsAsync = _assertSystemRequirements.assertSystemRequirementsAsync;\nexports.AppleDeviceManager = AppleDeviceManager;","map":{"version":3,"names":["_classCallCheck","require","_createClass","_inherits","_possibleConstructorReturn","_getPrototypeOf","_asyncToGenerator","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","constructor","Reflect","construct","arguments","apply","sham","Proxy","Boolean","prototype","valueOf","call","e","ensureSimulatorOpenAsync","osascript","_interopRequireWildcard","_assert","_interopRequireDefault","_chalk","_fs","_path","_delay","_errors","_plist","_url","_deviceManager","_expoGoInstaller","_assertSystemRequirements","_ensureSimulatorAppRunning","_getBestSimulator","_promptAppleDevice","SimControl","debug","EXPO_GO_BUNDLE_IDENTIFIER","_ensureSimulatorOpenAsync","_ref2","length","undefined","udid","osType","tryAgain","simulatorOpenedByApp","getBestBootedSimulatorAsync","bestUdid","getBestUnbootedSimulatorAsync","CommandError","bootedDevice","waitForActionAsync","action","default","bootAsync","AppleDeviceManager","_deviceManager$Device","_super","key","get","device","name","value","_getAppVersionAsync","appId","getInfoPlistValueAsync","getAppVersionAsync","_x","_startAsync","startAsync","_launchApplicationIdAsync","openAppIdAsync","status","activateWindowAsync","stderr","error","errorMessage","code","bold","gray","message","launchApplicationIdAsync","_x2","_installAppAsync","filePath","installAsync","waitForAppInstalledAsync","getApplicationIdFromBundle","installAppAsync","_x3","_getApplicationIdFromBundle","builtInfoPlistPath","join","existsSync","_yield$parsePlistAsyn","parsePlistAsync","CFBundleIdentifier","_x4","_waitForAppInstalledAsync","applicationId","isAppInstalledAsync","delayAsync","_x5","_uninstallAppAsync","uninstallAsync","uninstallAppAsync","_x6","_isAppInstalledAsync","getContainerPathAsync","_x7","_openUrlAsync","url","validateUrl","requireProtocol","openUrlAsync","_x8","_activateWindowAsync","ensureSimulatorAppRunningAsync","execAsync","_ensureExpoGoAsync","sdkVersion","installer","ExpoGoInstaller","ensureAsync","ensureExpoGoAsync","_x9","_resolveAsync","_ref","shouldPrompt","devices","getSelectableSimulatorsAsync","promptAppleDeviceAsync","booted","resolveAsync","DeviceManager","assertSystemRequirementsAsync"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\cli\\src\\start\\platforms\\ios\\AppleDeviceManager.ts"],"sourcesContent":["import * as osascript from '@expo/osascript';\nimport assert from 'assert';\nimport chalk from 'chalk';\nimport fs from 'fs';\nimport path from 'path';\n\nimport { delayAsync, waitForActionAsync } from '../../../utils/delay';\nimport { CommandError } from '../../../utils/errors';\nimport { parsePlistAsync } from '../../../utils/plist';\nimport { validateUrl } from '../../../utils/url';\nimport { DeviceManager } from '../DeviceManager';\nimport { ExpoGoInstaller } from '../ExpoGoInstaller';\nimport { BaseResolveDeviceProps } from '../PlatformManager';\nimport { assertSystemRequirementsAsync } from './assertSystemRequirements';\nimport { ensureSimulatorAppRunningAsync } from './ensureSimulatorAppRunning';\nimport {\n  getBestBootedSimulatorAsync,\n  getBestUnbootedSimulatorAsync,\n  getSelectableSimulatorsAsync,\n} from './getBestSimulator';\nimport { promptAppleDeviceAsync } from './promptAppleDevice';\nimport * as SimControl from './simctl';\n\nconst debug = require('debug')('expo:start:platforms:ios:AppleDeviceManager') as typeof console.log;\n\nconst EXPO_GO_BUNDLE_IDENTIFIER = 'host.exp.Exponent';\n\n/**\n * Ensure a simulator is booted and the Simulator app is opened.\n * This is where any timeout related error handling should live.\n */\nexport async function ensureSimulatorOpenAsync(\n  { udid, osType }: Partial<Pick<SimControl.Device, 'udid' | 'osType'>> = {},\n  tryAgain: boolean = true\n): Promise<SimControl.Device> {\n  // Use a default simulator if none was specified\n  if (!udid) {\n    // If a simulator is open, side step the entire booting sequence.\n    const simulatorOpenedByApp = await getBestBootedSimulatorAsync({ osType });\n    if (simulatorOpenedByApp) {\n      return simulatorOpenedByApp;\n    }\n\n    // Otherwise, find the best possible simulator from user defaults and continue\n    const bestUdid = await getBestUnbootedSimulatorAsync({ osType });\n    if (!bestUdid) {\n      throw new CommandError('No simulators found.');\n    }\n    udid = bestUdid;\n  }\n\n  const bootedDevice = await waitForActionAsync({\n    action: () => {\n      // Just for the type check.\n      assert(udid);\n      return SimControl.bootAsync({ udid });\n    },\n  });\n\n  if (!bootedDevice) {\n    // Give it a second chance, this might not be needed but it could potentially lead to a better UX on slower devices.\n    if (tryAgain) {\n      return await ensureSimulatorOpenAsync({ udid, osType }, false);\n    }\n    // TODO: We should eliminate all needs for a timeout error, it's bad UX to get an error about the simulator not starting while the user can clearly see it starting on their slow computer.\n    throw new CommandError(\n      'SIMULATOR_TIMEOUT',\n      `Simulator didn't boot fast enough. Try opening Simulator first, then running your app.`\n    );\n  }\n  return bootedDevice;\n}\nexport class AppleDeviceManager extends DeviceManager<SimControl.Device> {\n  static assertSystemRequirementsAsync = assertSystemRequirementsAsync;\n\n  static async resolveAsync({\n    device,\n    shouldPrompt,\n  }: BaseResolveDeviceProps<\n    Partial<Pick<SimControl.Device, 'udid' | 'osType'>>\n  > = {}): Promise<AppleDeviceManager> {\n    if (shouldPrompt) {\n      const devices = await getSelectableSimulatorsAsync(device);\n      device = await promptAppleDeviceAsync(devices, device?.osType);\n    }\n\n    const booted = await ensureSimulatorOpenAsync(device);\n    return new AppleDeviceManager(booted);\n  }\n\n  get name() {\n    return this.device.name;\n  }\n\n  get identifier(): string {\n    return this.device.udid;\n  }\n\n  async getAppVersionAsync(appId: string): Promise<string | null> {\n    return await SimControl.getInfoPlistValueAsync(this.device, {\n      appId,\n      key: 'CFBundleShortVersionString',\n    });\n  }\n\n  async startAsync(): Promise<SimControl.Device> {\n    return ensureSimulatorOpenAsync({ osType: this.device.osType, udid: this.device.udid });\n  }\n\n  async launchApplicationIdAsync(appId: string) {\n    try {\n      const result = await SimControl.openAppIdAsync(this.device, {\n        appId,\n      });\n      if (result.status === 0) {\n        await this.activateWindowAsync();\n      } else {\n        throw new CommandError(result.stderr);\n      }\n    } catch (error: any) {\n      let errorMessage = `Couldn't open iOS app with ID \"${appId}\" on device \"${this.name}\".`;\n      if (error instanceof CommandError && error.code === 'APP_NOT_INSTALLED') {\n        if (appId === EXPO_GO_BUNDLE_IDENTIFIER) {\n          errorMessage = `Couldn't open Expo Go app on device \"${this.name}\". Please install.`;\n        } else {\n          errorMessage += `\\nThe app might not be installed, try installing it with: ${chalk.bold(\n            `npx expo run:ios -d ${this.device.udid}`\n          )}`;\n        }\n      }\n      if (error.stderr) {\n        errorMessage += chalk.gray(`\\n${error.stderr}`);\n      } else if (error.message) {\n        errorMessage += chalk.gray(`\\n${error.message}`);\n      }\n      throw new CommandError(errorMessage);\n    }\n  }\n\n  async installAppAsync(filePath: string) {\n    await SimControl.installAsync(this.device, {\n      filePath,\n    });\n\n    await this.waitForAppInstalledAsync(await this.getApplicationIdFromBundle(filePath));\n  }\n\n  private async getApplicationIdFromBundle(filePath: string): Promise<string> {\n    debug('getApplicationIdFromBundle:', filePath);\n    const builtInfoPlistPath = path.join(filePath, 'Info.plist');\n    if (fs.existsSync(builtInfoPlistPath)) {\n      const { CFBundleIdentifier } = await parsePlistAsync(builtInfoPlistPath);\n      debug('getApplicationIdFromBundle: using built Info.plist', CFBundleIdentifier);\n      return CFBundleIdentifier;\n    }\n    debug('getApplicationIdFromBundle: no Info.plist found');\n    return EXPO_GO_BUNDLE_IDENTIFIER;\n  }\n\n  private async waitForAppInstalledAsync(applicationId: string): Promise<boolean> {\n    while (true) {\n      if (await this.isAppInstalledAsync(applicationId)) {\n        return true;\n      }\n      await delayAsync(100);\n    }\n  }\n\n  async uninstallAppAsync(appId: string) {\n    await SimControl.uninstallAsync(this.device, {\n      appId,\n    });\n  }\n\n  async isAppInstalledAsync(appId: string) {\n    return !!(await SimControl.getContainerPathAsync(this.device, {\n      appId,\n    }));\n  }\n\n  async openUrlAsync(url: string) {\n    // Non-compliant URLs will be treated as application identifiers.\n    if (!validateUrl(url, { requireProtocol: true })) {\n      return await this.launchApplicationIdAsync(url);\n    }\n\n    try {\n      await SimControl.openUrlAsync(this.device, { url });\n    } catch (error: any) {\n      // 194 means the device does not conform to a given URL, in this case we'll assume that the desired app is not installed.\n      if (error.status === 194) {\n        // An error was encountered processing the command (domain=NSOSStatusErrorDomain, code=-10814):\n        // The operation couldn’t be completed. (OSStatus error -10814.)\n        //\n        // This can be thrown when no app conforms to the URI scheme that we attempted to open.\n        throw new CommandError(\n          'APP_NOT_INSTALLED',\n          `Device ${this.device.name} (${this.device.udid}) has no app to handle the URI: ${url}`\n        );\n      }\n      throw error;\n    }\n  }\n\n  async activateWindowAsync() {\n    await ensureSimulatorAppRunningAsync(this.device);\n    // TODO: Focus the individual window\n    await osascript.execAsync(`tell application \"Simulator\" to activate`);\n  }\n\n  async ensureExpoGoAsync(sdkVersion?: string): Promise<boolean> {\n    const installer = new ExpoGoInstaller('ios', EXPO_GO_BUNDLE_IDENTIFIER, sdkVersion);\n    return installer.ensureAsync(this);\n  }\n}\n"],"mappings":"AAAA;;AAAA,IAAAA,eAAA,GAAAC,OAAA;AAAA,IAAAC,YAAA,GAAAD,OAAA;AAAA,IAAAE,SAAA,GAAAF,OAAA;AAAA,IAAAG,0BAAA,GAAAH,OAAA;AAAA,IAAAI,eAAA,GAAAJ,OAAA;AAAA,IAAAK,iBAAA,GAAAL,OAAA;AAAA,SAAAM,aAAAC,OAAA,QAAAC,yBAAA,GAAAC,yBAAA,oBAAAC,qBAAA,QAAAC,KAAA,GAAAP,eAAA,CAAAG,OAAA,GAAAK,MAAA,MAAAJ,yBAAA,QAAAK,SAAA,GAAAT,eAAA,OAAAU,WAAA,EAAAF,MAAA,GAAAG,OAAA,CAAAC,SAAA,CAAAL,KAAA,EAAAM,SAAA,EAAAJ,SAAA,YAAAD,MAAA,GAAAD,KAAA,CAAAO,KAAA,OAAAD,SAAA,YAAAd,0BAAA,OAAAS,MAAA;AAAA,SAAAH,0BAAA,eAAAM,OAAA,qBAAAA,OAAA,CAAAC,SAAA,oBAAAD,OAAA,CAAAC,SAAA,CAAAG,IAAA,2BAAAC,KAAA,oCAAAC,OAAA,CAAAC,SAAA,CAAAC,OAAA,CAAAC,IAAA,CAAAT,OAAA,CAAAC,SAAA,CAAAK,OAAA,8CAAAI,CAAA;;;;QA+BsBC,wBAAwB,GAAxBA,wBAAwB;AA/BlC,IAAAC,SAAS,GAAAC,uBAAA,CAAA5B,OAAA,CAAM,iBAAiB,EAAvB;AACF,IAAA6B,OAAQ,GAAAC,sBAAA,CAAA9B,OAAA,CAAR,QAAQ;AACT,IAAA+B,MAAO,GAAAD,sBAAA,CAAA9B,OAAA,CAAP,OAAO;AACV,IAAAgC,GAAI,GAAAF,sBAAA,CAAA9B,OAAA,CAAJ,IAAI;AACF,IAAAiC,KAAM,GAAAH,sBAAA,CAAA9B,OAAA,CAAN,MAAM;AAEwB,IAAAkC,MAAsB,GAAAlC,OAAA;AACxC,IAAAmC,OAAuB,GAAAnC,OAAA;AACpB,IAAAoC,MAAsB,GAAApC,OAAA;AAC1B,IAAAqC,IAAoB,GAAArC,OAAA;AAClB,IAAAsC,cAAkB,GAAAtC,OAAA;AAChB,IAAAuC,gBAAoB,GAAAvC,OAAA;AAEN,IAAAwC,yBAA4B,GAAAxC,OAAA;AAC3B,IAAAyC,0BAA6B,GAAAzC,OAAA;AAKrE,IAAA0C,iBAAoB,GAAA1C,OAAA;AACY,IAAA2C,kBAAqB,GAAA3C,OAAA;AAChD,IAAA4C,UAAU,GAAAhB,uBAAA,CAAA5B,OAAA,WAAgB,EAAhB;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEtB,IAAM6C,KAAK,GAAG7C,OAAO,CAAC,OAAO,CAAC,CAAC,6CAA6C,CAAC;AAE7E,IAAM8C,yBAAyB,GAAG,mBAAmB;AAAC,SAMhCpB,wBAAwBA,CAAA;EAAA,OAAAqB,yBAAA,CAAA7B,KAAA,OAAAD,SAAA;AAAA;AAAA,SAAA8B,0BAAA;EAAAA,yBAAA,GAAA1C,iBAAA,CAAvC,aAGuB;IAAA,IAAA2C,KAAA,GAAA/B,SAAA,CAAAgC,MAAA,QAAAhC,SAAA,QAAAiC,SAAA,GAAAjC,SAAA,MAF4C,EAAE;MAAxEkC,IAAI,GAAAH,KAAA,CAAJG,IAAI;MAAEC,MAAM,GAAAJ,KAAA,CAANI,MAAM;IAAA,IACdC,QAAiB,GAAApC,SAAA,CAAAgC,MAAA,QAAAhC,SAAA,QAAAiC,SAAA,GAAAjC,SAAA,MAAG,IAAI;IAGxB,IAAI,CAACkC,IAAI,EAAE;MAET,IAAMG,oBAAoB,SAAS,IAAAZ,iBAA2B,EAAYa,2BAAZ,CAAC;QAAEH,MAAM,EAANA;OAAQ,CAAC;MAC1E,IAAIE,oBAAoB,EAAE;QACxB,OAAOA,oBAAoB;;MAI7B,IAAME,QAAQ,SAAS,IAAAd,iBAA6B,EAAYe,6BAAZ,CAAC;QAAEL,MAAM,EAANA;OAAQ,CAAC;MAChE,IAAI,CAACI,QAAQ,EAAE;QACb,MAAM,IAAIrB,OAAY,CAAAuB,YAAA,CAAC,sBAAsB,CAAC;;MAEhDP,IAAI,GAAGK,QAAQ;;IAGjB,IAAMG,YAAY,SAAS,IAAAzB,MAAkB,EAM3C0B,kBAN2C,CAAC;MAC5CC,MAAM,EAAE,SAAAA,OAAA,EAAM;QAEZ,IAAAhC,OAAM,EAAMiC,OAAN,CAACX,IAAI,CAAC;QACZ,OAAOP,UAAU,CAACmB,SAAS,CAAC;UAAEZ,IAAI,EAAJA;SAAM,CAAC;;KAExC,CAAC;IAEF,IAAI,CAACQ,YAAY,EAAE;MAEjB,IAAIN,QAAQ,EAAE;QACZ,aAAa3B,wBAAwB,CAAC;UAAEyB,IAAI,EAAJA,IAAI;UAAEC,MAAM,EAANA;SAAQ,EAAE,KAAK,CAAC;;MAGhE,MAAM,IAAIjB,OAAY,CAAAuB,YAAA,CACpB,mBAAmB,EAClB,wFAAuF,CACzF;;IAEH,OAAOC,YAAY;GACpB;EAAA,OAAAZ,yBAAA,CAAA7B,KAAA,OAAAD,SAAA;AAAA;AAAA,IACY+C,kBAAkB,aAAAC,qBAAA;EAAA/D,SAAA,CAAA8D,kBAAA,EAAAC,qBAAA;EAAA,IAAAC,MAAA,GAAA5D,YAAA,CAAA0D,kBAAA;EAAA,SAAAA,mBAAA;IAAAjE,eAAA,OAAAiE,kBAAA;IAAA,OAAAE,MAAA,CAAAhD,KAAA,OAAAD,SAAA;EAAA;EAAAhB,YAAA,CAAA+D,kBAAA;IAAAG,GAAA;IAAAC,GAAA,EAkB7B,SAAAA,IAAA,EAAW;MACT,OAAO,IAAI,CAACC,MAAM,CAACC,IAAI;;EACxB;IAAAH,GAAA;IAAAC,GAAA,EAED,SAAAA,IAAA,EAAyB;MACvB,OAAO,IAAI,CAACC,MAAM,CAAClB,IAAI;;EACxB;IAAAgB,GAAA;IAAAI,KAAA;MAAA,IAAAC,mBAAA,GAAAnE,iBAAA,CAED,WAAyBoE,KAAa,EAA0B;QAC9D,aAAa7B,UAAU,CAAC8B,sBAAsB,CAAC,IAAI,CAACL,MAAM,EAAE;UAC1DI,KAAK,EAALA,KAAK;UACLN,GAAG,EAAE;SACN,CAAC;OACH;MAAA,SAAAQ,mBAAAC,EAAA;QAAA,OAAAJ,mBAAA,CAAAtD,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAA0D,kBAAA;IAAA;EAAA;IAAAR,GAAA;IAAAI,KAAA;MAAA,IAAAM,WAAA,GAAAxE,iBAAA,CAED,aAA+C;QAC7C,OAAOqB,wBAAwB,CAAC;UAAE0B,MAAM,EAAE,IAAI,CAACiB,MAAM,CAACjB,MAAM;UAAED,IAAI,EAAE,IAAI,CAACkB,MAAM,CAAClB;SAAM,CAAC;OACxF;MAAA,SAAA2B,WAAA;QAAA,OAAAD,WAAA,CAAA3D,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAA6D,UAAA;IAAA;EAAA;IAAAX,GAAA;IAAAI,KAAA;MAAA,IAAAQ,yBAAA,GAAA1E,iBAAA,CAED,WAA+BoE,KAAa,EAAE;QAC5C,IAAI;UACF,IAAM7D,MAAM,SAASgC,UAAU,CAACoC,cAAc,CAAC,IAAI,CAACX,MAAM,EAAE;YAC1DI,KAAK,EAALA;WACD,CAAC;UACF,IAAI7D,MAAM,CAACqE,MAAM,KAAK,CAAC,EAAE;YACvB,MAAM,IAAI,CAACC,mBAAmB,EAAE;WACjC,MAAM;YACL,MAAM,IAAI/C,OAAY,CAAAuB,YAAA,CAAC9C,MAAM,CAACuE,MAAM,CAAC;;SAExC,CAAC,OAAOC,KAAK,EAAO;UACnB,IAAIC,YAAY,GAAI,kCAAiCZ,KAAM,gBAAe,IAAI,CAACH,IAAK,IAAG;UACvF,IAAIc,KAAK,YAAYjD,OAAY,CAAAuB,YAAA,IAAI0B,KAAK,CAACE,IAAI,KAAK,mBAAmB,EAAE;YACvE,IAAIb,KAAK,KAAK3B,yBAAyB,EAAE;cACvCuC,YAAY,GAAI,wCAAuC,IAAI,CAACf,IAAK,oBAAmB;aACrF,MAAM;cACLe,YAAY,IAAK,6DAA4DtD,MAAK,CAAA+B,OAAA,CAACyB,IAAI,CACpF,uBAAsB,IAAI,CAAClB,MAAM,CAAClB,IAAK,EAAC,CACzC,EAAC;;;UAGP,IAAIiC,KAAK,CAACD,MAAM,EAAE;YAChBE,YAAY,IAAItD,MAAK,CAAA+B,OAAA,CAAC0B,IAAI,CAAE,KAAIJ,KAAK,CAACD,MAAO,EAAC,CAAC;WAChD,MAAM,IAAIC,KAAK,CAACK,OAAO,EAAE;YACxBJ,YAAY,IAAItD,MAAK,CAAA+B,OAAA,CAAC0B,IAAI,CAAE,KAAIJ,KAAK,CAACK,OAAQ,EAAC,CAAC;;UAElD,MAAM,IAAItD,OAAY,CAAAuB,YAAA,CAAC2B,YAAY,CAAC;;OAEvC;MAAA,SAAAK,yBAAAC,GAAA;QAAA,OAAAZ,yBAAA,CAAA7D,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAAyE,wBAAA;IAAA;EAAA;IAAAvB,GAAA;IAAAI,KAAA;MAAA,IAAAqB,gBAAA,GAAAvF,iBAAA,CAED,WAAsBwF,QAAgB,EAAE;QACtC,MAAMjD,UAAU,CAACkD,YAAY,CAAC,IAAI,CAACzB,MAAM,EAAE;UACzCwB,QAAQ,EAARA;SACD,CAAC;QAEF,MAAM,IAAI,CAACE,wBAAwB,OAAO,IAAI,CAACC,0BAA0B,CAACH,QAAQ,CAAC,CAAC;OACrF;MAAA,SAAAI,gBAAAC,GAAA;QAAA,OAAAN,gBAAA,CAAA1E,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAAgF,eAAA;IAAA;EAAA;IAAA9B,GAAA;IAAAI,KAAA;MAAA,IAAA4B,2BAAA,GAAA9F,iBAAA,CAED,WAAyCwF,QAAgB,EAAmB;QAC1EhD,KAAK,CAAC,6BAA6B,EAAEgD,QAAQ,CAAC;QAC9C,IAAMO,kBAAkB,GAAGnE,KAAI,CAAA6B,OAAA,CAACuC,IAAI,CAACR,QAAQ,EAAE,YAAY,CAAC;QAC5D,IAAI7D,GAAE,CAAA8B,OAAA,CAACwC,UAAU,CAACF,kBAAkB,CAAC,EAAE;UACrC,IAAAG,qBAAA,SAAqC,IAAAnE,MAAe,EAAoBoE,eAApB,CAACJ,kBAAkB,CAAC;YAAhEK,kBAAkB,GAAAF,qBAAA,CAAlBE,kBAAkB;UAC1B5D,KAAK,CAAC,oDAAoD,EAAE4D,kBAAkB,CAAC;UAC/E,OAAOA,kBAAkB;;QAE3B5D,KAAK,CAAC,iDAAiD,CAAC;QACxD,OAAOC,yBAAyB;OACjC;MAAA,SAAAkD,2BAAAU,GAAA;QAAA,OAAAP,2BAAA,CAAAjF,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAA+E,0BAAA;IAAA;EAAA;IAAA7B,GAAA;IAAAI,KAAA;MAAA,IAAAoC,yBAAA,GAAAtG,iBAAA,CAED,WAAuCuG,aAAqB,EAAoB;QAC9E,OAAO,IAAI,EAAE;UACX,UAAU,IAAI,CAACC,mBAAmB,CAACD,aAAa,CAAC,EAAE;YACjD,OAAO,IAAI;;UAEb,MAAM,IAAA1E,MAAU,EAAK4E,UAAL,CAAC,GAAG,CAAC;;OAExB;MAAA,SAAAf,yBAAAgB,GAAA;QAAA,OAAAJ,yBAAA,CAAAzF,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAA8E,wBAAA;IAAA;EAAA;IAAA5B,GAAA;IAAAI,KAAA;MAAA,IAAAyC,kBAAA,GAAA3G,iBAAA,CAED,WAAwBoE,KAAa,EAAE;QACrC,MAAM7B,UAAU,CAACqE,cAAc,CAAC,IAAI,CAAC5C,MAAM,EAAE;UAC3CI,KAAK,EAALA;SACD,CAAC;OACH;MAAA,SAAAyC,kBAAAC,GAAA;QAAA,OAAAH,kBAAA,CAAA9F,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAAiG,iBAAA;IAAA;EAAA;IAAA/C,GAAA;IAAAI,KAAA;MAAA,IAAA6C,oBAAA,GAAA/G,iBAAA,CAED,WAA0BoE,KAAa,EAAE;QACvC,OAAO,CAAC,QAAQ7B,UAAU,CAACyE,qBAAqB,CAAC,IAAI,CAAChD,MAAM,EAAE;UAC5DI,KAAK,EAALA;SACD,CAAC;OACH;MAAA,SAAAoC,oBAAAS,GAAA;QAAA,OAAAF,oBAAA,CAAAlG,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAA4F,mBAAA;IAAA;EAAA;IAAA1C,GAAA;IAAAI,KAAA;MAAA,IAAAgD,aAAA,GAAAlH,iBAAA,CAED,WAAmBmH,GAAW,EAAE;QAE9B,IAAI,CAAC,IAAAnF,IAAW,EAAgCoF,WAAhC,CAACD,GAAG,EAAE;UAAEE,eAAe,EAAE;SAAM,CAAC,EAAE;UAChD,aAAa,IAAI,CAAChC,wBAAwB,CAAC8B,GAAG,CAAC;;QAGjD,IAAI;UACF,MAAM5E,UAAU,CAAC+E,YAAY,CAAC,IAAI,CAACtD,MAAM,EAAE;YAAEmD,GAAG,EAAHA;WAAK,CAAC;SACpD,CAAC,OAAOpC,KAAK,EAAO;UAEnB,IAAIA,KAAK,CAACH,MAAM,KAAK,GAAG,EAAE;YAKxB,MAAM,IAAI9C,OAAY,CAAAuB,YAAA,CACpB,mBAAmB,EAClB,UAAS,IAAI,CAACW,MAAM,CAACC,IAAK,KAAI,IAAI,CAACD,MAAM,CAAClB,IAAK,mCAAkCqE,GAAI,EAAC,CACxF;;UAEH,MAAMpC,KAAK;;OAEd;MAAA,SAAAuC,aAAAC,GAAA;QAAA,OAAAL,aAAA,CAAArG,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAA0G,YAAA;IAAA;EAAA;IAAAxD,GAAA;IAAAI,KAAA;MAAA,IAAAsD,oBAAA,GAAAxH,iBAAA,CAED,aAA4B;QAC1B,MAAM,IAAAoC,0BAA8B,EAAaqF,8BAAb,CAAC,IAAI,CAACzD,MAAM,CAAC;QAEjD,MAAM1C,SAAS,CAACoG,SAAS,CAAE,0CAAyC,CAAC;OACtE;MAAA,SAAA7C,oBAAA;QAAA,OAAA2C,oBAAA,CAAA3G,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAAiE,mBAAA;IAAA;EAAA;IAAAf,GAAA;IAAAI,KAAA;MAAA,IAAAyD,kBAAA,GAAA3H,iBAAA,CAED,WAAwB4H,UAAmB,EAAoB;QAC7D,IAAMC,SAAS,GAAG,IAAI3F,gBAAe,CAAA4F,eAAA,CAAC,KAAK,EAAErF,yBAAyB,EAAEmF,UAAU,CAAC;QACnF,OAAOC,SAAS,CAACE,WAAW,CAAC,IAAI,CAAC;OACnC;MAAA,SAAAC,kBAAAC,GAAA;QAAA,OAAAN,kBAAA,CAAA9G,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAAoH,iBAAA;IAAA;EAAA;IAAAlE,GAAA;IAAAI,KAAA;MAAA,IAAAgE,aAAA,GAAAlI,iBAAA,CA1ID,aAKqC;QAAA,IAAAmI,IAAA,GAAAvH,SAAA,CAAAgC,MAAA,QAAAhC,SAAA,QAAAiC,SAAA,GAAAjC,SAAA,MAAjC,EAAE;UAJJoD,MAAM,GAAAmE,IAAA,CAANnE,MAAM;UACNoE,YAAY,GAAAD,IAAA,CAAZC,YAAY;QAIZ,IAAIA,YAAY,EAAE;UAChB,IAAMC,OAAO,SAAS,IAAAhG,iBAA4B,EAAQiG,4BAAR,CAACtE,MAAM,CAAC;UAC1DA,MAAM,SAAS,IAAA1B,kBAAsB,EAAyBiG,sBAAzB,CAACF,OAAO,EAAErE,MAAM,QAAQ,GAAd,MAAc,GAAdA,MAAM,CAAEjB,MAAM,CAAC;;QAGhE,IAAMyF,MAAM,SAASnH,wBAAwB,CAAC2C,MAAM,CAAC;QACrD,OAAO,IAAIL,kBAAkB,CAAC6E,MAAM,CAAC;OACtC;MAAA,SAAAC,aAAA;QAAA,OAAAP,aAAA,CAAArH,KAAA,OAAAD,SAAA;MAAA;MAAA,OAAA6H,YAAA;IAAA;EAAA;EAAA,OAAA9E,kBAAA;AAAA,EAhBqC1B,cAAa,CAAAyG,aAAA;AAAxC/E,kBAAkB,CACtBgF,6BAA6B,GAAGxG,yBAA6B,CAAAwG,6BAAA;QADzDhF,kBAAkB,GAAlBA,kBAAkB"},"metadata":{},"sourceType":"script","externalDependencies":[]}