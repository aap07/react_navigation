{"ast":null,"code":"'use strict';\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError('Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.');\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === 'string') return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === 'Object' && o.constructor) n = o.constructor.name;\n  if (n === 'Map' || n === 'Set') return Array.from(o);\n  if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : 'undefined' != typeof Symbol && arr[Symbol.iterator] || arr['@@iterator'];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nvar _require = require(\"./errors\"),\n  UnsupportedUnionTypeAnnotationParserError = _require.UnsupportedUnionTypeAnnotationParserError,\n  UnsupportedTypeAnnotationParserError = _require.UnsupportedTypeAnnotationParserError,\n  ParserError = _require.ParserError;\nvar _require2 = require(\"./error-utils\"),\n  throwIfArrayElementTypeAnnotationIsUnsupported = _require2.throwIfArrayElementTypeAnnotationIsUnsupported,\n  throwIfPartialNotAnnotatingTypeParameter = _require2.throwIfPartialNotAnnotatingTypeParameter,\n  throwIfPartialWithMoreParameter = _require2.throwIfPartialWithMoreParameter;\nvar _require3 = require(\"./parsers-utils\"),\n  nullGuard = _require3.nullGuard;\nvar _require4 = require(\"./parsers-commons\"),\n  assertGenericTypeAnnotationHasExactlyOneTypeParameter = _require4.assertGenericTypeAnnotationHasExactlyOneTypeParameter,\n  wrapNullable = _require4.wrapNullable,\n  unwrapNullable = _require4.unwrapNullable,\n  translateFunctionTypeAnnotation = _require4.translateFunctionTypeAnnotation;\nvar _require5 = require(\"./utils\"),\n  isModuleRegistryCall = _require5.isModuleRegistryCall;\nfunction emitBoolean(nullable) {\n  return wrapNullable(nullable, {\n    type: 'BooleanTypeAnnotation'\n  });\n}\nfunction emitInt32(nullable) {\n  return wrapNullable(nullable, {\n    type: 'Int32TypeAnnotation'\n  });\n}\nfunction emitNumber(nullable) {\n  return wrapNullable(nullable, {\n    type: 'NumberTypeAnnotation'\n  });\n}\nfunction emitRootTag(nullable) {\n  return wrapNullable(nullable, {\n    type: 'ReservedTypeAnnotation',\n    name: 'RootTag'\n  });\n}\nfunction emitDouble(nullable) {\n  return wrapNullable(nullable, {\n    type: 'DoubleTypeAnnotation'\n  });\n}\nfunction emitVoid(nullable) {\n  return wrapNullable(nullable, {\n    type: 'VoidTypeAnnotation'\n  });\n}\nfunction emitStringish(nullable) {\n  return wrapNullable(nullable, {\n    type: 'StringTypeAnnotation'\n  });\n}\nfunction emitFunction(nullable, hasteModuleName, typeAnnotation, types, aliasMap, enumMap, tryParse, cxxOnly, translateTypeAnnotation, parser) {\n  var translateFunctionTypeAnnotationValue = translateFunctionTypeAnnotation(hasteModuleName, typeAnnotation, types, aliasMap, enumMap, tryParse, cxxOnly, translateTypeAnnotation, parser);\n  return wrapNullable(nullable, translateFunctionTypeAnnotationValue);\n}\nfunction emitMixed(nullable) {\n  return wrapNullable(nullable, {\n    type: 'MixedTypeAnnotation'\n  });\n}\nfunction emitString(nullable) {\n  return wrapNullable(nullable, {\n    type: 'StringTypeAnnotation'\n  });\n}\nfunction typeAliasResolution(typeResolution, objectTypeAnnotation, aliasMap, nullable) {\n  if (!typeResolution.successful) {\n    return wrapNullable(nullable, objectTypeAnnotation);\n  }\n  aliasMap[typeResolution.name] = objectTypeAnnotation;\n  return wrapNullable(nullable, {\n    type: 'TypeAliasTypeAnnotation',\n    name: typeResolution.name\n  });\n}\nfunction typeEnumResolution(typeAnnotation, typeResolution, nullable, hasteModuleName, enumMap, parser) {\n  if (!typeResolution.successful || typeResolution.type !== 'enum') {\n    throw new UnsupportedTypeAnnotationParserError(hasteModuleName, typeAnnotation, parser.language());\n  }\n  var enumName = typeResolution.name;\n  var enumMemberType = parser.parseEnumMembersType(typeAnnotation);\n  try {\n    parser.validateEnumMembersSupported(typeAnnotation, enumMemberType);\n  } catch (e) {\n    if (e instanceof Error) {\n      throw new ParserError(hasteModuleName, typeAnnotation, `Failed parsing the enum ${enumName} in ${hasteModuleName} with the error: ${e.message}`);\n    } else {\n      throw e;\n    }\n  }\n  var enumMembers = parser.parseEnumMembers(typeAnnotation);\n  enumMap[enumName] = {\n    name: enumName,\n    type: 'EnumDeclarationWithMembers',\n    memberType: enumMemberType,\n    members: enumMembers\n  };\n  return wrapNullable(nullable, {\n    name: enumName,\n    type: 'EnumDeclaration',\n    memberType: enumMemberType\n  });\n}\nfunction emitPromise(hasteModuleName, typeAnnotation, parser, nullable, types, aliasMap, enumMap, tryParse, cxxOnly, translateTypeAnnotation) {\n  assertGenericTypeAnnotationHasExactlyOneTypeParameter(hasteModuleName, typeAnnotation, parser);\n  var elementType = typeAnnotation.typeParameters.params[0];\n  if (elementType.type === 'ExistsTypeAnnotation' || elementType.type === 'EmptyTypeAnnotation') {\n    return wrapNullable(nullable, {\n      type: 'PromiseTypeAnnotation'\n    });\n  } else {\n    try {\n      return wrapNullable(nullable, {\n        type: 'PromiseTypeAnnotation',\n        elementType: translateTypeAnnotation(hasteModuleName, typeAnnotation.typeParameters.params[0], types, aliasMap, enumMap, tryParse, cxxOnly, parser)\n      });\n    } catch (_unused) {\n      return wrapNullable(nullable, {\n        type: 'PromiseTypeAnnotation'\n      });\n    }\n  }\n}\nfunction emitGenericObject(nullable) {\n  return wrapNullable(nullable, {\n    type: 'GenericObjectTypeAnnotation'\n  });\n}\nfunction emitObject(nullable, properties) {\n  return wrapNullable(nullable, {\n    type: 'ObjectTypeAnnotation',\n    properties: properties\n  });\n}\nfunction emitFloat(nullable) {\n  return wrapNullable(nullable, {\n    type: 'FloatTypeAnnotation'\n  });\n}\nfunction emitUnion(nullable, hasteModuleName, typeAnnotation, parser) {\n  var unionTypes = parser.remapUnionTypeAnnotationMemberNames(typeAnnotation.types);\n  if (unionTypes.length > 1) {\n    throw new UnsupportedUnionTypeAnnotationParserError(hasteModuleName, typeAnnotation, unionTypes);\n  }\n  return wrapNullable(nullable, {\n    type: 'UnionTypeAnnotation',\n    memberType: unionTypes[0]\n  });\n}\nfunction translateArrayTypeAnnotation(hasteModuleName, types, aliasMap, enumMap, cxxOnly, arrayType, elementType, nullable, translateTypeAnnotation, parser) {\n  try {\n    var _unwrapNullable = unwrapNullable(translateTypeAnnotation(hasteModuleName, elementType, types, aliasMap, enumMap, nullGuard, cxxOnly, parser)),\n      _unwrapNullable2 = _slicedToArray(_unwrapNullable, 2),\n      _elementType = _unwrapNullable2[0],\n      isElementTypeNullable = _unwrapNullable2[1];\n    throwIfArrayElementTypeAnnotationIsUnsupported(hasteModuleName, elementType, arrayType, _elementType.type);\n    return wrapNullable(nullable, {\n      type: 'ArrayTypeAnnotation',\n      elementType: wrapNullable(isElementTypeNullable, _elementType)\n    });\n  } catch (ex) {\n    return wrapNullable(nullable, {\n      type: 'ArrayTypeAnnotation'\n    });\n  }\n}\nfunction emitArrayType(hasteModuleName, typeAnnotation, parser, types, aliasMap, enumMap, cxxOnly, nullable, translateTypeAnnotation) {\n  assertGenericTypeAnnotationHasExactlyOneTypeParameter(hasteModuleName, typeAnnotation, parser);\n  return translateArrayTypeAnnotation(hasteModuleName, types, aliasMap, enumMap, cxxOnly, typeAnnotation.type, typeAnnotation.typeParameters.params[0], nullable, translateTypeAnnotation, parser);\n}\nfunction Visitor(infoMap) {\n  return {\n    CallExpression: function CallExpression(node) {\n      if (node.callee.type === 'Identifier' && node.callee.name === 'codegenNativeComponent') {\n        infoMap.isComponent = true;\n      }\n      if (isModuleRegistryCall(node)) {\n        infoMap.isModule = true;\n      }\n    },\n    InterfaceExtends: function InterfaceExtends(node) {\n      if (node.id.name === 'TurboModule') {\n        infoMap.isModule = true;\n      }\n    },\n    TSInterfaceDeclaration: function TSInterfaceDeclaration(node) {\n      if (Array.isArray(node.extends) && node.extends.some(function (extension) {\n        return extension.expression.name === 'TurboModule';\n      })) {\n        infoMap.isModule = true;\n      }\n    }\n  };\n}\nfunction emitPartial(hasteModuleName, typeAnnotation, types, aliasMap, enumMap, tryParse, cxxOnly, nullable, parser) {\n  throwIfPartialWithMoreParameter(typeAnnotation);\n  throwIfPartialNotAnnotatingTypeParameter(typeAnnotation, types, parser);\n  var annotatedElement = parser.extractAnnotatedElement(typeAnnotation, types);\n  var annotatedElementProperties = parser.getAnnotatedElementProperties(annotatedElement);\n  var partialProperties = parser.computePartialProperties(annotatedElementProperties, hasteModuleName, types, aliasMap, enumMap, tryParse, cxxOnly);\n  return emitObject(nullable, partialProperties);\n}\nfunction emitCommonTypes(hasteModuleName, types, typeAnnotation, aliasMap, enumMap, tryParse, cxxOnly, nullable, parser) {\n  var genericTypeAnnotationName = parser.nameForGenericTypeAnnotation(typeAnnotation);\n  switch (genericTypeAnnotationName) {\n    case 'Stringish':\n      {\n        return emitStringish(nullable);\n      }\n    case 'Int32':\n      {\n        return emitInt32(nullable);\n      }\n    case 'Double':\n      {\n        return emitDouble(nullable);\n      }\n    case 'Float':\n      {\n        return emitFloat(nullable);\n      }\n    case 'UnsafeObject':\n    case 'Object':\n      {\n        return emitGenericObject(nullable);\n      }\n    case '$Partial':\n    case 'Partial':\n      {\n        return emitPartial(hasteModuleName, typeAnnotation, types, aliasMap, enumMap, tryParse, cxxOnly, nullable, parser);\n      }\n    default:\n      {\n        return null;\n      }\n  }\n}\nmodule.exports = {\n  emitArrayType: emitArrayType,\n  emitBoolean: emitBoolean,\n  emitDouble: emitDouble,\n  emitFloat: emitFloat,\n  emitFunction: emitFunction,\n  emitInt32: emitInt32,\n  emitNumber: emitNumber,\n  emitGenericObject: emitGenericObject,\n  emitObject: emitObject,\n  emitPromise: emitPromise,\n  emitRootTag: emitRootTag,\n  emitVoid: emitVoid,\n  emitString: emitString,\n  emitStringish: emitStringish,\n  emitMixed: emitMixed,\n  emitUnion: emitUnion,\n  emitPartial: emitPartial,\n  emitCommonTypes: emitCommonTypes,\n  typeAliasResolution: typeAliasResolution,\n  typeEnumResolution: typeEnumResolution,\n  translateArrayTypeAnnotation: translateArrayTypeAnnotation,\n  Visitor: Visitor\n};","map":{"version":3,"names":["_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","len","length","arr2","_i","Symbol","iterator","_s","_e","_x","_r","_arr","_n","_d","next","done","push","value","err","return","isArray","_require","require","UnsupportedUnionTypeAnnotationParserError","UnsupportedTypeAnnotationParserError","ParserError","_require2","throwIfArrayElementTypeAnnotationIsUnsupported","throwIfPartialNotAnnotatingTypeParameter","throwIfPartialWithMoreParameter","_require3","nullGuard","_require4","assertGenericTypeAnnotationHasExactlyOneTypeParameter","wrapNullable","unwrapNullable","translateFunctionTypeAnnotation","_require5","isModuleRegistryCall","emitBoolean","nullable","type","emitInt32","emitNumber","emitRootTag","emitDouble","emitVoid","emitStringish","emitFunction","hasteModuleName","typeAnnotation","types","aliasMap","enumMap","tryParse","cxxOnly","translateTypeAnnotation","parser","translateFunctionTypeAnnotationValue","emitMixed","emitString","typeAliasResolution","typeResolution","objectTypeAnnotation","successful","typeEnumResolution","language","enumName","enumMemberType","parseEnumMembersType","validateEnumMembersSupported","e","Error","message","enumMembers","parseEnumMembers","memberType","members","emitPromise","elementType","typeParameters","params","_unused","emitGenericObject","emitObject","properties","emitFloat","emitUnion","unionTypes","remapUnionTypeAnnotationMemberNames","translateArrayTypeAnnotation","arrayType","_unwrapNullable","_unwrapNullable2","_elementType","isElementTypeNullable","ex","emitArrayType","Visitor","infoMap","CallExpression","node","callee","isComponent","isModule","InterfaceExtends","id","TSInterfaceDeclaration","extends","some","extension","expression","emitPartial","annotatedElement","extractAnnotatedElement","annotatedElementProperties","getAnnotatedElementProperties","partialProperties","computePartialProperties","emitCommonTypes","genericTypeAnnotationName","nameForGenericTypeAnnotation","module","exports"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native/codegen/lib/parsers/parsers-primitives.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\n'use strict';\n\nfunction _slicedToArray(arr, i) {\n  return (\n    _arrayWithHoles(arr) ||\n    _iterableToArrayLimit(arr, i) ||\n    _unsupportedIterableToArray(arr, i) ||\n    _nonIterableRest()\n  );\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\n    'Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',\n  );\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === 'string') return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === 'Object' && o.constructor) n = o.constructor.name;\n  if (n === 'Map' || n === 'Set') return Array.from(o);\n  if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n    return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i =\n    null == arr\n      ? null\n      : ('undefined' != typeof Symbol && arr[Symbol.iterator]) ||\n        arr['@@iterator'];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (((_x = (_i = _i.call(arr)).next), 0 === i)) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else\n        for (\n          ;\n          !(_n = (_s = _x.call(_i)).done) &&\n          (_arr.push(_s.value), _arr.length !== i);\n          _n = !0\n        );\n    } catch (err) {\n      (_d = !0), (_e = err);\n    } finally {\n      try {\n        if (!_n && null != _i.return && ((_r = _i.return()), Object(_r) !== _r))\n          return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nconst _require = require('./errors'),\n  UnsupportedUnionTypeAnnotationParserError =\n    _require.UnsupportedUnionTypeAnnotationParserError,\n  UnsupportedTypeAnnotationParserError =\n    _require.UnsupportedTypeAnnotationParserError,\n  ParserError = _require.ParserError;\nconst _require2 = require('./error-utils'),\n  throwIfArrayElementTypeAnnotationIsUnsupported =\n    _require2.throwIfArrayElementTypeAnnotationIsUnsupported,\n  throwIfPartialNotAnnotatingTypeParameter =\n    _require2.throwIfPartialNotAnnotatingTypeParameter,\n  throwIfPartialWithMoreParameter = _require2.throwIfPartialWithMoreParameter;\nconst _require3 = require('./parsers-utils'),\n  nullGuard = _require3.nullGuard;\nconst _require4 = require('./parsers-commons'),\n  assertGenericTypeAnnotationHasExactlyOneTypeParameter =\n    _require4.assertGenericTypeAnnotationHasExactlyOneTypeParameter,\n  wrapNullable = _require4.wrapNullable,\n  unwrapNullable = _require4.unwrapNullable,\n  translateFunctionTypeAnnotation = _require4.translateFunctionTypeAnnotation;\nconst _require5 = require('./utils'),\n  isModuleRegistryCall = _require5.isModuleRegistryCall;\nfunction emitBoolean(nullable) {\n  return wrapNullable(nullable, {\n    type: 'BooleanTypeAnnotation',\n  });\n}\nfunction emitInt32(nullable) {\n  return wrapNullable(nullable, {\n    type: 'Int32TypeAnnotation',\n  });\n}\nfunction emitNumber(nullable) {\n  return wrapNullable(nullable, {\n    type: 'NumberTypeAnnotation',\n  });\n}\nfunction emitRootTag(nullable) {\n  return wrapNullable(nullable, {\n    type: 'ReservedTypeAnnotation',\n    name: 'RootTag',\n  });\n}\nfunction emitDouble(nullable) {\n  return wrapNullable(nullable, {\n    type: 'DoubleTypeAnnotation',\n  });\n}\nfunction emitVoid(nullable) {\n  return wrapNullable(nullable, {\n    type: 'VoidTypeAnnotation',\n  });\n}\nfunction emitStringish(nullable) {\n  return wrapNullable(nullable, {\n    type: 'StringTypeAnnotation',\n  });\n}\nfunction emitFunction(\n  nullable,\n  hasteModuleName,\n  typeAnnotation,\n  types,\n  aliasMap,\n  enumMap,\n  tryParse,\n  cxxOnly,\n  translateTypeAnnotation,\n  parser,\n) {\n  const translateFunctionTypeAnnotationValue = translateFunctionTypeAnnotation(\n    hasteModuleName,\n    typeAnnotation,\n    types,\n    aliasMap,\n    enumMap,\n    tryParse,\n    cxxOnly,\n    translateTypeAnnotation,\n    parser,\n  );\n  return wrapNullable(nullable, translateFunctionTypeAnnotationValue);\n}\nfunction emitMixed(nullable) {\n  return wrapNullable(nullable, {\n    type: 'MixedTypeAnnotation',\n  });\n}\nfunction emitString(nullable) {\n  return wrapNullable(nullable, {\n    type: 'StringTypeAnnotation',\n  });\n}\nfunction typeAliasResolution(\n  typeResolution,\n  objectTypeAnnotation,\n  aliasMap,\n  nullable,\n) {\n  if (!typeResolution.successful) {\n    return wrapNullable(nullable, objectTypeAnnotation);\n  }\n\n  /**\n   * All aliases RHS are required.\n   */\n  aliasMap[typeResolution.name] = objectTypeAnnotation;\n\n  /**\n   * Nullability of type aliases is transitive.\n   *\n   * Consider this case:\n   *\n   * type Animal = ?{\n   *   name: string,\n   * };\n   *\n   * type B = Animal\n   *\n   * export interface Spec extends TurboModule {\n   *   +greet: (animal: B) => void;\n   * }\n   *\n   * In this case, we follow B to Animal, and then Animal to ?{name: string}.\n   *\n   * We:\n   *   1. Replace `+greet: (animal: B) => void;` with `+greet: (animal: ?Animal) => void;`,\n   *   2. Pretend that Animal = {name: string}.\n   *\n   * Why do we do this?\n   *  1. In ObjC, we need to generate a struct called Animal, not B.\n   *  2. This design is simpler than managing nullability within both the type alias usage, and the type alias RHS.\n   *  3. What does it mean for a C++ struct, which is what this type alias RHS will generate, to be nullable? ¯\\_(ツ)_/¯\n   *     Nullability is a concept that only makes sense when talking about instances (i.e: usages) of the C++ structs.\n   *     Hence, it's better to manage nullability within the actual TypeAliasTypeAnnotation nodes, and not the\n   *     associated ObjectTypeAnnotations.\n   */\n  return wrapNullable(nullable, {\n    type: 'TypeAliasTypeAnnotation',\n    name: typeResolution.name,\n  });\n}\nfunction typeEnumResolution(\n  typeAnnotation,\n  typeResolution,\n  nullable,\n  hasteModuleName,\n  enumMap,\n  parser,\n) {\n  if (!typeResolution.successful || typeResolution.type !== 'enum') {\n    throw new UnsupportedTypeAnnotationParserError(\n      hasteModuleName,\n      typeAnnotation,\n      parser.language(),\n    );\n  }\n  const enumName = typeResolution.name;\n  const enumMemberType = parser.parseEnumMembersType(typeAnnotation);\n  try {\n    parser.validateEnumMembersSupported(typeAnnotation, enumMemberType);\n  } catch (e) {\n    if (e instanceof Error) {\n      throw new ParserError(\n        hasteModuleName,\n        typeAnnotation,\n        `Failed parsing the enum ${enumName} in ${hasteModuleName} with the error: ${e.message}`,\n      );\n    } else {\n      throw e;\n    }\n  }\n  const enumMembers = parser.parseEnumMembers(typeAnnotation);\n  enumMap[enumName] = {\n    name: enumName,\n    type: 'EnumDeclarationWithMembers',\n    memberType: enumMemberType,\n    members: enumMembers,\n  };\n  return wrapNullable(nullable, {\n    name: enumName,\n    type: 'EnumDeclaration',\n    memberType: enumMemberType,\n  });\n}\nfunction emitPromise(\n  hasteModuleName,\n  typeAnnotation,\n  parser,\n  nullable,\n  types,\n  aliasMap,\n  enumMap,\n  tryParse,\n  cxxOnly,\n  translateTypeAnnotation,\n) {\n  assertGenericTypeAnnotationHasExactlyOneTypeParameter(\n    hasteModuleName,\n    typeAnnotation,\n    parser,\n  );\n  const elementType = typeAnnotation.typeParameters.params[0];\n  if (\n    elementType.type === 'ExistsTypeAnnotation' ||\n    elementType.type === 'EmptyTypeAnnotation'\n  ) {\n    return wrapNullable(nullable, {\n      type: 'PromiseTypeAnnotation',\n    });\n  } else {\n    try {\n      return wrapNullable(nullable, {\n        type: 'PromiseTypeAnnotation',\n        elementType: translateTypeAnnotation(\n          hasteModuleName,\n          typeAnnotation.typeParameters.params[0],\n          types,\n          aliasMap,\n          enumMap,\n          tryParse,\n          cxxOnly,\n          parser,\n        ),\n      });\n    } catch {\n      return wrapNullable(nullable, {\n        type: 'PromiseTypeAnnotation',\n      });\n    }\n  }\n}\nfunction emitGenericObject(nullable) {\n  return wrapNullable(nullable, {\n    type: 'GenericObjectTypeAnnotation',\n  });\n}\nfunction emitObject(nullable, properties) {\n  return wrapNullable(nullable, {\n    type: 'ObjectTypeAnnotation',\n    properties,\n  });\n}\nfunction emitFloat(nullable) {\n  return wrapNullable(nullable, {\n    type: 'FloatTypeAnnotation',\n  });\n}\nfunction emitUnion(nullable, hasteModuleName, typeAnnotation, parser) {\n  const unionTypes = parser.remapUnionTypeAnnotationMemberNames(\n    typeAnnotation.types,\n  );\n\n  // Only support unionTypes of the same kind\n  if (unionTypes.length > 1) {\n    throw new UnsupportedUnionTypeAnnotationParserError(\n      hasteModuleName,\n      typeAnnotation,\n      unionTypes,\n    );\n  }\n  return wrapNullable(nullable, {\n    type: 'UnionTypeAnnotation',\n    memberType: unionTypes[0],\n  });\n}\nfunction translateArrayTypeAnnotation(\n  hasteModuleName,\n  types,\n  aliasMap,\n  enumMap,\n  cxxOnly,\n  arrayType,\n  elementType,\n  nullable,\n  translateTypeAnnotation,\n  parser,\n) {\n  try {\n    /**\n     * TODO(T72031674): Migrate all our NativeModule specs to not use\n     * invalid Array ElementTypes. Then, make the elementType a required\n     * parameter.\n     */\n    const _unwrapNullable = unwrapNullable(\n        translateTypeAnnotation(\n          hasteModuleName,\n          elementType,\n          types,\n          aliasMap,\n          enumMap,\n          /**\n           * TODO(T72031674): Ensure that all ParsingErrors that are thrown\n           * while parsing the array element don't get captured and collected.\n           * Why? If we detect any parsing error while parsing the element,\n           * we should default it to null down the line, here. This is\n           * the correct behaviour until we migrate all our NativeModule specs\n           * to be parseable.\n           */\n          nullGuard,\n          cxxOnly,\n          parser,\n        ),\n      ),\n      _unwrapNullable2 = _slicedToArray(_unwrapNullable, 2),\n      _elementType = _unwrapNullable2[0],\n      isElementTypeNullable = _unwrapNullable2[1];\n    throwIfArrayElementTypeAnnotationIsUnsupported(\n      hasteModuleName,\n      elementType,\n      arrayType,\n      _elementType.type,\n    );\n    return wrapNullable(nullable, {\n      type: 'ArrayTypeAnnotation',\n      // $FlowFixMe[incompatible-call]\n      elementType: wrapNullable(isElementTypeNullable, _elementType),\n    });\n  } catch (ex) {\n    return wrapNullable(nullable, {\n      type: 'ArrayTypeAnnotation',\n    });\n  }\n}\nfunction emitArrayType(\n  hasteModuleName,\n  typeAnnotation,\n  parser,\n  types,\n  aliasMap,\n  enumMap,\n  cxxOnly,\n  nullable,\n  translateTypeAnnotation,\n) {\n  assertGenericTypeAnnotationHasExactlyOneTypeParameter(\n    hasteModuleName,\n    typeAnnotation,\n    parser,\n  );\n  return translateArrayTypeAnnotation(\n    hasteModuleName,\n    types,\n    aliasMap,\n    enumMap,\n    cxxOnly,\n    typeAnnotation.type,\n    typeAnnotation.typeParameters.params[0],\n    nullable,\n    translateTypeAnnotation,\n    parser,\n  );\n}\nfunction Visitor(infoMap) {\n  return {\n    CallExpression(node) {\n      if (\n        node.callee.type === 'Identifier' &&\n        node.callee.name === 'codegenNativeComponent'\n      ) {\n        infoMap.isComponent = true;\n      }\n      if (isModuleRegistryCall(node)) {\n        infoMap.isModule = true;\n      }\n    },\n    InterfaceExtends(node) {\n      if (node.id.name === 'TurboModule') {\n        infoMap.isModule = true;\n      }\n    },\n    TSInterfaceDeclaration(node) {\n      if (\n        Array.isArray(node.extends) &&\n        node.extends.some(\n          extension => extension.expression.name === 'TurboModule',\n        )\n      ) {\n        infoMap.isModule = true;\n      }\n    },\n  };\n}\nfunction emitPartial(\n  hasteModuleName,\n  typeAnnotation,\n  types,\n  aliasMap,\n  enumMap,\n  tryParse,\n  cxxOnly,\n  nullable,\n  parser,\n) {\n  throwIfPartialWithMoreParameter(typeAnnotation);\n  throwIfPartialNotAnnotatingTypeParameter(typeAnnotation, types, parser);\n  const annotatedElement = parser.extractAnnotatedElement(\n    typeAnnotation,\n    types,\n  );\n  const annotatedElementProperties =\n    parser.getAnnotatedElementProperties(annotatedElement);\n  const partialProperties = parser.computePartialProperties(\n    annotatedElementProperties,\n    hasteModuleName,\n    types,\n    aliasMap,\n    enumMap,\n    tryParse,\n    cxxOnly,\n  );\n  return emitObject(nullable, partialProperties);\n}\nfunction emitCommonTypes(\n  hasteModuleName,\n  types,\n  typeAnnotation,\n  aliasMap,\n  enumMap,\n  tryParse,\n  cxxOnly,\n  nullable,\n  parser,\n) {\n  const genericTypeAnnotationName =\n    parser.nameForGenericTypeAnnotation(typeAnnotation);\n  switch (genericTypeAnnotationName) {\n    case 'Stringish': {\n      return emitStringish(nullable);\n    }\n    case 'Int32': {\n      return emitInt32(nullable);\n    }\n    case 'Double': {\n      return emitDouble(nullable);\n    }\n    case 'Float': {\n      return emitFloat(nullable);\n    }\n    case 'UnsafeObject':\n    case 'Object': {\n      return emitGenericObject(nullable);\n    }\n    case '$Partial':\n    case 'Partial': {\n      return emitPartial(\n        hasteModuleName,\n        typeAnnotation,\n        types,\n        aliasMap,\n        enumMap,\n        tryParse,\n        cxxOnly,\n        nullable,\n        parser,\n      );\n    }\n    default: {\n      return null;\n    }\n  }\n}\nmodule.exports = {\n  emitArrayType,\n  emitBoolean,\n  emitDouble,\n  emitFloat,\n  emitFunction,\n  emitInt32,\n  emitNumber,\n  emitGenericObject,\n  emitObject,\n  emitPromise,\n  emitRootTag,\n  emitVoid,\n  emitString,\n  emitStringish,\n  emitMixed,\n  emitUnion,\n  emitPartial,\n  emitCommonTypes,\n  typeAliasResolution,\n  typeEnumResolution,\n  translateArrayTypeAnnotation,\n  Visitor,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}