{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar BREAK = Symbol('break visit');\nvar SKIP = Symbol('skip children');\nvar REMOVE = Symbol('remove item');\nfunction visit(cst, visitor) {\n  if ('type' in cst && cst.type === 'document') cst = {\n    start: cst.start,\n    value: cst.value\n  };\n  _visit(Object.freeze([]), cst, visitor);\n}\nvisit.BREAK = BREAK;\nvisit.SKIP = SKIP;\nvisit.REMOVE = REMOVE;\nvisit.itemAtPath = function (cst, path) {\n  var item = cst;\n  for (var _ref of path) {\n    var _item;\n    var _ref2 = _slicedToArray(_ref, 2);\n    var field = _ref2[0];\n    var index = _ref2[1];\n    var tok = (_item = item) == null ? void 0 : _item[field];\n    if (tok && 'items' in tok) {\n      item = tok.items[index];\n    } else return undefined;\n  }\n  return item;\n};\nvisit.parentCollection = function (cst, path) {\n  var parent = visit.itemAtPath(cst, path.slice(0, -1));\n  var field = path[path.length - 1][0];\n  var coll = parent == null ? void 0 : parent[field];\n  if (coll && 'items' in coll) return coll;\n  throw new Error('Parent collection not found');\n};\nfunction _visit(path, item, visitor) {\n  var ctrl = visitor(item, path);\n  if (typeof ctrl === 'symbol') return ctrl;\n  for (var field of ['key', 'value']) {\n    var token = item[field];\n    if (token && 'items' in token) {\n      for (var i = 0; i < token.items.length; ++i) {\n        var ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);\n        if (typeof ci === 'number') i = ci - 1;else if (ci === BREAK) return BREAK;else if (ci === REMOVE) {\n          token.items.splice(i, 1);\n          i -= 1;\n        }\n      }\n      if (typeof ctrl === 'function' && field === 'key') ctrl = ctrl(item, path);\n    }\n  }\n  return typeof ctrl === 'function' ? ctrl(item, path) : ctrl;\n}\nexports.visit = visit;","map":{"version":3,"names":["_slicedToArray","require","BREAK","Symbol","SKIP","REMOVE","visit","cst","visitor","type","start","value","_visit","Object","freeze","itemAtPath","path","item","_ref","_item","_ref2","field","index","tok","items","undefined","parentCollection","parent","slice","length","coll","Error","ctrl","token","i","ci","concat","splice","exports"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native-community/cli-doctor/node_modules/yaml/dist/parse/cst-visit.js"],"sourcesContent":["'use strict';\n\nconst BREAK = Symbol('break visit');\nconst SKIP = Symbol('skip children');\nconst REMOVE = Symbol('remove item');\n/**\n * Apply a visitor to a CST document or item.\n *\n * Walks through the tree (depth-first) starting from the root, calling a\n * `visitor` function with two arguments when entering each item:\n *   - `item`: The current item, which included the following members:\n *     - `start: SourceToken[]` – Source tokens before the key or value,\n *       possibly including its anchor or tag.\n *     - `key?: Token | null` – Set for pair values. May then be `null`, if\n *       the key before the `:` separator is empty.\n *     - `sep?: SourceToken[]` – Source tokens between the key and the value,\n *       which should include the `:` map value indicator if `value` is set.\n *     - `value?: Token` – The value of a sequence item, or of a map pair.\n *   - `path`: The steps from the root to the current node, as an array of\n *     `['key' | 'value', number]` tuples.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this token, continue with\n *      next sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current item, then continue with the next one\n *   - `number`: Set the index of the next step. This is useful especially if\n *     the index of the current token has changed.\n *   - `function`: Define the next visitor for this item. After the original\n *     visitor is called on item entry, next visitors are called after handling\n *     a non-empty `key` and when exiting the item.\n */\nfunction visit(cst, visitor) {\n    if ('type' in cst && cst.type === 'document')\n        cst = { start: cst.start, value: cst.value };\n    _visit(Object.freeze([]), cst, visitor);\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisit.BREAK = BREAK;\n/** Do not visit the children of the current item */\nvisit.SKIP = SKIP;\n/** Remove the current item */\nvisit.REMOVE = REMOVE;\n/** Find the item at `path` from `cst` as the root */\nvisit.itemAtPath = (cst, path) => {\n    let item = cst;\n    for (const [field, index] of path) {\n        const tok = item?.[field];\n        if (tok && 'items' in tok) {\n            item = tok.items[index];\n        }\n        else\n            return undefined;\n    }\n    return item;\n};\n/**\n * Get the immediate parent collection of the item at `path` from `cst` as the root.\n *\n * Throws an error if the collection is not found, which should never happen if the item itself exists.\n */\nvisit.parentCollection = (cst, path) => {\n    const parent = visit.itemAtPath(cst, path.slice(0, -1));\n    const field = path[path.length - 1][0];\n    const coll = parent?.[field];\n    if (coll && 'items' in coll)\n        return coll;\n    throw new Error('Parent collection not found');\n};\nfunction _visit(path, item, visitor) {\n    let ctrl = visitor(item, path);\n    if (typeof ctrl === 'symbol')\n        return ctrl;\n    for (const field of ['key', 'value']) {\n        const token = item[field];\n        if (token && 'items' in token) {\n            for (let i = 0; i < token.items.length; ++i) {\n                const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === BREAK)\n                    return BREAK;\n                else if (ci === REMOVE) {\n                    token.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n            if (typeof ctrl === 'function' && field === 'key')\n                ctrl = ctrl(item, path);\n        }\n    }\n    return typeof ctrl === 'function' ? ctrl(item, path) : ctrl;\n}\n\nexports.visit = visit;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}