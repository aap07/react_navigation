{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getProjectRoot = getProjectRoot;\nexports.assertArgs = assertArgs;\nexports.assertWithOptionsArgs = assertWithOptionsArgs;\nexports.printHelp = printHelp;\nvar _arg = _interopRequireDefault(require(\"arg\"));\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\nvar _fs = require(\"fs\");\nvar _path = require(\"path\");\nvar Log = _interopRequireWildcard(require(\"../log\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nfunction getProjectRoot(args) {\n  var projectRoot = (0, _path).resolve(args._[0] || \".\");\n  if (!(0, _fs).existsSync(projectRoot)) {\n    Log.exit(`Invalid project root: ${projectRoot}`);\n  }\n  return projectRoot;\n}\nfunction assertArgs(schema, argv) {\n  return assertWithOptionsArgs(schema, {\n    argv: argv\n  });\n}\nfunction assertWithOptionsArgs(schema, options) {\n  try {\n    return (0, _arg).default(schema, options);\n  } catch (error) {\n    if (error.code === \"ARG_UNKNOWN_OPTION\") {\n      Log.exit(error.message, 1);\n    }\n    throw error;\n  }\n}\nfunction printHelp(info, usage, options) {\n  var extra = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n  Log.exit(_chalk.default`\n  {bold Info}\n    ${info}\n\n  {bold Usage}\n    {dim $} ${usage}\n\n  {bold Options}\n    ${options.split(\"\\n\").join(\"\\n    \")}\n` + extra, 0);\n}","map":{"version":3,"names":["getProjectRoot","assertArgs","assertWithOptionsArgs","printHelp","_arg","_interopRequireDefault","require","_chalk","_fs","_path","Log","_interopRequireWildcard","args","projectRoot","resolve","_","existsSync","exit","schema","argv","options","default","error","code","message","info","usage","extra","arguments","length","undefined","split","join"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\cli\\src\\utils\\args.ts"],"sourcesContent":["// Common utilities for interacting with `args` library.\n// These functions should be used by every command.\nimport arg from 'arg';\nimport chalk from 'chalk';\nimport { existsSync } from 'fs';\nimport { resolve } from 'path';\n\nimport * as Log from '../log';\n\n/**\n * Parse the first argument as a project directory.\n *\n * @returns valid project directory.\n */\nexport function getProjectRoot(args: arg.Result<arg.Spec>) {\n  const projectRoot = resolve(args._[0] || '.');\n\n  if (!existsSync(projectRoot)) {\n    Log.exit(`Invalid project root: ${projectRoot}`);\n  }\n\n  return projectRoot;\n}\n\n/**\n * Parse args and assert unknown options.\n *\n * @param schema the `args` schema for parsing the command line arguments.\n * @param argv extra strings\n * @returns processed args object.\n */\nexport function assertArgs(schema: arg.Spec, argv?: string[]): arg.Result<arg.Spec> {\n  return assertWithOptionsArgs(schema, { argv });\n}\n\nexport function assertWithOptionsArgs(\n  schema: arg.Spec,\n  options: arg.Options\n): arg.Result<arg.Spec> {\n  try {\n    return arg(schema, options);\n  } catch (error: any) {\n    // Ensure unknown options are handled the same way.\n    if (error.code === 'ARG_UNKNOWN_OPTION') {\n      Log.exit(error.message, 1);\n    }\n    // Otherwise rethrow the error.\n    throw error;\n  }\n}\n\nexport function printHelp(info: string, usage: string, options: string, extra: string = ''): never {\n  Log.exit(\n    chalk`\n  {bold Info}\n    ${info}\n\n  {bold Usage}\n    {dim $} ${usage}\n\n  {bold Options}\n    ${options.split('\\n').join('\\n    ')}\n` + extra,\n    0\n  );\n}\n"],"mappings":"AAEA;;;;;QAYgBA,cAAc,GAAdA,cAAc;QAiBdC,UAAU,GAAVA,UAAU;QAIVC,qBAAqB,GAArBA,qBAAqB;QAgBrBC,SAAS,GAATA,SAAS;AAjDT,IAAAC,IAAK,GAAAC,sBAAA,CAAAC,OAAA,CAAL,KAAK;AACH,IAAAC,MAAO,GAAAF,sBAAA,CAAAC,OAAA,CAAP,OAAO;AACE,IAAAE,GAAI,GAAAF,OAAA,CAAJ,IAAI;AACP,IAAAG,KAAM,GAAAH,OAAA,CAAN,MAAM;AAElB,IAAAI,GAAG,GAAAC,uBAAA,CAAAL,OAAA,SAAc,EAAd;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOR,SAASN,cAAcA,CAACY,IAA0B,EAAE;EACzD,IAAMC,WAAW,GAAG,IAAAJ,KAAO,EAAkBK,OAAlB,CAACF,IAAI,CAACG,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC;EAE7C,IAAI,CAAC,IAAAP,GAAU,EAAaQ,UAAb,CAACH,WAAW,CAAC,EAAE;IAC5BH,GAAG,CAACO,IAAI,CAAE,yBAAwBJ,WAAY,EAAC,CAAC;;EAGlD,OAAOA,WAAW;;AAUb,SAASZ,UAAUA,CAACiB,MAAgB,EAAEC,IAAe,EAAwB;EAClF,OAAOjB,qBAAqB,CAACgB,MAAM,EAAE;IAAEC,IAAI,EAAJA;GAAM,CAAC;;AAGzC,SAASjB,qBAAqBA,CACnCgB,MAAgB,EAChBE,OAAoB,EACE;EACtB,IAAI;IACF,OAAO,IAAAhB,IAAG,EAAiBiB,OAAjB,CAACH,MAAM,EAAEE,OAAO,CAAC;GAC5B,CAAC,OAAOE,KAAK,EAAO;IAEnB,IAAIA,KAAK,CAACC,IAAI,KAAK,oBAAoB,EAAE;MACvCb,GAAG,CAACO,IAAI,CAACK,KAAK,CAACE,OAAO,EAAE,CAAC,CAAC;;IAG5B,MAAMF,KAAK;;;AAIR,SAASnB,SAASA,CAACsB,IAAY,EAAEC,KAAa,EAAEN,OAAe,EAA6B;EAAA,IAA3BO,KAAa,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,EAAE;EACxFlB,GAAG,CAACO,IAAI,CACNV,MAAK,CAAAc,OAAC;;MAEJI,IAAK;;;cAGGC,KAAM;;;MAGdN,OAAO,CAACW,KAAK,CAAC,IAAI,CAAC,CAACC,IAAI,CAAC,QAAQ,CAAE;AACzC,CAAC,GAAGL,KAAK,EACL,CAAC,CACF"},"metadata":{},"sourceType":"script","externalDependencies":[]}