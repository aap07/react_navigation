{"ast":null,"code":"'use strict';\nvar _get = require(\"@babel/runtime/helpers/get\");\nvar _assertThisInitialized = require(\"@babel/runtime/helpers/assertThisInitialized\");\nvar _wrapNativeSuper = require(\"@babel/runtime/helpers/wrapNativeSuper\");\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nvar SUPPRESS = '==SUPPRESS==';\nvar OPTIONAL = '?';\nvar ZERO_OR_MORE = '*';\nvar ONE_OR_MORE = '+';\nvar PARSER = 'A...';\nvar REMAINDER = '...';\nvar _UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args';\nvar assert = require('assert');\nvar util = require('util');\nvar fs = require('fs');\nvar sub = require(\"./lib/sub\");\nvar path = require('path');\nvar repr = util.inspect;\nfunction get_argv() {\n  return process.argv.slice(1);\n}\nfunction get_terminal_size() {\n  return {\n    columns: +process.env.COLUMNS || process.stdout.columns || 80\n  };\n}\nfunction hasattr(object, name) {\n  return Object.prototype.hasOwnProperty.call(object, name);\n}\nfunction getattr(object, name, value) {\n  return hasattr(object, name) ? object[name] : value;\n}\nfunction setattr(object, name, value) {\n  object[name] = value;\n}\nfunction setdefault(object, name, value) {\n  if (!hasattr(object, name)) object[name] = value;\n  return object[name];\n}\nfunction delattr(object, name) {\n  delete object[name];\n}\nfunction range(from, to) {\n  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  if (arguments.length === 1) {\n    var _ref = [from, 0];\n    to = _ref[0];\n    from = _ref[1];\n  }\n  if (typeof from !== 'number' || typeof to !== 'number' || typeof step !== 'number') {\n    throw new TypeError('argument cannot be interpreted as an integer');\n  }\n  if (step === 0) throw new TypeError('range() arg 3 must not be zero');\n  var result = [];\n  if (step > 0) {\n    for (var i = from; i < to; i += step) result.push(i);\n  } else {\n    for (var _i = from; _i > to; _i += step) result.push(_i);\n  }\n  return result;\n}\nfunction splitlines(str) {\n  var keepends = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var result;\n  if (!keepends) {\n    result = str.split(/\\r\\n|[\\n\\r\\v\\f\\x1c\\x1d\\x1e\\x85\\u2028\\u2029]/);\n  } else {\n    result = [];\n    var parts = str.split(/(\\r\\n|[\\n\\r\\v\\f\\x1c\\x1d\\x1e\\x85\\u2028\\u2029])/);\n    for (var i = 0; i < parts.length; i += 2) {\n      result.push(parts[i] + (i + 1 < parts.length ? parts[i + 1] : ''));\n    }\n  }\n  if (!result[result.length - 1]) result.pop();\n  return result;\n}\nfunction _string_lstrip(string, prefix_chars) {\n  var idx = 0;\n  while (idx < string.length && prefix_chars.includes(string[idx])) idx++;\n  return idx ? string.slice(idx) : string;\n}\nfunction _string_split(string, sep, maxsplit) {\n  var result = string.split(sep);\n  if (result.length > maxsplit) {\n    result = result.slice(0, maxsplit).concat([result.slice(maxsplit).join(sep)]);\n  }\n  return result;\n}\nfunction _array_equal(array1, array2) {\n  if (array1.length !== array2.length) return false;\n  for (var i = 0; i < array1.length; i++) {\n    if (array1[i] !== array2[i]) return false;\n  }\n  return true;\n}\nfunction _array_remove(array, item) {\n  var idx = array.indexOf(item);\n  if (idx === -1) throw new TypeError(sub('%r not in list', item));\n  array.splice(idx, 1);\n}\nfunction _choices_to_array(choices) {\n  if (choices === undefined) {\n    return [];\n  } else if (Array.isArray(choices)) {\n    return choices;\n  } else if (choices !== null && typeof choices[Symbol.iterator] === 'function') {\n    return Array.from(choices);\n  } else if (typeof choices === 'object' && choices !== null) {\n    return Object.keys(choices);\n  } else {\n    throw new Error(sub('invalid choices value: %r', choices));\n  }\n}\nfunction _callable(cls) {\n  var result = _defineProperty({}, cls.name, function () {\n    var this_class = new.target === result || !new.target;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return Reflect.construct(cls, args, this_class ? cls : new.target);\n  });\n  result[cls.name].prototype = cls.prototype;\n  cls.prototype[Symbol.toStringTag] = cls.name;\n  return result[cls.name];\n}\nfunction _alias(object, from, to) {\n  try {\n    var name = object.constructor.name;\n    Object.defineProperty(object, from, {\n      value: util.deprecate(object[to], sub('%s.%s() is renamed to %s.%s()', name, from, name, to)),\n      enumerable: false\n    });\n  } catch (_unused) {}\n}\nfunction _camelcase_alias(_class) {\n  for (var name of Object.getOwnPropertyNames(_class.prototype)) {\n    var camelcase = name.replace(/\\w_[a-z]/g, function (s) {\n      return s[0] + s[2].toUpperCase();\n    });\n    if (camelcase !== name) _alias(_class.prototype, camelcase, name);\n  }\n  return _class;\n}\nfunction _to_legacy_name(key) {\n  key = key.replace(/\\w_[a-z]/g, function (s) {\n    return s[0] + s[2].toUpperCase();\n  });\n  if (key === 'default') key = 'defaultValue';\n  if (key === 'const') key = 'constant';\n  return key;\n}\nfunction _to_new_name(key) {\n  if (key === 'defaultValue') key = 'default';\n  if (key === 'constant') key = 'const';\n  key = key.replace(/[A-Z]/g, function (c) {\n    return '_' + c.toLowerCase();\n  });\n  return key;\n}\nvar no_default = Symbol('no_default_value');\nfunction _parse_opts(args, descriptor) {\n  function get_name() {\n    var stack = new Error().stack.split('\\n').map(function (x) {\n      return x.match(/^    at (.*) \\(.*\\)$/);\n    }).filter(Boolean).map(function (m) {\n      return m[1];\n    }).map(function (fn) {\n      return fn.match(/[^ .]*$/)[0];\n    });\n    if (stack.length && stack[0] === get_name.name) stack.shift();\n    if (stack.length && stack[0] === _parse_opts.name) stack.shift();\n    return stack.length ? stack[0] : '';\n  }\n  args = Array.from(args);\n  var kwargs = {};\n  var result = [];\n  var last_opt = args.length && args[args.length - 1];\n  if (typeof last_opt === 'object' && last_opt !== null && !Array.isArray(last_opt) && (!last_opt.constructor || last_opt.constructor.name === 'Object')) {\n    kwargs = Object.assign({}, args.pop());\n  }\n  var renames = [];\n  for (var key of Object.keys(descriptor)) {\n    var old_name = _to_legacy_name(key);\n    if (old_name !== key && old_name in kwargs) {\n      if (key in kwargs) {} else {\n        kwargs[key] = kwargs[old_name];\n      }\n      renames.push([old_name, key]);\n      delete kwargs[old_name];\n    }\n  }\n  if (renames.length) {\n    var name = get_name();\n    deprecate('camelcase_' + name, sub('%s(): following options are renamed: %s', name, renames.map(function (_ref2) {\n      var _ref3 = _slicedToArray(_ref2, 2),\n        a = _ref3[0],\n        b = _ref3[1];\n      return sub('%r -> %r', a, b);\n    })));\n  }\n  var missing_positionals = [];\n  var positional_count = args.length;\n  for (var _ref4 of Object.entries(descriptor)) {\n    var _ref5 = _slicedToArray(_ref4, 2);\n    var _key2 = _ref5[0];\n    var def = _ref5[1];\n    if (_key2[0] === '*') {\n      if (_key2.length > 0 && _key2[1] === '*') {\n        var _renames = [];\n        for (var _key3 of Object.keys(kwargs)) {\n          var new_name = _to_new_name(_key3);\n          if (new_name !== _key3 && _key3 in kwargs) {\n            if (new_name in kwargs) {} else {\n              kwargs[new_name] = kwargs[_key3];\n            }\n            _renames.push([_key3, new_name]);\n            delete kwargs[_key3];\n          }\n        }\n        if (_renames.length) {\n          var _name = get_name();\n          deprecate('camelcase_' + _name, sub('%s(): following options are renamed: %s', _name, _renames.map(function (_ref6) {\n            var _ref7 = _slicedToArray(_ref6, 2),\n              a = _ref7[0],\n              b = _ref7[1];\n            return sub('%r -> %r', a, b);\n          })));\n        }\n        result.push(kwargs);\n        kwargs = {};\n      } else {\n        result.push(args);\n        args = [];\n      }\n    } else if (_key2 in kwargs && args.length > 0) {\n      throw new TypeError(sub('%s() got multiple values for argument %r', get_name(), _key2));\n    } else if (_key2 in kwargs) {\n      result.push(kwargs[_key2]);\n      delete kwargs[_key2];\n    } else if (args.length > 0) {\n      result.push(args.shift());\n    } else if (def !== no_default) {\n      result.push(def);\n    } else {\n      missing_positionals.push(_key2);\n    }\n  }\n  if (Object.keys(kwargs).length) {\n    throw new TypeError(sub('%s() got an unexpected keyword argument %r', get_name(), Object.keys(kwargs)[0]));\n  }\n  if (args.length) {\n    var from = Object.entries(descriptor).filter(function (_ref8) {\n      var _ref9 = _slicedToArray(_ref8, 2),\n        k = _ref9[0],\n        v = _ref9[1];\n      return k[0] !== '*' && v !== no_default;\n    }).length;\n    var to = Object.entries(descriptor).filter(function (_ref10) {\n      var _ref11 = _slicedToArray(_ref10, 1),\n        k = _ref11[0];\n      return k[0] !== '*';\n    }).length;\n    throw new TypeError(sub('%s() takes %s positional argument%s but %s %s given', get_name(), from === to ? sub('from %s to %s', from, to) : to, from === to && to === 1 ? '' : 's', positional_count, positional_count === 1 ? 'was' : 'were'));\n  }\n  if (missing_positionals.length) {\n    var strs = missing_positionals.map(repr);\n    if (strs.length > 1) strs[strs.length - 1] = 'and ' + strs[strs.length - 1];\n    var str_joined = strs.join(strs.length === 2 ? '' : ', ');\n    throw new TypeError(sub('%s() missing %i required positional argument%s: %s', get_name(), strs.length, strs.length === 1 ? '' : 's', str_joined));\n  }\n  return result;\n}\nvar _deprecations = {};\nfunction deprecate(id, string) {\n  _deprecations[id] = _deprecations[id] || util.deprecate(function () {}, string);\n  _deprecations[id]();\n}\nfunction _AttributeHolder() {\n  var cls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object;\n  return function (_cls, _util$inspect$custom) {\n    _inherits(_AttributeHolder, _cls);\n    var _super = _createSuper(_AttributeHolder);\n    function _AttributeHolder() {\n      _classCallCheck(this, _AttributeHolder);\n      return _super.apply(this, arguments);\n    }\n    _createClass(_AttributeHolder, [{\n      key: _util$inspect$custom,\n      value: function value() {\n        var type_name = this.constructor.name;\n        var arg_strings = [];\n        var star_args = {};\n        for (var arg of this._get_args()) {\n          arg_strings.push(repr(arg));\n        }\n        for (var _ref12 of this._get_kwargs()) {\n          var _ref13 = _slicedToArray(_ref12, 2);\n          var name = _ref13[0];\n          var value = _ref13[1];\n          if (/^[a-z_][a-z0-9_$]*$/i.test(name)) {\n            arg_strings.push(sub('%s=%r', name, value));\n          } else {\n            star_args[name] = value;\n          }\n        }\n        if (Object.keys(star_args).length) {\n          arg_strings.push(sub('**%s', repr(star_args)));\n        }\n        return sub('%s(%s)', type_name, arg_strings.join(', '));\n      }\n    }, {\n      key: \"toString\",\n      value: function toString() {\n        return this[util.inspect.custom]();\n      }\n    }, {\n      key: \"_get_kwargs\",\n      value: function _get_kwargs() {\n        return Object.entries(this);\n      }\n    }, {\n      key: \"_get_args\",\n      value: function _get_args() {\n        return [];\n      }\n    }]);\n    return _AttributeHolder;\n  }(cls, util.inspect.custom);\n}\nfunction _copy_items(items) {\n  if (items === undefined) {\n    return [];\n  }\n  return items.slice(0);\n}\nvar HelpFormatter = _camelcase_alias(_callable(function () {\n  function HelpFormatter() {\n    _classCallCheck(this, HelpFormatter);\n    var _parse_opts2 = _parse_opts(arguments, {\n        prog: no_default,\n        indent_increment: 2,\n        max_help_position: 24,\n        width: undefined\n      }),\n      _parse_opts3 = _slicedToArray(_parse_opts2, 4),\n      prog = _parse_opts3[0],\n      indent_increment = _parse_opts3[1],\n      max_help_position = _parse_opts3[2],\n      width = _parse_opts3[3];\n    if (width === undefined) {\n      width = get_terminal_size().columns;\n      width -= 2;\n    }\n    this._prog = prog;\n    this._indent_increment = indent_increment;\n    this._max_help_position = Math.min(max_help_position, Math.max(width - 20, indent_increment * 2));\n    this._width = width;\n    this._current_indent = 0;\n    this._level = 0;\n    this._action_max_length = 0;\n    this._root_section = this._Section(this, undefined);\n    this._current_section = this._root_section;\n    this._whitespace_matcher = /[ \\t\\n\\r\\f\\v]+/g;\n    this._long_break_matcher = /\\n\\n\\n+/g;\n  }\n  _createClass(HelpFormatter, [{\n    key: \"_indent\",\n    value: function _indent() {\n      this._current_indent += this._indent_increment;\n      this._level += 1;\n    }\n  }, {\n    key: \"_dedent\",\n    value: function _dedent() {\n      this._current_indent -= this._indent_increment;\n      assert(this._current_indent >= 0, 'Indent decreased below 0.');\n      this._level -= 1;\n    }\n  }, {\n    key: \"_add_item\",\n    value: function _add_item(func, args) {\n      this._current_section.items.push([func, args]);\n    }\n  }, {\n    key: \"start_section\",\n    value: function start_section(heading) {\n      this._indent();\n      var section = this._Section(this, this._current_section, heading);\n      this._add_item(section.format_help.bind(section), []);\n      this._current_section = section;\n    }\n  }, {\n    key: \"end_section\",\n    value: function end_section() {\n      this._current_section = this._current_section.parent;\n      this._dedent();\n    }\n  }, {\n    key: \"add_text\",\n    value: function add_text(text) {\n      if (text !== SUPPRESS && text !== undefined) {\n        this._add_item(this._format_text.bind(this), [text]);\n      }\n    }\n  }, {\n    key: \"add_usage\",\n    value: function add_usage(usage, actions, groups) {\n      var prefix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n      if (usage !== SUPPRESS) {\n        var args = [usage, actions, groups, prefix];\n        this._add_item(this._format_usage.bind(this), args);\n      }\n    }\n  }, {\n    key: \"add_argument\",\n    value: function add_argument(action) {\n      if (action.help !== SUPPRESS) {\n        var invocations = [this._format_action_invocation(action)];\n        for (var subaction of this._iter_indented_subactions(action)) {\n          invocations.push(this._format_action_invocation(subaction));\n        }\n        var invocation_length = Math.max.apply(Math, _toConsumableArray(invocations.map(function (invocation) {\n          return invocation.length;\n        })));\n        var action_length = invocation_length + this._current_indent;\n        this._action_max_length = Math.max(this._action_max_length, action_length);\n        this._add_item(this._format_action.bind(this), [action]);\n      }\n    }\n  }, {\n    key: \"add_arguments\",\n    value: function add_arguments(actions) {\n      for (var action of actions) {\n        this.add_argument(action);\n      }\n    }\n  }, {\n    key: \"format_help\",\n    value: function format_help() {\n      var help = this._root_section.format_help();\n      if (help) {\n        help = help.replace(this._long_break_matcher, '\\n\\n');\n        help = help.replace(/^\\n+|\\n+$/g, '') + '\\n';\n      }\n      return help;\n    }\n  }, {\n    key: \"_join_parts\",\n    value: function _join_parts(part_strings) {\n      return part_strings.filter(function (part) {\n        return part && part !== SUPPRESS;\n      }).join('');\n    }\n  }, {\n    key: \"_format_usage\",\n    value: function _format_usage(usage, actions, groups, prefix) {\n      if (prefix === undefined) {\n        prefix = 'usage: ';\n      }\n      if (usage !== undefined) {\n        usage = sub(usage, {\n          prog: this._prog\n        });\n      } else if (usage === undefined && !actions.length) {\n        usage = sub('%(prog)s', {\n          prog: this._prog\n        });\n      } else if (usage === undefined) {\n        var prog = sub('%(prog)s', {\n          prog: this._prog\n        });\n        var optionals = [];\n        var positionals = [];\n        for (var action of actions) {\n          if (action.option_strings.length) {\n            optionals.push(action);\n          } else {\n            positionals.push(action);\n          }\n        }\n        var action_usage = this._format_actions_usage([].concat(optionals).concat(positionals), groups);\n        usage = [prog, action_usage].map(String).join(' ');\n        var text_width = this._width - this._current_indent;\n        if (prefix.length + usage.length > text_width) {\n          var part_regexp = /\\(.*?\\)+(?=\\s|$)|\\[.*?\\]+(?=\\s|$)|\\S+/g;\n          var opt_usage = this._format_actions_usage(optionals, groups);\n          var pos_usage = this._format_actions_usage(positionals, groups);\n          var opt_parts = opt_usage.match(part_regexp) || [];\n          var pos_parts = pos_usage.match(part_regexp) || [];\n          assert(opt_parts.join(' ') === opt_usage);\n          assert(pos_parts.join(' ') === pos_usage);\n          var get_lines = function get_lines(parts, indent) {\n            var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n            var lines = [];\n            var line = [];\n            var line_len;\n            if (prefix !== undefined) {\n              line_len = prefix.length - 1;\n            } else {\n              line_len = indent.length - 1;\n            }\n            for (var part of parts) {\n              if (line_len + 1 + part.length > text_width && line) {\n                lines.push(indent + line.join(' '));\n                line = [];\n                line_len = indent.length - 1;\n              }\n              line.push(part);\n              line_len += part.length + 1;\n            }\n            if (line.length) {\n              lines.push(indent + line.join(' '));\n            }\n            if (prefix !== undefined) {\n              lines[0] = lines[0].slice(indent.length);\n            }\n            return lines;\n          };\n          var lines;\n          if (prefix.length + prog.length <= 0.75 * text_width) {\n            var indent = ' '.repeat(prefix.length + prog.length + 1);\n            if (opt_parts.length) {\n              lines = get_lines([prog].concat(opt_parts), indent, prefix);\n              lines = lines.concat(get_lines(pos_parts, indent));\n            } else if (pos_parts.length) {\n              lines = get_lines([prog].concat(pos_parts), indent, prefix);\n            } else {\n              lines = [prog];\n            }\n          } else {\n            var _indent2 = ' '.repeat(prefix.length);\n            var parts = [].concat(opt_parts).concat(pos_parts);\n            lines = get_lines(parts, _indent2);\n            if (lines.length > 1) {\n              lines = [];\n              lines = lines.concat(get_lines(opt_parts, _indent2));\n              lines = lines.concat(get_lines(pos_parts, _indent2));\n            }\n            lines = [prog].concat(lines);\n          }\n          usage = lines.join('\\n');\n        }\n      }\n      return sub('%s%s\\n\\n', prefix, usage);\n    }\n  }, {\n    key: \"_format_actions_usage\",\n    value: function _format_actions_usage(actions, groups) {\n      var group_actions = new Set();\n      var inserts = {};\n      for (var group of groups) {\n        var start = actions.indexOf(group._group_actions[0]);\n        if (start === -1) {\n          continue;\n        } else {\n          var end = start + group._group_actions.length;\n          if (_array_equal(actions.slice(start, end), group._group_actions)) {\n            for (var action of group._group_actions) {\n              group_actions.add(action);\n            }\n            if (!group.required) {\n              if (start in inserts) {\n                inserts[start] += ' [';\n              } else {\n                inserts[start] = '[';\n              }\n              if (end in inserts) {\n                inserts[end] += ']';\n              } else {\n                inserts[end] = ']';\n              }\n            } else {\n              if (start in inserts) {\n                inserts[start] += ' (';\n              } else {\n                inserts[start] = '(';\n              }\n              if (end in inserts) {\n                inserts[end] += ')';\n              } else {\n                inserts[end] = ')';\n              }\n            }\n            for (var i of range(start + 1, end)) {\n              inserts[i] = '|';\n            }\n          }\n        }\n      }\n      var parts = [];\n      for (var _ref14 of Object.entries(actions)) {\n        var _ref15 = _slicedToArray(_ref14, 2);\n        var _i2 = _ref15[0];\n        var _action = _ref15[1];\n        if (_action.help === SUPPRESS) {\n          parts.push(undefined);\n          if (inserts[+_i2] === '|') {\n            delete inserts[+_i2];\n          } else if (inserts[+_i2 + 1] === '|') {\n            delete inserts[+_i2 + 1];\n          }\n        } else if (!_action.option_strings.length) {\n          var default_value = this._get_default_metavar_for_positional(_action);\n          var part = this._format_args(_action, default_value);\n          if (group_actions.has(_action)) {\n            if (part[0] === '[' && part[part.length - 1] === ']') {\n              part = part.slice(1, -1);\n            }\n          }\n          parts.push(part);\n        } else {\n          var option_string = _action.option_strings[0];\n          var _part = void 0;\n          if (_action.nargs === 0) {\n            _part = _action.format_usage();\n          } else {\n            var _default_value = this._get_default_metavar_for_optional(_action);\n            var args_string = this._format_args(_action, _default_value);\n            _part = sub('%s %s', option_string, args_string);\n          }\n          if (!_action.required && !group_actions.has(_action)) {\n            _part = sub('[%s]', _part);\n          }\n          parts.push(_part);\n        }\n      }\n      for (var _i3 of Object.keys(inserts).map(Number).sort(function (a, b) {\n        return b - a;\n      })) {\n        parts.splice(+_i3, 0, inserts[+_i3]);\n      }\n      var text = parts.filter(Boolean).join(' ');\n      text = text.replace(/([\\[(]) /g, '$1');\n      text = text.replace(/ ([\\])])/g, '$1');\n      text = text.replace(/[\\[(] *[\\])]/g, '');\n      text = text.replace(/\\(([^|]*)\\)/g, '$1', text);\n      text = text.trim();\n      return text;\n    }\n  }, {\n    key: \"_format_text\",\n    value: function _format_text(text) {\n      if (text.includes('%(prog)')) {\n        text = sub(text, {\n          prog: this._prog\n        });\n      }\n      var text_width = Math.max(this._width - this._current_indent, 11);\n      var indent = ' '.repeat(this._current_indent);\n      return this._fill_text(text, text_width, indent) + '\\n\\n';\n    }\n  }, {\n    key: \"_format_action\",\n    value: function _format_action(action) {\n      var help_position = Math.min(this._action_max_length + 2, this._max_help_position);\n      var help_width = Math.max(this._width - help_position, 11);\n      var action_width = help_position - this._current_indent - 2;\n      var action_header = this._format_action_invocation(action);\n      var indent_first;\n      if (!action.help) {\n        var tup = [this._current_indent, '', action_header];\n        action_header = sub.apply(void 0, ['%*s%s\\n'].concat(tup));\n      } else if (action_header.length <= action_width) {\n        var _tup = [this._current_indent, '', action_width, action_header];\n        action_header = sub.apply(void 0, ['%*s%-*s  '].concat(_tup));\n        indent_first = 0;\n      } else {\n        var _tup2 = [this._current_indent, '', action_header];\n        action_header = sub.apply(void 0, ['%*s%s\\n'].concat(_tup2));\n        indent_first = help_position;\n      }\n      var parts = [action_header];\n      if (action.help) {\n        var help_text = this._expand_help(action);\n        var help_lines = this._split_lines(help_text, help_width);\n        parts.push(sub('%*s%s\\n', indent_first, '', help_lines[0]));\n        for (var line of help_lines.slice(1)) {\n          parts.push(sub('%*s%s\\n', help_position, '', line));\n        }\n      } else if (!action_header.endsWith('\\n')) {\n        parts.push('\\n');\n      }\n      for (var subaction of this._iter_indented_subactions(action)) {\n        parts.push(this._format_action(subaction));\n      }\n      return this._join_parts(parts);\n    }\n  }, {\n    key: \"_format_action_invocation\",\n    value: function _format_action_invocation(action) {\n      if (!action.option_strings.length) {\n        var default_value = this._get_default_metavar_for_positional(action);\n        var metavar = this._metavar_formatter(action, default_value)(1)[0];\n        return metavar;\n      } else {\n        var parts = [];\n        if (action.nargs === 0) {\n          parts = parts.concat(action.option_strings);\n        } else {\n          var _default_value2 = this._get_default_metavar_for_optional(action);\n          var args_string = this._format_args(action, _default_value2);\n          for (var option_string of action.option_strings) {\n            parts.push(sub('%s %s', option_string, args_string));\n          }\n        }\n        return parts.join(', ');\n      }\n    }\n  }, {\n    key: \"_metavar_formatter\",\n    value: function _metavar_formatter(action, default_metavar) {\n      var result;\n      if (action.metavar !== undefined) {\n        result = action.metavar;\n      } else if (action.choices !== undefined) {\n        var choice_strs = _choices_to_array(action.choices).map(String);\n        result = sub('{%s}', choice_strs.join(','));\n      } else {\n        result = default_metavar;\n      }\n      function format(tuple_size) {\n        if (Array.isArray(result)) {\n          return result;\n        } else {\n          return Array(tuple_size).fill(result);\n        }\n      }\n      return format;\n    }\n  }, {\n    key: \"_format_args\",\n    value: function _format_args(action, default_metavar) {\n      var get_metavar = this._metavar_formatter(action, default_metavar);\n      var result;\n      if (action.nargs === undefined) {\n        result = sub.apply(void 0, ['%s'].concat(_toConsumableArray(get_metavar(1))));\n      } else if (action.nargs === OPTIONAL) {\n        result = sub.apply(void 0, ['[%s]'].concat(_toConsumableArray(get_metavar(1))));\n      } else if (action.nargs === ZERO_OR_MORE) {\n        var metavar = get_metavar(1);\n        if (metavar.length === 2) {\n          result = sub.apply(void 0, ['[%s [%s ...]]'].concat(_toConsumableArray(metavar)));\n        } else {\n          result = sub.apply(void 0, ['[%s ...]'].concat(_toConsumableArray(metavar)));\n        }\n      } else if (action.nargs === ONE_OR_MORE) {\n        result = sub.apply(void 0, ['%s [%s ...]'].concat(_toConsumableArray(get_metavar(2))));\n      } else if (action.nargs === REMAINDER) {\n        result = '...';\n      } else if (action.nargs === PARSER) {\n        result = sub.apply(void 0, ['%s ...'].concat(_toConsumableArray(get_metavar(1))));\n      } else if (action.nargs === SUPPRESS) {\n        result = '';\n      } else {\n        var formats;\n        try {\n          formats = range(action.nargs).map(function () {\n            return '%s';\n          });\n        } catch (err) {\n          throw new TypeError('invalid nargs value');\n        }\n        result = sub.apply(void 0, [formats.join(' ')].concat(_toConsumableArray(get_metavar(action.nargs))));\n      }\n      return result;\n    }\n  }, {\n    key: \"_expand_help\",\n    value: function _expand_help(action) {\n      var params = Object.assign({\n        prog: this._prog\n      }, action);\n      for (var name of Object.keys(params)) {\n        if (params[name] === SUPPRESS) {\n          delete params[name];\n        }\n      }\n      for (var _name2 of Object.keys(params)) {\n        if (params[_name2] && params[_name2].name) {\n          params[_name2] = params[_name2].name;\n        }\n      }\n      if (params.choices !== undefined) {\n        var choices_str = _choices_to_array(params.choices).map(String).join(', ');\n        params.choices = choices_str;\n      }\n      for (var key of Object.keys(params)) {\n        var old_name = _to_legacy_name(key);\n        if (old_name !== key) {\n          params[old_name] = params[key];\n        }\n      }\n      return sub(this._get_help_string(action), params);\n    }\n  }, {\n    key: \"_iter_indented_subactions\",\n    value: function* _iter_indented_subactions(action) {\n      if (typeof action._get_subactions === 'function') {\n        this._indent();\n        yield* action._get_subactions();\n        this._dedent();\n      }\n    }\n  }, {\n    key: \"_split_lines\",\n    value: function _split_lines(text, width) {\n      text = text.replace(this._whitespace_matcher, ' ').trim();\n      var textwrap = require(\"./lib/textwrap\");\n      return textwrap.wrap(text, {\n        width: width\n      });\n    }\n  }, {\n    key: \"_fill_text\",\n    value: function _fill_text(text, width, indent) {\n      text = text.replace(this._whitespace_matcher, ' ').trim();\n      var textwrap = require(\"./lib/textwrap\");\n      return textwrap.fill(text, {\n        width: width,\n        initial_indent: indent,\n        subsequent_indent: indent\n      });\n    }\n  }, {\n    key: \"_get_help_string\",\n    value: function _get_help_string(action) {\n      return action.help;\n    }\n  }, {\n    key: \"_get_default_metavar_for_optional\",\n    value: function _get_default_metavar_for_optional(action) {\n      return action.dest.toUpperCase();\n    }\n  }, {\n    key: \"_get_default_metavar_for_positional\",\n    value: function _get_default_metavar_for_positional(action) {\n      return action.dest;\n    }\n  }]);\n  return HelpFormatter;\n}()));\nHelpFormatter.prototype._Section = _callable(function () {\n  function _Section(formatter, parent) {\n    var heading = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    _classCallCheck(this, _Section);\n    this.formatter = formatter;\n    this.parent = parent;\n    this.heading = heading;\n    this.items = [];\n  }\n  _createClass(_Section, [{\n    key: \"format_help\",\n    value: function format_help() {\n      if (this.parent !== undefined) {\n        this.formatter._indent();\n      }\n      var item_help = this.formatter._join_parts(this.items.map(function (_ref16) {\n        var _ref17 = _slicedToArray(_ref16, 2),\n          func = _ref17[0],\n          args = _ref17[1];\n        return func.apply(null, args);\n      }));\n      if (this.parent !== undefined) {\n        this.formatter._dedent();\n      }\n      if (!item_help) {\n        return '';\n      }\n      var heading;\n      if (this.heading !== SUPPRESS && this.heading !== undefined) {\n        var current_indent = this.formatter._current_indent;\n        heading = sub('%*s%s:\\n', current_indent, '', this.heading);\n      } else {\n        heading = '';\n      }\n      return this.formatter._join_parts(['\\n', heading, item_help, '\\n']);\n    }\n  }]);\n  return _Section;\n}());\nvar RawDescriptionHelpFormatter = _camelcase_alias(_callable(function (_HelpFormatter) {\n  _inherits(RawDescriptionHelpFormatter, _HelpFormatter);\n  var _super2 = _createSuper(RawDescriptionHelpFormatter);\n  function RawDescriptionHelpFormatter() {\n    _classCallCheck(this, RawDescriptionHelpFormatter);\n    return _super2.apply(this, arguments);\n  }\n  _createClass(RawDescriptionHelpFormatter, [{\n    key: \"_fill_text\",\n    value: function _fill_text(text, width, indent) {\n      return splitlines(text, true).map(function (line) {\n        return indent + line;\n      }).join('');\n    }\n  }]);\n  return RawDescriptionHelpFormatter;\n}(HelpFormatter)));\nvar RawTextHelpFormatter = _camelcase_alias(_callable(function (_RawDescriptionHelpFo) {\n  _inherits(RawTextHelpFormatter, _RawDescriptionHelpFo);\n  var _super3 = _createSuper(RawTextHelpFormatter);\n  function RawTextHelpFormatter() {\n    _classCallCheck(this, RawTextHelpFormatter);\n    return _super3.apply(this, arguments);\n  }\n  _createClass(RawTextHelpFormatter, [{\n    key: \"_split_lines\",\n    value: function _split_lines(text) {\n      return splitlines(text);\n    }\n  }]);\n  return RawTextHelpFormatter;\n}(RawDescriptionHelpFormatter)));\nvar ArgumentDefaultsHelpFormatter = _camelcase_alias(_callable(function (_HelpFormatter2) {\n  _inherits(ArgumentDefaultsHelpFormatter, _HelpFormatter2);\n  var _super4 = _createSuper(ArgumentDefaultsHelpFormatter);\n  function ArgumentDefaultsHelpFormatter() {\n    _classCallCheck(this, ArgumentDefaultsHelpFormatter);\n    return _super4.apply(this, arguments);\n  }\n  _createClass(ArgumentDefaultsHelpFormatter, [{\n    key: \"_get_help_string\",\n    value: function _get_help_string(action) {\n      var help = action.help;\n      if (!action.help.includes('%(default)') && !action.help.includes('%(defaultValue)')) {\n        if (action.default !== SUPPRESS) {\n          var defaulting_nargs = [OPTIONAL, ZERO_OR_MORE];\n          if (action.option_strings.length || defaulting_nargs.includes(action.nargs)) {\n            help += ' (default: %(default)s)';\n          }\n        }\n      }\n      return help;\n    }\n  }]);\n  return ArgumentDefaultsHelpFormatter;\n}(HelpFormatter)));\nvar MetavarTypeHelpFormatter = _camelcase_alias(_callable(function (_HelpFormatter3) {\n  _inherits(MetavarTypeHelpFormatter, _HelpFormatter3);\n  var _super5 = _createSuper(MetavarTypeHelpFormatter);\n  function MetavarTypeHelpFormatter() {\n    _classCallCheck(this, MetavarTypeHelpFormatter);\n    return _super5.apply(this, arguments);\n  }\n  _createClass(MetavarTypeHelpFormatter, [{\n    key: \"_get_default_metavar_for_optional\",\n    value: function _get_default_metavar_for_optional(action) {\n      return typeof action.type === 'function' ? action.type.name : action.type;\n    }\n  }, {\n    key: \"_get_default_metavar_for_positional\",\n    value: function _get_default_metavar_for_positional(action) {\n      return typeof action.type === 'function' ? action.type.name : action.type;\n    }\n  }]);\n  return MetavarTypeHelpFormatter;\n}(HelpFormatter)));\nfunction _get_action_name(argument) {\n  if (argument === undefined) {\n    return undefined;\n  } else if (argument.option_strings.length) {\n    return argument.option_strings.join('/');\n  } else if (![undefined, SUPPRESS].includes(argument.metavar)) {\n    return argument.metavar;\n  } else if (![undefined, SUPPRESS].includes(argument.dest)) {\n    return argument.dest;\n  } else {\n    return undefined;\n  }\n}\nvar ArgumentError = _callable(function (_Error) {\n  _inherits(ArgumentError, _Error);\n  var _super6 = _createSuper(ArgumentError);\n  function ArgumentError(argument, message) {\n    var _this;\n    _classCallCheck(this, ArgumentError);\n    _this = _super6.call(this);\n    _this.name = 'ArgumentError';\n    _this._argument_name = _get_action_name(argument);\n    _this._message = message;\n    _this.message = _this.str();\n    return _this;\n  }\n  _createClass(ArgumentError, [{\n    key: \"str\",\n    value: function str() {\n      var format;\n      if (this._argument_name === undefined) {\n        format = '%(message)s';\n      } else {\n        format = 'argument %(argument_name)s: %(message)s';\n      }\n      return sub(format, {\n        message: this._message,\n        argument_name: this._argument_name\n      });\n    }\n  }]);\n  return ArgumentError;\n}(_wrapNativeSuper(Error)));\nvar ArgumentTypeError = _callable(function (_Error2) {\n  _inherits(ArgumentTypeError, _Error2);\n  var _super7 = _createSuper(ArgumentTypeError);\n  function ArgumentTypeError(message) {\n    var _this2;\n    _classCallCheck(this, ArgumentTypeError);\n    _this2 = _super7.call(this, message);\n    _this2.name = 'ArgumentTypeError';\n    return _this2;\n  }\n  return _createClass(ArgumentTypeError);\n}(_wrapNativeSuper(Error)));\nvar Action = _camelcase_alias(_callable(function (_AttributeHolder2) {\n  _inherits(Action, _AttributeHolder2);\n  var _super8 = _createSuper(Action);\n  function Action() {\n    var _this3;\n    _classCallCheck(this, Action);\n    var _parse_opts4 = _parse_opts(arguments, {\n        option_strings: no_default,\n        dest: no_default,\n        nargs: undefined,\n        const: undefined,\n        default: undefined,\n        type: undefined,\n        choices: undefined,\n        required: false,\n        help: undefined,\n        metavar: undefined\n      }),\n      _parse_opts5 = _slicedToArray(_parse_opts4, 10),\n      option_strings = _parse_opts5[0],\n      dest = _parse_opts5[1],\n      nargs = _parse_opts5[2],\n      const_value = _parse_opts5[3],\n      default_value = _parse_opts5[4],\n      type = _parse_opts5[5],\n      choices = _parse_opts5[6],\n      required = _parse_opts5[7],\n      help = _parse_opts5[8],\n      metavar = _parse_opts5[9];\n    _this3 = _super8.call(this, 'return arguments.callee.call.apply(arguments.callee, arguments)');\n    _this3.option_strings = option_strings;\n    _this3.dest = dest;\n    _this3.nargs = nargs;\n    _this3.const = const_value;\n    _this3.default = default_value;\n    _this3.type = type;\n    _this3.choices = choices;\n    _this3.required = required;\n    _this3.help = help;\n    _this3.metavar = metavar;\n    return _this3;\n  }\n  _createClass(Action, [{\n    key: \"_get_kwargs\",\n    value: function _get_kwargs() {\n      var _this4 = this;\n      var names = ['option_strings', 'dest', 'nargs', 'const', 'default', 'type', 'choices', 'help', 'metavar'];\n      return names.map(function (name) {\n        return [name, getattr(_this4, name)];\n      });\n    }\n  }, {\n    key: \"format_usage\",\n    value: function format_usage() {\n      return this.option_strings[0];\n    }\n  }, {\n    key: \"call\",\n    value: function call() {\n      throw new Error('.call() not defined');\n    }\n  }]);\n  return Action;\n}(_AttributeHolder(Function))));\nvar BooleanOptionalAction = _camelcase_alias(_callable(function (_Action) {\n  _inherits(BooleanOptionalAction, _Action);\n  var _super9 = _createSuper(BooleanOptionalAction);\n  function BooleanOptionalAction() {\n    _classCallCheck(this, BooleanOptionalAction);\n    var _parse_opts6 = _parse_opts(arguments, {\n        option_strings: no_default,\n        dest: no_default,\n        default: undefined,\n        type: undefined,\n        choices: undefined,\n        required: false,\n        help: undefined,\n        metavar: undefined\n      }),\n      _parse_opts7 = _slicedToArray(_parse_opts6, 8),\n      option_strings = _parse_opts7[0],\n      dest = _parse_opts7[1],\n      default_value = _parse_opts7[2],\n      type = _parse_opts7[3],\n      choices = _parse_opts7[4],\n      required = _parse_opts7[5],\n      help = _parse_opts7[6],\n      metavar = _parse_opts7[7];\n    var _option_strings = [];\n    for (var option_string of option_strings) {\n      _option_strings.push(option_string);\n      if (option_string.startsWith('--')) {\n        option_string = '--no-' + option_string.slice(2);\n        _option_strings.push(option_string);\n      }\n    }\n    if (help !== undefined && default_value !== undefined) {\n      help += ` (default: ${default_value})`;\n    }\n    return _super9.call(this, {\n      option_strings: _option_strings,\n      dest: dest,\n      nargs: 0,\n      default: default_value,\n      type: type,\n      choices: choices,\n      required: required,\n      help: help,\n      metavar: metavar\n    });\n  }\n  _createClass(BooleanOptionalAction, [{\n    key: \"call\",\n    value: function call(parser, namespace, values) {\n      var option_string = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n      if (this.option_strings.includes(option_string)) {\n        setattr(namespace, this.dest, !option_string.startsWith('--no-'));\n      }\n    }\n  }, {\n    key: \"format_usage\",\n    value: function format_usage() {\n      return this.option_strings.join(' | ');\n    }\n  }]);\n  return BooleanOptionalAction;\n}(Action)));\nvar _StoreAction = _callable(function (_Action2) {\n  _inherits(_StoreAction, _Action2);\n  var _super10 = _createSuper(_StoreAction);\n  function _StoreAction() {\n    _classCallCheck(this, _StoreAction);\n    var _parse_opts8 = _parse_opts(arguments, {\n        option_strings: no_default,\n        dest: no_default,\n        nargs: undefined,\n        const: undefined,\n        default: undefined,\n        type: undefined,\n        choices: undefined,\n        required: false,\n        help: undefined,\n        metavar: undefined\n      }),\n      _parse_opts9 = _slicedToArray(_parse_opts8, 10),\n      option_strings = _parse_opts9[0],\n      dest = _parse_opts9[1],\n      nargs = _parse_opts9[2],\n      const_value = _parse_opts9[3],\n      default_value = _parse_opts9[4],\n      type = _parse_opts9[5],\n      choices = _parse_opts9[6],\n      required = _parse_opts9[7],\n      help = _parse_opts9[8],\n      metavar = _parse_opts9[9];\n    if (nargs === 0) {\n      throw new TypeError('nargs for store actions must be != 0; if you ' + 'have nothing to store, actions such as store ' + 'true or store const may be more appropriate');\n    }\n    if (const_value !== undefined && nargs !== OPTIONAL) {\n      throw new TypeError(sub('nargs must be %r to supply const', OPTIONAL));\n    }\n    return _super10.call(this, {\n      option_strings: option_strings,\n      dest: dest,\n      nargs: nargs,\n      const: const_value,\n      default: default_value,\n      type: type,\n      choices: choices,\n      required: required,\n      help: help,\n      metavar: metavar\n    });\n  }\n  _createClass(_StoreAction, [{\n    key: \"call\",\n    value: function call(parser, namespace, values) {\n      setattr(namespace, this.dest, values);\n    }\n  }]);\n  return _StoreAction;\n}(Action));\nvar _StoreConstAction = _callable(function (_Action3) {\n  _inherits(_StoreConstAction, _Action3);\n  var _super11 = _createSuper(_StoreConstAction);\n  function _StoreConstAction() {\n    _classCallCheck(this, _StoreConstAction);\n    var _parse_opts10 = _parse_opts(arguments, {\n        option_strings: no_default,\n        dest: no_default,\n        const: no_default,\n        default: undefined,\n        required: false,\n        help: undefined,\n        metavar: undefined\n      }),\n      _parse_opts11 = _slicedToArray(_parse_opts10, 6),\n      option_strings = _parse_opts11[0],\n      dest = _parse_opts11[1],\n      const_value = _parse_opts11[2],\n      default_value = _parse_opts11[3],\n      required = _parse_opts11[4],\n      help = _parse_opts11[5];\n    return _super11.call(this, {\n      option_strings: option_strings,\n      dest: dest,\n      nargs: 0,\n      const: const_value,\n      default: default_value,\n      required: required,\n      help: help\n    });\n  }\n  _createClass(_StoreConstAction, [{\n    key: \"call\",\n    value: function call(parser, namespace) {\n      setattr(namespace, this.dest, this.const);\n    }\n  }]);\n  return _StoreConstAction;\n}(Action));\nvar _StoreTrueAction = _callable(function (_StoreConstAction2) {\n  _inherits(_StoreTrueAction, _StoreConstAction2);\n  var _super12 = _createSuper(_StoreTrueAction);\n  function _StoreTrueAction() {\n    _classCallCheck(this, _StoreTrueAction);\n    var _parse_opts12 = _parse_opts(arguments, {\n        option_strings: no_default,\n        dest: no_default,\n        default: false,\n        required: false,\n        help: undefined\n      }),\n      _parse_opts13 = _slicedToArray(_parse_opts12, 5),\n      option_strings = _parse_opts13[0],\n      dest = _parse_opts13[1],\n      default_value = _parse_opts13[2],\n      required = _parse_opts13[3],\n      help = _parse_opts13[4];\n    return _super12.call(this, {\n      option_strings: option_strings,\n      dest: dest,\n      const: true,\n      default: default_value,\n      required: required,\n      help: help\n    });\n  }\n  return _createClass(_StoreTrueAction);\n}(_StoreConstAction));\nvar _StoreFalseAction = _callable(function (_StoreConstAction3) {\n  _inherits(_StoreFalseAction, _StoreConstAction3);\n  var _super13 = _createSuper(_StoreFalseAction);\n  function _StoreFalseAction() {\n    _classCallCheck(this, _StoreFalseAction);\n    var _parse_opts14 = _parse_opts(arguments, {\n        option_strings: no_default,\n        dest: no_default,\n        default: true,\n        required: false,\n        help: undefined\n      }),\n      _parse_opts15 = _slicedToArray(_parse_opts14, 5),\n      option_strings = _parse_opts15[0],\n      dest = _parse_opts15[1],\n      default_value = _parse_opts15[2],\n      required = _parse_opts15[3],\n      help = _parse_opts15[4];\n    return _super13.call(this, {\n      option_strings: option_strings,\n      dest: dest,\n      const: false,\n      default: default_value,\n      required: required,\n      help: help\n    });\n  }\n  return _createClass(_StoreFalseAction);\n}(_StoreConstAction));\nvar _AppendAction = _callable(function (_Action4) {\n  _inherits(_AppendAction, _Action4);\n  var _super14 = _createSuper(_AppendAction);\n  function _AppendAction() {\n    _classCallCheck(this, _AppendAction);\n    var _parse_opts16 = _parse_opts(arguments, {\n        option_strings: no_default,\n        dest: no_default,\n        nargs: undefined,\n        const: undefined,\n        default: undefined,\n        type: undefined,\n        choices: undefined,\n        required: false,\n        help: undefined,\n        metavar: undefined\n      }),\n      _parse_opts17 = _slicedToArray(_parse_opts16, 10),\n      option_strings = _parse_opts17[0],\n      dest = _parse_opts17[1],\n      nargs = _parse_opts17[2],\n      const_value = _parse_opts17[3],\n      default_value = _parse_opts17[4],\n      type = _parse_opts17[5],\n      choices = _parse_opts17[6],\n      required = _parse_opts17[7],\n      help = _parse_opts17[8],\n      metavar = _parse_opts17[9];\n    if (nargs === 0) {\n      throw new TypeError('nargs for append actions must be != 0; if arg ' + 'strings are not supplying the value to append, ' + 'the append const action may be more appropriate');\n    }\n    if (const_value !== undefined && nargs !== OPTIONAL) {\n      throw new TypeError(sub('nargs must be %r to supply const', OPTIONAL));\n    }\n    return _super14.call(this, {\n      option_strings: option_strings,\n      dest: dest,\n      nargs: nargs,\n      const: const_value,\n      default: default_value,\n      type: type,\n      choices: choices,\n      required: required,\n      help: help,\n      metavar: metavar\n    });\n  }\n  _createClass(_AppendAction, [{\n    key: \"call\",\n    value: function call(parser, namespace, values) {\n      var items = getattr(namespace, this.dest, undefined);\n      items = _copy_items(items);\n      items.push(values);\n      setattr(namespace, this.dest, items);\n    }\n  }]);\n  return _AppendAction;\n}(Action));\nvar _AppendConstAction = _callable(function (_Action5) {\n  _inherits(_AppendConstAction, _Action5);\n  var _super15 = _createSuper(_AppendConstAction);\n  function _AppendConstAction() {\n    _classCallCheck(this, _AppendConstAction);\n    var _parse_opts18 = _parse_opts(arguments, {\n        option_strings: no_default,\n        dest: no_default,\n        const: no_default,\n        default: undefined,\n        required: false,\n        help: undefined,\n        metavar: undefined\n      }),\n      _parse_opts19 = _slicedToArray(_parse_opts18, 7),\n      option_strings = _parse_opts19[0],\n      dest = _parse_opts19[1],\n      const_value = _parse_opts19[2],\n      default_value = _parse_opts19[3],\n      required = _parse_opts19[4],\n      help = _parse_opts19[5],\n      metavar = _parse_opts19[6];\n    return _super15.call(this, {\n      option_strings: option_strings,\n      dest: dest,\n      nargs: 0,\n      const: const_value,\n      default: default_value,\n      required: required,\n      help: help,\n      metavar: metavar\n    });\n  }\n  _createClass(_AppendConstAction, [{\n    key: \"call\",\n    value: function call(parser, namespace) {\n      var items = getattr(namespace, this.dest, undefined);\n      items = _copy_items(items);\n      items.push(this.const);\n      setattr(namespace, this.dest, items);\n    }\n  }]);\n  return _AppendConstAction;\n}(Action));\nvar _CountAction = _callable(function (_Action6) {\n  _inherits(_CountAction, _Action6);\n  var _super16 = _createSuper(_CountAction);\n  function _CountAction() {\n    _classCallCheck(this, _CountAction);\n    var _parse_opts20 = _parse_opts(arguments, {\n        option_strings: no_default,\n        dest: no_default,\n        default: undefined,\n        required: false,\n        help: undefined\n      }),\n      _parse_opts21 = _slicedToArray(_parse_opts20, 5),\n      option_strings = _parse_opts21[0],\n      dest = _parse_opts21[1],\n      default_value = _parse_opts21[2],\n      required = _parse_opts21[3],\n      help = _parse_opts21[4];\n    return _super16.call(this, {\n      option_strings: option_strings,\n      dest: dest,\n      nargs: 0,\n      default: default_value,\n      required: required,\n      help: help\n    });\n  }\n  _createClass(_CountAction, [{\n    key: \"call\",\n    value: function call(parser, namespace) {\n      var count = getattr(namespace, this.dest, undefined);\n      if (count === undefined) {\n        count = 0;\n      }\n      setattr(namespace, this.dest, count + 1);\n    }\n  }]);\n  return _CountAction;\n}(Action));\nvar _HelpAction = _callable(function (_Action7) {\n  _inherits(_HelpAction, _Action7);\n  var _super17 = _createSuper(_HelpAction);\n  function _HelpAction() {\n    _classCallCheck(this, _HelpAction);\n    var _parse_opts22 = _parse_opts(arguments, {\n        option_strings: no_default,\n        dest: SUPPRESS,\n        default: SUPPRESS,\n        help: undefined\n      }),\n      _parse_opts23 = _slicedToArray(_parse_opts22, 4),\n      option_strings = _parse_opts23[0],\n      dest = _parse_opts23[1],\n      default_value = _parse_opts23[2],\n      help = _parse_opts23[3];\n    return _super17.call(this, {\n      option_strings: option_strings,\n      dest: dest,\n      default: default_value,\n      nargs: 0,\n      help: help\n    });\n  }\n  _createClass(_HelpAction, [{\n    key: \"call\",\n    value: function call(parser) {\n      parser.print_help();\n      parser.exit();\n    }\n  }]);\n  return _HelpAction;\n}(Action));\nvar _VersionAction = _callable(function (_Action8) {\n  _inherits(_VersionAction, _Action8);\n  var _super18 = _createSuper(_VersionAction);\n  function _VersionAction() {\n    var _this5;\n    _classCallCheck(this, _VersionAction);\n    var _parse_opts24 = _parse_opts(arguments, {\n        option_strings: no_default,\n        version: undefined,\n        dest: SUPPRESS,\n        default: SUPPRESS,\n        help: \"show program's version number and exit\"\n      }),\n      _parse_opts25 = _slicedToArray(_parse_opts24, 5),\n      option_strings = _parse_opts25[0],\n      version = _parse_opts25[1],\n      dest = _parse_opts25[2],\n      default_value = _parse_opts25[3],\n      help = _parse_opts25[4];\n    _this5 = _super18.call(this, {\n      option_strings: option_strings,\n      dest: dest,\n      default: default_value,\n      nargs: 0,\n      help: help\n    });\n    _this5.version = version;\n    return _this5;\n  }\n  _createClass(_VersionAction, [{\n    key: \"call\",\n    value: function call(parser) {\n      var version = this.version;\n      if (version === undefined) {\n        version = parser.version;\n      }\n      var formatter = parser._get_formatter();\n      formatter.add_text(version);\n      parser._print_message(formatter.format_help(), process.stdout);\n      parser.exit();\n    }\n  }]);\n  return _VersionAction;\n}(Action));\nvar _SubParsersAction = _camelcase_alias(_callable(function (_Action9) {\n  _inherits(_SubParsersAction, _Action9);\n  var _super19 = _createSuper(_SubParsersAction);\n  function _SubParsersAction() {\n    var _this6;\n    _classCallCheck(this, _SubParsersAction);\n    var _parse_opts26 = _parse_opts(arguments, {\n        option_strings: no_default,\n        prog: no_default,\n        parser_class: no_default,\n        dest: SUPPRESS,\n        required: false,\n        help: undefined,\n        metavar: undefined\n      }),\n      _parse_opts27 = _slicedToArray(_parse_opts26, 7),\n      option_strings = _parse_opts27[0],\n      prog = _parse_opts27[1],\n      parser_class = _parse_opts27[2],\n      dest = _parse_opts27[3],\n      required = _parse_opts27[4],\n      help = _parse_opts27[5],\n      metavar = _parse_opts27[6];\n    var name_parser_map = {};\n    _this6 = _super19.call(this, {\n      option_strings: option_strings,\n      dest: dest,\n      nargs: PARSER,\n      choices: name_parser_map,\n      required: required,\n      help: help,\n      metavar: metavar\n    });\n    _this6._prog_prefix = prog;\n    _this6._parser_class = parser_class;\n    _this6._name_parser_map = name_parser_map;\n    _this6._choices_actions = [];\n    return _this6;\n  }\n  _createClass(_SubParsersAction, [{\n    key: \"add_parser\",\n    value: function add_parser() {\n      var _parse_opts28 = _parse_opts(arguments, {\n          name: no_default,\n          '**kwargs': no_default\n        }),\n        _parse_opts29 = _slicedToArray(_parse_opts28, 2),\n        name = _parse_opts29[0],\n        kwargs = _parse_opts29[1];\n      if (kwargs.prog === undefined) {\n        kwargs.prog = sub('%s %s', this._prog_prefix, name);\n      }\n      var aliases = getattr(kwargs, 'aliases', []);\n      delete kwargs.aliases;\n      if ('help' in kwargs) {\n        var help = kwargs.help;\n        delete kwargs.help;\n        var choice_action = this._ChoicesPseudoAction(name, aliases, help);\n        this._choices_actions.push(choice_action);\n      }\n      var parser = new this._parser_class(kwargs);\n      this._name_parser_map[name] = parser;\n      for (var alias of aliases) {\n        this._name_parser_map[alias] = parser;\n      }\n      return parser;\n    }\n  }, {\n    key: \"_get_subactions\",\n    value: function _get_subactions() {\n      return this._choices_actions;\n    }\n  }, {\n    key: \"call\",\n    value: function call(parser, namespace, values) {\n      var parser_name = values[0];\n      var arg_strings = values.slice(1);\n      if (this.dest !== SUPPRESS) {\n        setattr(namespace, this.dest, parser_name);\n      }\n      if (hasattr(this._name_parser_map, parser_name)) {\n        parser = this._name_parser_map[parser_name];\n      } else {\n        var args = {\n          parser_name: parser_name,\n          choices: this._name_parser_map.join(', ')\n        };\n        var msg = sub('unknown parser %(parser_name)r (choices: %(choices)s)', args);\n        throw new ArgumentError(this, msg);\n      }\n      var subnamespace;\n      var _parser$parse_known_a = parser.parse_known_args(arg_strings, undefined);\n      var _parser$parse_known_a2 = _slicedToArray(_parser$parse_known_a, 2);\n      subnamespace = _parser$parse_known_a2[0];\n      arg_strings = _parser$parse_known_a2[1];\n      for (var _ref18 of Object.entries(subnamespace)) {\n        var _ref19 = _slicedToArray(_ref18, 2);\n        var key = _ref19[0];\n        var value = _ref19[1];\n        setattr(namespace, key, value);\n      }\n      if (arg_strings.length) {\n        var _getattr;\n        setdefault(namespace, _UNRECOGNIZED_ARGS_ATTR, []);\n        (_getattr = getattr(namespace, _UNRECOGNIZED_ARGS_ATTR)).push.apply(_getattr, _toConsumableArray(arg_strings));\n      }\n    }\n  }]);\n  return _SubParsersAction;\n}(Action)));\n_SubParsersAction.prototype._ChoicesPseudoAction = _callable(function (_Action10) {\n  _inherits(_ChoicesPseudoAction, _Action10);\n  var _super20 = _createSuper(_ChoicesPseudoAction);\n  function _ChoicesPseudoAction(name, aliases, help) {\n    _classCallCheck(this, _ChoicesPseudoAction);\n    var metavar = name,\n      dest = name;\n    if (aliases.length) {\n      metavar += sub(' (%s)', aliases.join(', '));\n    }\n    return _super20.call(this, {\n      option_strings: [],\n      dest: dest,\n      help: help,\n      metavar: metavar\n    });\n  }\n  return _createClass(_ChoicesPseudoAction);\n}(Action));\nvar _ExtendAction = _callable(function (_AppendAction2) {\n  _inherits(_ExtendAction, _AppendAction2);\n  var _super21 = _createSuper(_ExtendAction);\n  function _ExtendAction() {\n    _classCallCheck(this, _ExtendAction);\n    return _super21.apply(this, arguments);\n  }\n  _createClass(_ExtendAction, [{\n    key: \"call\",\n    value: function call(parser, namespace, values) {\n      var items = getattr(namespace, this.dest, undefined);\n      items = _copy_items(items);\n      items = items.concat(values);\n      setattr(namespace, this.dest, items);\n    }\n  }]);\n  return _ExtendAction;\n}(_AppendAction));\nvar FileType = _callable(function (_Function, _util$inspect$custom2) {\n  _inherits(FileType, _Function);\n  var _super22 = _createSuper(FileType);\n  function FileType() {\n    var _this7;\n    _classCallCheck(this, FileType);\n    var _parse_opts30 = _parse_opts(arguments, {\n        flags: 'r',\n        encoding: undefined,\n        mode: undefined,\n        autoClose: undefined,\n        emitClose: undefined,\n        start: undefined,\n        end: undefined,\n        highWaterMark: undefined,\n        fs: undefined\n      }),\n      _parse_opts31 = _slicedToArray(_parse_opts30, 9),\n      flags = _parse_opts31[0],\n      encoding = _parse_opts31[1],\n      mode = _parse_opts31[2],\n      autoClose = _parse_opts31[3],\n      emitClose = _parse_opts31[4],\n      start = _parse_opts31[5],\n      end = _parse_opts31[6],\n      highWaterMark = _parse_opts31[7],\n      fs = _parse_opts31[8];\n    _this7 = _super22.call(this, 'return arguments.callee.call.apply(arguments.callee, arguments)');\n    Object.defineProperty(_assertThisInitialized(_this7), 'name', {\n      get: function get() {\n        return sub('FileType(%r)', flags);\n      }\n    });\n    _this7._flags = flags;\n    _this7._options = {};\n    if (encoding !== undefined) _this7._options.encoding = encoding;\n    if (mode !== undefined) _this7._options.mode = mode;\n    if (autoClose !== undefined) _this7._options.autoClose = autoClose;\n    if (emitClose !== undefined) _this7._options.emitClose = emitClose;\n    if (start !== undefined) _this7._options.start = start;\n    if (end !== undefined) _this7._options.end = end;\n    if (highWaterMark !== undefined) _this7._options.highWaterMark = highWaterMark;\n    if (fs !== undefined) _this7._options.fs = fs;\n    return _this7;\n  }\n  _createClass(FileType, [{\n    key: \"call\",\n    value: function call(string) {\n      if (string === '-') {\n        if (this._flags.includes('r')) {\n          return process.stdin;\n        } else if (this._flags.includes('w')) {\n          return process.stdout;\n        } else {\n          var msg = sub('argument \"-\" with mode %r', this._flags);\n          throw new TypeError(msg);\n        }\n      }\n      var fd;\n      try {\n        fd = fs.openSync(string, this._flags, this._options.mode);\n      } catch (e) {\n        var args = {\n          filename: string,\n          error: e.message\n        };\n        var message = \"can't open '%(filename)s': %(error)s\";\n        throw new ArgumentTypeError(sub(message, args));\n      }\n      var options = Object.assign({\n        fd: fd,\n        flags: this._flags\n      }, this._options);\n      if (this._flags.includes('r')) {\n        return fs.createReadStream(undefined, options);\n      } else if (this._flags.includes('w')) {\n        return fs.createWriteStream(undefined, options);\n      } else {\n        var _msg = sub('argument \"%s\" with mode %r', string, this._flags);\n        throw new TypeError(_msg);\n      }\n    }\n  }, {\n    key: _util$inspect$custom2,\n    value: function value() {\n      var args = [this._flags];\n      var kwargs = Object.entries(this._options).map(function (_ref20) {\n        var _ref21 = _slicedToArray(_ref20, 2),\n          k = _ref21[0],\n          v = _ref21[1];\n        if (k === 'mode') v = _defineProperty({\n          value: v\n        }, util.inspect.custom, function () {\n          return '0o' + this.value.toString(8);\n        });\n        return [k, v];\n      });\n      var args_str = [].concat(args.filter(function (arg) {\n        return arg !== -1;\n      }).map(repr)).concat(kwargs.filter(function (_ref22) {\n        var _ref23 = _slicedToArray(_ref22, 2),\n          arg = _ref23[1];\n        return arg !== undefined;\n      }).map(function (_ref24) {\n        var _ref25 = _slicedToArray(_ref24, 2),\n          kw = _ref25[0],\n          arg = _ref25[1];\n        return sub('%s=%r', kw, arg);\n      })).join(', ');\n      return sub('%s(%s)', this.constructor.name, args_str);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this[util.inspect.custom]();\n    }\n  }]);\n  return FileType;\n}(_wrapNativeSuper(Function), util.inspect.custom));\nvar Namespace = _callable(function (_AttributeHolder3) {\n  _inherits(Namespace, _AttributeHolder3);\n  var _super23 = _createSuper(Namespace);\n  function Namespace() {\n    var _this8;\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, Namespace);\n    _this8 = _super23.call(this);\n    Object.assign(_assertThisInitialized(_this8), options);\n    return _this8;\n  }\n  return _createClass(Namespace);\n}(_AttributeHolder()));\nNamespace.prototype[Symbol.toStringTag] = undefined;\nvar _ActionsContainer = _camelcase_alias(_callable(function () {\n  function _ActionsContainer() {\n    var _this9 = this;\n    _classCallCheck(this, _ActionsContainer);\n    var _parse_opts32 = _parse_opts(arguments, {\n        description: no_default,\n        prefix_chars: no_default,\n        argument_default: no_default,\n        conflict_handler: no_default\n      }),\n      _parse_opts33 = _slicedToArray(_parse_opts32, 4),\n      description = _parse_opts33[0],\n      prefix_chars = _parse_opts33[1],\n      argument_default = _parse_opts33[2],\n      conflict_handler = _parse_opts33[3];\n    this.description = description;\n    this.argument_default = argument_default;\n    this.prefix_chars = prefix_chars;\n    this.conflict_handler = conflict_handler;\n    this._registries = {};\n    this.register('action', undefined, _StoreAction);\n    this.register('action', 'store', _StoreAction);\n    this.register('action', 'store_const', _StoreConstAction);\n    this.register('action', 'store_true', _StoreTrueAction);\n    this.register('action', 'store_false', _StoreFalseAction);\n    this.register('action', 'append', _AppendAction);\n    this.register('action', 'append_const', _AppendConstAction);\n    this.register('action', 'count', _CountAction);\n    this.register('action', 'help', _HelpAction);\n    this.register('action', 'version', _VersionAction);\n    this.register('action', 'parsers', _SubParsersAction);\n    this.register('action', 'extend', _ExtendAction);\n    ['storeConst', 'storeTrue', 'storeFalse', 'appendConst'].forEach(function (old_name) {\n      var new_name = _to_new_name(old_name);\n      _this9.register('action', old_name, util.deprecate(_this9._registry_get('action', new_name), sub('{action: \"%s\"} is renamed to {action: \"%s\"}', old_name, new_name)));\n    });\n    this._get_handler();\n    this._actions = [];\n    this._option_string_actions = {};\n    this._action_groups = [];\n    this._mutually_exclusive_groups = [];\n    this._defaults = {};\n    this._negative_number_matcher = /^-\\d+$|^-\\d*\\.\\d+$/;\n    this._has_negative_number_optionals = [];\n  }\n  _createClass(_ActionsContainer, [{\n    key: \"register\",\n    value: function register(registry_name, value, object) {\n      var registry = setdefault(this._registries, registry_name, {});\n      registry[value] = object;\n    }\n  }, {\n    key: \"_registry_get\",\n    value: function _registry_get(registry_name, value) {\n      var default_value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      return getattr(this._registries[registry_name], value, default_value);\n    }\n  }, {\n    key: \"set_defaults\",\n    value: function set_defaults(kwargs) {\n      Object.assign(this._defaults, kwargs);\n      for (var action of this._actions) {\n        if (action.dest in kwargs) {\n          action.default = kwargs[action.dest];\n        }\n      }\n    }\n  }, {\n    key: \"get_default\",\n    value: function get_default(dest) {\n      for (var action of this._actions) {\n        if (action.dest === dest && action.default !== undefined) {\n          return action.default;\n        }\n      }\n      return this._defaults[dest];\n    }\n  }, {\n    key: \"add_argument\",\n    value: function add_argument() {\n      var _parse_opts34 = _parse_opts(arguments, {\n          '*args': no_default,\n          '**kwargs': no_default\n        }),\n        _parse_opts35 = _slicedToArray(_parse_opts34, 2),\n        args = _parse_opts35[0],\n        kwargs = _parse_opts35[1];\n      if (args.length === 1 && Array.isArray(args[0])) {\n        args = args[0];\n        deprecate('argument-array', sub('use add_argument(%(args)s, {...}) instead of add_argument([ %(args)s ], { ... })', {\n          args: args.map(repr).join(', ')\n        }));\n      }\n      var chars = this.prefix_chars;\n      if (!args.length || args.length === 1 && !chars.includes(args[0][0])) {\n        if (args.length && 'dest' in kwargs) {\n          throw new TypeError('dest supplied twice for positional argument');\n        }\n        kwargs = this._get_positional_kwargs.apply(this, _toConsumableArray(args).concat([kwargs]));\n      } else {\n        kwargs = this._get_optional_kwargs.apply(this, _toConsumableArray(args).concat([kwargs]));\n      }\n      if (!('default' in kwargs)) {\n        var dest = kwargs.dest;\n        if (dest in this._defaults) {\n          kwargs.default = this._defaults[dest];\n        } else if (this.argument_default !== undefined) {\n          kwargs.default = this.argument_default;\n        }\n      }\n      var action_class = this._pop_action_class(kwargs);\n      if (typeof action_class !== 'function') {\n        throw new TypeError(sub('unknown action \"%s\"', action_class));\n      }\n      var action = new action_class(kwargs);\n      var type_func = this._registry_get('type', action.type, action.type);\n      if (typeof type_func !== 'function') {\n        throw new TypeError(sub('%r is not callable', type_func));\n      }\n      if (type_func === FileType) {\n        throw new TypeError(sub('%r is a FileType class object, instance of it' + ' must be passed', type_func));\n      }\n      if ('_get_formatter' in this) {\n        try {\n          this._get_formatter()._format_args(action, undefined);\n        } catch (err) {\n          if (err instanceof TypeError && err.message !== 'invalid nargs value') {\n            throw new TypeError('length of metavar tuple does not match nargs');\n          } else {\n            throw err;\n          }\n        }\n      }\n      return this._add_action(action);\n    }\n  }, {\n    key: \"add_argument_group\",\n    value: function add_argument_group() {\n      var group = _ArgumentGroup.apply(void 0, [this].concat(Array.prototype.slice.call(arguments)));\n      this._action_groups.push(group);\n      return group;\n    }\n  }, {\n    key: \"add_mutually_exclusive_group\",\n    value: function add_mutually_exclusive_group() {\n      var group = _MutuallyExclusiveGroup.apply(void 0, [this].concat(Array.prototype.slice.call(arguments)));\n      this._mutually_exclusive_groups.push(group);\n      return group;\n    }\n  }, {\n    key: \"_add_action\",\n    value: function _add_action(action) {\n      this._check_conflict(action);\n      this._actions.push(action);\n      action.container = this;\n      for (var option_string of action.option_strings) {\n        this._option_string_actions[option_string] = action;\n      }\n      for (var _option_string of action.option_strings) {\n        if (this._negative_number_matcher.test(_option_string)) {\n          if (!this._has_negative_number_optionals.length) {\n            this._has_negative_number_optionals.push(true);\n          }\n        }\n      }\n      return action;\n    }\n  }, {\n    key: \"_remove_action\",\n    value: function _remove_action(action) {\n      _array_remove(this._actions, action);\n    }\n  }, {\n    key: \"_add_container_actions\",\n    value: function _add_container_actions(container) {\n      var title_group_map = {};\n      for (var group of this._action_groups) {\n        if (group.title in title_group_map) {\n          var msg = 'cannot merge actions - two groups are named %r';\n          throw new TypeError(sub(msg, group.title));\n        }\n        title_group_map[group.title] = group;\n      }\n      var group_map = new Map();\n      for (var _group of container._action_groups) {\n        if (!(_group.title in title_group_map)) {\n          title_group_map[_group.title] = this.add_argument_group({\n            title: _group.title,\n            description: _group.description,\n            conflict_handler: _group.conflict_handler\n          });\n        }\n        for (var action of _group._group_actions) {\n          group_map.set(action, title_group_map[_group.title]);\n        }\n      }\n      for (var _group2 of container._mutually_exclusive_groups) {\n        var mutex_group = this.add_mutually_exclusive_group({\n          required: _group2.required\n        });\n        for (var _action2 of _group2._group_actions) {\n          group_map.set(_action2, mutex_group);\n        }\n      }\n      for (var _action3 of container._actions) {\n        group_map.get(_action3)._add_action(_action3);\n      }\n    }\n  }, {\n    key: \"_get_positional_kwargs\",\n    value: function _get_positional_kwargs() {\n      var _parse_opts36 = _parse_opts(arguments, {\n          dest: no_default,\n          '**kwargs': no_default\n        }),\n        _parse_opts37 = _slicedToArray(_parse_opts36, 2),\n        dest = _parse_opts37[0],\n        kwargs = _parse_opts37[1];\n      if ('required' in kwargs) {\n        var msg = \"'required' is an invalid argument for positionals\";\n        throw new TypeError(msg);\n      }\n      if (![OPTIONAL, ZERO_OR_MORE].includes(kwargs.nargs)) {\n        kwargs.required = true;\n      }\n      if (kwargs.nargs === ZERO_OR_MORE && !('default' in kwargs)) {\n        kwargs.required = true;\n      }\n      return Object.assign(kwargs, {\n        dest: dest,\n        option_strings: []\n      });\n    }\n  }, {\n    key: \"_get_optional_kwargs\",\n    value: function _get_optional_kwargs() {\n      var _parse_opts38 = _parse_opts(arguments, {\n          '*args': no_default,\n          '**kwargs': no_default\n        }),\n        _parse_opts39 = _slicedToArray(_parse_opts38, 2),\n        args = _parse_opts39[0],\n        kwargs = _parse_opts39[1];\n      var option_strings = [];\n      var long_option_strings = [];\n      var option_string;\n      for (option_string of args) {\n        if (!this.prefix_chars.includes(option_string[0])) {\n          var _args = {\n            option: option_string,\n            prefix_chars: this.prefix_chars\n          };\n          var msg = 'invalid option string %(option)r: ' + 'must start with a character %(prefix_chars)r';\n          throw new TypeError(sub(msg, _args));\n        }\n        option_strings.push(option_string);\n        if (option_string.length > 1 && this.prefix_chars.includes(option_string[1])) {\n          long_option_strings.push(option_string);\n        }\n      }\n      var dest = kwargs.dest;\n      delete kwargs.dest;\n      if (dest === undefined) {\n        var dest_option_string;\n        if (long_option_strings.length) {\n          dest_option_string = long_option_strings[0];\n        } else {\n          dest_option_string = option_strings[0];\n        }\n        dest = _string_lstrip(dest_option_string, this.prefix_chars);\n        if (!dest) {\n          var _msg2 = 'dest= is required for options like %r';\n          throw new TypeError(sub(_msg2, option_string));\n        }\n        dest = dest.replace(/-/g, '_');\n      }\n      return Object.assign(kwargs, {\n        dest: dest,\n        option_strings: option_strings\n      });\n    }\n  }, {\n    key: \"_pop_action_class\",\n    value: function _pop_action_class(kwargs) {\n      var default_value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var action = getattr(kwargs, 'action', default_value);\n      delete kwargs.action;\n      return this._registry_get('action', action, action);\n    }\n  }, {\n    key: \"_get_handler\",\n    value: function _get_handler() {\n      var handler_func_name = sub('_handle_conflict_%s', this.conflict_handler);\n      if (typeof this[handler_func_name] === 'function') {\n        return this[handler_func_name];\n      } else {\n        var msg = 'invalid conflict_resolution value: %r';\n        throw new TypeError(sub(msg, this.conflict_handler));\n      }\n    }\n  }, {\n    key: \"_check_conflict\",\n    value: function _check_conflict(action) {\n      var confl_optionals = [];\n      for (var option_string of action.option_strings) {\n        if (hasattr(this._option_string_actions, option_string)) {\n          var confl_optional = this._option_string_actions[option_string];\n          confl_optionals.push([option_string, confl_optional]);\n        }\n      }\n      if (confl_optionals.length) {\n        var conflict_handler = this._get_handler();\n        conflict_handler.call(this, action, confl_optionals);\n      }\n    }\n  }, {\n    key: \"_handle_conflict_error\",\n    value: function _handle_conflict_error(action, conflicting_actions) {\n      var message = conflicting_actions.length === 1 ? 'conflicting option string: %s' : 'conflicting option strings: %s';\n      var conflict_string = conflicting_actions.map(function (_ref26) {\n        var _ref27 = _slicedToArray(_ref26, 1),\n          option_string = _ref27[0];\n        return option_string;\n      }).join(', ');\n      throw new ArgumentError(action, sub(message, conflict_string));\n    }\n  }, {\n    key: \"_handle_conflict_resolve\",\n    value: function _handle_conflict_resolve(action, conflicting_actions) {\n      for (var _ref28 of conflicting_actions) {\n        var _ref29 = _slicedToArray(_ref28, 2);\n        var option_string = _ref29[0];\n        var _action4 = _ref29[1];\n        _array_remove(_action4.option_strings, option_string);\n        delete this._option_string_actions[option_string];\n        if (!_action4.option_strings.length) {\n          _action4.container._remove_action(_action4);\n        }\n      }\n    }\n  }]);\n  return _ActionsContainer;\n}()));\nvar _ArgumentGroup = _callable(function (_ActionsContainer2) {\n  _inherits(_ArgumentGroup, _ActionsContainer2);\n  var _super24 = _createSuper(_ArgumentGroup);\n  function _ArgumentGroup() {\n    var _this10;\n    _classCallCheck(this, _ArgumentGroup);\n    var _parse_opts40 = _parse_opts(arguments, {\n        container: no_default,\n        title: undefined,\n        description: undefined,\n        '**kwargs': no_default\n      }),\n      _parse_opts41 = _slicedToArray(_parse_opts40, 4),\n      container = _parse_opts41[0],\n      title = _parse_opts41[1],\n      description = _parse_opts41[2],\n      kwargs = _parse_opts41[3];\n    setdefault(kwargs, 'conflict_handler', container.conflict_handler);\n    setdefault(kwargs, 'prefix_chars', container.prefix_chars);\n    setdefault(kwargs, 'argument_default', container.argument_default);\n    _this10 = _super24.call(this, Object.assign({\n      description: description\n    }, kwargs));\n    _this10.title = title;\n    _this10._group_actions = [];\n    _this10._registries = container._registries;\n    _this10._actions = container._actions;\n    _this10._option_string_actions = container._option_string_actions;\n    _this10._defaults = container._defaults;\n    _this10._has_negative_number_optionals = container._has_negative_number_optionals;\n    _this10._mutually_exclusive_groups = container._mutually_exclusive_groups;\n    return _this10;\n  }\n  _createClass(_ArgumentGroup, [{\n    key: \"_add_action\",\n    value: function _add_action(action) {\n      action = _get(_getPrototypeOf(_ArgumentGroup.prototype), \"_add_action\", this).call(this, action);\n      this._group_actions.push(action);\n      return action;\n    }\n  }, {\n    key: \"_remove_action\",\n    value: function _remove_action(action) {\n      _get(_getPrototypeOf(_ArgumentGroup.prototype), \"_remove_action\", this).call(this, action);\n      _array_remove(this._group_actions, action);\n    }\n  }]);\n  return _ArgumentGroup;\n}(_ActionsContainer));\nvar _MutuallyExclusiveGroup = _callable(function (_ArgumentGroup2) {\n  _inherits(_MutuallyExclusiveGroup, _ArgumentGroup2);\n  var _super25 = _createSuper(_MutuallyExclusiveGroup);\n  function _MutuallyExclusiveGroup() {\n    var _this11;\n    _classCallCheck(this, _MutuallyExclusiveGroup);\n    var _parse_opts42 = _parse_opts(arguments, {\n        container: no_default,\n        required: false\n      }),\n      _parse_opts43 = _slicedToArray(_parse_opts42, 2),\n      container = _parse_opts43[0],\n      required = _parse_opts43[1];\n    _this11 = _super25.call(this, container);\n    _this11.required = required;\n    _this11._container = container;\n    return _this11;\n  }\n  _createClass(_MutuallyExclusiveGroup, [{\n    key: \"_add_action\",\n    value: function _add_action(action) {\n      if (action.required) {\n        var msg = 'mutually exclusive arguments must be optional';\n        throw new TypeError(msg);\n      }\n      action = this._container._add_action(action);\n      this._group_actions.push(action);\n      return action;\n    }\n  }, {\n    key: \"_remove_action\",\n    value: function _remove_action(action) {\n      this._container._remove_action(action);\n      _array_remove(this._group_actions, action);\n    }\n  }]);\n  return _MutuallyExclusiveGroup;\n}(_ArgumentGroup));\nvar ArgumentParser = _camelcase_alias(_callable(function (_AttributeHolder4) {\n  _inherits(ArgumentParser, _AttributeHolder4);\n  var _super26 = _createSuper(ArgumentParser);\n  function ArgumentParser() {\n    var _this12;\n    _classCallCheck(this, ArgumentParser);\n    var _parse_opts44 = _parse_opts(arguments, {\n        prog: undefined,\n        usage: undefined,\n        description: undefined,\n        epilog: undefined,\n        parents: [],\n        formatter_class: HelpFormatter,\n        prefix_chars: '-',\n        fromfile_prefix_chars: undefined,\n        argument_default: undefined,\n        conflict_handler: 'error',\n        add_help: true,\n        allow_abbrev: true,\n        exit_on_error: true,\n        debug: undefined,\n        version: undefined\n      }),\n      _parse_opts45 = _slicedToArray(_parse_opts44, 15),\n      prog = _parse_opts45[0],\n      usage = _parse_opts45[1],\n      description = _parse_opts45[2],\n      epilog = _parse_opts45[3],\n      parents = _parse_opts45[4],\n      formatter_class = _parse_opts45[5],\n      prefix_chars = _parse_opts45[6],\n      fromfile_prefix_chars = _parse_opts45[7],\n      argument_default = _parse_opts45[8],\n      conflict_handler = _parse_opts45[9],\n      add_help = _parse_opts45[10],\n      allow_abbrev = _parse_opts45[11],\n      exit_on_error = _parse_opts45[12],\n      debug = _parse_opts45[13],\n      version = _parse_opts45[14];\n    if (debug !== undefined) {\n      deprecate('debug', 'The \"debug\" argument to ArgumentParser is deprecated. Please ' + 'override ArgumentParser.exit function instead.');\n    }\n    if (version !== undefined) {\n      deprecate('version', 'The \"version\" argument to ArgumentParser is deprecated. Please use ' + \"add_argument(..., { action: 'version', version: 'N', ... }) instead.\");\n    }\n    _this12 = _super26.call(this, {\n      description: description,\n      prefix_chars: prefix_chars,\n      argument_default: argument_default,\n      conflict_handler: conflict_handler\n    });\n    if (prog === undefined) {\n      prog = path.basename(get_argv()[0] || '');\n    }\n    _this12.prog = prog;\n    _this12.usage = usage;\n    _this12.epilog = epilog;\n    _this12.formatter_class = formatter_class;\n    _this12.fromfile_prefix_chars = fromfile_prefix_chars;\n    _this12.add_help = add_help;\n    _this12.allow_abbrev = allow_abbrev;\n    _this12.exit_on_error = exit_on_error;\n    _this12.debug = debug;\n    _this12._positionals = _this12.add_argument_group('positional arguments');\n    _this12._optionals = _this12.add_argument_group('optional arguments');\n    _this12._subparsers = undefined;\n    function identity(string) {\n      return string;\n    }\n    _this12.register('type', undefined, identity);\n    _this12.register('type', null, identity);\n    _this12.register('type', 'auto', identity);\n    _this12.register('type', 'int', function (x) {\n      var result = Number(x);\n      if (!Number.isInteger(result)) {\n        throw new TypeError(sub('could not convert string to int: %r', x));\n      }\n      return result;\n    });\n    _this12.register('type', 'float', function (x) {\n      var result = Number(x);\n      if (isNaN(result)) {\n        throw new TypeError(sub('could not convert string to float: %r', x));\n      }\n      return result;\n    });\n    _this12.register('type', 'str', String);\n    _this12.register('type', 'string', util.deprecate(String, 'use {type:\"str\"} or {type:String} instead of {type:\"string\"}'));\n    var default_prefix = prefix_chars.includes('-') ? '-' : prefix_chars[0];\n    if (_this12.add_help) {\n      _this12.add_argument(default_prefix + 'h', default_prefix.repeat(2) + 'help', {\n        action: 'help',\n        default: SUPPRESS,\n        help: 'show this help message and exit'\n      });\n    }\n    if (version) {\n      _this12.add_argument(default_prefix + 'v', default_prefix.repeat(2) + 'version', {\n        action: 'version',\n        default: SUPPRESS,\n        version: _this12.version,\n        help: \"show program's version number and exit\"\n      });\n    }\n    for (var parent of parents) {\n      _this12._add_container_actions(parent);\n      Object.assign(_this12._defaults, parent._defaults);\n    }\n    return _this12;\n  }\n  _createClass(ArgumentParser, [{\n    key: \"_get_kwargs\",\n    value: function _get_kwargs() {\n      var _this13 = this;\n      var names = ['prog', 'usage', 'description', 'formatter_class', 'conflict_handler', 'add_help'];\n      return names.map(function (name) {\n        return [name, getattr(_this13, name)];\n      });\n    }\n  }, {\n    key: \"add_subparsers\",\n    value: function add_subparsers() {\n      var _parse_opts46 = _parse_opts(arguments, {\n          '**kwargs': no_default\n        }),\n        _parse_opts47 = _slicedToArray(_parse_opts46, 1),\n        kwargs = _parse_opts47[0];\n      if (this._subparsers !== undefined) {\n        this.error('cannot have multiple subparser arguments');\n      }\n      setdefault(kwargs, 'parser_class', this.constructor);\n      if ('title' in kwargs || 'description' in kwargs) {\n        var title = getattr(kwargs, 'title', 'subcommands');\n        var description = getattr(kwargs, 'description', undefined);\n        delete kwargs.title;\n        delete kwargs.description;\n        this._subparsers = this.add_argument_group(title, description);\n      } else {\n        this._subparsers = this._positionals;\n      }\n      if (kwargs.prog === undefined) {\n        var formatter = this._get_formatter();\n        var positionals = this._get_positional_actions();\n        var groups = this._mutually_exclusive_groups;\n        formatter.add_usage(this.usage, positionals, groups, '');\n        kwargs.prog = formatter.format_help().trim();\n      }\n      var parsers_class = this._pop_action_class(kwargs, 'parsers');\n      var action = new parsers_class(Object.assign({\n        option_strings: []\n      }, kwargs));\n      this._subparsers._add_action(action);\n      return action;\n    }\n  }, {\n    key: \"_add_action\",\n    value: function _add_action(action) {\n      if (action.option_strings.length) {\n        this._optionals._add_action(action);\n      } else {\n        this._positionals._add_action(action);\n      }\n      return action;\n    }\n  }, {\n    key: \"_get_optional_actions\",\n    value: function _get_optional_actions() {\n      return this._actions.filter(function (action) {\n        return action.option_strings.length;\n      });\n    }\n  }, {\n    key: \"_get_positional_actions\",\n    value: function _get_positional_actions() {\n      return this._actions.filter(function (action) {\n        return !action.option_strings.length;\n      });\n    }\n  }, {\n    key: \"parse_args\",\n    value: function parse_args() {\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      var namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var argv;\n      var _this$parse_known_arg = this.parse_known_args(args, namespace);\n      var _this$parse_known_arg2 = _slicedToArray(_this$parse_known_arg, 2);\n      args = _this$parse_known_arg2[0];\n      argv = _this$parse_known_arg2[1];\n      if (argv && argv.length > 0) {\n        var msg = 'unrecognized arguments: %s';\n        this.error(sub(msg, argv.join(' ')));\n      }\n      return args;\n    }\n  }, {\n    key: \"parse_known_args\",\n    value: function parse_known_args() {\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      var namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      if (args === undefined) {\n        args = get_argv().slice(1);\n      }\n      if (namespace === undefined) {\n        namespace = new Namespace();\n      }\n      for (var action of this._actions) {\n        if (action.dest !== SUPPRESS) {\n          if (!hasattr(namespace, action.dest)) {\n            if (action.default !== SUPPRESS) {\n              setattr(namespace, action.dest, action.default);\n            }\n          }\n        }\n      }\n      for (var dest of Object.keys(this._defaults)) {\n        if (!hasattr(namespace, dest)) {\n          setattr(namespace, dest, this._defaults[dest]);\n        }\n      }\n      if (this.exit_on_error) {\n        try {\n          var _this$_parse_known_ar = this._parse_known_args(args, namespace);\n          var _this$_parse_known_ar2 = _slicedToArray(_this$_parse_known_ar, 2);\n          namespace = _this$_parse_known_ar2[0];\n          args = _this$_parse_known_ar2[1];\n        } catch (err) {\n          if (err instanceof ArgumentError) {\n            this.error(err.message);\n          } else {\n            throw err;\n          }\n        }\n      } else {\n        var _this$_parse_known_ar3 = this._parse_known_args(args, namespace);\n        var _this$_parse_known_ar4 = _slicedToArray(_this$_parse_known_ar3, 2);\n        namespace = _this$_parse_known_ar4[0];\n        args = _this$_parse_known_ar4[1];\n      }\n      if (hasattr(namespace, _UNRECOGNIZED_ARGS_ATTR)) {\n        args = args.concat(getattr(namespace, _UNRECOGNIZED_ARGS_ATTR));\n        delattr(namespace, _UNRECOGNIZED_ARGS_ATTR);\n      }\n      return [namespace, args];\n    }\n  }, {\n    key: \"_parse_known_args\",\n    value: function _parse_known_args(arg_strings, namespace) {\n      var _this14 = this;\n      if (this.fromfile_prefix_chars !== undefined) {\n        arg_strings = this._read_args_from_files(arg_strings);\n      }\n      var action_conflicts = new Map();\n      for (var mutex_group of this._mutually_exclusive_groups) {\n        var group_actions = mutex_group._group_actions;\n        for (var _ref30 of Object.entries(mutex_group._group_actions)) {\n          var _ref31 = _slicedToArray(_ref30, 2);\n          var i = _ref31[0];\n          var mutex_action = _ref31[1];\n          var conflicts = action_conflicts.get(mutex_action) || [];\n          conflicts = conflicts.concat(group_actions.slice(0, +i));\n          conflicts = conflicts.concat(group_actions.slice(+i + 1));\n          action_conflicts.set(mutex_action, conflicts);\n        }\n      }\n      var option_string_indices = {};\n      var arg_string_pattern_parts = [];\n      var arg_strings_iter = Object.entries(arg_strings)[Symbol.iterator]();\n      for (var _ref32 of arg_strings_iter) {\n        var _ref33 = _slicedToArray(_ref32, 2);\n        var _i4 = _ref33[0];\n        var arg_string = _ref33[1];\n        if (arg_string === '--') {\n          arg_string_pattern_parts.push('-');\n          for (var _ref34 of arg_strings_iter) {\n            var _ref35 = _ref34;\n            var _ref36 = _slicedToArray(_ref35, 2);\n            i = _ref36[0];\n            arg_string = _ref36[1];\n            arg_string_pattern_parts.push('A');\n          }\n        } else {\n          var option_tuple = this._parse_optional(arg_string);\n          var pattern = void 0;\n          if (option_tuple === undefined) {\n            pattern = 'A';\n          } else {\n            option_string_indices[_i4] = option_tuple;\n            pattern = 'O';\n          }\n          arg_string_pattern_parts.push(pattern);\n        }\n      }\n      var arg_strings_pattern = arg_string_pattern_parts.join('');\n      var seen_actions = new Set();\n      var seen_non_default_actions = new Set();\n      var extras;\n      var take_action = function take_action(action, argument_strings) {\n        var option_string = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n        seen_actions.add(action);\n        var argument_values = _this14._get_values(action, argument_strings);\n        if (argument_values !== action.default) {\n          seen_non_default_actions.add(action);\n          for (var conflict_action of action_conflicts.get(action) || []) {\n            if (seen_non_default_actions.has(conflict_action)) {\n              var msg = 'not allowed with argument %s';\n              var action_name = _get_action_name(conflict_action);\n              throw new ArgumentError(action, sub(msg, action_name));\n            }\n          }\n        }\n        if (argument_values !== SUPPRESS) {\n          action(_this14, namespace, argument_values, option_string);\n        }\n      };\n      var consume_optional = function consume_optional(start_index) {\n        var option_tuple = option_string_indices[start_index];\n        var _option_tuple = _slicedToArray(option_tuple, 3),\n          action = _option_tuple[0],\n          option_string = _option_tuple[1],\n          explicit_arg = _option_tuple[2];\n        var action_tuples = [];\n        var stop;\n        for (;;) {\n          if (action === undefined) {\n            extras.push(arg_strings[start_index]);\n            return start_index + 1;\n          }\n          if (explicit_arg !== undefined) {\n            var arg_count = _this14._match_argument(action, 'A');\n            var chars = _this14.prefix_chars;\n            if (arg_count === 0 && !chars.includes(option_string[1])) {\n              action_tuples.push([action, [], option_string]);\n              var char = option_string[0];\n              option_string = char + explicit_arg[0];\n              var new_explicit_arg = explicit_arg.slice(1) || undefined;\n              var optionals_map = _this14._option_string_actions;\n              if (hasattr(optionals_map, option_string)) {\n                action = optionals_map[option_string];\n                explicit_arg = new_explicit_arg;\n              } else {\n                var msg = 'ignored explicit argument %r';\n                throw new ArgumentError(action, sub(msg, explicit_arg));\n              }\n            } else if (arg_count === 1) {\n              stop = start_index + 1;\n              var args = [explicit_arg];\n              action_tuples.push([action, args, option_string]);\n              break;\n            } else {\n              var _msg3 = 'ignored explicit argument %r';\n              throw new ArgumentError(action, sub(_msg3, explicit_arg));\n            }\n          } else {\n            var start = start_index + 1;\n            var selected_patterns = arg_strings_pattern.slice(start);\n            var _arg_count = _this14._match_argument(action, selected_patterns);\n            stop = start + _arg_count;\n            var _args2 = arg_strings.slice(start, stop);\n            action_tuples.push([action, _args2, option_string]);\n            break;\n          }\n        }\n        assert(action_tuples.length);\n        for (var _ref37 of action_tuples) {\n          var _ref38 = _slicedToArray(_ref37, 3);\n          var _action5 = _ref38[0];\n          var _args3 = _ref38[1];\n          var _option_string2 = _ref38[2];\n          take_action(_action5, _args3, _option_string2);\n        }\n        return stop;\n      };\n      var positionals = this._get_positional_actions();\n      var consume_positionals = function consume_positionals(start_index) {\n        var selected_pattern = arg_strings_pattern.slice(start_index);\n        var arg_counts = _this14._match_arguments_partial(positionals, selected_pattern);\n        for (var _i5 = 0; _i5 < positionals.length && _i5 < arg_counts.length; _i5++) {\n          var action = positionals[_i5];\n          var arg_count = arg_counts[_i5];\n          var args = arg_strings.slice(start_index, start_index + arg_count);\n          start_index += arg_count;\n          take_action(action, args);\n        }\n        positionals = positionals.slice(arg_counts.length);\n        return start_index;\n      };\n      extras = [];\n      var start_index = 0;\n      var max_option_string_index = Math.max.apply(Math, [-1].concat(_toConsumableArray(Object.keys(option_string_indices).map(Number))));\n      while (start_index <= max_option_string_index) {\n        var next_option_string_index = Math.min.apply(Math, _toConsumableArray(Object.keys(option_string_indices).map(Number).filter(function (index) {\n          return index >= start_index;\n        })));\n        if (start_index !== next_option_string_index) {\n          var positionals_end_index = consume_positionals(start_index);\n          if (positionals_end_index > start_index) {\n            start_index = positionals_end_index;\n            continue;\n          } else {\n            start_index = positionals_end_index;\n          }\n        }\n        if (!(start_index in option_string_indices)) {\n          var strings = arg_strings.slice(start_index, next_option_string_index);\n          extras = extras.concat(strings);\n          start_index = next_option_string_index;\n        }\n        start_index = consume_optional(start_index);\n      }\n      var stop_index = consume_positionals(start_index);\n      extras = extras.concat(arg_strings.slice(stop_index));\n      var required_actions = [];\n      for (var action of this._actions) {\n        if (!seen_actions.has(action)) {\n          if (action.required) {\n            required_actions.push(_get_action_name(action));\n          } else {\n            if (action.default !== undefined && typeof action.default === 'string' && hasattr(namespace, action.dest) && action.default === getattr(namespace, action.dest)) {\n              setattr(namespace, action.dest, this._get_value(action, action.default));\n            }\n          }\n        }\n      }\n      if (required_actions.length) {\n        this.error(sub('the following arguments are required: %s', required_actions.join(', ')));\n      }\n      for (var group of this._mutually_exclusive_groups) {\n        if (group.required) {\n          var no_actions_used = true;\n          for (var _action6 of group._group_actions) {\n            if (seen_non_default_actions.has(_action6)) {\n              no_actions_used = false;\n              break;\n            }\n          }\n          if (no_actions_used) {\n            var names = group._group_actions.filter(function (action) {\n              return action.help !== SUPPRESS;\n            }).map(function (action) {\n              return _get_action_name(action);\n            });\n            var msg = 'one of the arguments %s is required';\n            this.error(sub(msg, names.join(' ')));\n          }\n        }\n      }\n      return [namespace, extras];\n    }\n  }, {\n    key: \"_read_args_from_files\",\n    value: function _read_args_from_files(arg_strings) {\n      var new_arg_strings = [];\n      for (var arg_string of arg_strings) {\n        if (!arg_string || !this.fromfile_prefix_chars.includes(arg_string[0])) {\n          new_arg_strings.push(arg_string);\n        } else {\n          try {\n            var args_file = fs.readFileSync(arg_string.slice(1), 'utf8');\n            var _arg_strings = [];\n            for (var arg_line of splitlines(args_file)) {\n              for (var arg of this.convert_arg_line_to_args(arg_line)) {\n                _arg_strings.push(arg);\n              }\n            }\n            _arg_strings = this._read_args_from_files(_arg_strings);\n            new_arg_strings = new_arg_strings.concat(_arg_strings);\n          } catch (err) {\n            this.error(err.message);\n          }\n        }\n      }\n      return new_arg_strings;\n    }\n  }, {\n    key: \"convert_arg_line_to_args\",\n    value: function convert_arg_line_to_args(arg_line) {\n      return [arg_line];\n    }\n  }, {\n    key: \"_match_argument\",\n    value: function _match_argument(action, arg_strings_pattern) {\n      var nargs_pattern = this._get_nargs_pattern(action);\n      var match = arg_strings_pattern.match(new RegExp('^' + nargs_pattern));\n      if (match === null) {\n        var _nargs_errors;\n        var nargs_errors = (_nargs_errors = {\n          undefined: 'expected one argument'\n        }, _defineProperty(_nargs_errors, OPTIONAL, 'expected at most one argument'), _defineProperty(_nargs_errors, ONE_OR_MORE, 'expected at least one argument'), _nargs_errors);\n        var msg = nargs_errors[action.nargs];\n        if (msg === undefined) {\n          msg = sub(action.nargs === 1 ? 'expected %s argument' : 'expected %s arguments', action.nargs);\n        }\n        throw new ArgumentError(action, msg);\n      }\n      return match[1].length;\n    }\n  }, {\n    key: \"_match_arguments_partial\",\n    value: function _match_arguments_partial(actions, arg_strings_pattern) {\n      var _this15 = this;\n      var result = [];\n      for (var i of range(actions.length, 0, -1)) {\n        var actions_slice = actions.slice(0, i);\n        var pattern = actions_slice.map(function (action) {\n          return _this15._get_nargs_pattern(action);\n        }).join('');\n        var match = arg_strings_pattern.match(new RegExp('^' + pattern));\n        if (match !== null) {\n          result = result.concat(match.slice(1).map(function (string) {\n            return string.length;\n          }));\n          break;\n        }\n      }\n      return result;\n    }\n  }, {\n    key: \"_parse_optional\",\n    value: function _parse_optional(arg_string) {\n      if (!arg_string) {\n        return undefined;\n      }\n      if (!this.prefix_chars.includes(arg_string[0])) {\n        return undefined;\n      }\n      if (arg_string in this._option_string_actions) {\n        var action = this._option_string_actions[arg_string];\n        return [action, arg_string, undefined];\n      }\n      if (arg_string.length === 1) {\n        return undefined;\n      }\n      if (arg_string.includes('=')) {\n        var _string_split2 = _string_split(arg_string, '=', 1),\n          _string_split3 = _slicedToArray(_string_split2, 2),\n          option_string = _string_split3[0],\n          explicit_arg = _string_split3[1];\n        if (option_string in this._option_string_actions) {\n          var _action7 = this._option_string_actions[option_string];\n          return [_action7, option_string, explicit_arg];\n        }\n      }\n      var option_tuples = this._get_option_tuples(arg_string);\n      if (option_tuples.length > 1) {\n        var options = option_tuples.map(function (_ref39) {\n          var _ref40 = _slicedToArray(_ref39, 2),\n            option_string = _ref40[1];\n          return option_string;\n        }).join(', ');\n        var args = {\n          option: arg_string,\n          matches: options\n        };\n        var msg = 'ambiguous option: %(option)s could match %(matches)s';\n        this.error(sub(msg, args));\n      } else if (option_tuples.length === 1) {\n        var _option_tuples = _slicedToArray(option_tuples, 1),\n          option_tuple = _option_tuples[0];\n        return option_tuple;\n      }\n      if (this._negative_number_matcher.test(arg_string)) {\n        if (!this._has_negative_number_optionals.length) {\n          return undefined;\n        }\n      }\n      if (arg_string.includes(' ')) {\n        return undefined;\n      }\n      return [undefined, arg_string, undefined];\n    }\n  }, {\n    key: \"_get_option_tuples\",\n    value: function _get_option_tuples(option_string) {\n      var result = [];\n      var chars = this.prefix_chars;\n      if (chars.includes(option_string[0]) && chars.includes(option_string[1])) {\n        if (this.allow_abbrev) {\n          var option_prefix, explicit_arg;\n          if (option_string.includes('=')) {\n            var _string_split4 = _string_split(option_string, '=', 1);\n            var _string_split5 = _slicedToArray(_string_split4, 2);\n            option_prefix = _string_split5[0];\n            explicit_arg = _string_split5[1];\n          } else {\n            option_prefix = option_string;\n            explicit_arg = undefined;\n          }\n          for (var _option_string3 of Object.keys(this._option_string_actions)) {\n            if (_option_string3.startsWith(option_prefix)) {\n              var action = this._option_string_actions[_option_string3];\n              var tup = [action, _option_string3, explicit_arg];\n              result.push(tup);\n            }\n          }\n        }\n      } else if (chars.includes(option_string[0]) && !chars.includes(option_string[1])) {\n        var _option_prefix = option_string;\n        var _explicit_arg = undefined;\n        var short_option_prefix = option_string.slice(0, 2);\n        var short_explicit_arg = option_string.slice(2);\n        for (var _option_string4 of Object.keys(this._option_string_actions)) {\n          if (_option_string4 === short_option_prefix) {\n            var _action8 = this._option_string_actions[_option_string4];\n            var _tup3 = [_action8, _option_string4, short_explicit_arg];\n            result.push(_tup3);\n          } else if (_option_string4.startsWith(_option_prefix)) {\n            var _action9 = this._option_string_actions[_option_string4];\n            var _tup4 = [_action9, _option_string4, _explicit_arg];\n            result.push(_tup4);\n          }\n        }\n      } else {\n        this.error(sub('unexpected option string: %s', option_string));\n      }\n      return result;\n    }\n  }, {\n    key: \"_get_nargs_pattern\",\n    value: function _get_nargs_pattern(action) {\n      var nargs = action.nargs;\n      var nargs_pattern;\n      if (nargs === undefined) {\n        nargs_pattern = '(-*A-*)';\n      } else if (nargs === OPTIONAL) {\n        nargs_pattern = '(-*A?-*)';\n      } else if (nargs === ZERO_OR_MORE) {\n        nargs_pattern = '(-*[A-]*)';\n      } else if (nargs === ONE_OR_MORE) {\n        nargs_pattern = '(-*A[A-]*)';\n      } else if (nargs === REMAINDER) {\n        nargs_pattern = '([-AO]*)';\n      } else if (nargs === PARSER) {\n        nargs_pattern = '(-*A[-AO]*)';\n      } else if (nargs === SUPPRESS) {\n        nargs_pattern = '(-*-*)';\n      } else {\n        nargs_pattern = sub('(-*%s-*)', 'A'.repeat(nargs).split('').join('-*'));\n      }\n      if (action.option_strings.length) {\n        nargs_pattern = nargs_pattern.replace(/-\\*/g, '');\n        nargs_pattern = nargs_pattern.replace(/-/g, '');\n      }\n      return nargs_pattern;\n    }\n  }, {\n    key: \"parse_intermixed_args\",\n    value: function parse_intermixed_args() {\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      var namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var argv;\n      var _this$parse_known_int = this.parse_known_intermixed_args(args, namespace);\n      var _this$parse_known_int2 = _slicedToArray(_this$parse_known_int, 2);\n      args = _this$parse_known_int2[0];\n      argv = _this$parse_known_int2[1];\n      if (argv.length) {\n        var msg = 'unrecognized arguments: %s';\n        this.error(sub(msg, argv.join(' ')));\n      }\n      return args;\n    }\n  }, {\n    key: \"parse_known_intermixed_args\",\n    value: function parse_known_intermixed_args() {\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      var namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var extras;\n      var positionals = this._get_positional_actions();\n      var a = positionals.filter(function (action) {\n        return [PARSER, REMAINDER].includes(action.nargs);\n      });\n      if (a.length) {\n        throw new TypeError(sub('parse_intermixed_args: positional arg' + ' with nargs=%s', a[0].nargs));\n      }\n      for (var group of this._mutually_exclusive_groups) {\n        for (var action of group._group_actions) {\n          if (positionals.includes(action)) {\n            throw new TypeError('parse_intermixed_args: positional in' + ' mutuallyExclusiveGroup');\n          }\n        }\n      }\n      var save_usage;\n      try {\n        save_usage = this.usage;\n        var remaining_args;\n        try {\n          if (this.usage === undefined) {\n            this.usage = this.format_usage().slice(7);\n          }\n          for (var _action10 of positionals) {\n            _action10.save_nargs = _action10.nargs;\n            _action10.nargs = SUPPRESS;\n            _action10.save_default = _action10.default;\n            _action10.default = SUPPRESS;\n          }\n          var _this$parse_known_arg3 = this.parse_known_args(args, namespace);\n          var _this$parse_known_arg4 = _slicedToArray(_this$parse_known_arg3, 2);\n          namespace = _this$parse_known_arg4[0];\n          remaining_args = _this$parse_known_arg4[1];\n          for (var _action11 of positionals) {\n            var attr = getattr(namespace, _action11.dest);\n            if (Array.isArray(attr) && attr.length === 0) {\n              console.warn(sub('Do not expect %s in %s', _action11.dest, namespace));\n              delattr(namespace, _action11.dest);\n            }\n          }\n        } finally {\n          for (var _action12 of positionals) {\n            _action12.nargs = _action12.save_nargs;\n            _action12.default = _action12.save_default;\n          }\n        }\n        var optionals = this._get_optional_actions();\n        try {\n          for (var _action13 of optionals) {\n            _action13.save_required = _action13.required;\n            _action13.required = false;\n          }\n          for (var _group3 of this._mutually_exclusive_groups) {\n            _group3.save_required = _group3.required;\n            _group3.required = false;\n          }\n          var _this$parse_known_arg5 = this.parse_known_args(remaining_args, namespace);\n          var _this$parse_known_arg6 = _slicedToArray(_this$parse_known_arg5, 2);\n          namespace = _this$parse_known_arg6[0];\n          extras = _this$parse_known_arg6[1];\n        } finally {\n          for (var _action14 of optionals) {\n            _action14.required = _action14.save_required;\n          }\n          for (var _group4 of this._mutually_exclusive_groups) {\n            _group4.required = _group4.save_required;\n          }\n        }\n      } finally {\n        this.usage = save_usage;\n      }\n      return [namespace, extras];\n    }\n  }, {\n    key: \"_get_values\",\n    value: function _get_values(action, arg_strings) {\n      var _this16 = this;\n      if (![PARSER, REMAINDER].includes(action.nargs)) {\n        try {\n          _array_remove(arg_strings, '--');\n        } catch (err) {}\n      }\n      var value;\n      if (!arg_strings.length && action.nargs === OPTIONAL) {\n        if (action.option_strings.length) {\n          value = action.const;\n        } else {\n          value = action.default;\n        }\n        if (typeof value === 'string') {\n          value = this._get_value(action, value);\n          this._check_value(action, value);\n        }\n      } else if (!arg_strings.length && action.nargs === ZERO_OR_MORE && !action.option_strings.length) {\n        if (action.default !== undefined) {\n          value = action.default;\n        } else {\n          value = arg_strings;\n        }\n        this._check_value(action, value);\n      } else if (arg_strings.length === 1 && [undefined, OPTIONAL].includes(action.nargs)) {\n        var arg_string = arg_strings[0];\n        value = this._get_value(action, arg_string);\n        this._check_value(action, value);\n      } else if (action.nargs === REMAINDER) {\n        value = arg_strings.map(function (v) {\n          return _this16._get_value(action, v);\n        });\n      } else if (action.nargs === PARSER) {\n        value = arg_strings.map(function (v) {\n          return _this16._get_value(action, v);\n        });\n        this._check_value(action, value[0]);\n      } else if (action.nargs === SUPPRESS) {\n        value = SUPPRESS;\n      } else {\n        value = arg_strings.map(function (v) {\n          return _this16._get_value(action, v);\n        });\n        for (var v of value) {\n          this._check_value(action, v);\n        }\n      }\n      return value;\n    }\n  }, {\n    key: \"_get_value\",\n    value: function _get_value(action, arg_string) {\n      var type_func = this._registry_get('type', action.type, action.type);\n      if (typeof type_func !== 'function') {\n        var msg = '%r is not callable';\n        throw new ArgumentError(action, sub(msg, type_func));\n      }\n      var result;\n      try {\n        try {\n          result = type_func(arg_string);\n        } catch (err) {\n          if (err instanceof TypeError && /Class constructor .* cannot be invoked without 'new'/.test(err.message)) {\n            result = new type_func(arg_string);\n          } else {\n            throw err;\n          }\n        }\n      } catch (err) {\n        if (err instanceof ArgumentTypeError) {\n          var _msg4 = err.message;\n          throw new ArgumentError(action, _msg4);\n        } else if (err instanceof TypeError) {\n          var name = getattr(action.type, 'name', repr(action.type));\n          var args = {\n            type: name,\n            value: arg_string\n          };\n          var _msg5 = 'invalid %(type)s value: %(value)r';\n          throw new ArgumentError(action, sub(_msg5, args));\n        } else {\n          throw err;\n        }\n      }\n      return result;\n    }\n  }, {\n    key: \"_check_value\",\n    value: function _check_value(action, value) {\n      if (action.choices !== undefined && !_choices_to_array(action.choices).includes(value)) {\n        var args = {\n          value: value,\n          choices: _choices_to_array(action.choices).map(repr).join(', ')\n        };\n        var msg = 'invalid choice: %(value)r (choose from %(choices)s)';\n        throw new ArgumentError(action, sub(msg, args));\n      }\n    }\n  }, {\n    key: \"format_usage\",\n    value: function format_usage() {\n      var formatter = this._get_formatter();\n      formatter.add_usage(this.usage, this._actions, this._mutually_exclusive_groups);\n      return formatter.format_help();\n    }\n  }, {\n    key: \"format_help\",\n    value: function format_help() {\n      var formatter = this._get_formatter();\n      formatter.add_usage(this.usage, this._actions, this._mutually_exclusive_groups);\n      formatter.add_text(this.description);\n      for (var action_group of this._action_groups) {\n        formatter.start_section(action_group.title);\n        formatter.add_text(action_group.description);\n        formatter.add_arguments(action_group._group_actions);\n        formatter.end_section();\n      }\n      formatter.add_text(this.epilog);\n      return formatter.format_help();\n    }\n  }, {\n    key: \"_get_formatter\",\n    value: function _get_formatter() {\n      return new this.formatter_class({\n        prog: this.prog\n      });\n    }\n  }, {\n    key: \"print_usage\",\n    value: function print_usage() {\n      var file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      if (file === undefined) file = process.stdout;\n      this._print_message(this.format_usage(), file);\n    }\n  }, {\n    key: \"print_help\",\n    value: function print_help() {\n      var file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      if (file === undefined) file = process.stdout;\n      this._print_message(this.format_help(), file);\n    }\n  }, {\n    key: \"_print_message\",\n    value: function _print_message(message) {\n      var file = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      if (message) {\n        if (file === undefined) file = process.stderr;\n        file.write(message);\n      }\n    }\n  }, {\n    key: \"exit\",\n    value: function exit() {\n      var status = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      if (message) {\n        this._print_message(message, process.stderr);\n      }\n      process.exit(status);\n    }\n  }, {\n    key: \"error\",\n    value: function error(message) {\n      if (this.debug === true) throw new Error(message);\n      this.print_usage(process.stderr);\n      var args = {\n        prog: this.prog,\n        message: message\n      };\n      this.exit(2, sub('%(prog)s: error: %(message)s\\n', args));\n    }\n  }]);\n  return ArgumentParser;\n}(_AttributeHolder(_ActionsContainer))));\nmodule.exports = {\n  ArgumentParser: ArgumentParser,\n  ArgumentError: ArgumentError,\n  ArgumentTypeError: ArgumentTypeError,\n  BooleanOptionalAction: BooleanOptionalAction,\n  FileType: FileType,\n  HelpFormatter: HelpFormatter,\n  ArgumentDefaultsHelpFormatter: ArgumentDefaultsHelpFormatter,\n  RawDescriptionHelpFormatter: RawDescriptionHelpFormatter,\n  RawTextHelpFormatter: RawTextHelpFormatter,\n  MetavarTypeHelpFormatter: MetavarTypeHelpFormatter,\n  Namespace: Namespace,\n  Action: Action,\n  ONE_OR_MORE: ONE_OR_MORE,\n  OPTIONAL: OPTIONAL,\n  PARSER: PARSER,\n  REMAINDER: REMAINDER,\n  SUPPRESS: SUPPRESS,\n  ZERO_OR_MORE: ZERO_OR_MORE\n};\nObject.defineProperty(module.exports, 'Const', {\n  get: function get() {\n    var result = {};\n    Object.entries({\n      ONE_OR_MORE: ONE_OR_MORE,\n      OPTIONAL: OPTIONAL,\n      PARSER: PARSER,\n      REMAINDER: REMAINDER,\n      SUPPRESS: SUPPRESS,\n      ZERO_OR_MORE: ZERO_OR_MORE\n    }).forEach(function (_ref41) {\n      var _ref42 = _slicedToArray(_ref41, 2),\n        n = _ref42[0],\n        v = _ref42[1];\n      Object.defineProperty(result, n, {\n        get: function get() {\n          deprecate(n, sub('use argparse.%s instead of argparse.Const.%s', n, n));\n          return v;\n        }\n      });\n    });\n    Object.entries({\n      _UNRECOGNIZED_ARGS_ATTR: _UNRECOGNIZED_ARGS_ATTR\n    }).forEach(function (_ref43) {\n      var _ref44 = _slicedToArray(_ref43, 2),\n        n = _ref44[0],\n        v = _ref44[1];\n      Object.defineProperty(result, n, {\n        get: function get() {\n          deprecate(n, sub('argparse.Const.%s is an internal symbol and will no longer be available', n));\n          return v;\n        }\n      });\n    });\n    return result;\n  },\n  enumerable: false\n});","map":{"version":3,"names":["_get","require","_assertThisInitialized","_wrapNativeSuper","_toConsumableArray","_classCallCheck","_createClass","_inherits","_possibleConstructorReturn","_getPrototypeOf","_slicedToArray","_defineProperty","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","constructor","Reflect","construct","arguments","apply","sham","Proxy","Boolean","prototype","valueOf","call","e","SUPPRESS","OPTIONAL","ZERO_OR_MORE","ONE_OR_MORE","PARSER","REMAINDER","_UNRECOGNIZED_ARGS_ATTR","assert","util","fs","sub","path","repr","inspect","get_argv","process","argv","slice","get_terminal_size","columns","env","COLUMNS","stdout","hasattr","object","name","Object","hasOwnProperty","getattr","value","setattr","setdefault","delattr","range","from","to","step","length","undefined","_ref","TypeError","i","push","splitlines","str","keepends","split","parts","pop","_string_lstrip","string","prefix_chars","idx","includes","_string_split","sep","maxsplit","concat","join","_array_equal","array1","array2","_array_remove","array","item","indexOf","splice","_choices_to_array","choices","Array","isArray","Symbol","iterator","keys","Error","_callable","cls","this_class","new","target","_len","args","_key","toStringTag","_alias","defineProperty","deprecate","enumerable","_unused","_camelcase_alias","_class","getOwnPropertyNames","camelcase","replace","s","toUpperCase","_to_legacy_name","key","_to_new_name","c","toLowerCase","no_default","_parse_opts","descriptor","get_name","stack","map","x","match","filter","m","fn","shift","kwargs","last_opt","assign","renames","old_name","_ref2","_ref3","a","b","missing_positionals","positional_count","_ref4","entries","_ref5","def","new_name","_ref6","_ref7","_ref8","_ref9","k","v","_ref10","_ref11","strs","str_joined","_deprecations","id","_AttributeHolder","_cls","_util$inspect$custom","_super","type_name","arg_strings","star_args","arg","_get_args","_ref12","_get_kwargs","_ref13","test","toString","custom","_copy_items","items","HelpFormatter","_parse_opts2","prog","indent_increment","max_help_position","width","_parse_opts3","_prog","_indent_increment","_max_help_position","Math","min","max","_width","_current_indent","_level","_action_max_length","_root_section","_Section","_current_section","_whitespace_matcher","_long_break_matcher","_indent","_dedent","_add_item","func","start_section","heading","section","format_help","bind","end_section","parent","add_text","text","_format_text","add_usage","usage","actions","groups","prefix","_format_usage","add_argument","action","help","invocations","_format_action_invocation","subaction","_iter_indented_subactions","invocation_length","invocation","action_length","_format_action","add_arguments","_join_parts","part_strings","part","optionals","positionals","option_strings","action_usage","_format_actions_usage","String","text_width","part_regexp","opt_usage","pos_usage","opt_parts","pos_parts","get_lines","indent","lines","line","line_len","repeat","group_actions","Set","inserts","group","start","_group_actions","end","add","required","_ref14","_ref15","default_value","_get_default_metavar_for_positional","_format_args","has","option_string","nargs","format_usage","_get_default_metavar_for_optional","args_string","Number","sort","trim","_fill_text","help_position","help_width","action_width","action_header","indent_first","tup","help_text","_expand_help","help_lines","_split_lines","endsWith","metavar","_metavar_formatter","default_metavar","choice_strs","format","tuple_size","fill","get_metavar","formats","err","params","choices_str","_get_help_string","_get_subactions","textwrap","wrap","initial_indent","subsequent_indent","dest","formatter","item_help","_ref16","_ref17","current_indent","RawDescriptionHelpFormatter","_HelpFormatter","_super2","RawTextHelpFormatter","_RawDescriptionHelpFo","_super3","ArgumentDefaultsHelpFormatter","_HelpFormatter2","_super4","default","defaulting_nargs","MetavarTypeHelpFormatter","_HelpFormatter3","_super5","type","_get_action_name","argument","ArgumentError","_Error","_super6","message","_this","_argument_name","_message","argument_name","ArgumentTypeError","_Error2","_super7","_this2","Action","_AttributeHolder2","_super8","_this3","_parse_opts4","const","_parse_opts5","const_value","_this4","names","Function","BooleanOptionalAction","_Action","_super9","_parse_opts6","_parse_opts7","_option_strings","startsWith","parser","namespace","values","_StoreAction","_Action2","_super10","_parse_opts8","_parse_opts9","_StoreConstAction","_Action3","_super11","_parse_opts10","_parse_opts11","_StoreTrueAction","_StoreConstAction2","_super12","_parse_opts12","_parse_opts13","_StoreFalseAction","_StoreConstAction3","_super13","_parse_opts14","_parse_opts15","_AppendAction","_Action4","_super14","_parse_opts16","_parse_opts17","_AppendConstAction","_Action5","_super15","_parse_opts18","_parse_opts19","_CountAction","_Action6","_super16","_parse_opts20","_parse_opts21","count","_HelpAction","_Action7","_super17","_parse_opts22","_parse_opts23","print_help","exit","_VersionAction","_Action8","_super18","_this5","_parse_opts24","version","_parse_opts25","_get_formatter","_print_message","_SubParsersAction","_Action9","_super19","_this6","_parse_opts26","parser_class","_parse_opts27","name_parser_map","_prog_prefix","_parser_class","_name_parser_map","_choices_actions","add_parser","_parse_opts28","_parse_opts29","aliases","choice_action","_ChoicesPseudoAction","alias","parser_name","msg","subnamespace","_parser$parse_known_a","parse_known_args","_parser$parse_known_a2","_ref18","_ref19","_getattr","_Action10","_super20","_ExtendAction","_AppendAction2","_super21","FileType","_Function","_util$inspect$custom2","_super22","_this7","_parse_opts30","flags","encoding","mode","autoClose","emitClose","highWaterMark","_parse_opts31","get","_flags","_options","stdin","fd","openSync","filename","error","options","createReadStream","createWriteStream","_ref20","_ref21","args_str","_ref22","_ref23","_ref24","_ref25","kw","Namespace","_AttributeHolder3","_super23","_this8","_ActionsContainer","_this9","_parse_opts32","description","argument_default","conflict_handler","_parse_opts33","_registries","register","forEach","_registry_get","_get_handler","_actions","_option_string_actions","_action_groups","_mutually_exclusive_groups","_defaults","_negative_number_matcher","_has_negative_number_optionals","registry_name","registry","set_defaults","get_default","_parse_opts34","_parse_opts35","chars","_get_positional_kwargs","_get_optional_kwargs","action_class","_pop_action_class","type_func","_add_action","add_argument_group","_ArgumentGroup","add_mutually_exclusive_group","_MutuallyExclusiveGroup","_check_conflict","container","_remove_action","_add_container_actions","title_group_map","title","group_map","Map","set","mutex_group","_parse_opts36","_parse_opts37","_parse_opts38","_parse_opts39","long_option_strings","option","dest_option_string","handler_func_name","confl_optionals","confl_optional","_handle_conflict_error","conflicting_actions","conflict_string","_ref26","_ref27","_handle_conflict_resolve","_ref28","_ref29","_ActionsContainer2","_super24","_this10","_parse_opts40","_parse_opts41","_ArgumentGroup2","_super25","_this11","_parse_opts42","_parse_opts43","_container","ArgumentParser","_AttributeHolder4","_super26","_this12","_parse_opts44","epilog","parents","formatter_class","fromfile_prefix_chars","add_help","allow_abbrev","exit_on_error","debug","_parse_opts45","basename","_positionals","_optionals","_subparsers","identity","isInteger","isNaN","default_prefix","_this13","add_subparsers","_parse_opts46","_parse_opts47","_get_positional_actions","parsers_class","_get_optional_actions","parse_args","_this$parse_known_arg","_this$parse_known_arg2","_this$_parse_known_ar","_parse_known_args","_this$_parse_known_ar2","_this$_parse_known_ar3","_this$_parse_known_ar4","_this14","_read_args_from_files","action_conflicts","_ref30","_ref31","mutex_action","conflicts","option_string_indices","arg_string_pattern_parts","arg_strings_iter","_ref32","_ref33","arg_string","_ref34","_ref35","_ref36","option_tuple","_parse_optional","pattern","arg_strings_pattern","seen_actions","seen_non_default_actions","extras","take_action","argument_strings","argument_values","_get_values","conflict_action","action_name","consume_optional","start_index","_option_tuple","explicit_arg","action_tuples","stop","arg_count","_match_argument","char","new_explicit_arg","optionals_map","selected_patterns","_ref37","_ref38","consume_positionals","selected_pattern","arg_counts","_match_arguments_partial","max_option_string_index","next_option_string_index","index","positionals_end_index","strings","stop_index","required_actions","_get_value","no_actions_used","new_arg_strings","args_file","readFileSync","arg_line","convert_arg_line_to_args","nargs_pattern","_get_nargs_pattern","RegExp","_nargs_errors","nargs_errors","_this15","actions_slice","_string_split2","_string_split3","option_tuples","_get_option_tuples","_ref39","_ref40","matches","_option_tuples","option_prefix","_string_split4","_string_split5","short_option_prefix","short_explicit_arg","parse_intermixed_args","_this$parse_known_int","parse_known_intermixed_args","_this$parse_known_int2","save_usage","remaining_args","save_nargs","save_default","_this$parse_known_arg3","_this$parse_known_arg4","attr","console","warn","save_required","_this$parse_known_arg5","_this$parse_known_arg6","_this16","_check_value","action_group","print_usage","file","stderr","write","status","module","exports","_ref41","_ref42","n","_ref43","_ref44"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@expo/xcpretty/node_modules/argparse/argparse.js"],"sourcesContent":["// Port of python's argparse module, version 3.9.0:\n// https://github.com/python/cpython/blob/v3.9.0rc1/Lib/argparse.py\n\n'use strict'\n\n// Copyright (C) 2010-2020 Python Software Foundation.\n// Copyright (C) 2020 argparse.js authors\n\n/*\n * Command-line parsing library\n *\n * This module is an optparse-inspired command-line parsing library that:\n *\n *     - handles both optional and positional arguments\n *     - produces highly informative usage messages\n *     - supports parsers that dispatch to sub-parsers\n *\n * The following is a simple usage example that sums integers from the\n * command-line and writes the result to a file::\n *\n *     parser = argparse.ArgumentParser(\n *         description='sum the integers at the command line')\n *     parser.add_argument(\n *         'integers', metavar='int', nargs='+', type=int,\n *         help='an integer to be summed')\n *     parser.add_argument(\n *         '--log', default=sys.stdout, type=argparse.FileType('w'),\n *         help='the file where the sum should be written')\n *     args = parser.parse_args()\n *     args.log.write('%s' % sum(args.integers))\n *     args.log.close()\n *\n * The module contains the following public classes:\n *\n *     - ArgumentParser -- The main entry point for command-line parsing. As the\n *         example above shows, the add_argument() method is used to populate\n *         the parser with actions for optional and positional arguments. Then\n *         the parse_args() method is invoked to convert the args at the\n *         command-line into an object with attributes.\n *\n *     - ArgumentError -- The exception raised by ArgumentParser objects when\n *         there are errors with the parser's actions. Errors raised while\n *         parsing the command-line are caught by ArgumentParser and emitted\n *         as command-line messages.\n *\n *     - FileType -- A factory for defining types of files to be created. As the\n *         example above shows, instances of FileType are typically passed as\n *         the type= argument of add_argument() calls.\n *\n *     - Action -- The base class for parser actions. Typically actions are\n *         selected by passing strings like 'store_true' or 'append_const' to\n *         the action= argument of add_argument(). However, for greater\n *         customization of ArgumentParser actions, subclasses of Action may\n *         be defined and passed as the action= argument.\n *\n *     - HelpFormatter, RawDescriptionHelpFormatter, RawTextHelpFormatter,\n *         ArgumentDefaultsHelpFormatter -- Formatter classes which\n *         may be passed as the formatter_class= argument to the\n *         ArgumentParser constructor. HelpFormatter is the default,\n *         RawDescriptionHelpFormatter and RawTextHelpFormatter tell the parser\n *         not to change the formatting for help text, and\n *         ArgumentDefaultsHelpFormatter adds information about argument defaults\n *         to the help.\n *\n * All other classes in this module are considered implementation details.\n * (Also note that HelpFormatter and RawDescriptionHelpFormatter are only\n * considered public as object names -- the API of the formatter objects is\n * still considered an implementation detail.)\n */\n\nconst SUPPRESS = '==SUPPRESS=='\n\nconst OPTIONAL = '?'\nconst ZERO_OR_MORE = '*'\nconst ONE_OR_MORE = '+'\nconst PARSER = 'A...'\nconst REMAINDER = '...'\nconst _UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args'\n\n\n// ==================================\n// Utility functions used for porting\n// ==================================\nconst assert = require('assert')\nconst util = require('util')\nconst fs = require('fs')\nconst sub = require('./lib/sub')\nconst path = require('path')\nconst repr = util.inspect\n\nfunction get_argv() {\n    // omit first argument (which is assumed to be interpreter - `node`, `coffee`, `ts-node`, etc.)\n    return process.argv.slice(1)\n}\n\nfunction get_terminal_size() {\n    return {\n        columns: +process.env.COLUMNS || process.stdout.columns || 80\n    }\n}\n\nfunction hasattr(object, name) {\n    return Object.prototype.hasOwnProperty.call(object, name)\n}\n\nfunction getattr(object, name, value) {\n    return hasattr(object, name) ? object[name] : value\n}\n\nfunction setattr(object, name, value) {\n    object[name] = value\n}\n\nfunction setdefault(object, name, value) {\n    if (!hasattr(object, name)) object[name] = value\n    return object[name]\n}\n\nfunction delattr(object, name) {\n    delete object[name]\n}\n\nfunction range(from, to, step=1) {\n    // range(10) is equivalent to range(0, 10)\n    if (arguments.length === 1) [ to, from ] = [ from, 0 ]\n    if (typeof from !== 'number' || typeof to !== 'number' || typeof step !== 'number') {\n        throw new TypeError('argument cannot be interpreted as an integer')\n    }\n    if (step === 0) throw new TypeError('range() arg 3 must not be zero')\n\n    let result = []\n    if (step > 0) {\n        for (let i = from; i < to; i += step) result.push(i)\n    } else {\n        for (let i = from; i > to; i += step) result.push(i)\n    }\n    return result\n}\n\nfunction splitlines(str, keepends = false) {\n    let result\n    if (!keepends) {\n        result = str.split(/\\r\\n|[\\n\\r\\v\\f\\x1c\\x1d\\x1e\\x85\\u2028\\u2029]/)\n    } else {\n        result = []\n        let parts = str.split(/(\\r\\n|[\\n\\r\\v\\f\\x1c\\x1d\\x1e\\x85\\u2028\\u2029])/)\n        for (let i = 0; i < parts.length; i += 2) {\n            result.push(parts[i] + (i + 1 < parts.length ? parts[i + 1] : ''))\n        }\n    }\n    if (!result[result.length - 1]) result.pop()\n    return result\n}\n\nfunction _string_lstrip(string, prefix_chars) {\n    let idx = 0\n    while (idx < string.length && prefix_chars.includes(string[idx])) idx++\n    return idx ? string.slice(idx) : string\n}\n\nfunction _string_split(string, sep, maxsplit) {\n    let result = string.split(sep)\n    if (result.length > maxsplit) {\n        result = result.slice(0, maxsplit).concat([ result.slice(maxsplit).join(sep) ])\n    }\n    return result\n}\n\nfunction _array_equal(array1, array2) {\n    if (array1.length !== array2.length) return false\n    for (let i = 0; i < array1.length; i++) {\n        if (array1[i] !== array2[i]) return false\n    }\n    return true\n}\n\nfunction _array_remove(array, item) {\n    let idx = array.indexOf(item)\n    if (idx === -1) throw new TypeError(sub('%r not in list', item))\n    array.splice(idx, 1)\n}\n\n// normalize choices to array;\n// this isn't required in python because `in` and `map` operators work with anything,\n// but in js dealing with multiple types here is too clunky\nfunction _choices_to_array(choices) {\n    if (choices === undefined) {\n        return []\n    } else if (Array.isArray(choices)) {\n        return choices\n    } else if (choices !== null && typeof choices[Symbol.iterator] === 'function') {\n        return Array.from(choices)\n    } else if (typeof choices === 'object' && choices !== null) {\n        return Object.keys(choices)\n    } else {\n        throw new Error(sub('invalid choices value: %r', choices))\n    }\n}\n\n// decorator that allows a class to be called without new\nfunction _callable(cls) {\n    let result = { // object is needed for inferred class name\n        [cls.name]: function (...args) {\n            let this_class = new.target === result || !new.target\n            return Reflect.construct(cls, args, this_class ? cls : new.target)\n        }\n    }\n    result[cls.name].prototype = cls.prototype\n    // fix default tag for toString, e.g. [object Action] instead of [object Object]\n    cls.prototype[Symbol.toStringTag] = cls.name\n    return result[cls.name]\n}\n\nfunction _alias(object, from, to) {\n    try {\n        let name = object.constructor.name\n        Object.defineProperty(object, from, {\n            value: util.deprecate(object[to], sub('%s.%s() is renamed to %s.%s()',\n                name, from, name, to)),\n            enumerable: false\n        })\n    } catch {}\n}\n\n// decorator that allows snake_case class methods to be called with camelCase and vice versa\nfunction _camelcase_alias(_class) {\n    for (let name of Object.getOwnPropertyNames(_class.prototype)) {\n        let camelcase = name.replace(/\\w_[a-z]/g, s => s[0] + s[2].toUpperCase())\n        if (camelcase !== name) _alias(_class.prototype, camelcase, name)\n    }\n    return _class\n}\n\nfunction _to_legacy_name(key) {\n    key = key.replace(/\\w_[a-z]/g, s => s[0] + s[2].toUpperCase())\n    if (key === 'default') key = 'defaultValue'\n    if (key === 'const') key = 'constant'\n    return key\n}\n\nfunction _to_new_name(key) {\n    if (key === 'defaultValue') key = 'default'\n    if (key === 'constant') key = 'const'\n    key = key.replace(/[A-Z]/g, c => '_' + c.toLowerCase())\n    return key\n}\n\n// parse options\nlet no_default = Symbol('no_default_value')\nfunction _parse_opts(args, descriptor) {\n    function get_name() {\n        let stack = new Error().stack.split('\\n')\n            .map(x => x.match(/^    at (.*) \\(.*\\)$/))\n            .filter(Boolean)\n            .map(m => m[1])\n            .map(fn => fn.match(/[^ .]*$/)[0])\n\n        if (stack.length && stack[0] === get_name.name) stack.shift()\n        if (stack.length && stack[0] === _parse_opts.name) stack.shift()\n        return stack.length ? stack[0] : ''\n    }\n\n    args = Array.from(args)\n    let kwargs = {}\n    let result = []\n    let last_opt = args.length && args[args.length - 1]\n\n    if (typeof last_opt === 'object' && last_opt !== null && !Array.isArray(last_opt) &&\n        (!last_opt.constructor || last_opt.constructor.name === 'Object')) {\n        kwargs = Object.assign({}, args.pop())\n    }\n\n    // LEGACY (v1 compatibility): camelcase\n    let renames = []\n    for (let key of Object.keys(descriptor)) {\n        let old_name = _to_legacy_name(key)\n        if (old_name !== key && (old_name in kwargs)) {\n            if (key in kwargs) {\n                // default and defaultValue specified at the same time, happens often in old tests\n                //throw new TypeError(sub('%s() got multiple values for argument %r', get_name(), key))\n            } else {\n                kwargs[key] = kwargs[old_name]\n            }\n            renames.push([ old_name, key ])\n            delete kwargs[old_name]\n        }\n    }\n    if (renames.length) {\n        let name = get_name()\n        deprecate('camelcase_' + name, sub('%s(): following options are renamed: %s',\n            name, renames.map(([ a, b ]) => sub('%r -> %r', a, b))))\n    }\n    // end\n\n    let missing_positionals = []\n    let positional_count = args.length\n\n    for (let [ key, def ] of Object.entries(descriptor)) {\n        if (key[0] === '*') {\n            if (key.length > 0 && key[1] === '*') {\n                // LEGACY (v1 compatibility): camelcase\n                let renames = []\n                for (let key of Object.keys(kwargs)) {\n                    let new_name = _to_new_name(key)\n                    if (new_name !== key && (key in kwargs)) {\n                        if (new_name in kwargs) {\n                            // default and defaultValue specified at the same time, happens often in old tests\n                            //throw new TypeError(sub('%s() got multiple values for argument %r', get_name(), new_name))\n                        } else {\n                            kwargs[new_name] = kwargs[key]\n                        }\n                        renames.push([ key, new_name ])\n                        delete kwargs[key]\n                    }\n                }\n                if (renames.length) {\n                    let name = get_name()\n                    deprecate('camelcase_' + name, sub('%s(): following options are renamed: %s',\n                        name, renames.map(([ a, b ]) => sub('%r -> %r', a, b))))\n                }\n                // end\n                result.push(kwargs)\n                kwargs = {}\n            } else {\n                result.push(args)\n                args = []\n            }\n        } else if (key in kwargs && args.length > 0) {\n            throw new TypeError(sub('%s() got multiple values for argument %r', get_name(), key))\n        } else if (key in kwargs) {\n            result.push(kwargs[key])\n            delete kwargs[key]\n        } else if (args.length > 0) {\n            result.push(args.shift())\n        } else if (def !== no_default) {\n            result.push(def)\n        } else {\n            missing_positionals.push(key)\n        }\n    }\n\n    if (Object.keys(kwargs).length) {\n        throw new TypeError(sub('%s() got an unexpected keyword argument %r',\n            get_name(), Object.keys(kwargs)[0]))\n    }\n\n    if (args.length) {\n        let from = Object.entries(descriptor).filter(([ k, v ]) => k[0] !== '*' && v !== no_default).length\n        let to = Object.entries(descriptor).filter(([ k ]) => k[0] !== '*').length\n        throw new TypeError(sub('%s() takes %s positional argument%s but %s %s given',\n            get_name(),\n            from === to ? sub('from %s to %s', from, to) : to,\n            from === to && to === 1 ? '' : 's',\n            positional_count,\n            positional_count === 1 ? 'was' : 'were'))\n    }\n\n    if (missing_positionals.length) {\n        let strs = missing_positionals.map(repr)\n        if (strs.length > 1) strs[strs.length - 1] = 'and ' + strs[strs.length - 1]\n        let str_joined = strs.join(strs.length === 2 ? '' : ', ')\n        throw new TypeError(sub('%s() missing %i required positional argument%s: %s',\n            get_name(), strs.length, strs.length === 1 ? '' : 's', str_joined))\n    }\n\n    return result\n}\n\nlet _deprecations = {}\nfunction deprecate(id, string) {\n    _deprecations[id] = _deprecations[id] || util.deprecate(() => {}, string)\n    _deprecations[id]()\n}\n\n\n// =============================\n// Utility functions and classes\n// =============================\nfunction _AttributeHolder(cls = Object) {\n    /*\n     *  Abstract base class that provides __repr__.\n     *\n     *  The __repr__ method returns a string in the format::\n     *      ClassName(attr=name, attr=name, ...)\n     *  The attributes are determined either by a class-level attribute,\n     *  '_kwarg_names', or by inspecting the instance __dict__.\n     */\n\n    return class _AttributeHolder extends cls {\n        [util.inspect.custom]() {\n            let type_name = this.constructor.name\n            let arg_strings = []\n            let star_args = {}\n            for (let arg of this._get_args()) {\n                arg_strings.push(repr(arg))\n            }\n            for (let [ name, value ] of this._get_kwargs()) {\n                if (/^[a-z_][a-z0-9_$]*$/i.test(name)) {\n                    arg_strings.push(sub('%s=%r', name, value))\n                } else {\n                    star_args[name] = value\n                }\n            }\n            if (Object.keys(star_args).length) {\n                arg_strings.push(sub('**%s', repr(star_args)))\n            }\n            return sub('%s(%s)', type_name, arg_strings.join(', '))\n        }\n\n        toString() {\n            return this[util.inspect.custom]()\n        }\n\n        _get_kwargs() {\n            return Object.entries(this)\n        }\n\n        _get_args() {\n            return []\n        }\n    }\n}\n\n\nfunction _copy_items(items) {\n    if (items === undefined) {\n        return []\n    }\n    return items.slice(0)\n}\n\n\n// ===============\n// Formatting Help\n// ===============\nconst HelpFormatter = _camelcase_alias(_callable(class HelpFormatter {\n    /*\n     *  Formatter for generating usage messages and argument help strings.\n     *\n     *  Only the name of this class is considered a public API. All the methods\n     *  provided by the class are considered an implementation detail.\n     */\n\n    constructor() {\n        let [\n            prog,\n            indent_increment,\n            max_help_position,\n            width\n        ] = _parse_opts(arguments, {\n            prog: no_default,\n            indent_increment: 2,\n            max_help_position: 24,\n            width: undefined\n        })\n\n        // default setting for width\n        if (width === undefined) {\n            width = get_terminal_size().columns\n            width -= 2\n        }\n\n        this._prog = prog\n        this._indent_increment = indent_increment\n        this._max_help_position = Math.min(max_help_position,\n                                      Math.max(width - 20, indent_increment * 2))\n        this._width = width\n\n        this._current_indent = 0\n        this._level = 0\n        this._action_max_length = 0\n\n        this._root_section = this._Section(this, undefined)\n        this._current_section = this._root_section\n\n        this._whitespace_matcher = /[ \\t\\n\\r\\f\\v]+/g // equivalent to python /\\s+/ with ASCII flag\n        this._long_break_matcher = /\\n\\n\\n+/g\n    }\n\n    // ===============================\n    // Section and indentation methods\n    // ===============================\n    _indent() {\n        this._current_indent += this._indent_increment\n        this._level += 1\n    }\n\n    _dedent() {\n        this._current_indent -= this._indent_increment\n        assert(this._current_indent >= 0, 'Indent decreased below 0.')\n        this._level -= 1\n    }\n\n    _add_item(func, args) {\n        this._current_section.items.push([ func, args ])\n    }\n\n    // ========================\n    // Message building methods\n    // ========================\n    start_section(heading) {\n        this._indent()\n        let section = this._Section(this, this._current_section, heading)\n        this._add_item(section.format_help.bind(section), [])\n        this._current_section = section\n    }\n\n    end_section() {\n        this._current_section = this._current_section.parent\n        this._dedent()\n    }\n\n    add_text(text) {\n        if (text !== SUPPRESS && text !== undefined) {\n            this._add_item(this._format_text.bind(this), [text])\n        }\n    }\n\n    add_usage(usage, actions, groups, prefix = undefined) {\n        if (usage !== SUPPRESS) {\n            let args = [ usage, actions, groups, prefix ]\n            this._add_item(this._format_usage.bind(this), args)\n        }\n    }\n\n    add_argument(action) {\n        if (action.help !== SUPPRESS) {\n\n            // find all invocations\n            let invocations = [this._format_action_invocation(action)]\n            for (let subaction of this._iter_indented_subactions(action)) {\n                invocations.push(this._format_action_invocation(subaction))\n            }\n\n            // update the maximum item length\n            let invocation_length = Math.max(...invocations.map(invocation => invocation.length))\n            let action_length = invocation_length + this._current_indent\n            this._action_max_length = Math.max(this._action_max_length,\n                                               action_length)\n\n            // add the item to the list\n            this._add_item(this._format_action.bind(this), [action])\n        }\n    }\n\n    add_arguments(actions) {\n        for (let action of actions) {\n            this.add_argument(action)\n        }\n    }\n\n    // =======================\n    // Help-formatting methods\n    // =======================\n    format_help() {\n        let help = this._root_section.format_help()\n        if (help) {\n            help = help.replace(this._long_break_matcher, '\\n\\n')\n            help = help.replace(/^\\n+|\\n+$/g, '') + '\\n'\n        }\n        return help\n    }\n\n    _join_parts(part_strings) {\n        return part_strings.filter(part => part && part !== SUPPRESS).join('')\n    }\n\n    _format_usage(usage, actions, groups, prefix) {\n        if (prefix === undefined) {\n            prefix = 'usage: '\n        }\n\n        // if usage is specified, use that\n        if (usage !== undefined) {\n            usage = sub(usage, { prog: this._prog })\n\n        // if no optionals or positionals are available, usage is just prog\n        } else if (usage === undefined && !actions.length) {\n            usage = sub('%(prog)s', { prog: this._prog })\n\n        // if optionals and positionals are available, calculate usage\n        } else if (usage === undefined) {\n            let prog = sub('%(prog)s', { prog: this._prog })\n\n            // split optionals from positionals\n            let optionals = []\n            let positionals = []\n            for (let action of actions) {\n                if (action.option_strings.length) {\n                    optionals.push(action)\n                } else {\n                    positionals.push(action)\n                }\n            }\n\n            // build full usage string\n            let action_usage = this._format_actions_usage([].concat(optionals).concat(positionals), groups)\n            usage = [ prog, action_usage ].map(String).join(' ')\n\n            // wrap the usage parts if it's too long\n            let text_width = this._width - this._current_indent\n            if (prefix.length + usage.length > text_width) {\n\n                // break usage into wrappable parts\n                let part_regexp = /\\(.*?\\)+(?=\\s|$)|\\[.*?\\]+(?=\\s|$)|\\S+/g\n                let opt_usage = this._format_actions_usage(optionals, groups)\n                let pos_usage = this._format_actions_usage(positionals, groups)\n                let opt_parts = opt_usage.match(part_regexp) || []\n                let pos_parts = pos_usage.match(part_regexp) || []\n                assert(opt_parts.join(' ') === opt_usage)\n                assert(pos_parts.join(' ') === pos_usage)\n\n                // helper for wrapping lines\n                let get_lines = (parts, indent, prefix = undefined) => {\n                    let lines = []\n                    let line = []\n                    let line_len\n                    if (prefix !== undefined) {\n                        line_len = prefix.length - 1\n                    } else {\n                        line_len = indent.length - 1\n                    }\n                    for (let part of parts) {\n                        if (line_len + 1 + part.length > text_width && line) {\n                            lines.push(indent + line.join(' '))\n                            line = []\n                            line_len = indent.length - 1\n                        }\n                        line.push(part)\n                        line_len += part.length + 1\n                    }\n                    if (line.length) {\n                        lines.push(indent + line.join(' '))\n                    }\n                    if (prefix !== undefined) {\n                        lines[0] = lines[0].slice(indent.length)\n                    }\n                    return lines\n                }\n\n                let lines\n\n                // if prog is short, follow it with optionals or positionals\n                if (prefix.length + prog.length <= 0.75 * text_width) {\n                    let indent = ' '.repeat(prefix.length + prog.length + 1)\n                    if (opt_parts.length) {\n                        lines = get_lines([prog].concat(opt_parts), indent, prefix)\n                        lines = lines.concat(get_lines(pos_parts, indent))\n                    } else if (pos_parts.length) {\n                        lines = get_lines([prog].concat(pos_parts), indent, prefix)\n                    } else {\n                        lines = [prog]\n                    }\n\n                // if prog is long, put it on its own line\n                } else {\n                    let indent = ' '.repeat(prefix.length)\n                    let parts = [].concat(opt_parts).concat(pos_parts)\n                    lines = get_lines(parts, indent)\n                    if (lines.length > 1) {\n                        lines = []\n                        lines = lines.concat(get_lines(opt_parts, indent))\n                        lines = lines.concat(get_lines(pos_parts, indent))\n                    }\n                    lines = [prog].concat(lines)\n                }\n\n                // join lines into usage\n                usage = lines.join('\\n')\n            }\n        }\n\n        // prefix with 'usage:'\n        return sub('%s%s\\n\\n', prefix, usage)\n    }\n\n    _format_actions_usage(actions, groups) {\n        // find group indices and identify actions in groups\n        let group_actions = new Set()\n        let inserts = {}\n        for (let group of groups) {\n            let start = actions.indexOf(group._group_actions[0])\n            if (start === -1) {\n                continue\n            } else {\n                let end = start + group._group_actions.length\n                if (_array_equal(actions.slice(start, end), group._group_actions)) {\n                    for (let action of group._group_actions) {\n                        group_actions.add(action)\n                    }\n                    if (!group.required) {\n                        if (start in inserts) {\n                            inserts[start] += ' ['\n                        } else {\n                            inserts[start] = '['\n                        }\n                        if (end in inserts) {\n                            inserts[end] += ']'\n                        } else {\n                            inserts[end] = ']'\n                        }\n                    } else {\n                        if (start in inserts) {\n                            inserts[start] += ' ('\n                        } else {\n                            inserts[start] = '('\n                        }\n                        if (end in inserts) {\n                            inserts[end] += ')'\n                        } else {\n                            inserts[end] = ')'\n                        }\n                    }\n                    for (let i of range(start + 1, end)) {\n                        inserts[i] = '|'\n                    }\n                }\n            }\n        }\n\n        // collect all actions format strings\n        let parts = []\n        for (let [ i, action ] of Object.entries(actions)) {\n\n            // suppressed arguments are marked with None\n            // remove | separators for suppressed arguments\n            if (action.help === SUPPRESS) {\n                parts.push(undefined)\n                if (inserts[+i] === '|') {\n                    delete inserts[+i]\n                } else if (inserts[+i + 1] === '|') {\n                    delete inserts[+i + 1]\n                }\n\n            // produce all arg strings\n            } else if (!action.option_strings.length) {\n                let default_value = this._get_default_metavar_for_positional(action)\n                let part = this._format_args(action, default_value)\n\n                // if it's in a group, strip the outer []\n                if (group_actions.has(action)) {\n                    if (part[0] === '[' && part[part.length - 1] === ']') {\n                        part = part.slice(1, -1)\n                    }\n                }\n\n                // add the action string to the list\n                parts.push(part)\n\n            // produce the first way to invoke the option in brackets\n            } else {\n                let option_string = action.option_strings[0]\n                let part\n\n                // if the Optional doesn't take a value, format is:\n                //    -s or --long\n                if (action.nargs === 0) {\n                    part = action.format_usage()\n\n                // if the Optional takes a value, format is:\n                //    -s ARGS or --long ARGS\n                } else {\n                    let default_value = this._get_default_metavar_for_optional(action)\n                    let args_string = this._format_args(action, default_value)\n                    part = sub('%s %s', option_string, args_string)\n                }\n\n                // make it look optional if it's not required or in a group\n                if (!action.required && !group_actions.has(action)) {\n                    part = sub('[%s]', part)\n                }\n\n                // add the action string to the list\n                parts.push(part)\n            }\n        }\n\n        // insert things at the necessary indices\n        for (let i of Object.keys(inserts).map(Number).sort((a, b) => b - a)) {\n            parts.splice(+i, 0, inserts[+i])\n        }\n\n        // join all the action items with spaces\n        let text = parts.filter(Boolean).join(' ')\n\n        // clean up separators for mutually exclusive groups\n        text = text.replace(/([\\[(]) /g, '$1')\n        text = text.replace(/ ([\\])])/g, '$1')\n        text = text.replace(/[\\[(] *[\\])]/g, '')\n        text = text.replace(/\\(([^|]*)\\)/g, '$1', text)\n        text = text.trim()\n\n        // return the text\n        return text\n    }\n\n    _format_text(text) {\n        if (text.includes('%(prog)')) {\n            text = sub(text, { prog: this._prog })\n        }\n        let text_width = Math.max(this._width - this._current_indent, 11)\n        let indent = ' '.repeat(this._current_indent)\n        return this._fill_text(text, text_width, indent) + '\\n\\n'\n    }\n\n    _format_action(action) {\n        // determine the required width and the entry label\n        let help_position = Math.min(this._action_max_length + 2,\n                                     this._max_help_position)\n        let help_width = Math.max(this._width - help_position, 11)\n        let action_width = help_position - this._current_indent - 2\n        let action_header = this._format_action_invocation(action)\n        let indent_first\n\n        // no help; start on same line and add a final newline\n        if (!action.help) {\n            let tup = [ this._current_indent, '', action_header ]\n            action_header = sub('%*s%s\\n', ...tup)\n\n        // short action name; start on the same line and pad two spaces\n        } else if (action_header.length <= action_width) {\n            let tup = [ this._current_indent, '', action_width, action_header ]\n            action_header = sub('%*s%-*s  ', ...tup)\n            indent_first = 0\n\n        // long action name; start on the next line\n        } else {\n            let tup = [ this._current_indent, '', action_header ]\n            action_header = sub('%*s%s\\n', ...tup)\n            indent_first = help_position\n        }\n\n        // collect the pieces of the action help\n        let parts = [action_header]\n\n        // if there was help for the action, add lines of help text\n        if (action.help) {\n            let help_text = this._expand_help(action)\n            let help_lines = this._split_lines(help_text, help_width)\n            parts.push(sub('%*s%s\\n', indent_first, '', help_lines[0]))\n            for (let line of help_lines.slice(1)) {\n                parts.push(sub('%*s%s\\n', help_position, '', line))\n            }\n\n        // or add a newline if the description doesn't end with one\n        } else if (!action_header.endsWith('\\n')) {\n            parts.push('\\n')\n        }\n\n        // if there are any sub-actions, add their help as well\n        for (let subaction of this._iter_indented_subactions(action)) {\n            parts.push(this._format_action(subaction))\n        }\n\n        // return a single string\n        return this._join_parts(parts)\n    }\n\n    _format_action_invocation(action) {\n        if (!action.option_strings.length) {\n            let default_value = this._get_default_metavar_for_positional(action)\n            let metavar = this._metavar_formatter(action, default_value)(1)[0]\n            return metavar\n\n        } else {\n            let parts = []\n\n            // if the Optional doesn't take a value, format is:\n            //    -s, --long\n            if (action.nargs === 0) {\n                parts = parts.concat(action.option_strings)\n\n            // if the Optional takes a value, format is:\n            //    -s ARGS, --long ARGS\n            } else {\n                let default_value = this._get_default_metavar_for_optional(action)\n                let args_string = this._format_args(action, default_value)\n                for (let option_string of action.option_strings) {\n                    parts.push(sub('%s %s', option_string, args_string))\n                }\n            }\n\n            return parts.join(', ')\n        }\n    }\n\n    _metavar_formatter(action, default_metavar) {\n        let result\n        if (action.metavar !== undefined) {\n            result = action.metavar\n        } else if (action.choices !== undefined) {\n            let choice_strs = _choices_to_array(action.choices).map(String)\n            result = sub('{%s}', choice_strs.join(','))\n        } else {\n            result = default_metavar\n        }\n\n        function format(tuple_size) {\n            if (Array.isArray(result)) {\n                return result\n            } else {\n                return Array(tuple_size).fill(result)\n            }\n        }\n        return format\n    }\n\n    _format_args(action, default_metavar) {\n        let get_metavar = this._metavar_formatter(action, default_metavar)\n        let result\n        if (action.nargs === undefined) {\n            result = sub('%s', ...get_metavar(1))\n        } else if (action.nargs === OPTIONAL) {\n            result = sub('[%s]', ...get_metavar(1))\n        } else if (action.nargs === ZERO_OR_MORE) {\n            let metavar = get_metavar(1)\n            if (metavar.length === 2) {\n                result = sub('[%s [%s ...]]', ...metavar)\n            } else {\n                result = sub('[%s ...]', ...metavar)\n            }\n        } else if (action.nargs === ONE_OR_MORE) {\n            result = sub('%s [%s ...]', ...get_metavar(2))\n        } else if (action.nargs === REMAINDER) {\n            result = '...'\n        } else if (action.nargs === PARSER) {\n            result = sub('%s ...', ...get_metavar(1))\n        } else if (action.nargs === SUPPRESS) {\n            result = ''\n        } else {\n            let formats\n            try {\n                formats = range(action.nargs).map(() => '%s')\n            } catch (err) {\n                throw new TypeError('invalid nargs value')\n            }\n            result = sub(formats.join(' '), ...get_metavar(action.nargs))\n        }\n        return result\n    }\n\n    _expand_help(action) {\n        let params = Object.assign({ prog: this._prog }, action)\n        for (let name of Object.keys(params)) {\n            if (params[name] === SUPPRESS) {\n                delete params[name]\n            }\n        }\n        for (let name of Object.keys(params)) {\n            if (params[name] && params[name].name) {\n                params[name] = params[name].name\n            }\n        }\n        if (params.choices !== undefined) {\n            let choices_str = _choices_to_array(params.choices).map(String).join(', ')\n            params.choices = choices_str\n        }\n        // LEGACY (v1 compatibility): camelcase\n        for (let key of Object.keys(params)) {\n            let old_name = _to_legacy_name(key)\n            if (old_name !== key) {\n                params[old_name] = params[key]\n            }\n        }\n        // end\n        return sub(this._get_help_string(action), params)\n    }\n\n    * _iter_indented_subactions(action) {\n        if (typeof action._get_subactions === 'function') {\n            this._indent()\n            yield* action._get_subactions()\n            this._dedent()\n        }\n    }\n\n    _split_lines(text, width) {\n        text = text.replace(this._whitespace_matcher, ' ').trim()\n        // The textwrap module is used only for formatting help.\n        // Delay its import for speeding up the common usage of argparse.\n        let textwrap = require('./lib/textwrap')\n        return textwrap.wrap(text, { width })\n    }\n\n    _fill_text(text, width, indent) {\n        text = text.replace(this._whitespace_matcher, ' ').trim()\n        let textwrap = require('./lib/textwrap')\n        return textwrap.fill(text, { width,\n                                     initial_indent: indent,\n                                     subsequent_indent: indent })\n    }\n\n    _get_help_string(action) {\n        return action.help\n    }\n\n    _get_default_metavar_for_optional(action) {\n        return action.dest.toUpperCase()\n    }\n\n    _get_default_metavar_for_positional(action) {\n        return action.dest\n    }\n}))\n\nHelpFormatter.prototype._Section = _callable(class _Section {\n\n    constructor(formatter, parent, heading = undefined) {\n        this.formatter = formatter\n        this.parent = parent\n        this.heading = heading\n        this.items = []\n    }\n\n    format_help() {\n        // format the indented section\n        if (this.parent !== undefined) {\n            this.formatter._indent()\n        }\n        let item_help = this.formatter._join_parts(this.items.map(([ func, args ]) => func.apply(null, args)))\n        if (this.parent !== undefined) {\n            this.formatter._dedent()\n        }\n\n        // return nothing if the section was empty\n        if (!item_help) {\n            return ''\n        }\n\n        // add the heading if the section was non-empty\n        let heading\n        if (this.heading !== SUPPRESS && this.heading !== undefined) {\n            let current_indent = this.formatter._current_indent\n            heading = sub('%*s%s:\\n', current_indent, '', this.heading)\n        } else {\n            heading = ''\n        }\n\n        // join the section-initial newline, the heading and the help\n        return this.formatter._join_parts(['\\n', heading, item_help, '\\n'])\n    }\n})\n\n\nconst RawDescriptionHelpFormatter = _camelcase_alias(_callable(class RawDescriptionHelpFormatter extends HelpFormatter {\n    /*\n     *  Help message formatter which retains any formatting in descriptions.\n     *\n     *  Only the name of this class is considered a public API. All the methods\n     *  provided by the class are considered an implementation detail.\n     */\n\n    _fill_text(text, width, indent) {\n        return splitlines(text, true).map(line => indent + line).join('')\n    }\n}))\n\n\nconst RawTextHelpFormatter = _camelcase_alias(_callable(class RawTextHelpFormatter extends RawDescriptionHelpFormatter {\n    /*\n     *  Help message formatter which retains formatting of all help text.\n     *\n     *  Only the name of this class is considered a public API. All the methods\n     *  provided by the class are considered an implementation detail.\n     */\n\n    _split_lines(text/*, width*/) {\n        return splitlines(text)\n    }\n}))\n\n\nconst ArgumentDefaultsHelpFormatter = _camelcase_alias(_callable(class ArgumentDefaultsHelpFormatter extends HelpFormatter {\n    /*\n     *  Help message formatter which adds default values to argument help.\n     *\n     *  Only the name of this class is considered a public API. All the methods\n     *  provided by the class are considered an implementation detail.\n     */\n\n    _get_help_string(action) {\n        let help = action.help\n        // LEGACY (v1 compatibility): additional check for defaultValue needed\n        if (!action.help.includes('%(default)') && !action.help.includes('%(defaultValue)')) {\n            if (action.default !== SUPPRESS) {\n                let defaulting_nargs = [OPTIONAL, ZERO_OR_MORE]\n                if (action.option_strings.length || defaulting_nargs.includes(action.nargs)) {\n                    help += ' (default: %(default)s)'\n                }\n            }\n        }\n        return help\n    }\n}))\n\n\nconst MetavarTypeHelpFormatter = _camelcase_alias(_callable(class MetavarTypeHelpFormatter extends HelpFormatter {\n    /*\n     *  Help message formatter which uses the argument 'type' as the default\n     *  metavar value (instead of the argument 'dest')\n     *\n     *  Only the name of this class is considered a public API. All the methods\n     *  provided by the class are considered an implementation detail.\n     */\n\n    _get_default_metavar_for_optional(action) {\n        return typeof action.type === 'function' ? action.type.name : action.type\n    }\n\n    _get_default_metavar_for_positional(action) {\n        return typeof action.type === 'function' ? action.type.name : action.type\n    }\n}))\n\n\n// =====================\n// Options and Arguments\n// =====================\nfunction _get_action_name(argument) {\n    if (argument === undefined) {\n        return undefined\n    } else if (argument.option_strings.length) {\n        return argument.option_strings.join('/')\n    } else if (![ undefined, SUPPRESS ].includes(argument.metavar)) {\n        return argument.metavar\n    } else if (![ undefined, SUPPRESS ].includes(argument.dest)) {\n        return argument.dest\n    } else {\n        return undefined\n    }\n}\n\n\nconst ArgumentError = _callable(class ArgumentError extends Error {\n    /*\n     *  An error from creating or using an argument (optional or positional).\n     *\n     *  The string value of this exception is the message, augmented with\n     *  information about the argument that caused it.\n     */\n\n    constructor(argument, message) {\n        super()\n        this.name = 'ArgumentError'\n        this._argument_name = _get_action_name(argument)\n        this._message = message\n        this.message = this.str()\n    }\n\n    str() {\n        let format\n        if (this._argument_name === undefined) {\n            format = '%(message)s'\n        } else {\n            format = 'argument %(argument_name)s: %(message)s'\n        }\n        return sub(format, { message: this._message,\n                             argument_name: this._argument_name })\n    }\n})\n\n\nconst ArgumentTypeError = _callable(class ArgumentTypeError extends Error {\n    /*\n     * An error from trying to convert a command line string to a type.\n     */\n\n    constructor(message) {\n        super(message)\n        this.name = 'ArgumentTypeError'\n    }\n})\n\n\n// ==============\n// Action classes\n// ==============\nconst Action = _camelcase_alias(_callable(class Action extends _AttributeHolder(Function) {\n    /*\n     *  Information about how to convert command line strings to Python objects.\n     *\n     *  Action objects are used by an ArgumentParser to represent the information\n     *  needed to parse a single argument from one or more strings from the\n     *  command line. The keyword arguments to the Action constructor are also\n     *  all attributes of Action instances.\n     *\n     *  Keyword Arguments:\n     *\n     *      - option_strings -- A list of command-line option strings which\n     *          should be associated with this action.\n     *\n     *      - dest -- The name of the attribute to hold the created object(s)\n     *\n     *      - nargs -- The number of command-line arguments that should be\n     *          consumed. By default, one argument will be consumed and a single\n     *          value will be produced.  Other values include:\n     *              - N (an integer) consumes N arguments (and produces a list)\n     *              - '?' consumes zero or one arguments\n     *              - '*' consumes zero or more arguments (and produces a list)\n     *              - '+' consumes one or more arguments (and produces a list)\n     *          Note that the difference between the default and nargs=1 is that\n     *          with the default, a single value will be produced, while with\n     *          nargs=1, a list containing a single value will be produced.\n     *\n     *      - const -- The value to be produced if the option is specified and the\n     *          option uses an action that takes no values.\n     *\n     *      - default -- The value to be produced if the option is not specified.\n     *\n     *      - type -- A callable that accepts a single string argument, and\n     *          returns the converted value.  The standard Python types str, int,\n     *          float, and complex are useful examples of such callables.  If None,\n     *          str is used.\n     *\n     *      - choices -- A container of values that should be allowed. If not None,\n     *          after a command-line argument has been converted to the appropriate\n     *          type, an exception will be raised if it is not a member of this\n     *          collection.\n     *\n     *      - required -- True if the action must always be specified at the\n     *          command line. This is only meaningful for optional command-line\n     *          arguments.\n     *\n     *      - help -- The help string describing the argument.\n     *\n     *      - metavar -- The name to be used for the option's argument with the\n     *          help string. If None, the 'dest' value will be used as the name.\n     */\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            nargs,\n            const_value,\n            default_value,\n            type,\n            choices,\n            required,\n            help,\n            metavar\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: no_default,\n            nargs: undefined,\n            const: undefined,\n            default: undefined,\n            type: undefined,\n            choices: undefined,\n            required: false,\n            help: undefined,\n            metavar: undefined\n        })\n\n        // when this class is called as a function, redirect it to .call() method of itself\n        super('return arguments.callee.call.apply(arguments.callee, arguments)')\n\n        this.option_strings = option_strings\n        this.dest = dest\n        this.nargs = nargs\n        this.const = const_value\n        this.default = default_value\n        this.type = type\n        this.choices = choices\n        this.required = required\n        this.help = help\n        this.metavar = metavar\n    }\n\n    _get_kwargs() {\n        let names = [\n            'option_strings',\n            'dest',\n            'nargs',\n            'const',\n            'default',\n            'type',\n            'choices',\n            'help',\n            'metavar'\n        ]\n        return names.map(name => [ name, getattr(this, name) ])\n    }\n\n    format_usage() {\n        return this.option_strings[0]\n    }\n\n    call(/*parser, namespace, values, option_string = undefined*/) {\n        throw new Error('.call() not defined')\n    }\n}))\n\n\nconst BooleanOptionalAction = _camelcase_alias(_callable(class BooleanOptionalAction extends Action {\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            default_value,\n            type,\n            choices,\n            required,\n            help,\n            metavar\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: no_default,\n            default: undefined,\n            type: undefined,\n            choices: undefined,\n            required: false,\n            help: undefined,\n            metavar: undefined\n        })\n\n        let _option_strings = []\n        for (let option_string of option_strings) {\n            _option_strings.push(option_string)\n\n            if (option_string.startsWith('--')) {\n                option_string = '--no-' + option_string.slice(2)\n                _option_strings.push(option_string)\n            }\n        }\n\n        if (help !== undefined && default_value !== undefined) {\n            help += ` (default: ${default_value})`\n        }\n\n        super({\n            option_strings: _option_strings,\n            dest,\n            nargs: 0,\n            default: default_value,\n            type,\n            choices,\n            required,\n            help,\n            metavar\n        })\n    }\n\n    call(parser, namespace, values, option_string = undefined) {\n        if (this.option_strings.includes(option_string)) {\n            setattr(namespace, this.dest, !option_string.startsWith('--no-'))\n        }\n    }\n\n    format_usage() {\n        return this.option_strings.join(' | ')\n    }\n}))\n\n\nconst _StoreAction = _callable(class _StoreAction extends Action {\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            nargs,\n            const_value,\n            default_value,\n            type,\n            choices,\n            required,\n            help,\n            metavar\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: no_default,\n            nargs: undefined,\n            const: undefined,\n            default: undefined,\n            type: undefined,\n            choices: undefined,\n            required: false,\n            help: undefined,\n            metavar: undefined\n        })\n\n        if (nargs === 0) {\n            throw new TypeError('nargs for store actions must be != 0; if you ' +\n                        'have nothing to store, actions such as store ' +\n                        'true or store const may be more appropriate')\n        }\n        if (const_value !== undefined && nargs !== OPTIONAL) {\n            throw new TypeError(sub('nargs must be %r to supply const', OPTIONAL))\n        }\n        super({\n            option_strings,\n            dest,\n            nargs,\n            const: const_value,\n            default: default_value,\n            type,\n            choices,\n            required,\n            help,\n            metavar\n        })\n    }\n\n    call(parser, namespace, values/*, option_string = undefined*/) {\n        setattr(namespace, this.dest, values)\n    }\n})\n\n\nconst _StoreConstAction = _callable(class _StoreConstAction extends Action {\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            const_value,\n            default_value,\n            required,\n            help\n            //, metavar\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: no_default,\n            const: no_default,\n            default: undefined,\n            required: false,\n            help: undefined,\n            metavar: undefined\n        })\n\n        super({\n            option_strings,\n            dest,\n            nargs: 0,\n            const: const_value,\n            default: default_value,\n            required,\n            help\n        })\n    }\n\n    call(parser, namespace/*, values, option_string = undefined*/) {\n        setattr(namespace, this.dest, this.const)\n    }\n})\n\n\nconst _StoreTrueAction = _callable(class _StoreTrueAction extends _StoreConstAction {\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            default_value,\n            required,\n            help\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: no_default,\n            default: false,\n            required: false,\n            help: undefined\n        })\n\n        super({\n            option_strings,\n            dest,\n            const: true,\n            default: default_value,\n            required,\n            help\n        })\n    }\n})\n\n\nconst _StoreFalseAction = _callable(class _StoreFalseAction extends _StoreConstAction {\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            default_value,\n            required,\n            help\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: no_default,\n            default: true,\n            required: false,\n            help: undefined\n        })\n\n        super({\n            option_strings,\n            dest,\n            const: false,\n            default: default_value,\n            required,\n            help\n        })\n    }\n})\n\n\nconst _AppendAction = _callable(class _AppendAction extends Action {\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            nargs,\n            const_value,\n            default_value,\n            type,\n            choices,\n            required,\n            help,\n            metavar\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: no_default,\n            nargs: undefined,\n            const: undefined,\n            default: undefined,\n            type: undefined,\n            choices: undefined,\n            required: false,\n            help: undefined,\n            metavar: undefined\n        })\n\n        if (nargs === 0) {\n            throw new TypeError('nargs for append actions must be != 0; if arg ' +\n                        'strings are not supplying the value to append, ' +\n                        'the append const action may be more appropriate')\n        }\n        if (const_value !== undefined && nargs !== OPTIONAL) {\n            throw new TypeError(sub('nargs must be %r to supply const', OPTIONAL))\n        }\n        super({\n            option_strings,\n            dest,\n            nargs,\n            const: const_value,\n            default: default_value,\n            type,\n            choices,\n            required,\n            help,\n            metavar\n        })\n    }\n\n    call(parser, namespace, values/*, option_string = undefined*/) {\n        let items = getattr(namespace, this.dest, undefined)\n        items = _copy_items(items)\n        items.push(values)\n        setattr(namespace, this.dest, items)\n    }\n})\n\n\nconst _AppendConstAction = _callable(class _AppendConstAction extends Action {\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            const_value,\n            default_value,\n            required,\n            help,\n            metavar\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: no_default,\n            const: no_default,\n            default: undefined,\n            required: false,\n            help: undefined,\n            metavar: undefined\n        })\n\n        super({\n            option_strings,\n            dest,\n            nargs: 0,\n            const: const_value,\n            default: default_value,\n            required,\n            help,\n            metavar\n        })\n    }\n\n    call(parser, namespace/*, values, option_string = undefined*/) {\n        let items = getattr(namespace, this.dest, undefined)\n        items = _copy_items(items)\n        items.push(this.const)\n        setattr(namespace, this.dest, items)\n    }\n})\n\n\nconst _CountAction = _callable(class _CountAction extends Action {\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            default_value,\n            required,\n            help\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: no_default,\n            default: undefined,\n            required: false,\n            help: undefined\n        })\n\n        super({\n            option_strings,\n            dest,\n            nargs: 0,\n            default: default_value,\n            required,\n            help\n        })\n    }\n\n    call(parser, namespace/*, values, option_string = undefined*/) {\n        let count = getattr(namespace, this.dest, undefined)\n        if (count === undefined) {\n            count = 0\n        }\n        setattr(namespace, this.dest, count + 1)\n    }\n})\n\n\nconst _HelpAction = _callable(class _HelpAction extends Action {\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            default_value,\n            help\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: SUPPRESS,\n            default: SUPPRESS,\n            help: undefined\n        })\n\n        super({\n            option_strings,\n            dest,\n            default: default_value,\n            nargs: 0,\n            help\n        })\n    }\n\n    call(parser/*, namespace, values, option_string = undefined*/) {\n        parser.print_help()\n        parser.exit()\n    }\n})\n\n\nconst _VersionAction = _callable(class _VersionAction extends Action {\n\n    constructor() {\n        let [\n            option_strings,\n            version,\n            dest,\n            default_value,\n            help\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            version: undefined,\n            dest: SUPPRESS,\n            default: SUPPRESS,\n            help: \"show program's version number and exit\"\n        })\n\n        super({\n            option_strings,\n            dest,\n            default: default_value,\n            nargs: 0,\n            help\n        })\n        this.version = version\n    }\n\n    call(parser/*, namespace, values, option_string = undefined*/) {\n        let version = this.version\n        if (version === undefined) {\n            version = parser.version\n        }\n        let formatter = parser._get_formatter()\n        formatter.add_text(version)\n        parser._print_message(formatter.format_help(), process.stdout)\n        parser.exit()\n    }\n})\n\n\nconst _SubParsersAction = _camelcase_alias(_callable(class _SubParsersAction extends Action {\n\n    constructor() {\n        let [\n            option_strings,\n            prog,\n            parser_class,\n            dest,\n            required,\n            help,\n            metavar\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            prog: no_default,\n            parser_class: no_default,\n            dest: SUPPRESS,\n            required: false,\n            help: undefined,\n            metavar: undefined\n        })\n\n        let name_parser_map = {}\n\n        super({\n            option_strings,\n            dest,\n            nargs: PARSER,\n            choices: name_parser_map,\n            required,\n            help,\n            metavar\n        })\n\n        this._prog_prefix = prog\n        this._parser_class = parser_class\n        this._name_parser_map = name_parser_map\n        this._choices_actions = []\n    }\n\n    add_parser() {\n        let [\n            name,\n            kwargs\n        ] = _parse_opts(arguments, {\n            name: no_default,\n            '**kwargs': no_default\n        })\n\n        // set prog from the existing prefix\n        if (kwargs.prog === undefined) {\n            kwargs.prog = sub('%s %s', this._prog_prefix, name)\n        }\n\n        let aliases = getattr(kwargs, 'aliases', [])\n        delete kwargs.aliases\n\n        // create a pseudo-action to hold the choice help\n        if ('help' in kwargs) {\n            let help = kwargs.help\n            delete kwargs.help\n            let choice_action = this._ChoicesPseudoAction(name, aliases, help)\n            this._choices_actions.push(choice_action)\n        }\n\n        // create the parser and add it to the map\n        let parser = new this._parser_class(kwargs)\n        this._name_parser_map[name] = parser\n\n        // make parser available under aliases also\n        for (let alias of aliases) {\n            this._name_parser_map[alias] = parser\n        }\n\n        return parser\n    }\n\n    _get_subactions() {\n        return this._choices_actions\n    }\n\n    call(parser, namespace, values/*, option_string = undefined*/) {\n        let parser_name = values[0]\n        let arg_strings = values.slice(1)\n\n        // set the parser name if requested\n        if (this.dest !== SUPPRESS) {\n            setattr(namespace, this.dest, parser_name)\n        }\n\n        // select the parser\n        if (hasattr(this._name_parser_map, parser_name)) {\n            parser = this._name_parser_map[parser_name]\n        } else {\n            let args = {parser_name,\n                        choices: this._name_parser_map.join(', ')}\n            let msg = sub('unknown parser %(parser_name)r (choices: %(choices)s)', args)\n            throw new ArgumentError(this, msg)\n        }\n\n        // parse all the remaining options into the namespace\n        // store any unrecognized options on the object, so that the top\n        // level parser can decide what to do with them\n\n        // In case this subparser defines new defaults, we parse them\n        // in a new namespace object and then update the original\n        // namespace for the relevant parts.\n        let subnamespace\n        [ subnamespace, arg_strings ] = parser.parse_known_args(arg_strings, undefined)\n        for (let [ key, value ] of Object.entries(subnamespace)) {\n            setattr(namespace, key, value)\n        }\n\n        if (arg_strings.length) {\n            setdefault(namespace, _UNRECOGNIZED_ARGS_ATTR, [])\n            getattr(namespace, _UNRECOGNIZED_ARGS_ATTR).push(...arg_strings)\n        }\n    }\n}))\n\n\n_SubParsersAction.prototype._ChoicesPseudoAction = _callable(class _ChoicesPseudoAction extends Action {\n    constructor(name, aliases, help) {\n        let metavar = name, dest = name\n        if (aliases.length) {\n            metavar += sub(' (%s)', aliases.join(', '))\n        }\n        super({ option_strings: [], dest, help, metavar })\n    }\n})\n\n\nconst _ExtendAction = _callable(class _ExtendAction extends _AppendAction {\n    call(parser, namespace, values/*, option_string = undefined*/) {\n        let items = getattr(namespace, this.dest, undefined)\n        items = _copy_items(items)\n        items = items.concat(values)\n        setattr(namespace, this.dest, items)\n    }\n})\n\n\n// ==============\n// Type classes\n// ==============\nconst FileType = _callable(class FileType extends Function {\n    /*\n     *  Factory for creating file object types\n     *\n     *  Instances of FileType are typically passed as type= arguments to the\n     *  ArgumentParser add_argument() method.\n     *\n     *  Keyword Arguments:\n     *      - mode -- A string indicating how the file is to be opened. Accepts the\n     *          same values as the builtin open() function.\n     *      - bufsize -- The file's desired buffer size. Accepts the same values as\n     *          the builtin open() function.\n     *      - encoding -- The file's encoding. Accepts the same values as the\n     *          builtin open() function.\n     *      - errors -- A string indicating how encoding and decoding errors are to\n     *          be handled. Accepts the same value as the builtin open() function.\n     */\n\n    constructor() {\n        let [\n            flags,\n            encoding,\n            mode,\n            autoClose,\n            emitClose,\n            start,\n            end,\n            highWaterMark,\n            fs\n        ] = _parse_opts(arguments, {\n            flags: 'r',\n            encoding: undefined,\n            mode: undefined, // 0o666\n            autoClose: undefined, // true\n            emitClose: undefined, // false\n            start: undefined, // 0\n            end: undefined, // Infinity\n            highWaterMark: undefined, // 64 * 1024\n            fs: undefined\n        })\n\n        // when this class is called as a function, redirect it to .call() method of itself\n        super('return arguments.callee.call.apply(arguments.callee, arguments)')\n\n        Object.defineProperty(this, 'name', {\n            get() {\n                return sub('FileType(%r)', flags)\n            }\n        })\n        this._flags = flags\n        this._options = {}\n        if (encoding !== undefined) this._options.encoding = encoding\n        if (mode !== undefined) this._options.mode = mode\n        if (autoClose !== undefined) this._options.autoClose = autoClose\n        if (emitClose !== undefined) this._options.emitClose = emitClose\n        if (start !== undefined) this._options.start = start\n        if (end !== undefined) this._options.end = end\n        if (highWaterMark !== undefined) this._options.highWaterMark = highWaterMark\n        if (fs !== undefined) this._options.fs = fs\n    }\n\n    call(string) {\n        // the special argument \"-\" means sys.std{in,out}\n        if (string === '-') {\n            if (this._flags.includes('r')) {\n                return process.stdin\n            } else if (this._flags.includes('w')) {\n                return process.stdout\n            } else {\n                let msg = sub('argument \"-\" with mode %r', this._flags)\n                throw new TypeError(msg)\n            }\n        }\n\n        // all other arguments are used as file names\n        let fd\n        try {\n            fd = fs.openSync(string, this._flags, this._options.mode)\n        } catch (e) {\n            let args = { filename: string, error: e.message }\n            let message = \"can't open '%(filename)s': %(error)s\"\n            throw new ArgumentTypeError(sub(message, args))\n        }\n\n        let options = Object.assign({ fd, flags: this._flags }, this._options)\n        if (this._flags.includes('r')) {\n            return fs.createReadStream(undefined, options)\n        } else if (this._flags.includes('w')) {\n            return fs.createWriteStream(undefined, options)\n        } else {\n            let msg = sub('argument \"%s\" with mode %r', string, this._flags)\n            throw new TypeError(msg)\n        }\n    }\n\n    [util.inspect.custom]() {\n        let args = [ this._flags ]\n        let kwargs = Object.entries(this._options).map(([ k, v ]) => {\n            if (k === 'mode') v = { value: v, [util.inspect.custom]() { return '0o' + this.value.toString(8) } }\n            return [ k, v ]\n        })\n        let args_str = []\n                .concat(args.filter(arg => arg !== -1).map(repr))\n                .concat(kwargs.filter(([/*kw*/, arg]) => arg !== undefined)\n                    .map(([kw, arg]) => sub('%s=%r', kw, arg)))\n                .join(', ')\n        return sub('%s(%s)', this.constructor.name, args_str)\n    }\n\n    toString() {\n        return this[util.inspect.custom]()\n    }\n})\n\n// ===========================\n// Optional and Positional Parsing\n// ===========================\nconst Namespace = _callable(class Namespace extends _AttributeHolder() {\n    /*\n     *  Simple object for storing attributes.\n     *\n     *  Implements equality by attribute names and values, and provides a simple\n     *  string representation.\n     */\n\n    constructor(options = {}) {\n        super()\n        Object.assign(this, options)\n    }\n})\n\n// unset string tag to mimic plain object\nNamespace.prototype[Symbol.toStringTag] = undefined\n\n\nconst _ActionsContainer = _camelcase_alias(_callable(class _ActionsContainer {\n\n    constructor() {\n        let [\n            description,\n            prefix_chars,\n            argument_default,\n            conflict_handler\n        ] = _parse_opts(arguments, {\n            description: no_default,\n            prefix_chars: no_default,\n            argument_default: no_default,\n            conflict_handler: no_default\n        })\n\n        this.description = description\n        this.argument_default = argument_default\n        this.prefix_chars = prefix_chars\n        this.conflict_handler = conflict_handler\n\n        // set up registries\n        this._registries = {}\n\n        // register actions\n        this.register('action', undefined, _StoreAction)\n        this.register('action', 'store', _StoreAction)\n        this.register('action', 'store_const', _StoreConstAction)\n        this.register('action', 'store_true', _StoreTrueAction)\n        this.register('action', 'store_false', _StoreFalseAction)\n        this.register('action', 'append', _AppendAction)\n        this.register('action', 'append_const', _AppendConstAction)\n        this.register('action', 'count', _CountAction)\n        this.register('action', 'help', _HelpAction)\n        this.register('action', 'version', _VersionAction)\n        this.register('action', 'parsers', _SubParsersAction)\n        this.register('action', 'extend', _ExtendAction)\n        // LEGACY (v1 compatibility): camelcase variants\n        ;[ 'storeConst', 'storeTrue', 'storeFalse', 'appendConst' ].forEach(old_name => {\n            let new_name = _to_new_name(old_name)\n            this.register('action', old_name, util.deprecate(this._registry_get('action', new_name),\n                sub('{action: \"%s\"} is renamed to {action: \"%s\"}', old_name, new_name)))\n        })\n        // end\n\n        // raise an exception if the conflict handler is invalid\n        this._get_handler()\n\n        // action storage\n        this._actions = []\n        this._option_string_actions = {}\n\n        // groups\n        this._action_groups = []\n        this._mutually_exclusive_groups = []\n\n        // defaults storage\n        this._defaults = {}\n\n        // determines whether an \"option\" looks like a negative number\n        this._negative_number_matcher = /^-\\d+$|^-\\d*\\.\\d+$/\n\n        // whether or not there are any optionals that look like negative\n        // numbers -- uses a list so it can be shared and edited\n        this._has_negative_number_optionals = []\n    }\n\n    // ====================\n    // Registration methods\n    // ====================\n    register(registry_name, value, object) {\n        let registry = setdefault(this._registries, registry_name, {})\n        registry[value] = object\n    }\n\n    _registry_get(registry_name, value, default_value = undefined) {\n        return getattr(this._registries[registry_name], value, default_value)\n    }\n\n    // ==================================\n    // Namespace default accessor methods\n    // ==================================\n    set_defaults(kwargs) {\n        Object.assign(this._defaults, kwargs)\n\n        // if these defaults match any existing arguments, replace\n        // the previous default on the object with the new one\n        for (let action of this._actions) {\n            if (action.dest in kwargs) {\n                action.default = kwargs[action.dest]\n            }\n        }\n    }\n\n    get_default(dest) {\n        for (let action of this._actions) {\n            if (action.dest === dest && action.default !== undefined) {\n                return action.default\n            }\n        }\n        return this._defaults[dest]\n    }\n\n\n    // =======================\n    // Adding argument actions\n    // =======================\n    add_argument() {\n        /*\n         *  add_argument(dest, ..., name=value, ...)\n         *  add_argument(option_string, option_string, ..., name=value, ...)\n         */\n        let [\n            args,\n            kwargs\n        ] = _parse_opts(arguments, {\n            '*args': no_default,\n            '**kwargs': no_default\n        })\n        // LEGACY (v1 compatibility), old-style add_argument([ args ], { options })\n        if (args.length === 1 && Array.isArray(args[0])) {\n            args = args[0]\n            deprecate('argument-array',\n                sub('use add_argument(%(args)s, {...}) instead of add_argument([ %(args)s ], { ... })', {\n                    args: args.map(repr).join(', ')\n                }))\n        }\n        // end\n\n        // if no positional args are supplied or only one is supplied and\n        // it doesn't look like an option string, parse a positional\n        // argument\n        let chars = this.prefix_chars\n        if (!args.length || args.length === 1 && !chars.includes(args[0][0])) {\n            if (args.length && 'dest' in kwargs) {\n                throw new TypeError('dest supplied twice for positional argument')\n            }\n            kwargs = this._get_positional_kwargs(...args, kwargs)\n\n        // otherwise, we're adding an optional argument\n        } else {\n            kwargs = this._get_optional_kwargs(...args, kwargs)\n        }\n\n        // if no default was supplied, use the parser-level default\n        if (!('default' in kwargs)) {\n            let dest = kwargs.dest\n            if (dest in this._defaults) {\n                kwargs.default = this._defaults[dest]\n            } else if (this.argument_default !== undefined) {\n                kwargs.default = this.argument_default\n            }\n        }\n\n        // create the action object, and add it to the parser\n        let action_class = this._pop_action_class(kwargs)\n        if (typeof action_class !== 'function') {\n            throw new TypeError(sub('unknown action \"%s\"', action_class))\n        }\n        // eslint-disable-next-line new-cap\n        let action = new action_class(kwargs)\n\n        // raise an error if the action type is not callable\n        let type_func = this._registry_get('type', action.type, action.type)\n        if (typeof type_func !== 'function') {\n            throw new TypeError(sub('%r is not callable', type_func))\n        }\n\n        if (type_func === FileType) {\n            throw new TypeError(sub('%r is a FileType class object, instance of it' +\n                                    ' must be passed', type_func))\n        }\n\n        // raise an error if the metavar does not match the type\n        if ('_get_formatter' in this) {\n            try {\n                this._get_formatter()._format_args(action, undefined)\n            } catch (err) {\n                // check for 'invalid nargs value' is an artifact of TypeError and ValueError in js being the same\n                if (err instanceof TypeError && err.message !== 'invalid nargs value') {\n                    throw new TypeError('length of metavar tuple does not match nargs')\n                } else {\n                    throw err\n                }\n            }\n        }\n\n        return this._add_action(action)\n    }\n\n    add_argument_group() {\n        let group = _ArgumentGroup(this, ...arguments)\n        this._action_groups.push(group)\n        return group\n    }\n\n    add_mutually_exclusive_group() {\n        // eslint-disable-next-line no-use-before-define\n        let group = _MutuallyExclusiveGroup(this, ...arguments)\n        this._mutually_exclusive_groups.push(group)\n        return group\n    }\n\n    _add_action(action) {\n        // resolve any conflicts\n        this._check_conflict(action)\n\n        // add to actions list\n        this._actions.push(action)\n        action.container = this\n\n        // index the action by any option strings it has\n        for (let option_string of action.option_strings) {\n            this._option_string_actions[option_string] = action\n        }\n\n        // set the flag if any option strings look like negative numbers\n        for (let option_string of action.option_strings) {\n            if (this._negative_number_matcher.test(option_string)) {\n                if (!this._has_negative_number_optionals.length) {\n                    this._has_negative_number_optionals.push(true)\n                }\n            }\n        }\n\n        // return the created action\n        return action\n    }\n\n    _remove_action(action) {\n        _array_remove(this._actions, action)\n    }\n\n    _add_container_actions(container) {\n        // collect groups by titles\n        let title_group_map = {}\n        for (let group of this._action_groups) {\n            if (group.title in title_group_map) {\n                let msg = 'cannot merge actions - two groups are named %r'\n                throw new TypeError(sub(msg, group.title))\n            }\n            title_group_map[group.title] = group\n        }\n\n        // map each action to its group\n        let group_map = new Map()\n        for (let group of container._action_groups) {\n\n            // if a group with the title exists, use that, otherwise\n            // create a new group matching the container's group\n            if (!(group.title in title_group_map)) {\n                title_group_map[group.title] = this.add_argument_group({\n                    title: group.title,\n                    description: group.description,\n                    conflict_handler: group.conflict_handler\n                })\n            }\n\n            // map the actions to their new group\n            for (let action of group._group_actions) {\n                group_map.set(action, title_group_map[group.title])\n            }\n        }\n\n        // add container's mutually exclusive groups\n        // NOTE: if add_mutually_exclusive_group ever gains title= and\n        // description= then this code will need to be expanded as above\n        for (let group of container._mutually_exclusive_groups) {\n            let mutex_group = this.add_mutually_exclusive_group({\n                required: group.required\n            })\n\n            // map the actions to their new mutex group\n            for (let action of group._group_actions) {\n                group_map.set(action, mutex_group)\n            }\n        }\n\n        // add all actions to this container or their group\n        for (let action of container._actions) {\n            group_map.get(action)._add_action(action)\n        }\n    }\n\n    _get_positional_kwargs() {\n        let [\n            dest,\n            kwargs\n        ] = _parse_opts(arguments, {\n            dest: no_default,\n            '**kwargs': no_default\n        })\n\n        // make sure required is not specified\n        if ('required' in kwargs) {\n            let msg = \"'required' is an invalid argument for positionals\"\n            throw new TypeError(msg)\n        }\n\n        // mark positional arguments as required if at least one is\n        // always required\n        if (![OPTIONAL, ZERO_OR_MORE].includes(kwargs.nargs)) {\n            kwargs.required = true\n        }\n        if (kwargs.nargs === ZERO_OR_MORE && !('default' in kwargs)) {\n            kwargs.required = true\n        }\n\n        // return the keyword arguments with no option strings\n        return Object.assign(kwargs, { dest, option_strings: [] })\n    }\n\n    _get_optional_kwargs() {\n        let [\n            args,\n            kwargs\n        ] = _parse_opts(arguments, {\n            '*args': no_default,\n            '**kwargs': no_default\n        })\n\n        // determine short and long option strings\n        let option_strings = []\n        let long_option_strings = []\n        let option_string\n        for (option_string of args) {\n            // error on strings that don't start with an appropriate prefix\n            if (!this.prefix_chars.includes(option_string[0])) {\n                let args = {option: option_string,\n                            prefix_chars: this.prefix_chars}\n                let msg = 'invalid option string %(option)r: ' +\n                          'must start with a character %(prefix_chars)r'\n                throw new TypeError(sub(msg, args))\n            }\n\n            // strings starting with two prefix characters are long options\n            option_strings.push(option_string)\n            if (option_string.length > 1 && this.prefix_chars.includes(option_string[1])) {\n                long_option_strings.push(option_string)\n            }\n        }\n\n        // infer destination, '--foo-bar' -> 'foo_bar' and '-x' -> 'x'\n        let dest = kwargs.dest\n        delete kwargs.dest\n        if (dest === undefined) {\n            let dest_option_string\n            if (long_option_strings.length) {\n                dest_option_string = long_option_strings[0]\n            } else {\n                dest_option_string = option_strings[0]\n            }\n            dest = _string_lstrip(dest_option_string, this.prefix_chars)\n            if (!dest) {\n                let msg = 'dest= is required for options like %r'\n                throw new TypeError(sub(msg, option_string))\n            }\n            dest = dest.replace(/-/g, '_')\n        }\n\n        // return the updated keyword arguments\n        return Object.assign(kwargs, { dest, option_strings })\n    }\n\n    _pop_action_class(kwargs, default_value = undefined) {\n        let action = getattr(kwargs, 'action', default_value)\n        delete kwargs.action\n        return this._registry_get('action', action, action)\n    }\n\n    _get_handler() {\n        // determine function from conflict handler string\n        let handler_func_name = sub('_handle_conflict_%s', this.conflict_handler)\n        if (typeof this[handler_func_name] === 'function') {\n            return this[handler_func_name]\n        } else {\n            let msg = 'invalid conflict_resolution value: %r'\n            throw new TypeError(sub(msg, this.conflict_handler))\n        }\n    }\n\n    _check_conflict(action) {\n\n        // find all options that conflict with this option\n        let confl_optionals = []\n        for (let option_string of action.option_strings) {\n            if (hasattr(this._option_string_actions, option_string)) {\n                let confl_optional = this._option_string_actions[option_string]\n                confl_optionals.push([ option_string, confl_optional ])\n            }\n        }\n\n        // resolve any conflicts\n        if (confl_optionals.length) {\n            let conflict_handler = this._get_handler()\n            conflict_handler.call(this, action, confl_optionals)\n        }\n    }\n\n    _handle_conflict_error(action, conflicting_actions) {\n        let message = conflicting_actions.length === 1 ?\n            'conflicting option string: %s' :\n            'conflicting option strings: %s'\n        let conflict_string = conflicting_actions.map(([ option_string/*, action*/ ]) => option_string).join(', ')\n        throw new ArgumentError(action, sub(message, conflict_string))\n    }\n\n    _handle_conflict_resolve(action, conflicting_actions) {\n\n        // remove all conflicting options\n        for (let [ option_string, action ] of conflicting_actions) {\n\n            // remove the conflicting option\n            _array_remove(action.option_strings, option_string)\n            delete this._option_string_actions[option_string]\n\n            // if the option now has no option string, remove it from the\n            // container holding it\n            if (!action.option_strings.length) {\n                action.container._remove_action(action)\n            }\n        }\n    }\n}))\n\n\nconst _ArgumentGroup = _callable(class _ArgumentGroup extends _ActionsContainer {\n\n    constructor() {\n        let [\n            container,\n            title,\n            description,\n            kwargs\n        ] = _parse_opts(arguments, {\n            container: no_default,\n            title: undefined,\n            description: undefined,\n            '**kwargs': no_default\n        })\n\n        // add any missing keyword arguments by checking the container\n        setdefault(kwargs, 'conflict_handler', container.conflict_handler)\n        setdefault(kwargs, 'prefix_chars', container.prefix_chars)\n        setdefault(kwargs, 'argument_default', container.argument_default)\n        super(Object.assign({ description }, kwargs))\n\n        // group attributes\n        this.title = title\n        this._group_actions = []\n\n        // share most attributes with the container\n        this._registries = container._registries\n        this._actions = container._actions\n        this._option_string_actions = container._option_string_actions\n        this._defaults = container._defaults\n        this._has_negative_number_optionals =\n            container._has_negative_number_optionals\n        this._mutually_exclusive_groups = container._mutually_exclusive_groups\n    }\n\n    _add_action(action) {\n        action = super._add_action(action)\n        this._group_actions.push(action)\n        return action\n    }\n\n    _remove_action(action) {\n        super._remove_action(action)\n        _array_remove(this._group_actions, action)\n    }\n})\n\n\nconst _MutuallyExclusiveGroup = _callable(class _MutuallyExclusiveGroup extends _ArgumentGroup {\n\n    constructor() {\n        let [\n            container,\n            required\n        ] = _parse_opts(arguments, {\n            container: no_default,\n            required: false\n        })\n\n        super(container)\n        this.required = required\n        this._container = container\n    }\n\n    _add_action(action) {\n        if (action.required) {\n            let msg = 'mutually exclusive arguments must be optional'\n            throw new TypeError(msg)\n        }\n        action = this._container._add_action(action)\n        this._group_actions.push(action)\n        return action\n    }\n\n    _remove_action(action) {\n        this._container._remove_action(action)\n        _array_remove(this._group_actions, action)\n    }\n})\n\n\nconst ArgumentParser = _camelcase_alias(_callable(class ArgumentParser extends _AttributeHolder(_ActionsContainer) {\n    /*\n     *  Object for parsing command line strings into Python objects.\n     *\n     *  Keyword Arguments:\n     *      - prog -- The name of the program (default: sys.argv[0])\n     *      - usage -- A usage message (default: auto-generated from arguments)\n     *      - description -- A description of what the program does\n     *      - epilog -- Text following the argument descriptions\n     *      - parents -- Parsers whose arguments should be copied into this one\n     *      - formatter_class -- HelpFormatter class for printing help messages\n     *      - prefix_chars -- Characters that prefix optional arguments\n     *      - fromfile_prefix_chars -- Characters that prefix files containing\n     *          additional arguments\n     *      - argument_default -- The default value for all arguments\n     *      - conflict_handler -- String indicating how to handle conflicts\n     *      - add_help -- Add a -h/-help option\n     *      - allow_abbrev -- Allow long options to be abbreviated unambiguously\n     *      - exit_on_error -- Determines whether or not ArgumentParser exits with\n     *          error info when an error occurs\n     */\n\n    constructor() {\n        let [\n            prog,\n            usage,\n            description,\n            epilog,\n            parents,\n            formatter_class,\n            prefix_chars,\n            fromfile_prefix_chars,\n            argument_default,\n            conflict_handler,\n            add_help,\n            allow_abbrev,\n            exit_on_error,\n            debug, // LEGACY (v1 compatibility), debug mode\n            version // LEGACY (v1 compatibility), version\n        ] = _parse_opts(arguments, {\n            prog: undefined,\n            usage: undefined,\n            description: undefined,\n            epilog: undefined,\n            parents: [],\n            formatter_class: HelpFormatter,\n            prefix_chars: '-',\n            fromfile_prefix_chars: undefined,\n            argument_default: undefined,\n            conflict_handler: 'error',\n            add_help: true,\n            allow_abbrev: true,\n            exit_on_error: true,\n            debug: undefined, // LEGACY (v1 compatibility), debug mode\n            version: undefined // LEGACY (v1 compatibility), version\n        })\n\n        // LEGACY (v1 compatibility)\n        if (debug !== undefined) {\n            deprecate('debug',\n                'The \"debug\" argument to ArgumentParser is deprecated. Please ' +\n                'override ArgumentParser.exit function instead.'\n            )\n        }\n\n        if (version !== undefined) {\n            deprecate('version',\n                'The \"version\" argument to ArgumentParser is deprecated. Please use ' +\n                \"add_argument(..., { action: 'version', version: 'N', ... }) instead.\"\n            )\n        }\n        // end\n\n        super({\n            description,\n            prefix_chars,\n            argument_default,\n            conflict_handler\n        })\n\n        // default setting for prog\n        if (prog === undefined) {\n            prog = path.basename(get_argv()[0] || '')\n        }\n\n        this.prog = prog\n        this.usage = usage\n        this.epilog = epilog\n        this.formatter_class = formatter_class\n        this.fromfile_prefix_chars = fromfile_prefix_chars\n        this.add_help = add_help\n        this.allow_abbrev = allow_abbrev\n        this.exit_on_error = exit_on_error\n        // LEGACY (v1 compatibility), debug mode\n        this.debug = debug\n        // end\n\n        this._positionals = this.add_argument_group('positional arguments')\n        this._optionals = this.add_argument_group('optional arguments')\n        this._subparsers = undefined\n\n        // register types\n        function identity(string) {\n            return string\n        }\n        this.register('type', undefined, identity)\n        this.register('type', null, identity)\n        this.register('type', 'auto', identity)\n        this.register('type', 'int', function (x) {\n            let result = Number(x)\n            if (!Number.isInteger(result)) {\n                throw new TypeError(sub('could not convert string to int: %r', x))\n            }\n            return result\n        })\n        this.register('type', 'float', function (x) {\n            let result = Number(x)\n            if (isNaN(result)) {\n                throw new TypeError(sub('could not convert string to float: %r', x))\n            }\n            return result\n        })\n        this.register('type', 'str', String)\n        // LEGACY (v1 compatibility): custom types\n        this.register('type', 'string',\n            util.deprecate(String, 'use {type:\"str\"} or {type:String} instead of {type:\"string\"}'))\n        // end\n\n        // add help argument if necessary\n        // (using explicit default to override global argument_default)\n        let default_prefix = prefix_chars.includes('-') ? '-' : prefix_chars[0]\n        if (this.add_help) {\n            this.add_argument(\n                default_prefix + 'h',\n                default_prefix.repeat(2) + 'help',\n                {\n                    action: 'help',\n                    default: SUPPRESS,\n                    help: 'show this help message and exit'\n                }\n            )\n        }\n        // LEGACY (v1 compatibility), version\n        if (version) {\n            this.add_argument(\n                default_prefix + 'v',\n                default_prefix.repeat(2) + 'version',\n                {\n                    action: 'version',\n                    default: SUPPRESS,\n                    version: this.version,\n                    help: \"show program's version number and exit\"\n                }\n            )\n        }\n        // end\n\n        // add parent arguments and defaults\n        for (let parent of parents) {\n            this._add_container_actions(parent)\n            Object.assign(this._defaults, parent._defaults)\n        }\n    }\n\n    // =======================\n    // Pretty __repr__ methods\n    // =======================\n    _get_kwargs() {\n        let names = [\n            'prog',\n            'usage',\n            'description',\n            'formatter_class',\n            'conflict_handler',\n            'add_help'\n        ]\n        return names.map(name => [ name, getattr(this, name) ])\n    }\n\n    // ==================================\n    // Optional/Positional adding methods\n    // ==================================\n    add_subparsers() {\n        let [\n            kwargs\n        ] = _parse_opts(arguments, {\n            '**kwargs': no_default\n        })\n\n        if (this._subparsers !== undefined) {\n            this.error('cannot have multiple subparser arguments')\n        }\n\n        // add the parser class to the arguments if it's not present\n        setdefault(kwargs, 'parser_class', this.constructor)\n\n        if ('title' in kwargs || 'description' in kwargs) {\n            let title = getattr(kwargs, 'title', 'subcommands')\n            let description = getattr(kwargs, 'description', undefined)\n            delete kwargs.title\n            delete kwargs.description\n            this._subparsers = this.add_argument_group(title, description)\n        } else {\n            this._subparsers = this._positionals\n        }\n\n        // prog defaults to the usage message of this parser, skipping\n        // optional arguments and with no \"usage:\" prefix\n        if (kwargs.prog === undefined) {\n            let formatter = this._get_formatter()\n            let positionals = this._get_positional_actions()\n            let groups = this._mutually_exclusive_groups\n            formatter.add_usage(this.usage, positionals, groups, '')\n            kwargs.prog = formatter.format_help().trim()\n        }\n\n        // create the parsers action and add it to the positionals list\n        let parsers_class = this._pop_action_class(kwargs, 'parsers')\n        // eslint-disable-next-line new-cap\n        let action = new parsers_class(Object.assign({ option_strings: [] }, kwargs))\n        this._subparsers._add_action(action)\n\n        // return the created parsers action\n        return action\n    }\n\n    _add_action(action) {\n        if (action.option_strings.length) {\n            this._optionals._add_action(action)\n        } else {\n            this._positionals._add_action(action)\n        }\n        return action\n    }\n\n    _get_optional_actions() {\n        return this._actions.filter(action => action.option_strings.length)\n    }\n\n    _get_positional_actions() {\n        return this._actions.filter(action => !action.option_strings.length)\n    }\n\n    // =====================================\n    // Command line argument parsing methods\n    // =====================================\n    parse_args(args = undefined, namespace = undefined) {\n        let argv\n        [ args, argv ] = this.parse_known_args(args, namespace)\n        if (argv && argv.length > 0) {\n            let msg = 'unrecognized arguments: %s'\n            this.error(sub(msg, argv.join(' ')))\n        }\n        return args\n    }\n\n    parse_known_args(args = undefined, namespace = undefined) {\n        if (args === undefined) {\n            args = get_argv().slice(1)\n        }\n\n        // default Namespace built from parser defaults\n        if (namespace === undefined) {\n            namespace = new Namespace()\n        }\n\n        // add any action defaults that aren't present\n        for (let action of this._actions) {\n            if (action.dest !== SUPPRESS) {\n                if (!hasattr(namespace, action.dest)) {\n                    if (action.default !== SUPPRESS) {\n                        setattr(namespace, action.dest, action.default)\n                    }\n                }\n            }\n        }\n\n        // add any parser defaults that aren't present\n        for (let dest of Object.keys(this._defaults)) {\n            if (!hasattr(namespace, dest)) {\n                setattr(namespace, dest, this._defaults[dest])\n            }\n        }\n\n        // parse the arguments and exit if there are any errors\n        if (this.exit_on_error) {\n            try {\n                [ namespace, args ] = this._parse_known_args(args, namespace)\n            } catch (err) {\n                if (err instanceof ArgumentError) {\n                    this.error(err.message)\n                } else {\n                    throw err\n                }\n            }\n        } else {\n            [ namespace, args ] = this._parse_known_args(args, namespace)\n        }\n\n        if (hasattr(namespace, _UNRECOGNIZED_ARGS_ATTR)) {\n            args = args.concat(getattr(namespace, _UNRECOGNIZED_ARGS_ATTR))\n            delattr(namespace, _UNRECOGNIZED_ARGS_ATTR)\n        }\n\n        return [ namespace, args ]\n    }\n\n    _parse_known_args(arg_strings, namespace) {\n        // replace arg strings that are file references\n        if (this.fromfile_prefix_chars !== undefined) {\n            arg_strings = this._read_args_from_files(arg_strings)\n        }\n\n        // map all mutually exclusive arguments to the other arguments\n        // they can't occur with\n        let action_conflicts = new Map()\n        for (let mutex_group of this._mutually_exclusive_groups) {\n            let group_actions = mutex_group._group_actions\n            for (let [ i, mutex_action ] of Object.entries(mutex_group._group_actions)) {\n                let conflicts = action_conflicts.get(mutex_action) || []\n                conflicts = conflicts.concat(group_actions.slice(0, +i))\n                conflicts = conflicts.concat(group_actions.slice(+i + 1))\n                action_conflicts.set(mutex_action, conflicts)\n            }\n        }\n\n        // find all option indices, and determine the arg_string_pattern\n        // which has an 'O' if there is an option at an index,\n        // an 'A' if there is an argument, or a '-' if there is a '--'\n        let option_string_indices = {}\n        let arg_string_pattern_parts = []\n        let arg_strings_iter = Object.entries(arg_strings)[Symbol.iterator]()\n        for (let [ i, arg_string ] of arg_strings_iter) {\n\n            // all args after -- are non-options\n            if (arg_string === '--') {\n                arg_string_pattern_parts.push('-')\n                for ([ i, arg_string ] of arg_strings_iter) {\n                    arg_string_pattern_parts.push('A')\n                }\n\n            // otherwise, add the arg to the arg strings\n            // and note the index if it was an option\n            } else {\n                let option_tuple = this._parse_optional(arg_string)\n                let pattern\n                if (option_tuple === undefined) {\n                    pattern = 'A'\n                } else {\n                    option_string_indices[i] = option_tuple\n                    pattern = 'O'\n                }\n                arg_string_pattern_parts.push(pattern)\n            }\n        }\n\n        // join the pieces together to form the pattern\n        let arg_strings_pattern = arg_string_pattern_parts.join('')\n\n        // converts arg strings to the appropriate and then takes the action\n        let seen_actions = new Set()\n        let seen_non_default_actions = new Set()\n        let extras\n\n        let take_action = (action, argument_strings, option_string = undefined) => {\n            seen_actions.add(action)\n            let argument_values = this._get_values(action, argument_strings)\n\n            // error if this argument is not allowed with other previously\n            // seen arguments, assuming that actions that use the default\n            // value don't really count as \"present\"\n            if (argument_values !== action.default) {\n                seen_non_default_actions.add(action)\n                for (let conflict_action of action_conflicts.get(action) || []) {\n                    if (seen_non_default_actions.has(conflict_action)) {\n                        let msg = 'not allowed with argument %s'\n                        let action_name = _get_action_name(conflict_action)\n                        throw new ArgumentError(action, sub(msg, action_name))\n                    }\n                }\n            }\n\n            // take the action if we didn't receive a SUPPRESS value\n            // (e.g. from a default)\n            if (argument_values !== SUPPRESS) {\n                action(this, namespace, argument_values, option_string)\n            }\n        }\n\n        // function to convert arg_strings into an optional action\n        let consume_optional = start_index => {\n\n            // get the optional identified at this index\n            let option_tuple = option_string_indices[start_index]\n            let [ action, option_string, explicit_arg ] = option_tuple\n\n            // identify additional optionals in the same arg string\n            // (e.g. -xyz is the same as -x -y -z if no args are required)\n            let action_tuples = []\n            let stop\n            for (;;) {\n\n                // if we found no optional action, skip it\n                if (action === undefined) {\n                    extras.push(arg_strings[start_index])\n                    return start_index + 1\n                }\n\n                // if there is an explicit argument, try to match the\n                // optional's string arguments to only this\n                if (explicit_arg !== undefined) {\n                    let arg_count = this._match_argument(action, 'A')\n\n                    // if the action is a single-dash option and takes no\n                    // arguments, try to parse more single-dash options out\n                    // of the tail of the option string\n                    let chars = this.prefix_chars\n                    if (arg_count === 0 && !chars.includes(option_string[1])) {\n                        action_tuples.push([ action, [], option_string ])\n                        let char = option_string[0]\n                        option_string = char + explicit_arg[0]\n                        let new_explicit_arg = explicit_arg.slice(1) || undefined\n                        let optionals_map = this._option_string_actions\n                        if (hasattr(optionals_map, option_string)) {\n                            action = optionals_map[option_string]\n                            explicit_arg = new_explicit_arg\n                        } else {\n                            let msg = 'ignored explicit argument %r'\n                            throw new ArgumentError(action, sub(msg, explicit_arg))\n                        }\n\n                    // if the action expect exactly one argument, we've\n                    // successfully matched the option; exit the loop\n                    } else if (arg_count === 1) {\n                        stop = start_index + 1\n                        let args = [ explicit_arg ]\n                        action_tuples.push([ action, args, option_string ])\n                        break\n\n                    // error if a double-dash option did not use the\n                    // explicit argument\n                    } else {\n                        let msg = 'ignored explicit argument %r'\n                        throw new ArgumentError(action, sub(msg, explicit_arg))\n                    }\n\n                // if there is no explicit argument, try to match the\n                // optional's string arguments with the following strings\n                // if successful, exit the loop\n                } else {\n                    let start = start_index + 1\n                    let selected_patterns = arg_strings_pattern.slice(start)\n                    let arg_count = this._match_argument(action, selected_patterns)\n                    stop = start + arg_count\n                    let args = arg_strings.slice(start, stop)\n                    action_tuples.push([ action, args, option_string ])\n                    break\n                }\n            }\n\n            // add the Optional to the list and return the index at which\n            // the Optional's string args stopped\n            assert(action_tuples.length)\n            for (let [ action, args, option_string ] of action_tuples) {\n                take_action(action, args, option_string)\n            }\n            return stop\n        }\n\n        // the list of Positionals left to be parsed; this is modified\n        // by consume_positionals()\n        let positionals = this._get_positional_actions()\n\n        // function to convert arg_strings into positional actions\n        let consume_positionals = start_index => {\n            // match as many Positionals as possible\n            let selected_pattern = arg_strings_pattern.slice(start_index)\n            let arg_counts = this._match_arguments_partial(positionals, selected_pattern)\n\n            // slice off the appropriate arg strings for each Positional\n            // and add the Positional and its args to the list\n            for (let i = 0; i < positionals.length && i < arg_counts.length; i++) {\n                let action = positionals[i]\n                let arg_count = arg_counts[i]\n                let args = arg_strings.slice(start_index, start_index + arg_count)\n                start_index += arg_count\n                take_action(action, args)\n            }\n\n            // slice off the Positionals that we just parsed and return the\n            // index at which the Positionals' string args stopped\n            positionals = positionals.slice(arg_counts.length)\n            return start_index\n        }\n\n        // consume Positionals and Optionals alternately, until we have\n        // passed the last option string\n        extras = []\n        let start_index = 0\n        let max_option_string_index = Math.max(-1, ...Object.keys(option_string_indices).map(Number))\n        while (start_index <= max_option_string_index) {\n\n            // consume any Positionals preceding the next option\n            let next_option_string_index = Math.min(\n                // eslint-disable-next-line no-loop-func\n                ...Object.keys(option_string_indices).map(Number).filter(index => index >= start_index)\n            )\n            if (start_index !== next_option_string_index) {\n                let positionals_end_index = consume_positionals(start_index)\n\n                // only try to parse the next optional if we didn't consume\n                // the option string during the positionals parsing\n                if (positionals_end_index > start_index) {\n                    start_index = positionals_end_index\n                    continue\n                } else {\n                    start_index = positionals_end_index\n                }\n            }\n\n            // if we consumed all the positionals we could and we're not\n            // at the index of an option string, there were extra arguments\n            if (!(start_index in option_string_indices)) {\n                let strings = arg_strings.slice(start_index, next_option_string_index)\n                extras = extras.concat(strings)\n                start_index = next_option_string_index\n            }\n\n            // consume the next optional and any arguments for it\n            start_index = consume_optional(start_index)\n        }\n\n        // consume any positionals following the last Optional\n        let stop_index = consume_positionals(start_index)\n\n        // if we didn't consume all the argument strings, there were extras\n        extras = extras.concat(arg_strings.slice(stop_index))\n\n        // make sure all required actions were present and also convert\n        // action defaults which were not given as arguments\n        let required_actions = []\n        for (let action of this._actions) {\n            if (!seen_actions.has(action)) {\n                if (action.required) {\n                    required_actions.push(_get_action_name(action))\n                } else {\n                    // Convert action default now instead of doing it before\n                    // parsing arguments to avoid calling convert functions\n                    // twice (which may fail) if the argument was given, but\n                    // only if it was defined already in the namespace\n                    if (action.default !== undefined &&\n                        typeof action.default === 'string' &&\n                        hasattr(namespace, action.dest) &&\n                        action.default === getattr(namespace, action.dest)) {\n                        setattr(namespace, action.dest,\n                                this._get_value(action, action.default))\n                    }\n                }\n            }\n        }\n\n        if (required_actions.length) {\n            this.error(sub('the following arguments are required: %s',\n                       required_actions.join(', ')))\n        }\n\n        // make sure all required groups had one option present\n        for (let group of this._mutually_exclusive_groups) {\n            if (group.required) {\n                let no_actions_used = true\n                for (let action of group._group_actions) {\n                    if (seen_non_default_actions.has(action)) {\n                        no_actions_used = false\n                        break\n                    }\n                }\n\n                // if no actions were used, report the error\n                if (no_actions_used) {\n                    let names = group._group_actions\n                        .filter(action => action.help !== SUPPRESS)\n                        .map(action => _get_action_name(action))\n                    let msg = 'one of the arguments %s is required'\n                    this.error(sub(msg, names.join(' ')))\n                }\n            }\n        }\n\n        // return the updated namespace and the extra arguments\n        return [ namespace, extras ]\n    }\n\n    _read_args_from_files(arg_strings) {\n        // expand arguments referencing files\n        let new_arg_strings = []\n        for (let arg_string of arg_strings) {\n\n            // for regular arguments, just add them back into the list\n            if (!arg_string || !this.fromfile_prefix_chars.includes(arg_string[0])) {\n                new_arg_strings.push(arg_string)\n\n            // replace arguments referencing files with the file content\n            } else {\n                try {\n                    let args_file = fs.readFileSync(arg_string.slice(1), 'utf8')\n                    let arg_strings = []\n                    for (let arg_line of splitlines(args_file)) {\n                        for (let arg of this.convert_arg_line_to_args(arg_line)) {\n                            arg_strings.push(arg)\n                        }\n                    }\n                    arg_strings = this._read_args_from_files(arg_strings)\n                    new_arg_strings = new_arg_strings.concat(arg_strings)\n                } catch (err) {\n                    this.error(err.message)\n                }\n            }\n        }\n\n        // return the modified argument list\n        return new_arg_strings\n    }\n\n    convert_arg_line_to_args(arg_line) {\n        return [arg_line]\n    }\n\n    _match_argument(action, arg_strings_pattern) {\n        // match the pattern for this action to the arg strings\n        let nargs_pattern = this._get_nargs_pattern(action)\n        let match = arg_strings_pattern.match(new RegExp('^' + nargs_pattern))\n\n        // raise an exception if we weren't able to find a match\n        if (match === null) {\n            let nargs_errors = {\n                undefined: 'expected one argument',\n                [OPTIONAL]: 'expected at most one argument',\n                [ONE_OR_MORE]: 'expected at least one argument'\n            }\n            let msg = nargs_errors[action.nargs]\n            if (msg === undefined) {\n                msg = sub(action.nargs === 1 ? 'expected %s argument' : 'expected %s arguments', action.nargs)\n            }\n            throw new ArgumentError(action, msg)\n        }\n\n        // return the number of arguments matched\n        return match[1].length\n    }\n\n    _match_arguments_partial(actions, arg_strings_pattern) {\n        // progressively shorten the actions list by slicing off the\n        // final actions until we find a match\n        let result = []\n        for (let i of range(actions.length, 0, -1)) {\n            let actions_slice = actions.slice(0, i)\n            let pattern = actions_slice.map(action => this._get_nargs_pattern(action)).join('')\n            let match = arg_strings_pattern.match(new RegExp('^' + pattern))\n            if (match !== null) {\n                result = result.concat(match.slice(1).map(string => string.length))\n                break\n            }\n        }\n\n        // return the list of arg string counts\n        return result\n    }\n\n    _parse_optional(arg_string) {\n        // if it's an empty string, it was meant to be a positional\n        if (!arg_string) {\n            return undefined\n        }\n\n        // if it doesn't start with a prefix, it was meant to be positional\n        if (!this.prefix_chars.includes(arg_string[0])) {\n            return undefined\n        }\n\n        // if the option string is present in the parser, return the action\n        if (arg_string in this._option_string_actions) {\n            let action = this._option_string_actions[arg_string]\n            return [ action, arg_string, undefined ]\n        }\n\n        // if it's just a single character, it was meant to be positional\n        if (arg_string.length === 1) {\n            return undefined\n        }\n\n        // if the option string before the \"=\" is present, return the action\n        if (arg_string.includes('=')) {\n            let [ option_string, explicit_arg ] = _string_split(arg_string, '=', 1)\n            if (option_string in this._option_string_actions) {\n                let action = this._option_string_actions[option_string]\n                return [ action, option_string, explicit_arg ]\n            }\n        }\n\n        // search through all possible prefixes of the option string\n        // and all actions in the parser for possible interpretations\n        let option_tuples = this._get_option_tuples(arg_string)\n\n        // if multiple actions match, the option string was ambiguous\n        if (option_tuples.length > 1) {\n            let options = option_tuples.map(([ /*action*/, option_string/*, explicit_arg*/ ]) => option_string).join(', ')\n            let args = {option: arg_string, matches: options}\n            let msg = 'ambiguous option: %(option)s could match %(matches)s'\n            this.error(sub(msg, args))\n\n        // if exactly one action matched, this segmentation is good,\n        // so return the parsed action\n        } else if (option_tuples.length === 1) {\n            let [ option_tuple ] = option_tuples\n            return option_tuple\n        }\n\n        // if it was not found as an option, but it looks like a negative\n        // number, it was meant to be positional\n        // unless there are negative-number-like options\n        if (this._negative_number_matcher.test(arg_string)) {\n            if (!this._has_negative_number_optionals.length) {\n                return undefined\n            }\n        }\n\n        // if it contains a space, it was meant to be a positional\n        if (arg_string.includes(' ')) {\n            return undefined\n        }\n\n        // it was meant to be an optional but there is no such option\n        // in this parser (though it might be a valid option in a subparser)\n        return [ undefined, arg_string, undefined ]\n    }\n\n    _get_option_tuples(option_string) {\n        let result = []\n\n        // option strings starting with two prefix characters are only\n        // split at the '='\n        let chars = this.prefix_chars\n        if (chars.includes(option_string[0]) && chars.includes(option_string[1])) {\n            if (this.allow_abbrev) {\n                let option_prefix, explicit_arg\n                if (option_string.includes('=')) {\n                    [ option_prefix, explicit_arg ] = _string_split(option_string, '=', 1)\n                } else {\n                    option_prefix = option_string\n                    explicit_arg = undefined\n                }\n                for (let option_string of Object.keys(this._option_string_actions)) {\n                    if (option_string.startsWith(option_prefix)) {\n                        let action = this._option_string_actions[option_string]\n                        let tup = [ action, option_string, explicit_arg ]\n                        result.push(tup)\n                    }\n                }\n            }\n\n        // single character options can be concatenated with their arguments\n        // but multiple character options always have to have their argument\n        // separate\n        } else if (chars.includes(option_string[0]) && !chars.includes(option_string[1])) {\n            let option_prefix = option_string\n            let explicit_arg = undefined\n            let short_option_prefix = option_string.slice(0, 2)\n            let short_explicit_arg = option_string.slice(2)\n\n            for (let option_string of Object.keys(this._option_string_actions)) {\n                if (option_string === short_option_prefix) {\n                    let action = this._option_string_actions[option_string]\n                    let tup = [ action, option_string, short_explicit_arg ]\n                    result.push(tup)\n                } else if (option_string.startsWith(option_prefix)) {\n                    let action = this._option_string_actions[option_string]\n                    let tup = [ action, option_string, explicit_arg ]\n                    result.push(tup)\n                }\n            }\n\n        // shouldn't ever get here\n        } else {\n            this.error(sub('unexpected option string: %s', option_string))\n        }\n\n        // return the collected option tuples\n        return result\n    }\n\n    _get_nargs_pattern(action) {\n        // in all examples below, we have to allow for '--' args\n        // which are represented as '-' in the pattern\n        let nargs = action.nargs\n        let nargs_pattern\n\n        // the default (None) is assumed to be a single argument\n        if (nargs === undefined) {\n            nargs_pattern = '(-*A-*)'\n\n        // allow zero or one arguments\n        } else if (nargs === OPTIONAL) {\n            nargs_pattern = '(-*A?-*)'\n\n        // allow zero or more arguments\n        } else if (nargs === ZERO_OR_MORE) {\n            nargs_pattern = '(-*[A-]*)'\n\n        // allow one or more arguments\n        } else if (nargs === ONE_OR_MORE) {\n            nargs_pattern = '(-*A[A-]*)'\n\n        // allow any number of options or arguments\n        } else if (nargs === REMAINDER) {\n            nargs_pattern = '([-AO]*)'\n\n        // allow one argument followed by any number of options or arguments\n        } else if (nargs === PARSER) {\n            nargs_pattern = '(-*A[-AO]*)'\n\n        // suppress action, like nargs=0\n        } else if (nargs === SUPPRESS) {\n            nargs_pattern = '(-*-*)'\n\n        // all others should be integers\n        } else {\n            nargs_pattern = sub('(-*%s-*)', 'A'.repeat(nargs).split('').join('-*'))\n        }\n\n        // if this is an optional action, -- is not allowed\n        if (action.option_strings.length) {\n            nargs_pattern = nargs_pattern.replace(/-\\*/g, '')\n            nargs_pattern = nargs_pattern.replace(/-/g, '')\n        }\n\n        // return the pattern\n        return nargs_pattern\n    }\n\n    // ========================\n    // Alt command line argument parsing, allowing free intermix\n    // ========================\n\n    parse_intermixed_args(args = undefined, namespace = undefined) {\n        let argv\n        [ args, argv ] = this.parse_known_intermixed_args(args, namespace)\n        if (argv.length) {\n            let msg = 'unrecognized arguments: %s'\n            this.error(sub(msg, argv.join(' ')))\n        }\n        return args\n    }\n\n    parse_known_intermixed_args(args = undefined, namespace = undefined) {\n        // returns a namespace and list of extras\n        //\n        // positional can be freely intermixed with optionals.  optionals are\n        // first parsed with all positional arguments deactivated.  The 'extras'\n        // are then parsed.  If the parser definition is incompatible with the\n        // intermixed assumptions (e.g. use of REMAINDER, subparsers) a\n        // TypeError is raised.\n        //\n        // positionals are 'deactivated' by setting nargs and default to\n        // SUPPRESS.  This blocks the addition of that positional to the\n        // namespace\n\n        let extras\n        let positionals = this._get_positional_actions()\n        let a = positionals.filter(action => [ PARSER, REMAINDER ].includes(action.nargs))\n        if (a.length) {\n            throw new TypeError(sub('parse_intermixed_args: positional arg' +\n                                    ' with nargs=%s', a[0].nargs))\n        }\n\n        for (let group of this._mutually_exclusive_groups) {\n            for (let action of group._group_actions) {\n                if (positionals.includes(action)) {\n                    throw new TypeError('parse_intermixed_args: positional in' +\n                                        ' mutuallyExclusiveGroup')\n                }\n            }\n        }\n\n        let save_usage\n        try {\n            save_usage = this.usage\n            let remaining_args\n            try {\n                if (this.usage === undefined) {\n                    // capture the full usage for use in error messages\n                    this.usage = this.format_usage().slice(7)\n                }\n                for (let action of positionals) {\n                    // deactivate positionals\n                    action.save_nargs = action.nargs\n                    // action.nargs = 0\n                    action.nargs = SUPPRESS\n                    action.save_default = action.default\n                    action.default = SUPPRESS\n                }\n                [ namespace, remaining_args ] = this.parse_known_args(args,\n                                                                      namespace)\n                for (let action of positionals) {\n                    // remove the empty positional values from namespace\n                    let attr = getattr(namespace, action.dest)\n                    if (Array.isArray(attr) && attr.length === 0) {\n                        // eslint-disable-next-line no-console\n                        console.warn(sub('Do not expect %s in %s', action.dest, namespace))\n                        delattr(namespace, action.dest)\n                    }\n                }\n            } finally {\n                // restore nargs and usage before exiting\n                for (let action of positionals) {\n                    action.nargs = action.save_nargs\n                    action.default = action.save_default\n                }\n            }\n            let optionals = this._get_optional_actions()\n            try {\n                // parse positionals.  optionals aren't normally required, but\n                // they could be, so make sure they aren't.\n                for (let action of optionals) {\n                    action.save_required = action.required\n                    action.required = false\n                }\n                for (let group of this._mutually_exclusive_groups) {\n                    group.save_required = group.required\n                    group.required = false\n                }\n                [ namespace, extras ] = this.parse_known_args(remaining_args,\n                                                              namespace)\n            } finally {\n                // restore parser values before exiting\n                for (let action of optionals) {\n                    action.required = action.save_required\n                }\n                for (let group of this._mutually_exclusive_groups) {\n                    group.required = group.save_required\n                }\n            }\n        } finally {\n            this.usage = save_usage\n        }\n        return [ namespace, extras ]\n    }\n\n    // ========================\n    // Value conversion methods\n    // ========================\n    _get_values(action, arg_strings) {\n        // for everything but PARSER, REMAINDER args, strip out first '--'\n        if (![PARSER, REMAINDER].includes(action.nargs)) {\n            try {\n                _array_remove(arg_strings, '--')\n            } catch (err) {}\n        }\n\n        let value\n        // optional argument produces a default when not present\n        if (!arg_strings.length && action.nargs === OPTIONAL) {\n            if (action.option_strings.length) {\n                value = action.const\n            } else {\n                value = action.default\n            }\n            if (typeof value === 'string') {\n                value = this._get_value(action, value)\n                this._check_value(action, value)\n            }\n\n        // when nargs='*' on a positional, if there were no command-line\n        // args, use the default if it is anything other than None\n        } else if (!arg_strings.length && action.nargs === ZERO_OR_MORE &&\n              !action.option_strings.length) {\n            if (action.default !== undefined) {\n                value = action.default\n            } else {\n                value = arg_strings\n            }\n            this._check_value(action, value)\n\n        // single argument or optional argument produces a single value\n        } else if (arg_strings.length === 1 && [undefined, OPTIONAL].includes(action.nargs)) {\n            let arg_string = arg_strings[0]\n            value = this._get_value(action, arg_string)\n            this._check_value(action, value)\n\n        // REMAINDER arguments convert all values, checking none\n        } else if (action.nargs === REMAINDER) {\n            value = arg_strings.map(v => this._get_value(action, v))\n\n        // PARSER arguments convert all values, but check only the first\n        } else if (action.nargs === PARSER) {\n            value = arg_strings.map(v => this._get_value(action, v))\n            this._check_value(action, value[0])\n\n        // SUPPRESS argument does not put anything in the namespace\n        } else if (action.nargs === SUPPRESS) {\n            value = SUPPRESS\n\n        // all other types of nargs produce a list\n        } else {\n            value = arg_strings.map(v => this._get_value(action, v))\n            for (let v of value) {\n                this._check_value(action, v)\n            }\n        }\n\n        // return the converted value\n        return value\n    }\n\n    _get_value(action, arg_string) {\n        let type_func = this._registry_get('type', action.type, action.type)\n        if (typeof type_func !== 'function') {\n            let msg = '%r is not callable'\n            throw new ArgumentError(action, sub(msg, type_func))\n        }\n\n        // convert the value to the appropriate type\n        let result\n        try {\n            try {\n                result = type_func(arg_string)\n            } catch (err) {\n                // Dear TC39, why would you ever consider making es6 classes not callable?\n                // We had one universal interface, [[Call]], which worked for anything\n                // (with familiar this-instanceof guard for classes). Now we have two.\n                if (err instanceof TypeError &&\n                    /Class constructor .* cannot be invoked without 'new'/.test(err.message)) {\n                    // eslint-disable-next-line new-cap\n                    result = new type_func(arg_string)\n                } else {\n                    throw err\n                }\n            }\n\n        } catch (err) {\n            // ArgumentTypeErrors indicate errors\n            if (err instanceof ArgumentTypeError) {\n                //let name = getattr(action.type, 'name', repr(action.type))\n                let msg = err.message\n                throw new ArgumentError(action, msg)\n\n            // TypeErrors or ValueErrors also indicate errors\n            } else if (err instanceof TypeError) {\n                let name = getattr(action.type, 'name', repr(action.type))\n                let args = {type: name, value: arg_string}\n                let msg = 'invalid %(type)s value: %(value)r'\n                throw new ArgumentError(action, sub(msg, args))\n            } else {\n                throw err\n            }\n        }\n\n        // return the converted value\n        return result\n    }\n\n    _check_value(action, value) {\n        // converted value must be one of the choices (if specified)\n        if (action.choices !== undefined && !_choices_to_array(action.choices).includes(value)) {\n            let args = {value,\n                        choices: _choices_to_array(action.choices).map(repr).join(', ')}\n            let msg = 'invalid choice: %(value)r (choose from %(choices)s)'\n            throw new ArgumentError(action, sub(msg, args))\n        }\n    }\n\n    // =======================\n    // Help-formatting methods\n    // =======================\n    format_usage() {\n        let formatter = this._get_formatter()\n        formatter.add_usage(this.usage, this._actions,\n                            this._mutually_exclusive_groups)\n        return formatter.format_help()\n    }\n\n    format_help() {\n        let formatter = this._get_formatter()\n\n        // usage\n        formatter.add_usage(this.usage, this._actions,\n                            this._mutually_exclusive_groups)\n\n        // description\n        formatter.add_text(this.description)\n\n        // positionals, optionals and user-defined groups\n        for (let action_group of this._action_groups) {\n            formatter.start_section(action_group.title)\n            formatter.add_text(action_group.description)\n            formatter.add_arguments(action_group._group_actions)\n            formatter.end_section()\n        }\n\n        // epilog\n        formatter.add_text(this.epilog)\n\n        // determine help from format above\n        return formatter.format_help()\n    }\n\n    _get_formatter() {\n        // eslint-disable-next-line new-cap\n        return new this.formatter_class({ prog: this.prog })\n    }\n\n    // =====================\n    // Help-printing methods\n    // =====================\n    print_usage(file = undefined) {\n        if (file === undefined) file = process.stdout\n        this._print_message(this.format_usage(), file)\n    }\n\n    print_help(file = undefined) {\n        if (file === undefined) file = process.stdout\n        this._print_message(this.format_help(), file)\n    }\n\n    _print_message(message, file = undefined) {\n        if (message) {\n            if (file === undefined) file = process.stderr\n            file.write(message)\n        }\n    }\n\n    // ===============\n    // Exiting methods\n    // ===============\n    exit(status = 0, message = undefined) {\n        if (message) {\n            this._print_message(message, process.stderr)\n        }\n        process.exit(status)\n    }\n\n    error(message) {\n        /*\n         *  error(message: string)\n         *\n         *  Prints a usage message incorporating the message to stderr and\n         *  exits.\n         *\n         *  If you override this in a subclass, it should not return -- it\n         *  should either exit or raise an exception.\n         */\n\n        // LEGACY (v1 compatibility), debug mode\n        if (this.debug === true) throw new Error(message)\n        // end\n        this.print_usage(process.stderr)\n        let args = {prog: this.prog, message: message}\n        this.exit(2, sub('%(prog)s: error: %(message)s\\n', args))\n    }\n}))\n\n\nmodule.exports = {\n    ArgumentParser,\n    ArgumentError,\n    ArgumentTypeError,\n    BooleanOptionalAction,\n    FileType,\n    HelpFormatter,\n    ArgumentDefaultsHelpFormatter,\n    RawDescriptionHelpFormatter,\n    RawTextHelpFormatter,\n    MetavarTypeHelpFormatter,\n    Namespace,\n    Action,\n    ONE_OR_MORE,\n    OPTIONAL,\n    PARSER,\n    REMAINDER,\n    SUPPRESS,\n    ZERO_OR_MORE\n}\n\n// LEGACY (v1 compatibility), Const alias\nObject.defineProperty(module.exports, 'Const', {\n    get() {\n        let result = {}\n        Object.entries({ ONE_OR_MORE, OPTIONAL, PARSER, REMAINDER, SUPPRESS, ZERO_OR_MORE }).forEach(([ n, v ]) => {\n            Object.defineProperty(result, n, {\n                get() {\n                    deprecate(n, sub('use argparse.%s instead of argparse.Const.%s', n, n))\n                    return v\n                }\n            })\n        })\n        Object.entries({ _UNRECOGNIZED_ARGS_ATTR }).forEach(([ n, v ]) => {\n            Object.defineProperty(result, n, {\n                get() {\n                    deprecate(n, sub('argparse.Const.%s is an internal symbol and will no longer be available', n))\n                    return v\n                }\n            })\n        })\n        return result\n    },\n    enumerable: false\n})\n// end\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}