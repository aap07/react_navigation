{"ast":null,"code":"'use strict';\n\nvar _require = require(\"./CppHelpers.js\"),\n  generateEventStructName = _require.generateEventStructName;\nvar FileTemplate = function FileTemplate(_ref) {\n  var events = _ref.events,\n    libraryName = _ref.libraryName;\n  return `\n/**\n * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).\n *\n * Do not edit this file as changes may cause incorrect behavior and will be lost\n * once the code is regenerated.\n *\n * ${'@'}generated by codegen project: GenerateEventEmitterCpp.js\n */\n\n#include <react/renderer/components/${libraryName}/EventEmitters.h>\n\nnamespace facebook {\nnamespace react {\n\n${events}\n\n} // namespace react\n} // namespace facebook\n`;\n};\nvar ComponentTemplate = function ComponentTemplate(_ref2) {\n  var className = _ref2.className,\n    eventName = _ref2.eventName,\n    structName = _ref2.structName,\n    dispatchEventName = _ref2.dispatchEventName,\n    implementation = _ref2.implementation;\n  var capture = implementation.includes('event') ? 'event=std::move(event)' : '';\n  return `\nvoid ${className}EventEmitter::${eventName}(${structName} event) const {\n  dispatchEvent(\"${dispatchEventName}\", [${capture}](jsi::Runtime &runtime) {\n    ${implementation}\n  });\n}\n`.trim();\n};\nvar BasicComponentTemplate = function BasicComponentTemplate(_ref3) {\n  var className = _ref3.className,\n    eventName = _ref3.eventName,\n    dispatchEventName = _ref3.dispatchEventName;\n  return `\nvoid ${className}EventEmitter::${eventName}() const {\n  dispatchEvent(\"${dispatchEventName}\");\n}\n`.trim();\n};\nfunction generateSetter(variableName, propertyName, propertyParts) {\n  var trailingPeriod = propertyParts.length === 0 ? '' : '.';\n  var eventChain = `event.${propertyParts.join('.')}${trailingPeriod}${propertyName});`;\n  return `${variableName}.setProperty(runtime, \"${propertyName}\", ${eventChain}`;\n}\nfunction generateEnumSetter(variableName, propertyName, propertyParts) {\n  var trailingPeriod = propertyParts.length === 0 ? '' : '.';\n  var eventChain = `event.${propertyParts.join('.')}${trailingPeriod}${propertyName})`;\n  return `${variableName}.setProperty(runtime, \"${propertyName}\", toString(${eventChain});`;\n}\nfunction generateSetters(parentPropertyName, properties, propertyParts) {\n  var propSetters = properties.map(function (eventProperty) {\n    var typeAnnotation = eventProperty.typeAnnotation;\n    switch (typeAnnotation.type) {\n      case 'BooleanTypeAnnotation':\n        return generateSetter(parentPropertyName, eventProperty.name, propertyParts);\n      case 'StringTypeAnnotation':\n        return generateSetter(parentPropertyName, eventProperty.name, propertyParts);\n      case 'Int32TypeAnnotation':\n        return generateSetter(parentPropertyName, eventProperty.name, propertyParts);\n      case 'DoubleTypeAnnotation':\n        return generateSetter(parentPropertyName, eventProperty.name, propertyParts);\n      case 'FloatTypeAnnotation':\n        return generateSetter(parentPropertyName, eventProperty.name, propertyParts);\n      case 'StringEnumTypeAnnotation':\n        return generateEnumSetter(parentPropertyName, eventProperty.name, propertyParts);\n      case 'ObjectTypeAnnotation':\n        var propertyName = eventProperty.name;\n        return `\n            {\n              auto ${propertyName} = jsi::Object(runtime);\n              ${generateSetters(propertyName, typeAnnotation.properties, propertyParts.concat([propertyName]))}\n\n              ${parentPropertyName}.setProperty(runtime, \"${propertyName}\", ${propertyName});\n            }\n          `.trim();\n      default:\n        typeAnnotation.type;\n        throw new Error('Received invalid event property type');\n    }\n  }).join('\\n');\n  return propSetters;\n}\nfunction generateEvent(componentName, event) {\n  var dispatchEventName = `${event.name[2].toLowerCase()}${event.name.slice(3)}`;\n  if (event.typeAnnotation.argument) {\n    var implementation = `\n    auto payload = jsi::Object(runtime);\n    ${generateSetters('payload', event.typeAnnotation.argument.properties, [])}\n    return payload;\n  `.trim();\n    if (!event.name.startsWith('on')) {\n      throw new Error('Expected the event name to start with `on`');\n    }\n    return ComponentTemplate({\n      className: componentName,\n      eventName: event.name,\n      dispatchEventName: dispatchEventName,\n      structName: generateEventStructName([event.name]),\n      implementation: implementation\n    });\n  }\n  return BasicComponentTemplate({\n    className: componentName,\n    eventName: event.name,\n    dispatchEventName: dispatchEventName\n  });\n}\nmodule.exports = {\n  generate: function generate(libraryName, schema, packageName) {\n    var assumeNonnull = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var moduleComponents = Object.keys(schema.modules).map(function (moduleName) {\n      var module = schema.modules[moduleName];\n      if (module.type !== 'Component') {\n        return;\n      }\n      var components = module.components;\n      if (components == null) {\n        return null;\n      }\n      return components;\n    }).filter(Boolean).reduce(function (acc, components) {\n      return Object.assign(acc, components);\n    }, {});\n    var fileName = 'EventEmitters.cpp';\n    var componentEmitters = Object.keys(moduleComponents).map(function (componentName) {\n      var component = moduleComponents[componentName];\n      return component.events.map(function (event) {\n        return generateEvent(componentName, event);\n      }).join('\\n');\n    }).join('\\n');\n    var replacedTemplate = FileTemplate({\n      libraryName: libraryName,\n      events: componentEmitters\n    });\n    return new Map([[fileName, replacedTemplate]]);\n  }\n};","map":{"version":3,"names":["_require","require","generateEventStructName","FileTemplate","_ref","events","libraryName","ComponentTemplate","_ref2","className","eventName","structName","dispatchEventName","implementation","capture","includes","trim","BasicComponentTemplate","_ref3","generateSetter","variableName","propertyName","propertyParts","trailingPeriod","length","eventChain","join","generateEnumSetter","generateSetters","parentPropertyName","properties","propSetters","map","eventProperty","typeAnnotation","type","name","concat","Error","generateEvent","componentName","event","toLowerCase","slice","argument","startsWith","module","exports","generate","schema","packageName","assumeNonnull","arguments","undefined","moduleComponents","Object","keys","modules","moduleName","components","filter","Boolean","reduce","acc","assign","fileName","componentEmitters","component","replacedTemplate","Map"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native/codegen/lib/generators/components/GenerateEventEmitterCpp.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\n'use strict';\n\nconst _require = require('./CppHelpers.js'),\n  generateEventStructName = _require.generateEventStructName;\nconst FileTemplate = ({events, libraryName}) => `\n/**\n * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).\n *\n * Do not edit this file as changes may cause incorrect behavior and will be lost\n * once the code is regenerated.\n *\n * ${'@'}generated by codegen project: GenerateEventEmitterCpp.js\n */\n\n#include <react/renderer/components/${libraryName}/EventEmitters.h>\n\nnamespace facebook {\nnamespace react {\n\n${events}\n\n} // namespace react\n} // namespace facebook\n`;\nconst ComponentTemplate = ({\n  className,\n  eventName,\n  structName,\n  dispatchEventName,\n  implementation,\n}) => {\n  const capture = implementation.includes('event')\n    ? 'event=std::move(event)'\n    : '';\n  return `\nvoid ${className}EventEmitter::${eventName}(${structName} event) const {\n  dispatchEvent(\"${dispatchEventName}\", [${capture}](jsi::Runtime &runtime) {\n    ${implementation}\n  });\n}\n`.trim();\n};\nconst BasicComponentTemplate = ({className, eventName, dispatchEventName}) =>\n  `\nvoid ${className}EventEmitter::${eventName}() const {\n  dispatchEvent(\"${dispatchEventName}\");\n}\n`.trim();\nfunction generateSetter(variableName, propertyName, propertyParts) {\n  const trailingPeriod = propertyParts.length === 0 ? '' : '.';\n  const eventChain = `event.${propertyParts.join(\n    '.',\n  )}${trailingPeriod}${propertyName});`;\n  return `${variableName}.setProperty(runtime, \"${propertyName}\", ${eventChain}`;\n}\nfunction generateEnumSetter(variableName, propertyName, propertyParts) {\n  const trailingPeriod = propertyParts.length === 0 ? '' : '.';\n  const eventChain = `event.${propertyParts.join(\n    '.',\n  )}${trailingPeriod}${propertyName})`;\n  return `${variableName}.setProperty(runtime, \"${propertyName}\", toString(${eventChain});`;\n}\nfunction generateSetters(parentPropertyName, properties, propertyParts) {\n  const propSetters = properties\n    .map(eventProperty => {\n      const typeAnnotation = eventProperty.typeAnnotation;\n      switch (typeAnnotation.type) {\n        case 'BooleanTypeAnnotation':\n          return generateSetter(\n            parentPropertyName,\n            eventProperty.name,\n            propertyParts,\n          );\n        case 'StringTypeAnnotation':\n          return generateSetter(\n            parentPropertyName,\n            eventProperty.name,\n            propertyParts,\n          );\n        case 'Int32TypeAnnotation':\n          return generateSetter(\n            parentPropertyName,\n            eventProperty.name,\n            propertyParts,\n          );\n        case 'DoubleTypeAnnotation':\n          return generateSetter(\n            parentPropertyName,\n            eventProperty.name,\n            propertyParts,\n          );\n        case 'FloatTypeAnnotation':\n          return generateSetter(\n            parentPropertyName,\n            eventProperty.name,\n            propertyParts,\n          );\n        case 'StringEnumTypeAnnotation':\n          return generateEnumSetter(\n            parentPropertyName,\n            eventProperty.name,\n            propertyParts,\n          );\n        case 'ObjectTypeAnnotation':\n          const propertyName = eventProperty.name;\n          return `\n            {\n              auto ${propertyName} = jsi::Object(runtime);\n              ${generateSetters(\n                propertyName,\n                typeAnnotation.properties,\n                propertyParts.concat([propertyName]),\n              )}\n\n              ${parentPropertyName}.setProperty(runtime, \"${propertyName}\", ${propertyName});\n            }\n          `.trim();\n        default:\n          typeAnnotation.type;\n          throw new Error('Received invalid event property type');\n      }\n    })\n    .join('\\n');\n  return propSetters;\n}\nfunction generateEvent(componentName, event) {\n  // This is a gross hack necessary because native code is sending\n  // events named things like topChange to JS which is then converted back to\n  // call the onChange prop. We should be consistent throughout the system.\n  // In order to migrate to this new system we have to support the current\n  // naming scheme. We should delete this once we are able to control this name\n  // throughout the system.\n  const dispatchEventName = `${event.name[2].toLowerCase()}${event.name.slice(\n    3,\n  )}`;\n  if (event.typeAnnotation.argument) {\n    const implementation = `\n    auto payload = jsi::Object(runtime);\n    ${generateSetters('payload', event.typeAnnotation.argument.properties, [])}\n    return payload;\n  `.trim();\n    if (!event.name.startsWith('on')) {\n      throw new Error('Expected the event name to start with `on`');\n    }\n    return ComponentTemplate({\n      className: componentName,\n      eventName: event.name,\n      dispatchEventName,\n      structName: generateEventStructName([event.name]),\n      implementation,\n    });\n  }\n  return BasicComponentTemplate({\n    className: componentName,\n    eventName: event.name,\n    dispatchEventName,\n  });\n}\nmodule.exports = {\n  generate(libraryName, schema, packageName, assumeNonnull = false) {\n    const moduleComponents = Object.keys(schema.modules)\n      .map(moduleName => {\n        const module = schema.modules[moduleName];\n        if (module.type !== 'Component') {\n          return;\n        }\n        const components = module.components;\n        // No components in this module\n        if (components == null) {\n          return null;\n        }\n        return components;\n      })\n      .filter(Boolean)\n      .reduce((acc, components) => Object.assign(acc, components), {});\n    const fileName = 'EventEmitters.cpp';\n    const componentEmitters = Object.keys(moduleComponents)\n      .map(componentName => {\n        const component = moduleComponents[componentName];\n        return component.events\n          .map(event => {\n            return generateEvent(componentName, event);\n          })\n          .join('\\n');\n      })\n      .join('\\n');\n    const replacedTemplate = FileTemplate({\n      libraryName,\n      events: componentEmitters,\n    });\n    return new Map([[fileName, replacedTemplate]]);\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}