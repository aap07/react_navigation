{"ast":null,"code":"'use strict';\n\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, 'string');\n  return typeof key === 'symbol' ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== 'object' || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || 'default');\n    if (typeof res !== 'object') return res;\n    throw new TypeError('@@toPrimitive must return a primitive value.');\n  }\n  return (hint === 'string' ? String : Number)(input);\n}\nvar flowParser = require('flow-parser');\nvar _require = require(\"./errors\"),\n  UnsupportedObjectPropertyTypeAnnotationParserError = _require.UnsupportedObjectPropertyTypeAnnotationParserError;\nvar schemaMock = {\n  modules: {\n    StringPropNativeComponentView: {\n      type: 'Component',\n      components: {\n        StringPropNativeComponentView: {\n          extendsProps: [],\n          events: [],\n          props: [],\n          commands: []\n        }\n      }\n    }\n  }\n};\nexport var MockedParser = function () {\n  function MockedParser() {\n    _classCallCheck(this, MockedParser);\n    _defineProperty(this, 'typeParameterInstantiation', 'TypeParameterInstantiation');\n  }\n  _createClass(MockedParser, [{\n    key: \"isProperty\",\n    value: function isProperty(property) {\n      return property.type === 'ObjectTypeProperty';\n    }\n  }, {\n    key: \"getKeyName\",\n    value: function getKeyName(property, hasteModuleName) {\n      if (!this.isProperty(property)) {\n        throw new UnsupportedObjectPropertyTypeAnnotationParserError(hasteModuleName, property, property.type, this.language());\n      }\n      return property.key.name;\n    }\n  }, {\n    key: \"language\",\n    value: function language() {\n      return 'Flow';\n    }\n  }, {\n    key: \"nameForGenericTypeAnnotation\",\n    value: function nameForGenericTypeAnnotation(typeAnnotation) {\n      return typeAnnotation.id.name;\n    }\n  }, {\n    key: \"checkIfInvalidModule\",\n    value: function checkIfInvalidModule(typeArguments) {\n      return false;\n    }\n  }, {\n    key: \"remapUnionTypeAnnotationMemberNames\",\n    value: function remapUnionTypeAnnotationMemberNames(membersTypes) {\n      return [];\n    }\n  }, {\n    key: \"parseFile\",\n    value: function parseFile(filename) {\n      return schemaMock;\n    }\n  }, {\n    key: \"parseString\",\n    value: function parseString(contents, filename) {\n      return schemaMock;\n    }\n  }, {\n    key: \"parseModuleFixture\",\n    value: function parseModuleFixture(filename) {\n      return schemaMock;\n    }\n  }, {\n    key: \"getAst\",\n    value: function getAst(contents) {\n      return flowParser.parse(contents, {\n        enums: true\n      });\n    }\n  }, {\n    key: \"getFunctionTypeAnnotationParameters\",\n    value: function getFunctionTypeAnnotationParameters(functionTypeAnnotation) {\n      return functionTypeAnnotation.params;\n    }\n  }, {\n    key: \"getFunctionNameFromParameter\",\n    value: function getFunctionNameFromParameter(parameter) {\n      return parameter.name;\n    }\n  }, {\n    key: \"getParameterName\",\n    value: function getParameterName(parameter) {\n      return parameter.name.name;\n    }\n  }, {\n    key: \"getParameterTypeAnnotation\",\n    value: function getParameterTypeAnnotation(parameter) {\n      return parameter.typeAnnotation;\n    }\n  }, {\n    key: \"getFunctionTypeAnnotationReturnType\",\n    value: function getFunctionTypeAnnotationReturnType(functionTypeAnnotation) {\n      return functionTypeAnnotation.returnType;\n    }\n  }, {\n    key: \"parseEnumMembersType\",\n    value: function parseEnumMembersType(typeAnnotation) {\n      return typeAnnotation.type;\n    }\n  }, {\n    key: \"validateEnumMembersSupported\",\n    value: function validateEnumMembersSupported(typeAnnotation, enumMembersType) {\n      return;\n    }\n  }, {\n    key: \"parseEnumMembers\",\n    value: function parseEnumMembers(typeAnnotation) {\n      return typeAnnotation.type === 'StringTypeAnnotation' ? [{\n        name: 'Hello',\n        value: 'hello'\n      }, {\n        name: 'Goodbye',\n        value: 'goodbye'\n      }] : [{\n        name: 'On',\n        value: '1'\n      }, {\n        name: 'Off',\n        value: '0'\n      }];\n    }\n  }, {\n    key: \"isModuleInterface\",\n    value: function isModuleInterface(node) {\n      return node.type === 'InterfaceDeclaration' && node.extends.length === 1 && node.extends[0].type === 'InterfaceExtends' && node.extends[0].id.name === 'TurboModule';\n    }\n  }, {\n    key: \"extractAnnotatedElement\",\n    value: function extractAnnotatedElement(typeAnnotation, types) {\n      return types[typeAnnotation.typeParameters.params[0].id.name];\n    }\n  }, {\n    key: \"getTypes\",\n    value: function getTypes(ast) {\n      return {};\n    }\n  }, {\n    key: \"callExpressionTypeParameters\",\n    value: function callExpressionTypeParameters(callExpression) {\n      return callExpression.typeArguments || null;\n    }\n  }, {\n    key: \"computePartialProperties\",\n    value: function computePartialProperties(properties, hasteModuleName, types, aliasMap, enumMap, tryParse, cxxOnly) {\n      return [{\n        name: 'a',\n        optional: true,\n        typeAnnotation: {\n          type: 'StringTypeAnnotation'\n        }\n      }, {\n        name: 'b',\n        optional: true,\n        typeAnnotation: {\n          type: 'BooleanTypeAnnotation'\n        }\n      }];\n    }\n  }, {\n    key: \"functionTypeAnnotation\",\n    value: function functionTypeAnnotation(propertyValueType) {\n      return propertyValueType === 'FunctionTypeAnnotation';\n    }\n  }, {\n    key: \"getTypeArgumentParamsFromDeclaration\",\n    value: function getTypeArgumentParamsFromDeclaration(declaration) {\n      return declaration.typeArguments.params;\n    }\n  }, {\n    key: \"getNativeComponentType\",\n    value: function getNativeComponentType(typeArgumentParams, funcArgumentParams) {\n      return {\n        propsTypeName: typeArgumentParams[0].id.name,\n        componentName: funcArgumentParams[0].value\n      };\n    }\n  }, {\n    key: \"getAnnotatedElementProperties\",\n    value: function getAnnotatedElementProperties(annotatedElement) {\n      return annotatedElement.right.properties;\n    }\n  }]);\n  return MockedParser;\n}();","map":{"version":3,"names":["_classCallCheck","_createClass","_defineProperty","obj","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","arg","_toPrimitive","String","input","hint","prim","Symbol","toPrimitive","undefined","res","call","TypeError","Number","flowParser","require","_require","UnsupportedObjectPropertyTypeAnnotationParserError","schemaMock","modules","StringPropNativeComponentView","type","components","extendsProps","events","props","commands","MockedParser","isProperty","property","getKeyName","hasteModuleName","language","name","nameForGenericTypeAnnotation","typeAnnotation","id","checkIfInvalidModule","typeArguments","remapUnionTypeAnnotationMemberNames","membersTypes","parseFile","filename","parseString","contents","parseModuleFixture","getAst","parse","enums","getFunctionTypeAnnotationParameters","functionTypeAnnotation","params","getFunctionNameFromParameter","parameter","getParameterName","getParameterTypeAnnotation","getFunctionTypeAnnotationReturnType","returnType","parseEnumMembersType","validateEnumMembersSupported","enumMembersType","parseEnumMembers","isModuleInterface","node","extends","length","extractAnnotatedElement","types","typeParameters","getTypes","ast","callExpressionTypeParameters","callExpression","computePartialProperties","properties","aliasMap","enumMap","tryParse","cxxOnly","optional","propertyValueType","getTypeArgumentParamsFromDeclaration","declaration","getNativeComponentType","typeArgumentParams","funcArgumentParams","propsTypeName","componentName","getAnnotatedElementProperties","annotatedElement","right"],"sources":["C:/Users/CR Laptop/Desktop/rn-project/react_navigation/node_modules/@react-native/codegen/lib/parsers/parserMock.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *\n * @format\n */\n\n'use strict';\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true,\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, 'string');\n  return typeof key === 'symbol' ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== 'object' || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || 'default');\n    if (typeof res !== 'object') return res;\n    throw new TypeError('@@toPrimitive must return a primitive value.');\n  }\n  return (hint === 'string' ? String : Number)(input);\n}\n// $FlowFixMe[untyped-import] there's no flowtype flow-parser\nconst flowParser = require('flow-parser');\nconst _require = require('./errors'),\n  UnsupportedObjectPropertyTypeAnnotationParserError =\n    _require.UnsupportedObjectPropertyTypeAnnotationParserError;\nconst schemaMock = {\n  modules: {\n    StringPropNativeComponentView: {\n      type: 'Component',\n      components: {\n        StringPropNativeComponentView: {\n          extendsProps: [],\n          events: [],\n          props: [],\n          commands: [],\n        },\n      },\n    },\n  },\n};\nexport class MockedParser {\n  constructor() {\n    _defineProperty(\n      this,\n      'typeParameterInstantiation',\n      'TypeParameterInstantiation',\n    );\n  }\n  isProperty(property) {\n    return property.type === 'ObjectTypeProperty';\n  }\n  getKeyName(property, hasteModuleName) {\n    if (!this.isProperty(property)) {\n      throw new UnsupportedObjectPropertyTypeAnnotationParserError(\n        hasteModuleName,\n        property,\n        property.type,\n        this.language(),\n      );\n    }\n    return property.key.name;\n  }\n  language() {\n    return 'Flow';\n  }\n  nameForGenericTypeAnnotation(typeAnnotation) {\n    return typeAnnotation.id.name;\n  }\n  checkIfInvalidModule(typeArguments) {\n    return false;\n  }\n  remapUnionTypeAnnotationMemberNames(membersTypes) {\n    return [];\n  }\n  parseFile(filename) {\n    return schemaMock;\n  }\n  parseString(contents, filename) {\n    return schemaMock;\n  }\n  parseModuleFixture(filename) {\n    return schemaMock;\n  }\n  getAst(contents) {\n    return flowParser.parse(contents, {\n      enums: true,\n    });\n  }\n  getFunctionTypeAnnotationParameters(functionTypeAnnotation) {\n    return functionTypeAnnotation.params;\n  }\n  getFunctionNameFromParameter(parameter) {\n    return parameter.name;\n  }\n  getParameterName(parameter) {\n    return parameter.name.name;\n  }\n  getParameterTypeAnnotation(parameter) {\n    return parameter.typeAnnotation;\n  }\n  getFunctionTypeAnnotationReturnType(functionTypeAnnotation) {\n    return functionTypeAnnotation.returnType;\n  }\n  parseEnumMembersType(typeAnnotation) {\n    return typeAnnotation.type;\n  }\n  validateEnumMembersSupported(typeAnnotation, enumMembersType) {\n    return;\n  }\n  parseEnumMembers(typeAnnotation) {\n    return typeAnnotation.type === 'StringTypeAnnotation'\n      ? [\n          {\n            name: 'Hello',\n            value: 'hello',\n          },\n          {\n            name: 'Goodbye',\n            value: 'goodbye',\n          },\n        ]\n      : [\n          {\n            name: 'On',\n            value: '1',\n          },\n          {\n            name: 'Off',\n            value: '0',\n          },\n        ];\n  }\n  isModuleInterface(node) {\n    return (\n      node.type === 'InterfaceDeclaration' &&\n      node.extends.length === 1 &&\n      node.extends[0].type === 'InterfaceExtends' &&\n      node.extends[0].id.name === 'TurboModule'\n    );\n  }\n  extractAnnotatedElement(typeAnnotation, types) {\n    return types[typeAnnotation.typeParameters.params[0].id.name];\n  }\n  getTypes(ast) {\n    return {};\n  }\n  callExpressionTypeParameters(callExpression) {\n    return callExpression.typeArguments || null;\n  }\n  computePartialProperties(\n    properties,\n    hasteModuleName,\n    types,\n    aliasMap,\n    enumMap,\n    tryParse,\n    cxxOnly,\n  ) {\n    return [\n      {\n        name: 'a',\n        optional: true,\n        typeAnnotation: {\n          type: 'StringTypeAnnotation',\n        },\n      },\n      {\n        name: 'b',\n        optional: true,\n        typeAnnotation: {\n          type: 'BooleanTypeAnnotation',\n        },\n      },\n    ];\n  }\n  functionTypeAnnotation(propertyValueType) {\n    return propertyValueType === 'FunctionTypeAnnotation';\n  }\n  getTypeArgumentParamsFromDeclaration(declaration) {\n    return declaration.typeArguments.params;\n  }\n  getNativeComponentType(typeArgumentParams, funcArgumentParams) {\n    return {\n      propsTypeName: typeArgumentParams[0].id.name,\n      componentName: funcArgumentParams[0].value,\n    };\n  }\n  getAnnotatedElementProperties(annotatedElement) {\n    return annotatedElement.right.properties;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}