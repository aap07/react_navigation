{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.retryUsernamePasswordAuthWithOTPAsync = retryUsernamePasswordAuthWithOTPAsync;\nexports.UserSecondFactorDeviceMethod = void 0;\nvar _assert = _interopRequireDefault(require(\"assert\"));\nvar _chalk = _interopRequireDefault(require(\"chalk\"));\nvar Log = _interopRequireWildcard(require(\"../../log\"));\nvar _errors = require(\"../../utils/errors\");\nvar _link = require(\"../../utils/link\");\nvar _prompts = require(\"../../utils/prompts\");\nvar _client = require(\"../rest/client\");\nvar _user = require(\"./user\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nvar UserSecondFactorDeviceMethod;\nexports.UserSecondFactorDeviceMethod = UserSecondFactorDeviceMethod;\n(function (UserSecondFactorDeviceMethod) {\n  UserSecondFactorDeviceMethod[\"AUTHENTICATOR\"] = \"authenticator\";\n  UserSecondFactorDeviceMethod[\"SMS\"] = \"sms\";\n})(UserSecondFactorDeviceMethod || (exports.UserSecondFactorDeviceMethod = UserSecondFactorDeviceMethod = {}));\nvar nonInteractiveHelp = `Use the EXPO_TOKEN environment variable to authenticate in CI (${(0, _link).learnMore(\"https://docs.expo.dev/accounts/programmatic-access/\")})`;\nfunction promptForOTPAsync(_x) {\n  return _promptForOTPAsync.apply(this, arguments);\n}\nfunction _promptForOTPAsync() {\n  _promptForOTPAsync = _asyncToGenerator(function* (cancelBehavior) {\n    var enterMessage = cancelBehavior === \"cancel\" ? _chalk.default`press {bold Enter} to cancel` : _chalk.default`press {bold Enter} for more options`;\n    var _yield$promptAsync = yield (0, _prompts).promptAsync({\n        type: \"text\",\n        name: \"otp\",\n        message: `One-time password or backup code (${enterMessage}):`\n      }, {\n        nonInteractiveHelp: nonInteractiveHelp\n      }),\n      otp = _yield$promptAsync.otp;\n    return otp || null;\n  });\n  return _promptForOTPAsync.apply(this, arguments);\n}\nfunction promptForBackupOTPAsync(_x2, _x3, _x4) {\n  return _promptForBackupOTPAsync.apply(this, arguments);\n}\nfunction _promptForBackupOTPAsync() {\n  _promptForBackupOTPAsync = _asyncToGenerator(function* (username, password, secondFactorDevices) {\n    var nonPrimarySecondFactorDevices = secondFactorDevices.filter(function (device) {\n      return !device.is_primary;\n    });\n    if (nonPrimarySecondFactorDevices.length === 0) {\n      throw new _errors.CommandError(\"No other second-factor devices set up. Ensure you have set up and certified a backup device.\");\n    }\n    var hasAuthenticatorSecondFactorDevice = nonPrimarySecondFactorDevices.find(function (device) {\n      return device.method === \"authenticator\";\n    });\n    var smsNonPrimarySecondFactorDevices = nonPrimarySecondFactorDevices.filter(function (device) {\n      return device.method === \"sms\";\n    });\n    var authenticatorChoiceSentinel = -1;\n    var cancelChoiceSentinel = -2;\n    var deviceChoices = smsNonPrimarySecondFactorDevices.map(function (device, idx) {\n      return {\n        title: device.sms_phone_number,\n        value: idx\n      };\n    });\n    if (hasAuthenticatorSecondFactorDevice) {\n      deviceChoices.push({\n        title: \"Authenticator\",\n        value: authenticatorChoiceSentinel\n      });\n    }\n    deviceChoices.push({\n      title: \"Cancel\",\n      value: cancelChoiceSentinel\n    });\n    var selectedValue = yield (0, _prompts).selectAsync(\"Select a second-factor device:\", deviceChoices, {\n      nonInteractiveHelp: nonInteractiveHelp\n    });\n    if (selectedValue === cancelChoiceSentinel) {\n      return null;\n    } else if (selectedValue === authenticatorChoiceSentinel) {\n      return yield promptForOTPAsync(\"cancel\");\n    }\n    var device1 = smsNonPrimarySecondFactorDevices[selectedValue];\n    yield (0, _client).fetchAsync(\"auth/send-sms-otp\", {\n      method: \"POST\",\n      body: JSON.stringify({\n        username: username,\n        password: password,\n        secondFactorDeviceID: device1.id\n      })\n    });\n    return yield promptForOTPAsync(\"cancel\");\n  });\n  return _promptForBackupOTPAsync.apply(this, arguments);\n}\nfunction retryUsernamePasswordAuthWithOTPAsync(_x5, _x6, _x7) {\n  return _retryUsernamePasswordAuthWithOTPAsync.apply(this, arguments);\n}\nfunction _retryUsernamePasswordAuthWithOTPAsync() {\n  _retryUsernamePasswordAuthWithOTPAsync = _asyncToGenerator(function* (username, password, metadata) {\n    var secondFactorDevices = metadata.secondFactorDevices,\n      smsAutomaticallySent = metadata.smsAutomaticallySent;\n    (0, _assert).default(secondFactorDevices !== undefined && smsAutomaticallySent !== undefined, `Malformed OTP error metadata: ${metadata}`);\n    var primaryDevice = secondFactorDevices.find(function (device) {\n      return device.is_primary;\n    });\n    var otp = null;\n    if (smsAutomaticallySent) {\n      (0, _assert).default(primaryDevice, \"OTP should only automatically be sent when there is a primary device\");\n      Log.log(`One-time password was sent to the phone number ending in ${primaryDevice.sms_phone_number}.`);\n      otp = yield promptForOTPAsync(\"menu\");\n    }\n    if ((primaryDevice == null ? void 0 : primaryDevice.method) === \"authenticator\") {\n      Log.log(\"One-time password from authenticator required.\");\n      otp = yield promptForOTPAsync(\"menu\");\n    }\n    if (!otp) {\n      otp = yield promptForBackupOTPAsync(username, password, secondFactorDevices);\n    }\n    if (!otp) {\n      throw new _errors.AbortCommandError();\n    }\n    yield (0, _user).loginAsync({\n      username: username,\n      password: password,\n      otp: otp\n    });\n  });\n  return _retryUsernamePasswordAuthWithOTPAsync.apply(this, arguments);\n}","map":{"version":3,"names":["_asyncToGenerator","require","retryUsernamePasswordAuthWithOTPAsync","_assert","_interopRequireDefault","_chalk","Log","_interopRequireWildcard","_errors","_link","_prompts","_client","_user","UserSecondFactorDeviceMethod","exports","nonInteractiveHelp","learnMore","promptForOTPAsync","_x","_promptForOTPAsync","apply","arguments","cancelBehavior","enterMessage","default","_yield$promptAsync","promptAsync","type","name","message","otp","promptForBackupOTPAsync","_x2","_x3","_x4","_promptForBackupOTPAsync","username","password","secondFactorDevices","nonPrimarySecondFactorDevices","filter","device","is_primary","length","CommandError","hasAuthenticatorSecondFactorDevice","find","method","smsNonPrimarySecondFactorDevices","authenticatorChoiceSentinel","cancelChoiceSentinel","deviceChoices","map","idx","title","sms_phone_number","value","push","selectedValue","selectAsync","device1","fetchAsync","body","JSON","stringify","secondFactorDeviceID","id","_x5","_x6","_x7","_retryUsernamePasswordAuthWithOTPAsync","metadata","smsAutomaticallySent","undefined","primaryDevice","log","AbortCommandError","loginAsync"],"sources":["C:\\Users\\CR Laptop\\Desktop\\rn-project\\react_navigation\\node_modules\\@expo\\cli\\src\\api\\user\\otp.ts"],"sourcesContent":["import assert from 'assert';\nimport chalk from 'chalk';\n\nimport * as Log from '../../log';\nimport { AbortCommandError, CommandError } from '../../utils/errors';\nimport { learnMore } from '../../utils/link';\nimport { promptAsync, selectAsync } from '../../utils/prompts';\nimport { fetchAsync } from '../rest/client';\nimport { loginAsync } from './user';\n\nexport enum UserSecondFactorDeviceMethod {\n  AUTHENTICATOR = 'authenticator',\n  SMS = 'sms',\n}\n\n/** Device properties for 2FA */\nexport type SecondFactorDevice = {\n  id: string;\n  method: UserSecondFactorDeviceMethod;\n  sms_phone_number: string | null;\n  is_primary: boolean;\n};\n\nconst nonInteractiveHelp = `Use the EXPO_TOKEN environment variable to authenticate in CI (${learnMore(\n  'https://docs.expo.dev/accounts/programmatic-access/'\n)})`;\n\n/**\n * Prompt for an OTP with the option to cancel the question by answering empty (pressing return key).\n */\nasync function promptForOTPAsync(cancelBehavior: 'cancel' | 'menu'): Promise<string | null> {\n  const enterMessage =\n    cancelBehavior === 'cancel'\n      ? chalk`press {bold Enter} to cancel`\n      : chalk`press {bold Enter} for more options`;\n  const { otp } = await promptAsync(\n    {\n      type: 'text',\n      name: 'otp',\n      message: `One-time password or backup code (${enterMessage}):`,\n    },\n    { nonInteractiveHelp }\n  );\n  return otp || null;\n}\n\n/**\n * Prompt for user to choose a backup OTP method. If selected method is SMS, a request\n * for a new OTP will be sent to that method. Then, prompt for the OTP, and retry the user login.\n */\nasync function promptForBackupOTPAsync(\n  username: string,\n  password: string,\n  secondFactorDevices: SecondFactorDevice[]\n): Promise<string | null> {\n  const nonPrimarySecondFactorDevices = secondFactorDevices.filter((device) => !device.is_primary);\n\n  if (nonPrimarySecondFactorDevices.length === 0) {\n    throw new CommandError(\n      'No other second-factor devices set up. Ensure you have set up and certified a backup device.'\n    );\n  }\n\n  const hasAuthenticatorSecondFactorDevice = nonPrimarySecondFactorDevices.find(\n    (device) => device.method === UserSecondFactorDeviceMethod.AUTHENTICATOR\n  );\n\n  const smsNonPrimarySecondFactorDevices = nonPrimarySecondFactorDevices.filter(\n    (device) => device.method === UserSecondFactorDeviceMethod.SMS\n  );\n\n  const authenticatorChoiceSentinel = -1;\n  const cancelChoiceSentinel = -2;\n\n  const deviceChoices = smsNonPrimarySecondFactorDevices.map((device, idx) => ({\n    title: device.sms_phone_number!,\n    value: idx,\n  }));\n\n  if (hasAuthenticatorSecondFactorDevice) {\n    deviceChoices.push({\n      title: 'Authenticator',\n      value: authenticatorChoiceSentinel,\n    });\n  }\n\n  deviceChoices.push({\n    title: 'Cancel',\n    value: cancelChoiceSentinel,\n  });\n\n  const selectedValue = await selectAsync('Select a second-factor device:', deviceChoices, {\n    nonInteractiveHelp,\n  });\n  if (selectedValue === cancelChoiceSentinel) {\n    return null;\n  } else if (selectedValue === authenticatorChoiceSentinel) {\n    return await promptForOTPAsync('cancel');\n  }\n\n  const device = smsNonPrimarySecondFactorDevices[selectedValue];\n\n  await fetchAsync('auth/send-sms-otp', {\n    method: 'POST',\n    body: JSON.stringify({\n      username,\n      password,\n      secondFactorDeviceID: device.id,\n    }),\n  });\n\n  return await promptForOTPAsync('cancel');\n}\n\n/**\n * Handle the special case error indicating that a second-factor is required for\n * authentication.\n *\n * There are three cases we need to handle:\n * 1. User's primary second-factor device was SMS, OTP was automatically sent by the server to that\n *    device already. In this case we should just prompt for the SMS OTP (or backup code), which the\n *    user should be receiving shortly. We should give the user a way to cancel and the prompt and move\n *    to case 3 below.\n * 2. User's primary second-factor device is authenticator. In this case we should prompt for authenticator\n *    OTP (or backup code) and also give the user a way to cancel and move to case 3 below.\n * 3. User doesn't have a primary device or doesn't have access to their primary device. In this case\n *    we should show a picker of the SMS devices that they can have an OTP code sent to, and when\n *    the user picks one we show a prompt() for the sent OTP.\n */\nexport async function retryUsernamePasswordAuthWithOTPAsync(\n  username: string,\n  password: string,\n  metadata: {\n    secondFactorDevices?: SecondFactorDevice[];\n    smsAutomaticallySent?: boolean;\n  }\n): Promise<void> {\n  const { secondFactorDevices, smsAutomaticallySent } = metadata;\n  assert(\n    secondFactorDevices !== undefined && smsAutomaticallySent !== undefined,\n    `Malformed OTP error metadata: ${metadata}`\n  );\n\n  const primaryDevice = secondFactorDevices.find((device) => device.is_primary);\n  let otp: string | null = null;\n\n  if (smsAutomaticallySent) {\n    assert(primaryDevice, 'OTP should only automatically be sent when there is a primary device');\n    Log.log(\n      `One-time password was sent to the phone number ending in ${primaryDevice.sms_phone_number}.`\n    );\n    otp = await promptForOTPAsync('menu');\n  }\n\n  if (primaryDevice?.method === UserSecondFactorDeviceMethod.AUTHENTICATOR) {\n    Log.log('One-time password from authenticator required.');\n    otp = await promptForOTPAsync('menu');\n  }\n\n  // user bailed on case 1 or 2, wants to move to case 3\n  if (!otp) {\n    otp = await promptForBackupOTPAsync(username, password, secondFactorDevices);\n  }\n\n  if (!otp) {\n    throw new AbortCommandError();\n  }\n\n  await loginAsync({\n    username,\n    password,\n    otp,\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}